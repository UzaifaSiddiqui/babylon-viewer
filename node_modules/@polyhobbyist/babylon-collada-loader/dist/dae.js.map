{"version":3,"file":"dae.js","mappings":"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","sources":["webpack://dae_loader/webpack/universalModuleDefinition","webpack://dae_loader/external umd {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack://dae_loader/webpack/bootstrap","webpack://dae_loader/webpack/runtime/define property getters","webpack://dae_loader/webpack/runtime/hasOwnProperty shorthand","webpack://dae_loader/webpack/runtime/make namespace object","webpack://dae_loader/./src/log.ts","webpack://dae_loader/./src/context.ts","webpack://dae_loader/./src/loader/link.ts","webpack://dae_loader/./src/loader/context.ts","webpack://dae_loader/./src/loader/element.ts","webpack://dae_loader/./src/loader/utils.ts","webpack://dae_loader/./src/loader/scene.ts","webpack://dae_loader/./src/loader/channel.ts","webpack://dae_loader/./src/loader/input.ts","webpack://dae_loader/./src/loader/sampler.ts","webpack://dae_loader/./src/loader/source.ts","webpack://dae_loader/./src/loader/animation.ts","webpack://dae_loader/./src/loader/asset.ts","webpack://dae_loader/./src/loader/camera_param.ts","webpack://dae_loader/./src/loader/camera.ts","webpack://dae_loader/./src/loader/morph.ts","webpack://dae_loader/./src/loader/joints.ts","webpack://dae_loader/./src/loader/vertex_weights.ts","webpack://dae_loader/./src/loader/skin.ts","webpack://dae_loader/./src/loader/controller.ts","webpack://dae_loader/./src/loader/effect_sampler.ts","webpack://dae_loader/./src/loader/effect_surface.ts","webpack://dae_loader/./src/loader/effect_param.ts","webpack://dae_loader/./src/loader/color_or_texture.ts","webpack://dae_loader/./src/loader/effect_technique.ts","webpack://dae_loader/./src/loader/effect.ts","webpack://dae_loader/./src/loader/triangles.ts","webpack://dae_loader/./src/loader/vertices.ts","webpack://dae_loader/./src/loader/geometry.ts","webpack://dae_loader/./src/loader/image.ts","webpack://dae_loader/./src/loader/light_param.ts","webpack://dae_loader/./src/loader/light.ts","webpack://dae_loader/./src/loader/material.ts","webpack://dae_loader/./src/loader/instance_camera.ts","webpack://dae_loader/./src/loader/instance_material.ts","webpack://dae_loader/./src/loader/bind_material.ts","webpack://dae_loader/./src/loader/instance_controller.ts","webpack://dae_loader/./src/loader/instance_geometry.ts","webpack://dae_loader/./src/loader/instance_light.ts","webpack://dae_loader/./src/loader/node_transform.ts","webpack://dae_loader/./src/loader/visual_scene_node.ts","webpack://dae_loader/./src/loader/visual_scene.ts","webpack://dae_loader/./src/loader/document.ts","webpack://dae_loader/./src/loader.ts","webpack://dae_loader/./src/model.ts","webpack://dae_loader/./src/model-loader.ts","webpack://dae_loader/./src/babylon-loader.ts","webpack://dae_loader/./src/converter/utils.ts","webpack://dae_loader/./src/converter/transform.ts","webpack://dae_loader/./src/math.ts","webpack://dae_loader/./src/converter/animation_channel.ts","webpack://dae_loader/./src/converter/animation.ts","webpack://dae_loader/./src/converter/animation_data.ts","webpack://dae_loader/./src/converter/context.ts","webpack://dae_loader/./src/converter/texture.ts","webpack://dae_loader/./src/converter/material.ts","webpack://dae_loader/./src/converter/bounding_box.ts","webpack://dae_loader/./src/converter/geometry_chunk.ts","webpack://dae_loader/./src/converter/bone.ts","webpack://dae_loader/./src/converter/skeleton.ts","webpack://dae_loader/./src/converter/geometry.ts","webpack://dae_loader/./src/converter/options.ts","webpack://dae_loader/./src/converter/node.ts","webpack://dae_loader/./src/converter/file.ts","webpack://dae_loader/./src/converter/colladaconverter.ts","webpack://dae_loader/./src/exporter/context.ts","webpack://dae_loader/./src/exporter/material.ts","webpack://dae_loader/./src/exporter/data_chunk.ts","webpack://dae_loader/./src/exporter/geometry.ts","webpack://dae_loader/./src/exporter/skeleton.ts","webpack://dae_loader/./src/exporter/animation_track.ts","webpack://dae_loader/./src/exporter/animation.ts","webpack://dae_loader/./src/exporter/document.ts","webpack://dae_loader/./src/exporter/colladaexporter.ts","webpack://dae_loader/./src/daeFileLoader.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"dae_loader\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dae_loader\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"dae_loader\"] = factory(root[\"BABYLON\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__43__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__43__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\n\n    export enum LogLevel {\n        Debug = 1,\n        Trace = 2,\n        Info = 3,\n        Warning = 4,\n        Error = 5,\n        Exception = 6\n    };\n\n    export function LogLevelToString(level: LogLevel): string {\n        switch (level) {\n            case LogLevel.Debug: return \"DEBUG\";\n            case LogLevel.Trace: return \"TRACE\";\n            case LogLevel.Info: return \"INFO\";\n            case LogLevel.Warning: return \"WARNING\";\n            case LogLevel.Error: return \"ERROR\";\n            case LogLevel.Exception: return \"EXCEPTION\";\n            default: return \"OTHER\";\n        }\n    }\n\n    export interface Log {\n        write: (message: string, level: LogLevel) => void;\n    }\n\n    export class LogCallback implements Log {\n        onmessage: undefined | ((message: string, level: LogLevel) => void) = undefined;\n\n        write(message: string, level: LogLevel) {\n            if (this.onmessage) {\n                this.onmessage(message, level);\n            }\n        }\n    }\n\n    export class LogArray implements Log {\n        messages: { message: string; level: LogLevel }[];\n\n        constructor() {\n            this.messages = [];\n        }\n\n        write(message: string, level: LogLevel) {\n            this.messages.push({ message: message, level: level });\n        }\n    }\n\n    export class LogConsole implements Log {\n\n        constructor() {\n        }\n\n        write(message: string, level: LogLevel) {\n            console.log(LogLevelToString(level) + \": \" + message);\n        }\n    }\n\n\n    export class LogTextArea implements Log {\n        area: HTMLTextAreaElement;\n\n        constructor(area: HTMLTextAreaElement) {\n            this.area = area;\n        }\n\n        write(message: string, level: LogLevel) {\n            var line: string = LogLevelToString(level) + \": \" + message;\n            this.area.textContent += line + \"\\n\";\n        }\n    }\n\n    export class LogFilter implements Log {\n        level: LogLevel;\n        log: Log;\n\n        constructor(log: Log, level: LogLevel) {\n            this.log = log;\n            this.level = level;\n        }\n\n\n        write(message: string, level: LogLevel) {\n            if (level > this.level) {\n                this.log.write(message, level);\n            }\n        }\n    }\n","\nimport {Log, LogLevel} from \"./log\"\n\n    export class Context {\n        log: Log;\n        constructor(l : Log) {\n            this.log = l;\n        }\n\n        isInstanceOf(el: any, typeName: string): boolean {\n            return el._className.indexOf(\"|\" + typeName + \"|\") > -1;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\n\n\n    export interface LinkResolveResult {\n        result: EElement | undefined;\n        warning: string | undefined;\n    }\n\n    /**\n    * Base class for all links within a collada document\n    */\n    export class Link {\n        url: string = \"\";\n        target: EElement | undefined;\n\n        constructor() {\n        }\n\n        getUrl(): string {\n            throw new Error(\"not implemented\");\n        }\n\n        resolve(context: LoaderContext) {\n            throw new Error(\"not implemented\");\n        }\n\n    };\n\n    /**\n    *   COLLADA URL addressing\n    *\n    *   See chapter 3, section \"Adress Syntax\"\n    *   Uses XML ids that are unique within the whole document.\n    *   Hyperlinks to ids start with a hash.\n    *   <element id=\"xyz\">\n    *   <element source=\"#xyz\">\n    */\n    export class UrlLink extends Link {\n\n        constructor(url: string) {\n            super();\n            this.url = url.trim().replace(/^#/, \"\");\n        }\n\n        getUrl(): string {\n            return this.url;\n        }\n\n        resolve(context: LoaderContext): void {\n            // IDs are globally unique\n            var object: EElement = context.ids[this.url];\n            if (object != null) {\n                this.target = object;\n            } else {\n                context.log?.write(\"Could not find URL target with URL \" + this.url, LogLevel.Warning);\n            }\n        }\n    };\n\n    /**\n    *   COLLADA FX parameter addressing\n    *\n    *   See chapter 7, section \"About Parameters\"\n    *   Uses scoped ids that are unique within the given scope.\n    *   If the target is not defined within the same scope,\n    *   the search continues in the parent scope\n    *   <element sid=\"xyz\">\n    *   <element texture=\"xyz\">\n    */\n    export class FxLink extends Link {\n        scope: EElement | undefined;\n\n        constructor(url: string, scope: EElement) {\n            super();\n            this.url = url;\n            this.scope = scope;\n        }\n\n        getUrl(): string {\n            return this.url;\n        }\n\n        resolve(context: LoaderContext): void {\n            var scope: EElement | undefined = this.scope;\n            var object: EElement | undefined = undefined;\n            // FX targets have a unique SID within a scope\n            // If the target is not found in the current scope,\n            // continue searching in the parent scope.\n            while ((object == undefined) && scope) {\n                object = scope.fxChildren[this.url];\n                scope = scope.fxParent;\n            }\n            if (object) {\n                this.target = object;\n            } else {\n                context.log?.write(\"Could not find FX target with URL \" + this.url, LogLevel.Warning);\n            };\n        }\n    }\n\n    /**\n    *   COLLADA SID addressing\n    *\n    *   See chapter 3, section \"Adress Syntax\"\n    *   Uses scoped ids that are unique within the parent element.\n    *   Adresses are anchored at a globally unique id and have a path of scoped ids.\n    *   <elementA id=\"xyz\"><elementB sid=\"abc\"></elementB></elementA>\n    *   <element target=\"xyz/abc\">\n    */\n    export class SidLink extends Link {\n        parentId: string;\n        id: string | undefined;\n        sids: string[];\n        member: string | undefined;\n        indices: number[];\n        dotSyntax: boolean;\n        arrSyntax: boolean;\n\n        constructor(url: string, parentId: string) {\n            super();\n            this.url = url;\n            this.parentId = parentId;\n            this.sids = [];\n            this.indices = [];\n            this.dotSyntax = false;\n            this.arrSyntax = false;\n            this._parseUrl();\n        }\n\n        getUrl(): string {\n            return this.url;\n        }\n\n        private _parseUrl() {\n            var parts: string[] = this.url.split(\"/\");\n\n            // Part 1: element id\n            this.id = parts.shift();\n            if (this.id === \".\") {\n                this.id = this.parentId;\n            }\n\n            // Part 2: list of sids\n            while (parts.length > 1) {\n                var s = parts.shift();\n                if (s) {\n                    this.sids.push();\n                }\n            }\n\n            // Part 3: last sid\n            if (parts.length > 0) {\n                var lastSid: string = parts[0];\n                var dotSyntax: boolean = lastSid.indexOf(\".\") >= 0;\n                var arrSyntax: boolean = lastSid.indexOf(\"(\") >= 0;\n                if (dotSyntax) {\n                    parts = lastSid.split(\".\");\n                    var s = parts.shift();\n                    if (s) {\n                        this.sids?.push(s);\n                    }\n                    this.member = parts.shift();\n                    this.dotSyntax = true;\n                } else if (arrSyntax) {\n                    var arrIndices: string[] = lastSid.split(\"(\");\n                    var idx = arrIndices.shift();\n                    if (idx) {\n                        this.sids.push(idx);\n                    }\n                    this.indices = [];\n                    var index: string;\n                    for (var i: number = 0, len: number = arrIndices.length; i < len; i++) {\n                        index = arrIndices[i];\n                        this.indices.push(parseInt(index.replace(/\\)/, \"\"), 10));\n                    }\n                    this.arrSyntax = true;\n                } else {\n                    this.sids.push(lastSid);\n                }\n            }\n        };\n\n        /**\n        *   Find the SID target given by the URL (array of sid parts).\n        *\n        *   @param url The complete URL, for debugging only\n        *   @param root Root element, where the search starts.\n        *   @param sids SID parts.\n        *   @returns The collada element the URL points to, or an error why it wasn't found\n        */\n        static findSidTarget(url: string, root: EElement, sids: string[], context: Context): LinkResolveResult {\n            var result: LinkResolveResult = { result: undefined, warning: undefined };\n            if (root == null) {\n                result.result = undefined;\n                result.warning = \"Could not resolve SID target \" + sids.join(\"/\") + \", missing root element\";\n                return result;\n            }\n            var parentObject: EElement = root;\n            var childObject: EElement | undefined = undefined;\n            // For each SID part, perform a depth-first search\n            for (var i: number = 0, ilen: number = sids.length; i < ilen; i++) {\n                var sid: string = sids[i];\n                // Initialize a queue for the search\n                var queue: EElement[] = [parentObject];\n                // Dept-first search\n                while (queue.length !== 0) {\n                    // Get front of search queue\n                    var front: EElement | undefined = queue.shift();\n                    if (front) {\n                        // Stop if we found the target\n                        if (front.sid === sid) {\n                            childObject = front;\n                            break;\n                        }\n                        // Add all children to the back of the queue\n                        var frontChildren: EElement[] = front.sidChildren;\n                        if (frontChildren != null) {\n                            for (var j: number = 0, jlen: number = frontChildren.length; j < jlen; j++) {\n                                var sidChild: EElement = frontChildren[j];\n                                queue.push(sidChild);\n                            }\n                        }\n                    }\n                }\n                // Abort if the current SID part was not found\n                if (!childObject) {\n                    result.result = undefined;\n                    result.warning = \"Could not resolve SID target \" + sids.join(\"/\") + \", missing SID part \" + sid;\n                    return result;\n                }\n                parentObject = childObject;\n            }\n            // All parts processed, return the final target\n            result.result = childObject;\n            result.warning = \"\";\n            return result;\n        }\n\n        resolve(context: LoaderContext): void {\n            var object: EElement | undefined;\n            if (this.id == null) {\n                context.log?.write(\"Could not resolve SID #\" + this.url + \", link has no root ID\", LogLevel.Warning);\n                return;\n            }\n            object = context.ids[this.id];\n            if (object == null) {\n                context.log?.write(\"Could not resolve SID #\" + this.url + \", could not find root element \" + this.id, LogLevel.Warning);\n                return;\n            }\n            var result = SidLink.findSidTarget(this.url, object, this.sids, context);\n            if (result.warning) {\n                context.log?.write(result.warning, LogLevel.Warning);\n            }\n            this.target = result.result;\n        }\n    }\n","\nimport * as COLLADAContext from \"../context\"\nimport { Log, LogLevel } from \"../log\"\nimport { EElement } from \"./element\";\nimport { Link, UrlLink, SidLink, FxLink } from \"./link\";\n\n\n\n    export class LoaderContext extends COLLADAContext.Context {\n        ids: { [s: string]: EElement; }\n        links: Link[] | undefined;\n        totalBytes: number = 0;\n        loadedBytes: number = 0;\n\n        constructor(log: Log) {\n            super(log);\n            this.ids = {};\n            this.links = [];\n        }\n\n        getAttributeNamed(el: Node, name: string) : Attr | undefined {\n            var e = el as Element;\n            var a = e.getAttributeNode(name);\n            if (a) {\n                return a;\n            } else {\n                return undefined;\n            }\n\n        }\n\n        getAttributeFromChildNodesNamed(cn: NodeListOf<ChildNode>, name: string) : Attr | undefined {\n            cn.forEach(el => {\n                var a = this.getAttributeNamed(el, name);\n                if (a) {\n                    return a;\n                }\n            });\n            return undefined;\n        }\n\n        getTextContent(el: Node): string {\n            return el.textContent || (<any>el).firstChild.getNodeValue()+\"\";\n        }\n\n        getFloatsContent(el: Node): Float32Array {\n            return this.strToFloats(this.getTextContent(el));\n        }\n\n        getFloatContent(el: Node): number {\n            return parseFloat(this.getTextContent(el));\n        }\n\n        getIntsContent(el: Node): Int32Array {\n            return this.strToInts(this.getTextContent(el));\n        }\n\n        getUintsContent(el: Node): Uint32Array {\n            return this.strToUints(this.getTextContent(el));\n        }\n\n        getIntContent(el: Node): number {\n            return parseInt(this.getTextContent(el), 10);\n        }\n\n        getBoolsContent(el: Node): Uint8Array {\n            return this.strToBools(this.getTextContent(el));\n        }\n\n        getStringsContent(el: Node): string[] {\n            return this.strToStrings(this.getTextContent(el));\n        }\n\n        getAttributeAsFloat(el: Node, name: string, defaultValue: number, required: boolean): number {\n            var attr = this.getAttributeFromChildNodesNamed(el.childNodes, name);\n            if (attr) {\n                return parseFloat(attr.value);\n            } else if (!required) {\n                return defaultValue;\n            } else {\n                this.log?.write(\"Element \" + el.nodeName + \" is missing required float attribute \" + name + \". Using default value \" + defaultValue + \".\", LogLevel.Error);\n                return defaultValue;\n            }\n        }\n\n        getAttributeAsInt(el: Node, name: string, defaultValue: number, required: boolean): number{\n            var attr = this.getAttributeNamed(el, name);\n            if (attr) {\n                return parseInt(attr.value, 10);\n            } else if (!required) {\n                return defaultValue;\n            } else {\n                this.log?.write(\"Element \" + el.nodeName + \" is missing required integer attribute \" + name + \". Using default value \" + defaultValue + \".\", LogLevel.Error);\n                return defaultValue;\n            }\n        }\n\n        getAttributeAsString(el: Node, name: string, defaultValue: string | undefined, required: boolean): string {\n            var attr = this.getAttributeNamed(el, name);\n            if (attr) {\n                return attr.value + \"\";\n            } else if (!required) {\n                return defaultValue?defaultValue:\"\";\n            } else {\n                this.log?.write(\"Element \" + el.nodeName + \" is missing required string attribute \" + name + \". Using default value \" + defaultValue + \".\", LogLevel.Error);\n                return defaultValue?defaultValue:\"\";\n            }\n        }\n\n        createUrlLink(url: string): UrlLink {\n            var link: UrlLink = new UrlLink(url);\n            this.links?.push(link);\n            return link;\n        }\n\n        createSidLink(url: string, parentId: string): SidLink {\n            var link: SidLink = new SidLink(url, parentId);\n            this.links?.push(link);\n            return link;\n        }\n\n        createFxLink(url: string, scope: EElement): FxLink {\n            var link: FxLink = new FxLink(url, scope);\n            this.links?.push(link);\n            return link;\n        }\n\n        getAttributeAsUrlLink(el: Node, name: string, required: boolean): UrlLink | undefined{\n            var attr = this.getAttributeNamed(el, name);\n            if (attr) {\n                return this.createUrlLink(attr.value);\n            } else if (!required) {\n                return undefined;\n            } else {\n                this.log?.write(\"Element \" + el.nodeName + \" is missing required URL link attribute \" + name + \".\", LogLevel.Error);\n                return undefined;\n            }\n        }\n\n        getAttributeAsSidLink(el: Node, name: string, parentId: string, required: boolean): SidLink | undefined {\n            var attr = this.getAttributeNamed(el, name);\n            if (attr) {\n                return this.createSidLink(attr.value, parentId);\n            } else if (!required) {\n                return undefined;\n            } else {\n                this.log?.write(\"Element \" + el.nodeName + \" is missing required SID link attribute \" + name + \".\", LogLevel.Error);\n                return undefined;\n            }\n        }\n\n        getAttributeAsFxLink(el: Node, name: string, scope: EElement, required: boolean): FxLink | undefined{\n            var attr = this.getAttributeNamed(el, name);\n            if (attr) {\n                return this.createFxLink(attr.value, scope);\n            } else if (!required) {\n                return undefined;\n            } else {\n                this.log?.write(\"Element \" + el.nodeName + \" is missing required FX link attribute \" + name + \".\", LogLevel.Error);\n                return undefined;\n            }\n        }\n\n        /**\n        *   Splits a string into whitespace-separated strings\n        */\n        strToStrings(str: string): string[] {\n            if (str.length > 0) {\n                return str.trim().split(/\\s+/);\n            } else {\n                return [];\n            }\n        }\n\n        /**\n        *   Parses a string of whitespace-separated float numbers\n        */\n        strToFloats(str: string): Float32Array {\n            var strings: string[] = this.strToStrings(str);\n            var data: Float32Array = new Float32Array(strings.length);\n            var len: number = strings.length;\n            for (var i: number = 0; i < len; ++i) {\n                data[i] = parseFloat(strings[i]);\n            }\n            return data;\n        }\n\n        /**\n        *   Parses a string of whitespace-separated integer numbers\n        */\n        strToInts(str: string): Int32Array {\n            var strings: string[] = this.strToStrings(str);\n            var data: Int32Array = new Int32Array(strings.length);\n            var len: number = strings.length;\n            for (var i: number = 0; i < len; ++i) {\n                data[i] = parseInt(strings[i], 10);\n            }\n            return data;\n        }\n\n        /**\n        *   Parses a string of whitespace-separated integer numbers\n        */\n        strToUints(str: string): Uint32Array {\n            var strings: string[] = this.strToStrings(str);\n            var data: Uint32Array = new Uint32Array(strings.length);\n            var len: number = strings.length;\n            for (var i: number = 0; i < len; ++i) {\n                data[i] = parseInt(strings[i], 10);\n            }\n            return data;\n        }\n\n        /**\n        *   Parses a string of whitespace-separated booleans\n        */\n        strToBools(str: string): Uint8Array {\n            var strings: string[] = this.strToStrings(str);\n            var data: Uint8Array = new Uint8Array(strings.length);\n            var len: number = strings.length;\n            for (var i: number = 0; i < len; ++i) {\n                data[i] = (strings[i] === \"true\" || strings[i] === \"1\") ? 1 : 0;\n            }\n            return data;\n        }\n\n        /**\n        *   Parses a color string\n        */\n        strToColor(str: string): Float32Array {\n            var rgba = this.strToFloats(str);\n            if (rgba.length === 4) {\n                return rgba;\n            } else {\n                this.log?.write(\"Skipped color element because it does not contain 4 numbers\", LogLevel.Error);\n                return new Float32Array();\n            }\n        }\n\n        registerUrlTarget(object: EElement, needsId: boolean) {\n            var id: string = object.id;\n            // Abort if the object has no ID\n            if (id == null) {\n                if (needsId) {\n                    this.log?.write(\"Object has no ID, object was not registered as a URL target.\", LogLevel.Error);\n                }\n                return;\n            }\n            // IDs must be unique\n            if (this.ids[id] != null) {\n                this.log?.write(\"There is already an object with ID \" + id + \". IDs must be globally unique.\", LogLevel.Error);\n                return;\n            }\n            // URL links are registered globally\n            this.ids[id] = object;\n        }\n\n        registerFxTarget(object: EElement, scope: EElement) {\n            var sid: string = object.sid;\n            if (sid == null) {\n                this.log?.write(\"Cannot add a FX target: object has no SID.\", LogLevel.Error);\n                return;\n            }\n            if (scope.fxChildren[sid] != null) {\n                this.log?.write(\"There is already an FX target with SID \" + sid + \".\", LogLevel.Error);\n                return;\n            }\n            // FX links are registered within the parent scope\n            object.fxParent = scope;\n            scope.fxChildren[sid] = object;\n        }\n\n        registerSidTarget(object: EElement, parent: EElement) {\n            // SID links are registered within the parent scope\n            parent.sidChildren.push(object);\n        }\n\n        getNodePath(node: Node): string {\n            var path: string = \"<\" + node.nodeName + \">\";\n            var len: number = 1;\n            var maxLen: number = 10;\n            while (node.parentNode != null) {\n                node = node.parentNode;\n                if (node.nodeName.toUpperCase() === \"COLLADA\") {\n                    break;\n                } else if (len >= maxLen) {\n                    path = \".../\" + path;\n                    break;\n                } else {\n                    path = (\"<\" + node.nodeName + \">/\") + path;\n                    len += 1;\n                }\n            }\n            return path;\n        }\n\n        reportUnexpectedChild(child: Node) {\n            this.log?.write(\"Skipped unexpected element \" + (this.getNodePath(child)) + \".\", LogLevel.Warning);\n        }\n\n        reportUnhandledChild(child: Node) {\n            this.log?.write(\"Element \" + (this.getNodePath(child)) + \" is legal, but not handled by this loader.\", LogLevel.Trace);\n        }\n\n        resolveAllLinks() {\n            if (this.links) {\n                var linksLen: number = this.links.length;\n                for (var i = 0; i < linksLen; ++i) {\n                    var link: Link = this.links[i];\n                    link.resolve(this);\n                }\n            }\n        }\n    };\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\nimport { Link } from \"./link\";\n\n\n    /**\n    *   Base class for any collada element.\n    *\n    *   Contains members for URL, FX, and SID adressing,\n    *   even if the actual element does not support those.\n    */\n    export class EElement {\n        /** Class name so that we do not depend on instanceof */\n        _className: string;\n        /** Collada URL adressing: identifier */\n        id: string = \"\";\n        /** Collada SID/FX adressing: identifier */\n        sid: string = \"\";\n        /** Collada FX adressing: parent element */\n        fxParent: EElement | undefined;\n        /** Collada FX adressing: child elements */\n        fxChildren: { [sid: string]: EElement; };\n        /** Collada SID adressing: child elements */\n        sidChildren: EElement[];\n        /** Name of the element. Not used for any adressing. */\n        name: string = \"\";\n\n        /** Empty constructor */\n        constructor() {\n            this.fxChildren = {};\n            this.sidChildren = [];\n            this._className = \"|Element|\";\n        }\n\n        static fromLink(link: Link, context: Context): EElement | undefined{\n            return EElement._fromLink<EElement>(link, \"Element\", context);\n        }\n\n        static _fromLink<T extends EElement>(link: Link, typeName: string, context: Context): T | undefined{\n            if (!link) {\n                return undefined;\n            } else if (!link.target) {\n                return undefined;\n            } else if (context.isInstanceOf(link.target, typeName)) {\n                return <T> link.target;\n            } else {\n                context.log.write(\"Link with url \" + link.url + \" does not point to a \" + typeName + \", link target ignored\", LogLevel.Error);\n                return undefined;\n            }\n        }\n    };\n","\n    export function forEachChild(node: Node, fn: (child: Node) => void) {\n\n        var childNodes: NodeList = node.childNodes;\n        var childNodesLength: number = childNodes.length;\n\n        // Iterate over all children (can be nodes or text content)\n        for (var i: number = 0; i < childNodesLength; i++) {\n            var child: Node = childNodes[i] || childNodes.item(i);\n\n            // Skip text content\n            if (child.nodeType !== 1) continue;\n\n            // Callback for child node\n            fn(child);\n        }\n    }\n","\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\nimport * as Utils from \"./utils\"\n\n    /**\n    *   A <scene> element.\n    */\n    export class Scene extends EElement {\n        instance: Link | undefined = undefined;\n\n        constructor() {\n            super();\n            this._className += \"Scene|\";\n        }\n\n        static parse(node: Node, context: LoaderContext): Scene {\n            var result: Scene = new Scene();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"instance_visual_scene\":\n                        result.instance = context.getAttributeAsUrlLink(child, \"url\", true);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    };\n","\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { UrlLink, SidLink } from \"./link\";\nimport * as Utils from \"./utils\";\nimport {Animation} from \"./animation\";\n\n    export class Channel extends EElement {\n        source: UrlLink | undefined;\n        target: SidLink | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Channel|\";\n        }\n\n        /**\n        *   Parses a <channel> element.\n        */\n        static parse(node: Node, parent: Animation, context: LoaderContext): Channel {\n            var result: Channel = new Channel();\n\n            result.source = context.getAttributeAsUrlLink(node, \"source\", true);\n            result.target = context.getAttributeAsSidLink(node, \"target\", parent.id, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n    }\n","import { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { UrlLink } from \"./link\";\n\n\n\n    export class Input extends EElement {\n        /** \"VERTEX\", \"POSITION\", \"NORMAL\", \"TEXCOORD\", ... */\n        semantic: string = \"\";\n        /** URL of source object */\n        source: UrlLink | undefined;\n        /** Offset in index array */\n        offset: number = 0;\n        /** Optional set identifier */\n        set: number = 0;\n\n        constructor() {\n            super();\n            this._className += \"Input|\";\n        }\n\n        /**\n        *   Parses an <input> element.\n        */\n        static parse(node: Node, shared: boolean, context: LoaderContext): Input {\n            var result: Input = new Input();\n\n            result.semantic = context.getAttributeAsString(node, \"semantic\", undefined, true);\n            result.source = context.getAttributeAsUrlLink(node, \"source\", true);\n\n            if (shared) {\n                result.offset = context.getAttributeAsInt(node, \"offset\", 0, true);\n                result.set = context.getAttributeAsInt(node, \"set\", 0, false);\n            }\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Input } from \"./input\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n    export class Sampler extends EElement {\n        input: Input | undefined;\n        outputs: Input[];\n        inTangents: Input[];\n        outTangents: Input[];\n        interpolation: Input | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Sampler|\";\n            this.outputs = [];\n            this.inTangents = [];\n            this.outTangents = [];\n        }\n\n        static fromLink(link: Link, context: Context): Sampler | undefined{\n            return EElement._fromLink<Sampler>(link, \"Sampler\", context);\n        }\n\n        /**\n        *   Parses a <sampler> element.\n        */\n        static parse(node: Node, context: LoaderContext): Sampler {\n            var result: Sampler = new Sampler();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, false);\n            context.registerUrlTarget(result, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"input\":\n                        var input: Input = Input.parse(child, false, context);\n                        Sampler?.addInput(result, input, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        static addInput(sampler: Sampler, input: Input, context: LoaderContext) {\n            switch (input.semantic) {\n                case \"INPUT\":\n                    sampler.input = input;\n                    break;\n                case \"OUTPUT\":\n                    sampler.outputs.push(input);\n                    break;\n                case \"INTERPOLATION\":\n                    sampler.interpolation = input;\n                    break;\n                case \"IN_TANGENT\":\n                    sampler.inTangents.push(input);\n                    break;\n                case \"OUT_TANGENT\":\n                    sampler.outTangents.push(input);\n                    break;\n                default:\n                    context.log.write(\"Unknown sampler input semantic \" + input.semantic, LogLevel.Error);\n            }\n        }\n\n    }\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\n\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { Link } from \"./link\"\nimport * as Utils from \"./utils\"\n\n    export interface SourceData {\n        length: number;\n        [index: number]: any;\n    }\n\n    export class Source extends EElement {\n        sourceId: string | undefined;\n        count: number = 0;\n        stride: number = 0;\n        offset: number = 0;\n        /** Can be one of: Float32Array, Int32Array, Uint8Array, Array<string> */\n        data: SourceData | undefined;\n        params: { [s: string]: string; }\n\n        constructor() {\n            super();\n            this._className += \"Source|\";\n            this.params = {};\n        }\n\n        static fromLink(link: Link | undefined, context: Context): Source | undefined {\n            if (!link) {\n                return undefined;\n            }\n            return EElement._fromLink<Source>(link, \"Source\", context);\n        }\n\n        /**\n        *   Parses a <source> element\n        */\n        static parse(node: Node, context: LoaderContext): Source {\n            var result: Source = new Source();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerUrlTarget(result, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"bool_array\":\n                        result.sourceId = context.getAttributeAsString(child, \"id\", undefined, false);\n                        result.data = context.getBoolsContent(child);\n                        break;\n                    case \"float_array\":\n                        result.sourceId = context.getAttributeAsString(child, \"id\", undefined, false);\n                        result.data = context.getFloatsContent(child);\n                        break;\n                    case \"int_array\":\n                        result.sourceId = context.getAttributeAsString(child, \"id\", undefined, false);\n                        result.data = context.getIntsContent(child);\n                        break;\n                    case \"IDREF_array\":\n                    case \"Name_array\":\n                        result.sourceId = context.getAttributeAsString(child, \"id\", undefined, false);\n                        result.data = context.getStringsContent(child);\n                        break;\n                    case \"technique_common\":\n                        Source.parseSourceTechniqueCommon(child, result, context);\n                        break;\n                    case \"technique\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        /**\n        *   Parses a <source>/<technique_common> element\n        */\n        static parseSourceTechniqueCommon(node: Node, source: Source, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"accessor\":\n                        Source.parseAccessor(child, source, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n\n        /**\n        *   Parses a <source>/<technique_common>/<accessor> element\n        */\n        static parseAccessor(node: Node, source: Source, context: LoaderContext) {\n\n            var sourceId: string = context.getAttributeAsString(node, \"source\", undefined, true);\n            source.count = context.getAttributeAsInt(node, \"count\", 0, true) || 0;\n            source.stride = context.getAttributeAsInt(node, \"stride\", 1, false) || 0;\n            source.offset = context.getAttributeAsInt(node, \"offset\", 0, false) || 0;\n            if (sourceId !== \"#\" + source.sourceId) {\n                context.log.write(\"Source \" + source.id + \" uses a non-local data source, this is not supported\", LogLevel.Error);\n            }\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"param\":\n                        Source.parseAccessorParam(child, source, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n\n        /**\n        *   Parses a <source>/<technique_common>/<accessor>/<param> element\n        */\n        static parseAccessorParam(node: Node, source: Source, context: LoaderContext) {\n\n            var name: string = context.getAttributeAsString(node, \"name\", undefined, false);\n            var semantic: string = context.getAttributeAsString(node, \"semantic\", undefined, false);\n            var type: string = context.getAttributeAsString(node, \"type\", undefined, true);\n            var sid: string = context.getAttributeAsString(node, \"sid\", undefined, false);\n\n            if ((name != null) && (type != null)) {\n                source.params[name] = type;\n            } else if ((semantic != null) && (type != null)) {\n                source.params[semantic] = type;\n            } else if (type != null) {\n                // Both name and semantic are optional\n                source.params[\"unnamed param #\" + Object.keys(source.params).length] = type\n            } else {\n                // Type is required\n                context.log.write(\"Accessor param for source \" + source.id + \" ignored due to missing type\", LogLevel.Warning);\n            }\n        }\n    }\n","import { Channel } from \"./channel\"\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { Sampler } from \"./sampler\"\nimport * as SourceLoader from \"./source\"\nimport * as Utils from \"./utils\"\nimport * as AnimationConverter from \"../converter/animation\"\n\n\n\n    export class Animation extends EElement {\n        parent: Animation | undefined;\n        children: Animation[];\n        sources: SourceLoader.Source[];\n        samplers: Sampler[];\n        channels: Channel[];\n\n        constructor() {\n            super();\n            this._className += \"Animation|\";\n            this.children = [];\n            this.sources = [];\n            this.samplers = [];\n            this.channels = [];\n        }\n\n        root(): Animation {\n            if (this.parent != null) {\n                return this.parent.root();\n            } else {\n                return this;\n            }\n        }\n\n        /**\n        *   Parses an <animation> element.\n        */\n        static parse(node: Node, context: LoaderContext): Animation {\n            var result: Animation = new Animation();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, false);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n\n            context.registerUrlTarget(result, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"animation\":\n                        var animation: Animation = Animation.parse(child, context);\n                        animation.parent = result;\n                        result.children.push(animation);\n                        break;\n                    case \"source\":\n                        result.sources.push(SourceLoader.Source.parse(child, context));\n                        break;\n                    case \"sampler\":\n                        result.samplers.push(Sampler.parse(child, context));\n                        break;\n                    case \"channel\":\n                        result.channels.push(Channel.parse(child, result, context));\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n    };\n\n    \n    export class AnimationLibrary extends EElement {\n        children: Animation[] = [];\n\n        static parse(node: Node, context: LoaderContext): AnimationLibrary {\n            var result: AnimationLibrary = new AnimationLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"animation\":\n                        result.children.push(Animation.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport * as Utils from \"./utils\";\n\n    /**\n    *   An <asset> element.\n    */\n    export class Asset extends EElement {\n        unit: number = 0;\n        upAxis: string = \"\";\n\n        constructor() {\n            super();\n            this._className += \"Asset|\";\n        }\n\n        static parse(node: Node, context: LoaderContext): Asset {\n            var result: Asset = new Asset();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"unit\":\n                        result.unit = context.getAttributeAsFloat(child, \"meter\", 1, false);\n                        break;\n                    case \"up_axis\":\n                        result.upAxis = context.getTextContent(child).toUpperCase().charAt(0);\n                        break;\n                    case \"contributor\":\n                    case \"created\":\n                    case \"modified\":\n                    case \"revision\":\n                    case \"title\":\n                    case \"subject\":\n                    case \"keywords\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\n\n    export class CameraParam extends EElement {\n        value: number = 0;\n\n        constructor() {\n            super();\n            this._className += \"CameraParam|\";\n        }\n\n        /**\n        *   Parses a camera parameter element.\n        */\n        static parse(node: Node, context: LoaderContext): CameraParam {\n            var result: CameraParam = new CameraParam();\n\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            result.name = node.nodeName;\n            result.value = parseFloat(context.getTextContent(node));\n\n            return result;\n        }\n\n    }\n","import { CameraParam } from \"./camera_param\";\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport * as Utils from \"./utils\";\n\n    export class Camera extends EElement {\n        type: string = \"\";\n        params: { [s: string]: CameraParam; }\n\n        constructor() {\n            super();\n            this._className += \"Camera|\";\n            this.params = {};\n        }\n\n        /**\n        *   Parses a <camera> element.\n        */\n        static parse(node: Node, context: LoaderContext): Camera {\n            var result: Camera = new Camera();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerUrlTarget(result, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"asset\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    case \"optics\":\n                        Camera.parseOptics(child, result, context);\n                        break;\n                    case \"imager\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        /**\n        *   Parses a <camera>/<optics> element.\n        */\n        static parseOptics(node: Node, camera: Camera, context: LoaderContext) {\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"technique_common\":\n                        Camera.parseTechniqueCommon(child, camera, context);\n                        break;\n                    case \"technique\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n        }\n\n        /**\n        *   Parses a <camera>/<optics>/<technique_common> element.\n        */\n        static parseTechniqueCommon(node: Node, camera: Camera, context: LoaderContext) {\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"orthographic\":\n                        Camera.parseParams(child, camera, context);\n                        break;\n                    case \"perspective\":\n                        Camera.parseParams(child, camera, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n        }\n\n        /**\n        *   Parses a <camera>/<optics>/<technique_common>/(<orthographic>|<perspective>) element.\n        */\n        static parseParams(node: Node, camera: Camera, context: LoaderContext) {\n\n            camera.type = node.nodeName;\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"xmag\":\n                    case \"ymag\":\n                    case \"xfov\":\n                    case \"yfov\":\n                    case \"aspect_ratio\":\n                    case \"znear\":\n                    case \"zfar\":\n                        var param: CameraParam = CameraParam.parse(child, context);\n                        context.registerSidTarget(param, camera);\n                        camera.params[param.name] = param;\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n        }\n    }\n\n    export class CameraLibrary extends EElement {\n        children: Camera[] = [];\n\n\n        static parse(node: Node, context: LoaderContext): CameraLibrary {\n            var result: CameraLibrary = new CameraLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"camera\":\n                        result.children.push(Camera.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\n\n\n    export class Morph extends EElement {\n\n        constructor() {\n            super();\n            this._className += \"Morph|\";\n        }\n\n        /**\n        *   Parses a <morph> element.\n        */\n        static parse(node: Node, context: LoaderContext): Morph {\n            var result: Morph = new Morph();\n\n            context.log.write(\"Morph controllers not implemented\", LogLevel.Error);\n\n            return result;\n        }\n\n    }\n","import { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Input } from \"./input\";\n\nimport * as Utils from \"./utils\"\n\n    export class Joints extends EElement {\n        joints: Input | undefined;\n        invBindMatrices: Input | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Joints|\";\n        }\n\n        /**\n        *   Parses a <joints> element.\n        */\n        static parse(node: Node, context: LoaderContext): Joints {\n            var result: Joints = new Joints();\n\n            var inputs: Input[] = [];\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"input\":\n                        var input: Input = Input.parse(child, false, context);\n                        Joints.addInput(result, input, context);\n                        inputs.push(input);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        static addInput(joints: Joints, input: Input, context: LoaderContext) {\n            switch (input.semantic) {\n                case \"JOINT\":\n                    joints.joints = input;\n                    break;\n                case \"INV_BIND_MATRIX\":\n                    joints.invBindMatrices = input;\n                    break;\n                default:\n                    context.log?.write(\"Unknown joints input semantic \" + input.semantic, LogLevel.Error);\n            }\n        }\n\n    }\n","import { LogLevel } from \"../log\"\n\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { Input } from \"./input\"\nimport * as Utils from \"./utils\"\n\n    export class VertexWeights extends EElement {\n        inputs: Input[];\n        vcount: Int32Array = new Int32Array();\n        v: Int32Array = new Int32Array();\n        joints: Input | undefined = undefined;\n        weights: Input | undefined = undefined;\n        count: number = 0;\n\n        constructor() {\n            super();\n            this._className += \"VertexWeights|\";\n            this.inputs = [];\n        }\n\n        /**\n        *   Parses a <vertex_weights> element.\n        */\n        static parse(node: Node, context: LoaderContext): VertexWeights {\n            var result: VertexWeights = new VertexWeights();\n\n            result.count = context.getAttributeAsInt(node, \"count\", 0, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"input\":\n                        var input: Input = Input.parse(child, true, context);\n                        VertexWeights.addInput(result, input, context);\n                        break;\n                    case \"vcount\":\n                        result.vcount = context.getIntsContent(child);\n                        break;\n                    case \"v\":\n                        result.v = context.getIntsContent(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        static addInput(weights: VertexWeights, input: Input, context: LoaderContext) {\n            switch (input.semantic) {\n                case \"JOINT\":\n                    weights.joints = input;\n                    break;\n                case \"WEIGHT\":\n                    weights.weights = input;\n                    break;\n                default:\n                    context.log.write(\"Unknown vertex weights input semantic \" + input.semantic, LogLevel.Error);\n            }\n        }\n    }\n","\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Joints } from \"./joints\";\nimport { UrlLink } from \"./link\";\nimport * as SourceLoader from \"./source\"\nimport * as Utils from \"./utils\"\nimport { VertexWeights } from \"./vertex_weights\";\n\n    export class Skin extends EElement {\n        source: UrlLink | undefined;\n        bindShapeMatrix: Float32Array = new Float32Array();\n        sources: SourceLoader.Source[] | undefined;\n        joints: Joints | undefined;\n        vertexWeights: VertexWeights | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Skin|\";\n        }\n\n        /**\n        *   Parses a <skin> element.\n        */\n        static parse(node: Node, context: LoaderContext): Skin {\n            var result: Skin = new Skin();\n\n            result.source = context.getAttributeAsUrlLink(node, \"source\", true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"bind_shape_matrix\":\n                        result.bindShapeMatrix = context.getFloatsContent(child);\n                        break;\n                    case \"source\":\n                        result.sources?.push(SourceLoader.Source.parse(child, context));\n                        break;\n                    case \"joints\":\n                        result.joints = Joints.parse(child, context);\n                        break;\n                    case \"vertex_weights\":\n                        result.vertexWeights = VertexWeights.parse(child, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n    }\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\nimport { Morph } from \"./morph\";\nimport { Skin } from \"./skin\";\n\nimport * as Utils from \"./utils\"\n\n\n\n    export class Controller extends EElement {\n        skin: Skin | undefined;\n        morph: Morph | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Controller|\";\n        }\n\n        static fromLink(link: Link, context: Context): Controller | undefined {\n            return EElement._fromLink<Controller>(link, \"Controller\", context);\n        }\n\n        /**\n        *   Parses a <controller> element.\n        */\n        static parse(node: Node, context: LoaderContext): Controller {\n            var result: Controller = new Controller();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerUrlTarget(result, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"skin\":\n                        if (result.skin != null) {\n                            context.log.write(\"Controller \" + result.id + \" has multiple skins\", LogLevel.Error);\n                        }\n                        result.skin = Skin.parse(child, context);\n                        break;\n                    case \"morph\":\n                        if (result.morph != null) {\n                            context.log.write(\"Controller \" + result.id + \" has multiple morphs\", LogLevel.Error);\n                        }\n                        result.morph = Morph.parse(child, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n    }\n\n    export class ControllerLibrary extends EElement {\n        children: Controller[];\n\n\n        static parse(node: Node, context: LoaderContext): ControllerLibrary {\n            var result: ControllerLibrary = new ControllerLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"controller\":\n                        result.children.push(Controller.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n    /**\n    *   An <newparam> element.\n    */\n    export class EffectSampler extends EElement {\n        surface: Link | undefined;\n        image: Link | undefined;\n        wrapS: string = \"\";\n        wrapT: string = \"\";\n        minFilter: string = \"\";\n        magFilter: string = \"\";\n        borderColor: Float32Array | undefined;\n        mipmapMaxLevel: number = 0;\n        mipmapBias: number = 0;\n\n        constructor() {\n            super();\n            this._className += \"EffectSampler|\";\n        }\n\n        static fromLink(link: Link, context: Context): EffectSampler | undefined {\n            return EElement._fromLink<EffectSampler>(link, \"EffectSampler\", context);\n        }\n\n        /**\n        *   Parses a <newparam> element.\n        */\n        static parse(node: Node, parent: EElement, context: LoaderContext): EffectSampler {\n            var result: EffectSampler = new EffectSampler();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"source\":\n                        result.surface = context.createFxLink(context.getTextContent(child), parent);\n                        break;\n                    case \"instance_image\":\n                        result.image = context.getAttributeAsUrlLink(child, \"url\", true);\n                        break;\n                    case \"wrap_s\":\n                        result.wrapS = context.getTextContent(child);\n                        break;\n                    case \"wrap_t\":\n                        result.wrapT = context.getTextContent(child);\n                        break;\n                    case \"minfilter\":\n                        result.minFilter = context.getTextContent(child);\n                        break;\n                    case \"magfilter\":\n                        result.magFilter = context.getTextContent(child);\n                        break;\n                    case \"border_color\":\n                        result.borderColor = context.getFloatsContent(child);\n                        break;\n                    case \"mipmap_maxlevel\":\n                        result.mipmapMaxLevel = context.getIntContent(child);\n                        break;\n                    case \"mipmap_bias\":\n                        result.mipmapBias = context.getFloatContent(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n\n\n    /**\n    *   A <surface> element.\n    *\n    */\n    export class EffectSurface extends EElement {\n        type: string = \"\";\n        initFrom: Link | undefined;\n        format: string = \"\";\n        size: Float32Array = new Float32Array();\n        viewportRatio: Float32Array = new Float32Array();\n        mipLevels: number = 0;\n        mipmapGenerate: boolean = false;\n\n        constructor() {\n            super();\n            this._className += \"EffectSurface|\";\n        }\n\n        static fromLink(link: Link, context: Context): EffectSurface | undefined{\n            return EElement._fromLink<EffectSurface>(link, \"EffectSurface\", context);\n        }\n\n        /**\n        *   Parses a <surface> element.\n        */\n        static parse(node: Node, parent: EElement, context: LoaderContext): EffectSurface {\n            var result: EffectSurface = new EffectSurface();\n\n            result.type = context.getAttributeAsString(node, \"type\", undefined, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"init_from\":\n                        result.initFrom = context.createUrlLink(context.getTextContent(child));\n                        break;\n                    case \"format\":\n                        result.format = context.getTextContent(child);\n                        break;\n                    case \"size\":\n                        result.size = context.getFloatsContent(child);\n                        break;\n                    case \"viewport_ratio\":\n                        result.viewportRatio = context.getFloatsContent(child);\n                        break;\n                    case \"mip_levels\":\n                        result.mipLevels = context.getIntContent(child);\n                        break;\n                    case \"mipmap_generate\":\n                        result.mipmapGenerate = (context.getTextContent(child).toLowerCase() === \"true\");\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LoaderContext } from \"./context\";\nimport { EffectSampler } from \"./effect_sampler\";\nimport { EffectSurface } from \"./effect_surface\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n\n    /**\n    *   An <newparam> element.\n    *\n    */\n    export class EffectParam extends EElement {\n        semantic: string| undefined;\n        surface: EffectSurface| undefined;\n        sampler: EffectSampler| undefined;\n        floats: Float32Array| undefined;\n\n        constructor() {\n            super();\n            this._className += \"EffectParam|\";\n        }\n\n        static fromLink(link: Link, context: Context): EffectParam | undefined {\n            return EElement._fromLink<EffectParam>(link, \"EffectParam\", context);\n        }\n\n        /**\n        *   Parses a <newparam> element.\n        */\n        static parse(node: Node, parent: EElement, context: LoaderContext): EffectParam {\n            var result: EffectParam = new EffectParam();\n\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            context.registerFxTarget(result, parent);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"semantic\":\n                        result.semantic = context.getTextContent(child);\n                        break;\n                    case \"float\":\n                        result.floats = context.getFloatsContent(child);\n                        break;\n                    case \"float2\":\n                        result.floats = context.getFloatsContent(child);\n                        break;\n                    case \"float3\":\n                        result.floats = context.getFloatsContent(child);\n                        break;\n                    case \"float4\":\n                        result.floats = context.getFloatsContent(child);\n                        break;\n                    case \"surface\":\n                        result.surface = EffectSurface.parse(child, result, context);\n                        break;\n                    case \"sampler2D\":\n                        result.sampler = EffectSampler.parse(child, result, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    }\n","\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\nimport * as Utils from \"./utils\";\n\n    export class ColorOrTexture extends EElement {\n        color: Float32Array | undefined;\n        textureSampler: Link | undefined;\n        texcoord: string = \"\";\n        opaque: string = \"\";\n        bumptype: string = \"\";\n\n        constructor() {\n            super();\n            this._className += \"ColorOrTexture|\";\n        }\n\n        /**\n        *   Parses a color or texture element  (<ambient>, <diffuse>, ...).\n        */\n        static parse(node: Node, parent: EElement, context: LoaderContext): ColorOrTexture {\n            var result: ColorOrTexture = new ColorOrTexture();\n\n            result.opaque = context.getAttributeAsString(node, \"opaque\", undefined, false);\n            result.bumptype = context.getAttributeAsString(node, \"bumptype\", undefined, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"color\":\n                        result.color = context.strToColor(context.getTextContent(child));\n                        break;\n                    case \"texture\":\n                        result.textureSampler = context.getAttributeAsFxLink(child, \"texture\", parent, true);\n                        result.texcoord = context.getAttributeAsString(child, \"texcoord\", undefined, true);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\nimport { ColorOrTexture } from \"./color_or_texture\";\nimport { LoaderContext } from \"./context\";\nimport { EffectParam } from \"./effect_param\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n    /**\n    *   An <technique> element.\n    *\n    */\n    export class EffectTechnique extends EElement {\n        params: EffectParam[] | undefined;\n        shading: string = \"\";\n        emission: ColorOrTexture | undefined;\n        ambient: ColorOrTexture | undefined;\n        diffuse: ColorOrTexture | undefined;\n        specular: ColorOrTexture | undefined;\n        reflective: ColorOrTexture | undefined;\n        transparent: ColorOrTexture | undefined;\n        bump: ColorOrTexture | undefined;\n        shininess: number = 0;\n        transparency: number = 0;\n        reflectivity: number = 0;\n        index_of_refraction: number = 0;\n        double_sided: boolean = false;\n\n        constructor() {\n            super();\n            this._className += \"EffectTechnique|\";\n            this.params = [];\n        }\n\n        static fromLink(link: Link, context: Context): EffectTechnique | undefined{\n            return EElement._fromLink<EffectTechnique>(link, \"EffectTechnique\", context);\n        }\n\n        /**\n        *   Parses a <technique> element.\n        */\n        static parse(node: Node, parent: EElement, context: LoaderContext): EffectTechnique {\n            var result: EffectTechnique = new EffectTechnique();\n\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            context.registerFxTarget(result, parent);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"blinn\":\n                    case \"phong\":\n                    case \"lambert\":\n                    case \"constant\":\n                        result.shading = child.nodeName;\n                        EffectTechnique.parseParam(child, result, \"COMMON\", context);\n                        break;\n                    case \"extra\":\n                        EffectTechnique.parseExtra(child, result, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        /**\n        *   Parses a <technique>/(<blinn>|<phong>|<lambert>|<constant>) element.\n        *   In addition to <technique>, node may also be child of <technique>/<extra>\n        */\n        static parseParam(node: Node, technique: EffectTechnique, profile: string, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"newparam\":\n                        technique.params?.push(EffectParam.parse(child, technique, context));\n                        break;\n                    case \"emission\":\n                        technique.emission = ColorOrTexture.parse(child, technique, context);\n                        break;\n                    case \"ambient\":\n                        technique.ambient = ColorOrTexture.parse(child, technique, context);\n                        break;\n                    case \"diffuse\":\n                        technique.diffuse = ColorOrTexture.parse(child, technique, context);\n                        break;\n                    case \"specular\":\n                        technique.specular = ColorOrTexture.parse(child, technique, context);\n                        break;\n                    case \"reflective\":\n                        technique.reflective = ColorOrTexture.parse(child, technique, context);\n                        break;\n                    case \"transparent\":\n                        technique.transparent = ColorOrTexture.parse(child, technique, context);\n                        break;\n                    case \"bump\":\n                        technique.bump = ColorOrTexture.parse(child, technique, context);\n                        break;\n                    case \"shininess\":\n                        technique.shininess = context.getFloatContent(child.childNodes[1] || child.childNodes.item(0));\n                        break;\n                    case \"reflectivity\":\n                        technique.reflectivity = context.getFloatContent(child.childNodes[1] || child.childNodes.item(0));\n                        break;\n                    case \"transparency\":\n                        technique.transparency = context.getFloatContent(child.childNodes[1] || child.childNodes.item(0));\n                        break;\n                    case \"index_of_refraction\":\n                        technique.index_of_refraction = context.getFloatContent(child.childNodes[1] || child.childNodes.item(0));\n                        break;\n                    case \"double_sided\":\n                        technique.double_sided = context.getFloatContent(child) > 0;\n                        break;\n                    default:\n                        if (profile === \"COMMON\") {\n                            context.reportUnexpectedChild(child);\n                        }\n                }\n            });\n        }\n\n        /**\n        *   Parses a <technique>/<extra> element.\n        */\n        static parseExtra(node: Node, technique: EffectTechnique, context: LoaderContext) {\n            if (technique == null) {\n                context.log.write(\"Ignored element <extra>, because there is no <technique>.\", LogLevel.Warning);\n                return;\n            }\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"technique\":\n                        var profile: string = context.getAttributeAsString(child, \"profile\", undefined, true);\n                        EffectTechnique.parseParam(child, technique, profile, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n    }\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EffectParam } from \"./effect_param\";\nimport { EffectTechnique } from \"./effect_technique\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n    /**\n    *   An <effect> element.\n    *\n    */\n    export class Effect extends EElement {\n        params: EffectParam[];\n        technique: EffectTechnique | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Effect|\";\n            this.params = [];\n        }\n\n        static fromLink(link: Link, context: Context): Effect | undefined{\n            return EElement._fromLink<Effect>(link, \"Effect\", context);\n        }\n\n        /**\n        *   Parses an <effect> element.\n        */\n        static parse(node: Node, context: LoaderContext): Effect {\n            var result: Effect = new Effect();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            context.registerUrlTarget(result, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"profile_COMMON\":\n                        Effect.parseProfileCommon(child, result, context);\n                        break;\n                    case \"profile\":\n                        context.log.write(\"Skipped non-common effect profile for effect \" + result.id + \".\", LogLevel.Warning);\n                        break;\n                    case \"extra\":\n                        if (result.technique) {\n                            EffectTechnique.parseExtra(child, result.technique, context);\n                        }\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        /**\n        *   Parses an <effect>/<profile_COMMON> element.\n        */\n        static parseProfileCommon(node: Node, effect: Effect, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"newparam\":\n                        effect.params.push(EffectParam.parse(child, effect, context));\n                        break;\n                    case \"technique\":\n                        effect.technique = EffectTechnique.parse(child, effect, context);\n                        break;\n                    case \"extra\":\n                        if (effect.technique) {\n                            EffectTechnique.parseExtra(child, effect.technique, context);\n                        }\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n    };\n\n    export class EffectLibrary extends EElement {\n        children: Effect[] = [];\n\n\n        static parse(node: Node, context: LoaderContext): EffectLibrary {\n            var result: EffectLibrary = new EffectLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"effect\":\n                        result.children.push(Effect.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { Input } from \"./input\"\nimport * as Utils from \"./utils\"\n\n    export class Triangles extends EElement {\n        /** \"triangles\", \"polylist\", or \"polygons\" */\n        type: string = \"\";\n        count: number = 0;\n        /** A material \"symbol\", bound by <bind_material> */\n        material: string = \"\";\n        inputs: Input[] = [];\n        indices: Uint32Array = new Uint32Array();\n        vcount: Uint32Array = new Uint32Array();\n\n        constructor() {\n            super();\n            this._className += \"Triangles|\";\n        }\n\n        /**\n        *   Parses a <triangles> element.\n        */\n        static parse(node: Node, context: LoaderContext): Triangles {\n            var result: Triangles = new Triangles();\n\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            result.material = context.getAttributeAsString(node, \"material\", undefined, false);\n            result.count = context.getAttributeAsInt(node, \"count\", 0, true) || 0;\n            result.type = node.nodeName;\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"input\":\n                        result.inputs.push(Input.parse(child, true, context));\n                        break;\n                    case \"vcount\":\n                        result.vcount = context.getUintsContent(child);\n                        break;\n                    case \"p\":\n                        result.indices = context.getUintsContent(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n    }\n","import { Context } from \"../context\"\n\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { Input } from \"./input\"\nimport { Link } from \"./link\"\nimport * as Utils from \"./utils\"\n\n    export class Vertices extends EElement {\n        inputs: Input[];\n\n        constructor() {\n            super();\n            this._className += \"Vertices|\";\n            this.inputs = [];\n        }\n\n        static fromLink(link: Link, context: Context): Vertices | undefined {\n            return EElement._fromLink<Vertices>(link, \"Vertices\", context);\n        }\n\n        /**\n        *   Parses a <vertices> element.\n        */\n        static parse(node: Node, context: LoaderContext): Vertices {\n            var result: Vertices = new Vertices();\n\n            result.id = context.getAttributeAsString(node, \"id\", \"\", true);\n            result.name = context.getAttributeAsString(node, \"name\", \"\", false);\n            context.registerUrlTarget(result, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"input\":\n                        result.inputs.push(Input.parse(child, false, context));\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n    }\n","import { Context } from \"../context\"\nimport { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { Link } from \"./link\"\nimport * as SourceLoader from \"./source\"\nimport { Triangles } from \"./triangles\"\nimport * as Utils from \"./utils\"\nimport { Vertices } from \"./vertices\"\n\n    export class Geometry extends EElement {\n        sources: SourceLoader.Source[];\n        vertices: Vertices[];\n        triangles: Triangles[];\n\n        constructor() {\n            super();\n            this._className += \"Geometry|\";\n            this.sources = [];\n            this.vertices = [];\n            this.triangles = [];\n        }\n\n        static fromLink(link: Link, context: Context): Geometry | undefined{\n            return EElement._fromLink<Geometry>(link, \"Geometry\", context);\n        }\n\n        /**\n        *   Parses a <geometry> element\n        */\n        static parse(node: Node, context: LoaderContext): Geometry {\n            var result: Geometry = new Geometry();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerUrlTarget(result, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"mesh\":\n                        Geometry.parseMesh(child, result, context);\n                        break;\n                    case \"convex_mesh\":\n                    case \"spline\":\n                        context.log.write(\"Geometry type \" + child.nodeName + \" not supported.\", LogLevel.Error);\n                        break;\n                    case \"extra\":\n                        Geometry.parseGeometryExtra(child, result, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        /**\n        *   Parses a <geometry>/<mesh> element\n        */\n        static parseMesh(node: Node, geometry: Geometry, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"source\":\n                        geometry.sources.push(SourceLoader.Source.parse(child, context));\n                        break;\n                    case \"vertices\":\n                        geometry.vertices.push(Vertices.parse(child, context));\n                        break;\n                    case \"triangles\":\n                    case \"polylist\":\n                    case \"polygons\":\n                        geometry.triangles.push(Triangles.parse(child, context));\n                        break;\n                    case \"lines\":\n                    case \"linestrips\":\n                    case \"trifans\":\n                    case \"tristrips\":\n                        context.log.write(\"Geometry primitive type \" + child.nodeName + \" not supported.\", LogLevel.Error);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n\n        /**\n        *   Parses a <geometry>/<extra> element\n        */\n        static parseGeometryExtra(node: Node, geometry: Geometry, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"technique\":\n                        var profile: string = context.getAttributeAsString(child, \"profile\", undefined, true);\n                        Geometry.parseGeometryExtraTechnique(child, geometry, profile, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n\n        /**\n        *   Parses a <geometry>/<extra>/<technique> element\n        */\n        static parseGeometryExtraTechnique(node: Node, geometry: Geometry, profile: string, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    default:\n                        context.reportUnhandledChild(child);\n                }\n            });\n        }\n    };\n\n\n    export class GeometryLibrary extends EElement {\n        children: Geometry[] = [];\n\n        static parse(node: Node, context: LoaderContext): GeometryLibrary {\n            var result: GeometryLibrary = new GeometryLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"geometry\":\n                        result.children.push(Geometry.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n\n    export class Image extends EElement {\n        initFrom: string | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Image|\";\n        }\n\n        static fromLink(link: Link, context: Context): Image  | undefined{\n            return EElement._fromLink<Image>(link, \"Image\", context);\n        }\n\n        /**\n        *   Parses an <image> element.\n        */\n        static parse(node: Node, context: LoaderContext): Image {\n            var result: Image = new Image();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            context.registerUrlTarget(result, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"init_from\":\n                        result.initFrom = context.getTextContent(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n    }\n\n    export class ImageLibrary extends EElement {\n        children: Image[] = [];\n\n        static parse(node: Node, context: LoaderContext): ImageLibrary {\n            var result: ImageLibrary = new ImageLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"image\":\n                        result.children.push(Image.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\n\n\n    export class LightParam extends EElement {\n        value: number| undefined;\n\n        constructor() {\n            super();\n            this._className += \"LightParam|\";\n        }\n\n        /**\n        *   Parses a light parameter element.\n        */\n        static parse(node: Node, context: LoaderContext): LightParam {\n            var result: LightParam = new LightParam();\n\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            result.name = node.nodeName;\n            result.value = context.getFloatContent(node);\n\n            return result;\n        }\n\n    }\n","\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { LightParam } from \"./light_param\";\nimport * as Utils from \"./utils\"\n\nexport class Light extends EElement {\n        type: string | undefined;\n        color: Float32Array | undefined;\n        params: { [s: string]: LightParam; }\n\n        constructor() {\n            super();\n            this._className += \"Light|\";\n            this.params = {};\n        }\n\n        /**\n        *   Parses a <light> element.\n        */\n        static parse(node: Node, context: LoaderContext): Light {\n            var result: Light = new Light();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerUrlTarget(result, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"technique_common\":\n                        Light.parseTechniqueCommon(child, result, context);\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        /**\n        *   Parses a <light>/<technique_common> element.\n        */\n        static parseTechniqueCommon(node: Node, light: Light, context: LoaderContext) {\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"ambient\":\n                    case \"directional\":\n                    case \"point\":\n                    case \"spot\":\n                        Light.parseParams(child, light, \"COMMON\", context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n        }\n\n        /**\n        *   Parses a <light>/<technique_common>/(<ambient>|<directional>|<point>|<spot>) element.\n        */\n        static parseParams(node: Node, light: Light, profile: string, context: LoaderContext) {\n\n            light.type = node.nodeName;\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"color\":\n                        light.color = context.getFloatsContent(child);\n                        break;\n                    case \"constant_attenuation\":\n                    case \"linear_attenuation\":\n                    case \"quadratic_attenuation\":\n                    case \"falloff_angle\":\n                    case \"falloff_exponent\":\n                        var param: LightParam = LightParam.parse(child, context);\n                        context.registerSidTarget(param, light);\n                        light.params[param.name] = param;\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n        }\n\n    }\n\n\n    export class LightLibrary extends EElement {\n        children: Light[] = [];\n\n        static parse(node: Node, context: LoaderContext): LightLibrary {\n            var result: LightLibrary = new LightLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"effect\": //\"light\": // Polyhobbyist - this is what it was called in the code.\n                        result.children.push(Light.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n    export class Material extends EElement {\n        effect: Link | undefined;\n\n        constructor() {\n            super();\n            this._className += \"Material|\";\n        }\n\n        static fromLink(link: Link, context: Context): Material | undefined {\n            return EElement._fromLink<Material>(link, \"Material\", context);\n        }\n\n        /**\n        *   Parses a <material> element.\n        */\n        static parse(node: Node, context: LoaderContext): Material {\n            var result: Material = new Material();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, true);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerUrlTarget(result, true);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"instance_effect\":\n                        result.effect = context.getAttributeAsUrlLink(child, \"url\", true);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    };\n\n    \nexport class MaterialLibrary extends EElement {\n    children: Material[] = [];\n\n    static parse(node: Node, context: LoaderContext): MaterialLibrary {\n        var result: MaterialLibrary = new MaterialLibrary();\n\n        Utils.forEachChild(node, function (child: Node) {\n            switch (child.nodeName) {\n                case \"material\":\n                    result.children.push(Material.parse(child, context));\n                    break;\n                case \"extra\":\n                    context.reportUnhandledChild(child);\n                    break;\n                default:\n                    context.reportUnexpectedChild(child);\n                    break;\n            }\n        });\n\n        return result;\n    }\n}\n","\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\nimport * as Utils from \"./utils\"\nimport { VisualSceneNode } from \"./visual_scene_node\";\n\n\n    export class InstanceCamera extends EElement {\n        camera: Link | undefined;\n\n        constructor() {\n            super();\n            this._className += \"InstanceCamera|\";\n        }\n\n        /**\n        *   Parses a <instance_light> element.\n        */\n        static parse(node: Node, parent: VisualSceneNode, context: LoaderContext): InstanceCamera {\n            var result: InstanceCamera = new InstanceCamera();\n\n            result.camera = context.getAttributeAsUrlLink(node, \"url\", true);\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerSidTarget(result, parent);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    };\n","import { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { SidLink, UrlLink } from \"./link\";\n\nimport * as Utils from \"./utils\"\n\n    export interface InstanceMaterialVertexInput {\n        inputSemantic: string;\n        inputSet: number;\n    }\n\n    export interface InstanceMaterialParam {\n        target: SidLink;\n    }\n\n    export interface InstanceMaterialContainer extends EElement {\n        materials: InstanceMaterial[];\n    }\n\n    export class InstanceMaterial extends EElement {\n        material: UrlLink | undefined;\n        symbol: string = \"\";\n        /** Contains uniform parameters */\n        params: { [s: string]: InstanceMaterialParam; }\n        /** Contains vertex paramters */\n        vertexInputs: { [s: string]: InstanceMaterialVertexInput; }\n\n        constructor() {\n            super();\n            this._className += \"InstanceMaterial|\";\n            this.params = {};\n            this.vertexInputs = {};\n        }\n\n        /**\n        *   Parses a <instance_material> element.\n        */\n        static parse(node: Node, parent: InstanceMaterialContainer, context: LoaderContext): InstanceMaterial {\n            var result: InstanceMaterial = new InstanceMaterial();\n\n            result.symbol = context.getAttributeAsString(node, \"symbol\", undefined, false);\n            result.material = context.getAttributeAsUrlLink(node, \"target\", true);\n            context.registerSidTarget(result, parent);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"bind_vertex_input\":\n                        InstanceMaterial.parseBindVertexInput(child, result, context);\n                        break;\n                    case \"bind\":\n                        InstanceMaterial.parseBind(child, result, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n\n        /**\n        *   Parses a <instance_material>/<bind_vertex_input> element.\n        */\n        static parseBindVertexInput(node: Node, instanceMaterial: InstanceMaterial, context: LoaderContext) {\n            var semantic: string = context.getAttributeAsString(node, \"semantic\", undefined, true);\n            var inputSemantic: string = context.getAttributeAsString(node, \"input_semantic\", undefined, true);\n            var inputSet: number | undefined = context.getAttributeAsInt(node, \"input_set\", 0, false);\n\n            if ((semantic != null) && (inputSemantic != null) && inputSet) {\n                instanceMaterial.vertexInputs[semantic] = {\n                    inputSemantic: inputSemantic,\n                    inputSet: inputSet\n                };\n            } else {\n                context.log.write(\"Skipped a material vertex binding because of missing semantics.\", LogLevel.Warning);\n            }\n        }\n\n        /**\n        *   Parses a <instance_material>/<bind> element.\n        */\n        static parseBind(node: Node, instanceMaterial: InstanceMaterial, context: LoaderContext) {\n            var semantic: string = context.getAttributeAsString(node, \"semantic\", undefined, false);\n            var target: SidLink | undefined = context.getAttributeAsSidLink(node, \"target\", \"\", true);\n\n            if (semantic != null && target) {\n                instanceMaterial.params[semantic] = {\n                    target: target\n                };\n            } else {\n                context.log.write(\"Skipped a material uniform binding because of missing semantics.\", LogLevel.Warning);\n            }\n        }\n    }\n","import { LoaderContext } from \"./context\";\nimport { InstanceMaterial, InstanceMaterialContainer } from \"./instance_material\";\nimport * as Utils from \"./utils\";\n\n\n    export class BindMaterial {\n\n        /**\n        *   Parses a <bind_material> element. Can be child of <instance_geometry> or <instance_controller>\n        */\n        static parse(node: Node, parent: InstanceMaterialContainer, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"technique_common\":\n                        BindMaterial.parseTechniqueCommon(child, parent, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n\n        /**\n        *   Parses a <instance_geometry>/<bind_material>/<technique_common> element.\n        */\n        static parseTechniqueCommon(node: Node, parent: InstanceMaterialContainer, context: LoaderContext) {\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"instance_material\":\n                        parent.materials.push(InstanceMaterial.parse(child, parent, context));\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n        }\n    }\n","\nimport { BindMaterial } from \"./bind_material\";\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { InstanceMaterial } from \"./instance_material\";\nimport { Link } from \"./link\";\nimport * as Utils from \"./utils\"\n\n    export interface InstanceControllerContainer extends EElement {\n        controllers: InstanceController[];\n    }\n\n    export class InstanceController extends EElement {\n        controller: Link | undefined;\n        skeletons: Link[];\n        materials: InstanceMaterial[];\n\n        constructor() {\n            super();\n            this._className += \"InstanceController|\";\n            this.skeletons = [];\n            this.materials = [];\n        }\n\n        /**\n        *   Parses a <instance_controller> element.\n        */\n        static parse(node: Node, parent: InstanceControllerContainer, context: LoaderContext): InstanceController {\n            var result: InstanceController = new InstanceController();\n\n            result.controller = context.getAttributeAsUrlLink(node, \"url\", true);\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerSidTarget(result, parent);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"skeleton\":\n                        result.skeletons.push(context.createUrlLink(context.getTextContent(child)));\n                        break;\n                    case \"bind_material\":\n                        BindMaterial.parse(child, result, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    };\n","\nimport { BindMaterial } from \"./bind_material\";\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { InstanceMaterial } from \"./instance_material\";\nimport { Link } from \"./link\";\nimport * as Utils from \"./utils\"\n\n    export class InstanceGeometry extends EElement {\n        geometry: Link | undefined;\n        materials: InstanceMaterial[];\n\n        constructor() {\n            super();\n            this._className += \"InstanceGeometry|\";\n            this.materials = [];\n        }\n\n        /**\n        *   Parses a <instance_geometry> element.\n        */\n        static parse(node: Node, parent: EElement, context: LoaderContext): InstanceGeometry {\n            var result: InstanceGeometry = new InstanceGeometry();\n\n            result.geometry = context.getAttributeAsUrlLink(node, \"url\", true);\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"bind_material\":\n                        BindMaterial.parse(child, result, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    };\n","\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { Link } from \"./link\";\nimport * as Utils from \"./utils\"\nimport { VisualSceneNode } from \"./visual_scene_node\";\n\n    export class InstanceLight extends EElement {\n        light: Link | undefined;\n\n        constructor() {\n            super();\n            this._className += \"InstanceLight|\";\n        }\n\n        /**\n        *   Parses a <instance_light> element.\n        */\n        static parse(node: Node, parent: VisualSceneNode, context: LoaderContext): InstanceLight {\n            var result: InstanceLight = new InstanceLight();\n\n            result.light = context.getAttributeAsUrlLink(node, \"url\", true);\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            context.registerSidTarget(result, parent);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    };\n","import { LogLevel } from \"../log\"\nimport { LoaderContext } from \"./context\";\nimport { EElement } from \"./element\";\nimport { VisualSceneNode } from \"./visual_scene_node\";\n\n\n    export class NodeTransform extends EElement {\n        type: string | undefined;\n        data: Float32Array | undefined;\n\n        constructor() {\n            super();\n            this._className += \"NodeTransform|\";\n        }\n\n        /**\n        *   Parses a transformation element.\n        */\n        static parse(node: Node, parent: VisualSceneNode, context: LoaderContext): NodeTransform {\n            var result: NodeTransform = new NodeTransform();\n\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            result.type = node.nodeName;\n\n            context.registerSidTarget(result, parent);\n            result.data = context.getFloatsContent(node);\n\n            var expectedDataLength: number = 0;\n            switch (result.type) {\n                case \"matrix\":\n                    expectedDataLength = 16;\n                    break;\n                case \"rotate\":\n                    expectedDataLength = 4;\n                    break;\n                case \"translate\":\n                    expectedDataLength = 3;\n                    break;\n                case \"scale\":\n                    expectedDataLength = 3;\n                    break;\n                case \"skew\":\n                    expectedDataLength = 7;\n                    break;\n                case \"lookat\":\n                    expectedDataLength = 9;\n                    break;\n                default:\n                    context.log.write(\"Unknown transformation type \" + result.type + \".\", LogLevel.Error);\n            }\n\n            if (result.data.length !== expectedDataLength) {\n                context.log.write(\"Wrong number of elements for transformation type '\" + result.type + \"': expected \" +\n                    expectedDataLength + \", found \" + result.data.length, LogLevel.Error);\n            }\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\n\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { InstanceCamera } from \"./instance_camera\"\nimport { InstanceController } from \"./instance_controller\"\nimport { InstanceGeometry } from \"./instance_geometry\"\nimport { InstanceLight } from \"./instance_light\"\nimport { Link } from \"./link\"\nimport { NodeTransform } from \"./node_transform\"\nimport * as Utils from \"./utils\"\n\n\n    /**\n    *   A <node> element (child of <visual_scene>, <library_nodes>, or another <node>).\n    */\n    export class VisualSceneNode extends EElement {\n        type: string;\n        layer: string;\n        children: VisualSceneNode[];\n        parent: EElement | undefined;\n        transformations: NodeTransform[];\n        geometries: InstanceGeometry[];\n        controllers: InstanceController[];\n        lights: InstanceLight[];\n        cameras: InstanceCamera[];\n\n        constructor() {\n            super();\n            this._className += \"VisualSceneNode|\";\n            this.type = \"\";\n            this.layer = \"\";\n            this.children = [];\n            this.parent = undefined;\n            this.transformations = [];\n            this.geometries = [];\n            this.controllers = [];\n            this.lights = [];\n            this.cameras = [];\n        }\n\n        static fromLink(link: Link, context: Context): VisualSceneNode | undefined {\n            return EElement._fromLink<VisualSceneNode>(link, \"VisualSceneNode\", context);\n        }\n\n        static registerParent(child: VisualSceneNode, parent: EElement, context: LoaderContext) {\n            child.parent = parent;\n            context.registerSidTarget(child, parent);\n        }\n\n        static parse(node: Node, context: LoaderContext): VisualSceneNode {\n            var result: VisualSceneNode = new VisualSceneNode();\n\n            result.id = context.getAttributeAsString(node, \"id\", undefined, false);\n            result.sid = context.getAttributeAsString(node, \"sid\", undefined, false);\n            result.name = context.getAttributeAsString(node, \"name\", undefined, false);\n            result.type = context.getAttributeAsString(node, \"type\", undefined, false);\n            result.layer = context.getAttributeAsString(node, \"layer\", undefined, false);\n\n            context.registerUrlTarget(result, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"instance_geometry\":\n                        result.geometries.push(InstanceGeometry.parse(child, result, context));\n                        break;\n                    case \"instance_controller\":\n                        result.controllers.push(InstanceController.parse(child, result, context));\n                        break;\n                    case \"instance_light\":\n                        result.lights.push(InstanceLight.parse(child, result, context));\n                        break;\n                    case \"instance_camera\":\n                        result.cameras.push(InstanceCamera.parse(child, result, context));\n                        break;\n                    case \"matrix\":\n                    case \"rotate\":\n                    case \"translate\":\n                    case \"scale\":\n                        result.transformations.push(NodeTransform.parse(child, result, context));\n                        break;\n                    case \"node\":\n                        var childNode: VisualSceneNode = VisualSceneNode.parse(child, context);\n                        VisualSceneNode.registerParent(childNode, result, context);\n                        result.children.push(childNode);\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    };\n\n\n    export class VisualSceneNodeLibrary extends EElement {\n        children: VisualSceneNode[] = [];\n\n        static parse(node: Node, context: LoaderContext): VisualSceneNodeLibrary {\n            var result: VisualSceneNodeLibrary = new VisualSceneNodeLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"node\":\n                        result.children.push(VisualSceneNode.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Context } from \"../context\"\n\nimport { LoaderContext } from \"./context\"\nimport { EElement } from \"./element\"\nimport { Link } from \"./link\"\nimport * as Utils from \"./utils\"\nimport { VisualSceneNode } from \"./visual_scene_node\"\n\n    /**\n    *   An <visual_scene> element.\n    */\n    export class VisualScene extends EElement {\n        children: VisualSceneNode[];\n\n        constructor() {\n            super();\n            this._className += \"VisualScene|\";\n            this.children = [];\n        }\n\n        static fromLink(link: Link, context: Context): VisualScene | undefined {\n            return EElement._fromLink<VisualScene>(link, \"VisualScene\", context);\n        }\n\n        static parse(node: Node, context: LoaderContext): VisualScene {\n            var result: VisualScene = new VisualScene();\n\n            result.id = context.getAttributeAsString(node, \"id\", \"\", false);\n\n            context.registerUrlTarget(result, false);\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"node\":\n                        var childNode: VisualSceneNode = VisualSceneNode.parse(child, context);\n                        VisualSceneNode.registerParent(childNode, result, context);\n                        result.children.push(childNode);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    };\n\n    export class VisualSceneLibrary extends EElement {\n        children: VisualScene[] = [];\n\n        static parse(node: Node, context: LoaderContext): VisualSceneLibrary {\n            var result: VisualSceneLibrary = new VisualSceneLibrary();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"visual_scene\":\n                        result.children.push(VisualScene.parse(child, context));\n                        break;\n                    case \"extra\":\n                        context.reportUnhandledChild(child);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                        break;\n                }\n            });\n\n            return result;\n        }\n    }\n","import { Scene } from \"./scene\"\nimport { LogLevel } from \"../log\"\nimport { AnimationLibrary } from \"./animation\"\nimport { Asset } from \"./asset\"\nimport { CameraLibrary } from \"./camera\"\nimport { LoaderContext } from \"./context\"\nimport { ControllerLibrary } from \"./controller\"\nimport { EffectLibrary } from \"./effect\"\nimport { GeometryLibrary } from \"./geometry\"\nimport { ImageLibrary } from \"./image\"\nimport { LightLibrary } from \"./light\"\nimport { MaterialLibrary } from \"./material\"\nimport * as Utils from \"./utils\"\nimport { VisualSceneLibrary } from \"./visual_scene\"\nimport { VisualSceneNodeLibrary } from \"./visual_scene_node\"\n\n\n    export class Document {\n        scene: Scene | undefined;\n        asset: Asset | undefined;\n        libEffects: EffectLibrary;\n        libMaterials: MaterialLibrary;\n        libGeometries: GeometryLibrary;\n        libControllers: ControllerLibrary;\n        libLights: LightLibrary;\n        libCameras: CameraLibrary;\n        libImages: ImageLibrary;\n        libVisualScenes: VisualSceneLibrary;\n        libAnimations: AnimationLibrary;\n        libNodes: VisualSceneNodeLibrary;\n\n        constructor() {\n            this.libEffects = new EffectLibrary();\n            this.libMaterials = new MaterialLibrary();\n            this.libGeometries = new GeometryLibrary();\n            this.libControllers = new ControllerLibrary();\n            this.libLights = new LightLibrary();\n            this.libCameras = new CameraLibrary;\n            this.libImages = new ImageLibrary;\n            this.libVisualScenes = new VisualSceneLibrary;\n            this.libAnimations = new AnimationLibrary;\n            this.libNodes = new VisualSceneNodeLibrary();\n        }\n\n        static parse(doc: XMLDocument, context: LoaderContext): Document {\n\n            // There should be one top level <COLLADA> element\n            var colladaNodes = doc.getElementsByTagName(\"COLLADA\");\n            if (colladaNodes.length === 0) {\n                context.log?.write(\"Cannot parse document, no top level COLLADA element.\", LogLevel.Error);\n                return new Document();\n            } else if (colladaNodes.length > 1) {\n                context.log?.write(\"Cannot parse document, more than one top level COLLADA element.\", LogLevel.Error);\n                return new Document();\n            }\n\n            return Document.parseCOLLADA(colladaNodes[0] || colladaNodes.item(0), context);\n        }\n\n        static parseCOLLADA(node: Node, context: LoaderContext): Document {\n            var result: Document = new Document();\n\n            Utils.forEachChild(node, function (child: Node) {\n                switch (child.nodeName) {\n                    case \"asset\":\n                        result.asset = Asset.parse(child, context);\n                        break;\n                    case \"scene\":\n                        result.scene = Scene.parse(child, context);\n                        break;\n                    case \"library_effects\":\n                        result.libEffects = EffectLibrary.parse(child, context);\n                        break;\n                    case \"library_materials\":\n                        result.libMaterials = MaterialLibrary.parse(child, context);\n                        break;\n                    case \"library_geometries\":\n                        result.libGeometries = GeometryLibrary.parse(child, context);\n                        break;\n                    case \"library_images\":\n                        result.libImages = ImageLibrary.parse(child, context);\n                        break;\n                    case \"library_visual_scenes\":\n                        result.libVisualScenes = VisualSceneLibrary.parse(child, context);\n                        break;\n                    case \"library_controllers\":\n                        result.libControllers = ControllerLibrary.parse(child, context);\n                        break;\n                    case \"library_animations\":\n                        result.libAnimations = AnimationLibrary.parse(child, context);\n                        break;\n                    case \"library_lights\":\n                        result.libLights = LightLibrary.parse(child, context);\n                        break;\n                    case \"library_cameras\":\n                        result.libCameras = CameraLibrary.parse(child, context);\n                        break;\n                    case \"library_nodes\":\n                        result.libNodes = VisualSceneNodeLibrary.parse(child, context);\n                        break;\n                    default:\n                        context.reportUnexpectedChild(child);\n                }\n            });\n\n            return result;\n        }\n    };\n","import {Context} from \"./context\"\nimport { LoaderContext } from \"./loader/context\";\nimport {Log, LogLevel, LogConsole} from \"./log\"\nimport {Document} from \"./loader/document\"\nimport * as BABYLON from \"babylonjs\";\n\n\nexport class ColladaLoader {\n        onFinished: ((id: string, doc?: Document) => void) | undefined;\n        onProgress: ((id: string, loaded: number, total: number) => void) | undefined;\n        log: Log;\n\n        constructor() {\n            this.log = new LogConsole();\n        }\n\n        private _reportError(id: string, context: LoaderContext) {\n            if (this.onFinished) {\n                this.onFinished(id, undefined);\n            }\n        }\n\n        private _reportSuccess(id: string, doc: Document, context: LoaderContext) {\n            if (this.onFinished) {\n                this.onFinished(id, doc);\n            }\n        }\n\n        private _reportProgress(id: string, context: LoaderContext) {\n            if (this.onProgress) {\n                this.onProgress(id, context.loadedBytes, context.totalBytes);\n            }\n        }\n\n        loadFromXML(id: string, doc: XMLDocument): Document {\n            var context: LoaderContext = new LoaderContext(this.log);\n            return this._loadFromXML(id, doc, context);\n        }\n\n        private _loadFromXML(id: string, doc: XMLDocument, context: LoaderContext): Document | undefined {\n            var result: Document | undefined = undefined;\n            try {\n                result = Document.parse(doc, context);\n                context.resolveAllLinks();\n            } catch (err) {\n                context.log.write(err.message + \"\\n\" + err.stack, LogLevel.Exception);\n                context.log.write(err.message + \"\\n\" + err.stack, LogLevel.Error);\n                this._reportError(id, context);\n                return undefined;\n            }\n            this._reportSuccess(id, result, context);\n            return result;\n        }\n\n        loadFromURL(id: string, url: string) {\n            var context: LoaderContext = new LoaderContext(this.log);\n            var loader: ColladaLoader = this;\n\n            if (document != null && document.implementation != null && document.implementation.createDocument != null) {\n\n                var req: XMLHttpRequest = new XMLHttpRequest();\n                if (typeof req.overrideMimeType === \"function\") {\n                    req.overrideMimeType(\"text/xml\");\n                }\n\n                req.onreadystatechange = function () {\n                    if (req.readyState === 4) {\n                        if (req.status === 0 || req.status === 200) {\n                            if (req.responseXML) {\n                                var result: Document = Document.parse(req.responseXML, context);\n                                loader._reportSuccess(id, result, context);\n                            } else {\n                                context.log.write(\"Empty or non-existing file \" + url + \".\", LogLevel.Error);\n                                loader._reportError(id, context);\n                            }\n                        }\n                    } else if (req.readyState === 3) {\n                        if (!(context.totalBytes > 0)) {\n                            context.totalBytes = parseInt(req.getResponseHeader(\"Content-Length\") || \"0\");\n                        }\n                        context.loadedBytes = req.responseText.length;\n                        loader._reportProgress(id, context);\n                    }\n                };\n                req.open(\"GET\", url, true);\n                req.send(null);\n            } else {\n                context.log.write(\"Don't know how to parse XML!\", LogLevel.Error);\n                loader._reportError(id, context);\n            }\n        }\n    }\n","import * as BABYLON from 'babylonjs';\n\n\n\n/**\n* A skinned mesh with an animation\n*/\nexport class RMXModel {\n    chunks: RMXModelChunk[];\n    skeleton: RMXSkeleton;\n    materials: RMXMaterial[];\n    animations: RMXAnimation[];\n\n    constructor() {\n        this.chunks = [];\n        this.skeleton = new RMXSkeleton();\n        this.materials = [];\n        this.animations = [];\n    }\n}\n\n/**\n* One piece of geometry with one material\n*/\nexport class RMXModelChunk {\n    name: string;\n    triangle_count: number;\n    index_offset: number;\n    vertex_count: number;\n    material_index: number;\n\n    data_position: Float32Array | undefined;\n    data_normal: Float32Array | undefined;\n    data_texcoord: Float32Array | undefined;\n    data_boneweight: Float32Array | undefined;\n    data_boneindex: Uint8Array | undefined;\n    data_indices: Uint32Array | undefined;\n\n    constructor() {\n        this.name = \"\";\n        this.triangle_count = 0;\n        this.vertex_count = 0;\n        this.index_offset = 0;\n        this.material_index = 0;\n    }\n}\n\n/**\n* A material.\n* Does not contain coefficients, use textures instead.\n*/\nexport class RMXMaterial {\n    diffuse: string = \"\";\n    specular: string = \"\";\n    normal: string = \"\";\n\n    diffuseColor: number[] | undefined;\n    specularColor: number[] | undefined;\n    emissiveColor: number[] | undefined;\n\n    constructor() {\n    }\n\n    hash(): string {\n        return \"material|\" + (this.diffuse || \"\") + \"|\" + (this.specular || \"\") + \"|\" + (this.normal || \"\") + \"|\" + (this.diffuseColor || \"\") + \"|\" + (this.specularColor || \"\" + \"|\" + (this.emissiveColor || \"\"));\n    }\n}\n\n/**\n* A skinned mesh skeleton\n*/\nexport class RMXSkeleton {\n    bones: RMXBone[];\n\n    constructor() {\n        this.bones = [];\n    }\n}\n\n/**\n* A skeleton bone.\n*/\nexport class RMXBone {\n    /** Bone name */\n    name: string = \"\";\n    /** Parent bone index */\n    parent: number = 0;\n    /** Indicates whether this bone is used by the geometry */\n    skinned: boolean = false;\n    /** Inverse bind matrix */\n    inv_bind_mat: Float32Array | undefined;\n\n    matrix: Float32Array | undefined;\n    /** Rest pose position (3D vector) */\n    pos: BABYLON.Vector3 = new BABYLON.Vector3();\n    /** Rest pose rotation (quaternion) */\n    rot: BABYLON.Quaternion = new BABYLON.Quaternion();\n    /** Rest pose scale (3D vector) */\n    scl: BABYLON.Vector3 = new BABYLON.Vector3();\n}\n\n/**\n* A skinned mesh animation\n*/\nexport class RMXAnimation {\n    name: string;\n    frames: number;\n    fps: number;\n    tracks: RMXAnimationTrack[];\n\n    constructor() {\n        this.name = \"\";\n        this.frames = 0;\n        this.fps = 0;\n        this.tracks = [];\n    }\n}\n\n/**\n* An animation track.\n* Contains animation curves for the transformation of a single bone.\n*/\nexport class RMXAnimationTrack {\n    bone: number;\n    pos: Float32Array | undefined;\n    rot: Float32Array | undefined;\n    scl: Float32Array | undefined;\n\n    constructor() {\n        this.bone = 0;\n    }\n}\n","import {Context} from \"./context\"\nimport { DataChunkJSON, GeometryJSON, DocumentJSON, BoneJSON, AnimationTrackJSON, AnimationJSON, MaterialJSON } from \"./exporter/format\";\nimport {LogLevel} from \"./log\"\nimport * as Model from \"./model\"\nimport * as ModelAnimation from \"./model-animation\"\n\n/**\n* Loads our custom file format\n*/\nexport class RMXModelLoader {\n\n    constructor() {\n    }\n\n    private loadFloatData(json: DataChunkJSON, data: ArrayBuffer): Float32Array  | undefined{\n        if (json) {\n            return new Float32Array(data, json.byte_offset, json.count * json.stride);\n        } else {\n            return null;\n        }\n    }\n\n    private loadUint8Data(json: DataChunkJSON, data: ArrayBuffer): Uint8Array | undefined{\n        if (json) {\n            return new Uint8Array(data, json.byte_offset, json.count * json.stride);\n        } else {\n            return null;\n        }\n    }\n\n    private loadUint32Data(json: DataChunkJSON, data: ArrayBuffer): Uint32Array {\n        if (json) {\n            return new Uint32Array(data, json.byte_offset, json.count * json.stride);\n        } else {\n            return null;\n        }\n    }\n\n    private loadModelChunk(json: GeometryJSON, data: ArrayBuffer): Model.RMXModelChunk {\n        var result = new Model.RMXModelChunk;\n\n        result.name = json.name;\n        result.triangle_count = json.triangle_count;\n        result.material_index = json.material;\n\n        result.data_position   = this.loadFloatData(json.position, data);\n        result.data_normal     = this.loadFloatData(json.normal, data);\n        result.data_texcoord   = this.loadFloatData(json.texcoord, data);\n        result.data_boneweight = this.loadFloatData(json.boneweight, data);\n        result.data_boneindex  = this.loadUint8Data(json.boneindex, data);\n        result.data_indices    = this.loadUint32Data(json.indices, data);\n\n        // Three.js wants float data\n        if (result.data_boneindex) {\n            result.data_boneindex = new Uint8Array(result.data_boneindex);\n        }\n\n        return result;\n    }\n\n    loadModel(json: DocumentJSON, data: ArrayBuffer): Model.RMXModel {\n        var result = new Model.RMXModel;\n\n        // Load geometry\n        result.chunks = json.chunks.map((chunk) => { return this.loadModelChunk(chunk, data) });\n\n        // Load skeleton\n        result.skeleton = this.loadSkeleton(json, data);\n\n        // Load animations\n        result.animations = json.animations.map((animation) => { return this.loadAnimation(animation, data) });\n\n        // Load materials\n        result.materials = json.materials.map((material) => { return this.loadMaterial(material, data) });\n\n        return result;\n    }\n\n    private loadBone(json: BoneJSON, data: ArrayBuffer): Model.RMXBone {\n        if (json == null) {\n            return null;\n        }\n\n        var result: Model.RMXBone = new Model.RMXBone;\n\n        result.name = json.name;\n        result.parent = json.parent;\n        result.skinned = json.skinned;\n        result.inv_bind_mat = new Float32Array(json.inv_bind_mat);\n        result.matrix = new Float32Array(json.matrix);\n        result.pos.set(json.pos[0], json.pos[1], json.pos[2]);\n        result.rot.set(json.rot[0], json.rot[1], json.rot[2], json.rot[3]);\n        result.scl.set(json.scl[0], json.scl[1], json.scl[2]);\n\n        return result;\n    }\n\n    private loadSkeleton(json: DocumentJSON, data: ArrayBuffer): Model.RMXSkeleton {\n        if (json.bones == null || json.bones.length == 0) {\n            return null;\n        }\n\n        var result = new Model.RMXSkeleton;\n\n        result.bones = json.bones.map((bone) => { return this.loadBone(bone, data) });\n\n        return result;\n    }\n\n    private loadAnimationTrack(json: AnimationTrackJSON, data: ArrayBuffer): Model.RMXAnimationTrack {\n        if (json == null) {\n            return null;\n        }\n\n        var result = new Model.RMXAnimationTrack;\n        result.bone = json.bone;\n        result.pos = this.loadFloatData(json.pos, data);\n        result.rot = this.loadFloatData(json.rot, data);\n        result.scl = this.loadFloatData(json.scl, data);\n        return result;\n    }\n\n    private loadAnimation(json: AnimationJSON, data: ArrayBuffer): Model.RMXAnimation {\n        if (json == null) {\n            return null;\n        }\n\n        var result = new Model.RMXAnimation;\n        result.name = json.name;\n        result.fps = json.fps;\n        result.frames = json.frames;\n        result.tracks = json.tracks.map((track) => { return this.loadAnimationTrack(track, data) });\n\n        return result;\n    }\n\n    private loadMaterial(json: MaterialJSON, data: ArrayBuffer): Model.RMXMaterial {\n        var result = new Model.RMXMaterial;\n        result.diffuse = json.diffuse;\n        result.specular = json.specular;\n        result.normal = json.normal;\n\n        result.diffuseColor = json.diffuseColor;\n        result.specularColor = json.specularColor;\n        result.emissiveColor = json.emissiveColor;\n        \n\n        return result;\n    }\n}\n","import {Context} from \"./context\"\nimport {LogLevel} from \"./log\"\nimport * as Model from \"./model\"\nimport * as ModelAnimation from \"./model-animation\"\nimport * as BABYLON from 'babylonjs';\n\n/**\n* Converts a RMXModel into corresponding three.js objects\n*/\nexport class BabylonModelLoader {\n\n    private materialCache: { [hash: string]: BABYLON.Material };\n\n    constructor() {\n        this.materialCache = {};\n    }\n\n    private createGeometry(chunk: Model.RMXModelChunk, scene : BABYLON.Scene): BABYLON.VertexData {\n        var vertexData = new BABYLON.VertexData();\n\n        if (chunk.data_position) {\n            vertexData.positions = chunk.data_position;\n        }\n        if (chunk.data_normal) {\n            vertexData.normals = chunk.data_normal;\n        }\n\n        if (chunk.data_texcoord) {\n            vertexData.uvs = chunk.data_texcoord;\n        }\n        if (chunk.data_boneindex) {\n            //result.addAttribute(\"skinIndex\", new THREE.BufferAttribute(chunk.data_boneindex, 4));\n        }\n        if (chunk.data_boneindex) {\n            //result.addAttribute(\"skinWeight\", new THREE.BufferAttribute(chunk.data_boneweight, 4));\n        }\n        if (chunk.data_indices) {\n            vertexData.indices = chunk.data_indices;\n\n            // reverse the winding order\n            for (var i = 0; i < vertexData.indices.length; i += 3) {\n                var tmp = vertexData.indices[i];\n                vertexData.indices[i] = vertexData.indices[i + 2];\n                vertexData.indices[i + 2] = tmp;\n            }\n        }\n\n        return vertexData;\n    }\n\n    private createTexture(url: string, scene : BABYLON.Scene): BABYLON.Texture {\n        if ((url == null)  || (url == \"\")) {\n            return new BABYLON.Texture(\"\", scene);\n        }\n\n        // TODO Polyhobbyist\n\n        return new BABYLON.Texture(url, scene);\n    }\n\n    private parseColor(color: string) : BABYLON.Color3 {\n        color = color.trim();\n        var rgba = color.split(' ');\n        if (rgba.length >= 3) {\n            throw new Error(\"Color ${rgba} does not have 3 values\")\n        }\n    \n        return new BABYLON.Color3(parseFloat(rgba[0]), parseFloat(rgba[1]), parseFloat(rgba[2]));\n    }\n\n    private createMaterial(material: Model.RMXMaterial, skinned: boolean, scene : BABYLON.Scene): BABYLON.Material {\n        var prefix = skinned ? \"skinned-\" : \"static-\";\n        var hash = prefix + material.hash();\n        var cached_material = this.materialCache[hash];\n\n        if (cached_material) {\n            return cached_material;\n        } else {\n            var result = new BABYLON.StandardMaterial(hash, scene);\n            result.backFaceCulling = false;\n            \n            //result.skinning = skinned;\n            if (material.diffuse) {\n                result.diffuseTexture = this.createTexture(material.diffuse, scene);\n            }\n\n            if (material.specular) {\n                result.specularTexture = this.createTexture(material.specular, scene);\n            }\n\n            if (material.diffuseColor != undefined && material.diffuseColor.length == 4) {\n                result.diffuseColor = new BABYLON.Color3(material.diffuseColor[0], material.diffuseColor[1], material.diffuseColor[2]);\n            }\n\n            if (material.emissiveColor != undefined && material.emissiveColor.length == 4) {\n                result.emissiveColor = new BABYLON.Color3(material.emissiveColor[0], material.emissiveColor[1], material.emissiveColor[2]);\n            }\n\n            if (material.specularColor != undefined && material.specularColor.length == 4) {\n                result.specularColor = new BABYLON.Color3(material.specularColor[0], material.specularColor[1], material.specularColor[2])\n            } else {\n                result.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);\n            }\n\n            this.materialCache[hash] = result;\n            return result;\n        }\n    }\n\n    createBabylonModel(model: Model.RMXModel, scene : BABYLON.Scene): BabylonModel {\n        var result = new BabylonModel();\n        var skinned = model.skeleton? true : false;\n\n        // Create root transform node\n        let transformNodes: BABYLON.TransformNode[] = [];\n        \n        // Create transform hierarchy instead of skeleton\n        if (model.skeleton) {\n            \n            // First pass: create all transform nodes\n            for (var i = 0; i < model.skeleton.bones.length; ++i) {\n                var bone = model.skeleton.bones[i];\n                let boneMatrix = BABYLON.Matrix.FromArray(bone.matrix);\n                \n                let transformNode = new BABYLON.TransformNode(bone.name, scene);\n                transformNode.setPreTransformMatrix(boneMatrix);\n                transformNodes.push(transformNode);\n            }\n            \n            // Second pass: set up parent relationships\n            for (var i = 0; i < model.skeleton.bones.length; ++i) {\n                var bone = model.skeleton.bones[i];\n                if (bone.parent >= 0 && bone.parent < transformNodes.length) {\n                    transformNodes[i].parent = transformNodes[bone.parent];\n                }\n            }\n        }\n\n        result.transformNodes = transformNodes;\n\n        // Geometry\n        for (var i = 0; i < model.chunks.length; ++i) {\n            var rmx_chunk = model.chunks[i];\n            var chunk = new BabylonModelChunk;\n            chunk.geometry = this.createGeometry(rmx_chunk, scene);\n            chunk.material = this.createMaterial(model.materials[rmx_chunk.material_index], skinned, scene);\n            result.chunks.push(chunk);\n\n            if (chunk.geometry) {\n                var m = new BABYLON.Mesh(rmx_chunk.name, scene);\n                chunk.geometry.applyToMesh(m);\n                m.material = chunk.material;\n                result.meshes.push(m);\n\n                var normals = m.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n                var positions = m.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n\n                BABYLON.VertexData.ComputeNormals(positions, m.getIndices(), normals, { useRightHandedSystem: scene.useRightHandedSystem });\n                m.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);\n                m.convertToFlatShadedMesh();\n                m.sideOrientation = BABYLON.Material.CounterClockWiseSideOrientation;\n\n                // Attach mesh to transform nodes instead of bones\n                if (result.transformNodes) {\n                    var bone_indices = rmx_chunk.data_boneindex;\n                    if (bone_indices) {\n                        var bone_count = bone_indices.length / 4;\n                        for (var j = 0; j < bone_count; ++j) {\n                            var bone_index = bone_indices[j * 4];\n                            if (bone_index >= 0 && bone_index < result.transformNodes.length) {\n                                m.parent = result.transformNodes[bone_index];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Animation - store for later use\n        result.animations = model.animations;\n        return result;\n    }\n}\n\n/**\n* A custom class that replaces THREE.Skeleton with transforms\n*/\nexport class BabylonSkeleton {\n    boneTexture: ModelAnimation.RMXBoneMatrixTexture;\n    skeleton: Model.RMXSkeleton;\n    pose: ModelAnimation.RMXPose;\n    transformNodes: BABYLON.TransformNode[];\n\n    constructor(skeleton: Model.RMXSkeleton, transformNodes: BABYLON.TransformNode[]) {\n        this.skeleton = skeleton;\n        this.transformNodes = transformNodes;\n        this.pose = new ModelAnimation.RMXPose(skeleton.bones.length);\n        ModelAnimation.RMXSkeletalAnimation.resetPose(this.skeleton, this.pose);\n        this.boneTexture = new ModelAnimation.RMXBoneMatrixTexture(skeleton.bones.length);\n    }\n\n    update(gl: WebGLRenderingContext) {\n        ModelAnimation.RMXSkeletalAnimation.exportPose(this.skeleton, this.pose, this.boneTexture.data);\n        // Update transform nodes based on pose\n        for (let i = 0; i < this.transformNodes.length; i++) {\n            const pos = new BABYLON.Vector3(\n                this.pose.pos[i * 3],\n                this.pose.pos[i * 3 + 1],\n                this.pose.pos[i * 3 + 2]\n            );\n            const rot = new BABYLON.Quaternion(\n                this.pose.rot[i * 4],\n                this.pose.rot[i * 4 + 1],\n                this.pose.rot[i * 4 + 2],\n                this.pose.rot[i * 4 + 3]\n            );\n            const scl = new BABYLON.Vector3(\n                this.pose.scl[i * 3],\n                this.pose.scl[i * 3 + 1],\n                this.pose.scl[i * 3 + 2]\n            );\n            \n            this.transformNodes[i].position = pos;\n            this.transformNodes[i].rotationQuaternion = rot;\n            this.transformNodes[i].scaling = scl;\n        }\n        this.boneTexture.update(gl);\n    }\n}\n\n/**\n* Stores information about a piece of geometry\n*/\nclass BabylonModelChunk {\n    geometry: BABYLON.VertexData | undefined = undefined;\n    material: BABYLON.Material | undefined = undefined;\n\n    constructor() {\n    }\n}\n\nexport class BabylonModelInstance {\n    model: BabylonModel;\n    skeleton: BabylonSkeleton | undefined;\n\n    constructor(model: BabylonModel, skeleton: BabylonSkeleton | undefined) {\n        this.model = model;\n        this.skeleton = skeleton;\n    }\n}\n\n/**\n* A factory for producing models using transform nodes instead of skeletons\n*/\nexport class BabylonModel {\n    chunks: BabylonModelChunk[];\n    transformNodes: BABYLON.TransformNode[] | undefined;\n    rootNode: BABYLON.TransformNode;\n    animations: Model.RMXAnimation[];\n    static identityMatrix: BABYLON.Matrix = new BABYLON.Matrix();\n    meshes: BABYLON.AbstractMesh[] = [];\n\n    constructor() {\n        this.chunks = [];\n        this.transformNodes = undefined;\n        this.animations = [];\n    }\n}\n","import {Log, LogLevel} from \"../log\"\nimport * as BABYLON from 'babylonjs';\nimport {Context} from \"../context\"\nimport * as SourceLoader from \"../loader/source\"\nimport { ConverterContext } from \"./context\";\n\n        /**\n        * Re-indexes data.\n        * Copies srcData[srcIndices[i*srcStride + srcOffset]] to destData[destIndices[i*destStride + destOffset]]\n        *\n        * Used because in COLLADA, each geometry attribute (position, normal, ...) can have its own index buffer,\n        * whereas for GPU rendering, there is only one index buffer for the whole geometry.\n        *\n        */\n        export function reIndex<T>(\n            srcData: T, srcIndices: Uint32Array, srcStride: number, srcOffset: number, srcDim: number,\n            destData: T, destIndices: Uint32Array, destStride: number, destOffset: number, destDim: number) {\n\n            var dim: number = Math.min(srcDim, destDim);\n            var srcIndexCount: number = srcIndices.length;\n\n            // Index in the \"indices\" array at which the next index can be found\n            var srcIndexIndex: number = srcOffset;\n            var destIndexIndex: number = destOffset;\n\n            while (srcIndexIndex < srcIndexCount) {\n\n                // Index in the \"data\" array at which the vertex data can be found\n                var srcIndex: number = srcIndices[srcIndexIndex];\n                srcIndexIndex += srcStride;\n                var destIndex: number = destIndices[destIndexIndex];\n                destIndexIndex += destStride;\n\n                // Copy vertex data (one value for each dimension)\n                for (var d: number = 0; d < dim; ++d) {\n                    destData[srcDim * destIndex + d] = srcData[destDim * srcIndex + d];\n                }\n            }\n        }\n\n        /**\n        * Given a list of indices stored as indices[i*stride + offset],\n        * returns a similar list of indices stored as an array of consecutive numbers.\n        */\n        export function compactIndices(indices: Uint32Array, stride: number, offset: number): Uint32Array {\n            var uniqueCount: number = 0;\n            var indexCount = indices.length / stride;\n            var uniqueMap: Uint32Array = new Uint32Array(indexCount);\n\n            var invalidIndex: number = 0xffffff;\n\n            // Find out which indices are unique and which appeared previously\n            for (var i: number = 0; i < indexCount; ++i) {\n\n                var previousIndex: number = invalidIndex;\n                for (var j: number = 0; j < i; ++j) {\n                    if (indices[j * stride + offset] === indices[i * stride + offset]) {\n                        previousIndex = j;\n                        break;\n                    }\n                }\n\n                uniqueMap[i] = previousIndex;\n                if (previousIndex !== invalidIndex) {\n                    uniqueCount++;\n                }\n            }\n\n            // Create new indices\n            var result: Uint32Array = new Uint32Array(indexCount);\n            var nextIndex = 0;\n            for (var i: number = 0; i < indexCount; ++i) {\n                var previousIndex = uniqueMap[i];\n                if (previousIndex === invalidIndex) {\n                    result[i] = nextIndex;\n                    nextIndex++;\n                } else {\n                    result[i] = result[previousIndex];\n                }\n            }\n\n            return result;\n        }\n\n        /**\n        * Returns the maximum element of a list of non-negative integers\n        */\n        export function maxIndex(indices: Uint32Array): number {\n            if (!indices) {\n                return 0;\n            }\n            var result: number = -1;\n            var length: number = indices.length\n        for (var i: number = 0; i < length; ++i) {\n                if (indices[i] > result) result = indices[i];\n            }\n            return result;\n        }\n\n        export function createFloatArray(source: SourceLoader.Source, name: string, outDim: number, context: Context): Float32Array {\n            if (!source) {\n                return null;\n            }\n\n            if (source.stride > outDim) {\n                context.log.write(\"Source data for \" + name + \" contains too many dimensions, \" + (source.stride - outDim) + \" dimensions will be ignored\", LogLevel.Warning);\n            } else if (source.stride < outDim) {\n                context.log.write(\"Source data for \" + name + \" does not contain enough dimensions, \" + (outDim - source.stride) + \" dimensions will be zero\", LogLevel.Warning);\n            }\n\n            // Start and end index\n            var iBegin: number = source.offset;\n            var iEnd: number = source.offset + source.count * source.stride;\n            if (iEnd > source.data.length) {\n                context.log.write(\"Source for \" + name + \" tries to access too many elements, data ignored\", LogLevel.Warning);\n                return null;\n            }\n\n            // Get source raw data\n            if (!(source.data instanceof Float32Array)) {\n                context.log.write(\"Source for \" + name + \" does not contain floating point data, data ignored\", LogLevel.Warning);\n                return null;\n            }\n            var srcData: Float32Array = <Float32Array>source.data;\n\n            // Copy data\n            var result = new Float32Array(source.count * outDim);\n            var src_offset = source.offset;\n            var src_stride = source.stride;\n            var dest_offset = 0;\n            var dest_stride = outDim;\n            for (var i: number = 0; i < source.count; ++i) {\n                for (var j: number = 0; j < outDim; ++j) {\n                    result[dest_offset + dest_stride * i + j] = srcData[src_offset + src_stride*i + j];\n                }\n            }\n            return result;\n        }\n\n        export function createStringArray(source: SourceLoader.Source, name: string, outDim: number, context: Context): string[] {\n            if (!source) {\n                return [];\n            }\n            if (source.stride > outDim) {\n                context.log.write(\"Source data for \" + name + \" contains too many dimensions, \" + (source.stride - outDim) + \" dimensions will be ignored\", LogLevel.Warning);\n            } else if (source.stride < outDim) {\n                context.log.write(\"Source data for \" + name + \" does not contain enough dimensions, \" + (outDim - source.stride) + \" dimensions will be zero\", LogLevel.Warning);\n            }\n\n            // Start and end index\n            var iBegin: number = source.offset;\n            var iEnd: number = source.offset + source.count * source.stride;\n            if (iEnd > source.data.length) {\n                context.log.write(\"Source for \" + name + \" tries to access too many elements, data ignored\", LogLevel.Warning);\n                return [];\n            }\n\n            // Get source raw data\n            if (!(source.data instanceof Array)) {\n                context.log.write(\"Source for \" + name + \" does not contain string data, data ignored\", LogLevel.Warning);\n                return [];\n            }\n            var srcData: string[] = <string[]> source.data;\n\n            // Copy data\n            var result: string[] = new Array(source.count * outDim);\n            var src_offset = source.offset;\n            var src_stride = source.stride;\n            var dest_offset = 0;\n            var dest_stride = outDim;\n            for (var i: number = 0; i < source.count; ++i) {\n                for (var j: number = 0; j < outDim; ++j) {\n                    result[dest_offset + dest_stride * i + j] = srcData[src_offset + src_stride * i + j];\n                }\n            }\n            return result;\n        }\n\n        export function spawElements<T>(array: T, i1: number, i2: number): void {\n            var temp = array[i1];\n            array[i1] = array[i2];\n            array[i2] = temp;\n        }\n\n        export function insertBone<T>(indices: T, weights: Float32Array, index: number, weight: number, offsetBegin: number, offsetEnd: number) {\n\n            if (weights[offsetEnd] < weight) {\n\n                // Insert at last position\n                weights[offsetEnd] = weight;\n                indices[offsetEnd] = index;\n\n                // Bubble towards the front\n                for (var i = offsetEnd; i > offsetBegin; --i) {\n                    if (weights[i] > weights[i - 1]) {\n                        spawElements(weights, i, i - 1);\n                        spawElements(indices, i, i - 1);\n                    }\n                }\n            }\n        }\n\n        var worldTransform: BABYLON.Matrix = new BABYLON.Matrix();\n        export function getWorldTransform(context: ConverterContext): BABYLON.Matrix {\n            var mat: BABYLON.Matrix = worldTransform;\n            mat.copyFrom(getWorldRotation(context));\n            var s = getWorldScale(context);\n            var matScale = BABYLON.Matrix.Scaling(s.x, s.y, s.z);\n            mat = mat.multiply(matScale);\n            return mat;\n        }\n\n        var worldInvTransform: BABYLON.Matrix = new BABYLON.Matrix();\n        export function getWorldInvTransform(context: ConverterContext): BABYLON.Matrix {\n            var mat: BABYLON.Matrix = getWorldTransform(context);\n            mat.copyFrom(getWorldRotation(context));\n            mat.invert();\n            return worldInvTransform;\n        }\n\n        var worldScale: BABYLON.Vector3 = new BABYLON.Vector3();\n        export function getWorldScale(context: ConverterContext): BABYLON.Vector3 {\n            var scale: number = context.options.worldTransformScale.value;\n            worldScale = new BABYLON.Vector3(scale, scale, scale);\n            return worldScale;\n        }\n\n        var worldInvScale: BABYLON.Vector3 = new BABYLON.Vector3();\n        export function getWorldInvScale(context: ConverterContext): BABYLON.Vector3 {\n            var invScale: number = 1 / context.options.worldTransformScale.value;\n            worldInvScale = new BABYLON.Vector3(invScale, invScale, invScale);\n            return worldInvScale;\n        }\n\n        var worldRotation: BABYLON.Matrix = new BABYLON.Matrix();\n        export function getWorldRotation(context: ConverterContext): BABYLON.Matrix {\n            var rotationAxis: string = context.options.worldTransformRotationAxis.value;\n            var rotationAngle: number = context.options.worldTransformRotationAngle.value * Math.PI / 180;\n\n            var mat: BABYLON.Matrix = worldRotation;\n\n            switch (rotationAxis) {\n                case \"none\": break;\n                case \"x\": mat = BABYLON.Matrix.RotationX(rotationAngle); break;\n                case \"y\": mat = BABYLON.Matrix.RotationY(rotationAngle); break;\n                case \"z\": mat = BABYLON.Matrix.RotationZ(rotationAngle); break;\n                default: context.log.write(\"Unknown rotation axis\", LogLevel.Warning); break;\n            }\n\n            return mat;\n        }\n","import {Log, LogLevel} from \"../log\"\nimport { NodeTransform } from \"../loader/node_transform\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Bone} from \"./bone\"\nimport {Texture} from \"./texture\"\nimport {Animation, AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport {Options} from \"./options\"\nimport {BoundingBox} from \"./bounding_box\"\nimport * as BABYLON from 'babylonjs';\nimport { AnimationChannel } from \"./animation_channel\"\nimport { ConverterContext } from \"./context\"\n\n\n    export enum TransformType {\n        Translation = 1,\n        Rotation = 2,\n        Scale = 3\n    };\n\n    export class Transform {\n        data: Float32Array;\n        original_data: Float32Array;\n        rows: number;\n        colums: number;\n        channels: AnimationChannel[] | undefined;\n\n        constructor(transform: NodeTransform, rows: number, columns: number) {\n            this.rows = rows;\n            this.colums = columns;\n            this.channels = [];\n            var data_elements: number = rows * columns;\n            this.data = new Float32Array(data_elements);\n            this.original_data = new Float32Array(data_elements);\n            for (var i = 0; i < data_elements; ++i) {\n                this.data[i] = transform.data[i];\n                this.original_data[i] = transform.data[i];\n            }\n        }\n        getTargetDataRows(): number {\n            return this.rows;\n        }\n        getTargetDataColumns(): number {\n            return this.colums;\n        }\n        applyAnimation(channel: AnimationChannel, time: number, context: ConverterContext) {\n            AnimationChannel?.applyToData(channel, this.data, time, context);\n            this.updateFromData();\n        }\n        registerAnimation(channel: AnimationChannel): void {\n            this.channels?.push(channel);\n        }\n        isAnimated(): boolean {\n            return this.channels?this.channels.length > 0:false;\n        }\n        isAnimatedBy(animation: Animation): boolean {\n            if (animation !== null && this.channels) {\n                for (var i: number = 0; i < this.channels.length || 0; ++i) {\n                    var channel: AnimationChannel = this.channels[i];\n                    if (animation.channels.indexOf(channel) !== -1) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                return this.channels?this.channels.length > 0:false;\n            }\n        }\n        resetAnimation() {\n            for (var i = 0; i < this.data.length; ++i) {\n                this.data[i] = this.original_data[i];\n            }\n            this.updateFromData();\n        }\n        applyTransformation(mat: BABYLON.Matrix) {\n            throw new Error(\"Not implemented\");\n        }\n        updateFromData() {\n            throw new Error(\"Not implemented\");\n        }\n        hasTransformType(type: TransformType): boolean {\n            throw new Error(\"Not implemented\");\n        }\n    }\n\n    export class TransformMatrix extends Transform implements AnimationTarget {\n        matrix: BABYLON.Matrix;\n        constructor(transform: NodeTransform) {\n            super(transform, 4, 4);\n            this.matrix = new BABYLON.Matrix();\n            this.updateFromData();\n        }\n        updateFromData() {\n            MathUtils.mat4Extract(this.data, 0, this.matrix);\n        }\n        applyTransformation(mat: BABYLON.Matrix) {\n            mat.copyFrom(mat.multiply(this.matrix));\n        }\n        hasTransformType(type: TransformType): boolean {\n            return true;\n        }\n    }\n\n    export class TransformRotate extends Transform implements AnimationTarget {\n        /** Source data: axis */\n        axis: BABYLON.Vector3 = new BABYLON.Vector3;\n        /** Source data: angle */\n        radians: number;\n        constructor(transform: NodeTransform) {\n            super(transform, 4, 1);\n            this.axis = new BABYLON.Vector3;\n            this.radians = 0;\n            this.updateFromData();\n        }\n        updateFromData() {\n            this.axis.set(this.data[0], this.data[1], this.data[2]);\n            this.radians = this.data[3] / 180 * Math.PI;\n        }\n        applyTransformation(mat: BABYLON.Matrix) {\n            let t = BABYLON.Matrix.RotationAxis(this.axis, this.radians);\n            mat.copyFrom(mat.multiply(t));\n        }\n        hasTransformType(type: TransformType): boolean {\n            return (type === TransformType.Rotation);\n        }\n    }\n\n    export class TransformTranslate extends Transform implements AnimationTarget {\n        /** Source data: translation */\n        pos: BABYLON.Vector3 = new BABYLON.Vector3();\n        constructor(transform: NodeTransform) {\n            super(transform, 3, 1);\n            this.updateFromData();\n        }\n        updateFromData() {\n            this.pos.set(this.data[0], this.data[1], this.data[2]);\n        }\n        applyTransformation(mat: BABYLON.Matrix) {\n            let t = BABYLON.Matrix.Translation(this.pos.x, this.pos.y, this.pos.z);\n            mat.copyFrom(mat.multiply(t));\n        }\n        hasTransformType(type: TransformType): boolean {\n            return (type === TransformType.Translation);\n        }\n    }\n\n    export class TransformScale extends Transform implements AnimationTarget {\n        /** Source data: scaling */\n        scl: BABYLON.Vector3 = new BABYLON.Vector3();\n        constructor(transform: NodeTransform) {\n            super(transform, 3, 1);\n            this.updateFromData();\n        }\n        updateFromData() {\n            this.scl.set(this.data[0], this.data[1], this.data[2]);\n        }\n        applyTransformation(mat: BABYLON.Matrix) {\n            let t = BABYLON.Matrix.Scaling(this.scl.x, this.scl.y, this.scl.z);\n            mat.copyFrom(mat.multiply(t))\n        }\n        hasTransformType(type: TransformType): boolean {\n            return (type === TransformType.Scale);\n        }\n    }\n","import * as BABYLON from 'babylonjs';\n\n\n    export interface NumberArray {\n        length: number;\n        [index: number]: number;\n    }\n\n    var TO_RADIANS: number = Math.PI / 180.0;\n\n    export function round(num: number, decimals: number): number {\n        if (decimals !== null) {\n            // Nice, but does not work for scientific notation numbers\n            // return +(Math.round(+(num + \"e+\" + decimals)) + \"e-\" + decimals);\n            return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);\n        } else {\n            return num;\n        }\n    }\n\n    export function copyNumberArray(src: NumberArray, dest: NumberArray, count: number) {\n        for (var i: number = 0; i < count; ++i) {\n            dest[i] = src[i];\n        }\n    }\n\n    export function copyNumberArrayOffset(src: NumberArray, srcOffset: number, dest: NumberArray, destOffset: number, count: number) {\n        for (var i: number = 0; i < count; ++i) {\n            dest[destOffset + i] = src[srcOffset + i];\n        }\n    }\n\n    /**\n    * Calls the given function for each src[i*stride + offset]\n    */\n    export function forEachElement(src: NumberArray, stride: number, offset: number, fn: (x: number) => void) {\n        var count = src.length / stride;\n        for (var i: number = 0; i < count; ++i) {\n            fn(src[i * stride + offset]);\n        }\n    }\n\n    /**\n    * Extracts a 4D matrix from an array of matrices (stored as an array of numbers)\n    */\n    export function mat4Extract(src: NumberArray, srcOff: number, dest: BABYLON.Matrix) {\n        let d = new Float32Array(16);\n        for (var i: number = 0; i < 16; ++i) {\n            d[i] = src[srcOff * 16 + i];\n        }\n        dest.copyFrom(BABYLON.Matrix.FromArray(d).transpose());\n\n        // Collada matrices are row major\n        // glMatrix matrices are column major\n        // webgl matrices are column major\n        // BABlong is Row major dest.transpose();\n    }\n\n    export function bezier(p0: number, c0: number, c1: number, p1: number, s: number): number {\n        if (s < 0 || s > 1) throw new Error(\"Invalid Bezier parameter: \" + s);\n        return p0 * (1 - s) * (1 - s) * (1 - s) + 3 * c0 * s * (1 - s) * (1 - s) + 3 * c1 * s * s * (1 - s) + p1 * s * s * s;\n    }\n\n    export function hermite(p0: number, t0: number, t1: number, p1: number, s: number): number {\n        if (s < 0 || s > 1) throw new Error(\"Invalid Hermite parameter: \" + s);\n        var s2: number = s * s;\n        var s3: number = s2 * s;\n        return p0 * (2 * s3 - 3 * s2 + 1) + t0 * (s3 - 2 * s2 + s) + p1 * (-2 * s3 + 3 * s2) + t1 * (s3 - s2);\n    }\n\n    /**\n     * \n    * Given a monotonously increasing function fn and a value target_y, finds a value x with 0<=x<=1 such that fn(x)=target_y\n    */\n    export function bisect(target_y: number, fn: (x: number) => number, tol_y: number, max_iterations: number): number {\n        var x0: number = 0;\n        var x1: number = 1;\n        var y0: number = fn(x0);\n        var y1: number = fn(x1);\n        if (target_y <= y0) return x0;\n        if (target_y >= y1) return x1;\n\n        var x: number = 0.5 * (x0 + x1);\n        var y: number = fn(x);\n\n        var iteration: number = 0;\n        while (Math.abs(y - target_y) > tol_y) {\n\n            // Update bounds\n            if (y < target_y) {\n                x0 = x;\n            } else if (y > target_y) {\n                x1 = x;\n            } else {\n                return x;\n            }\n\n            // Update values\n            x = 0.5 * (x0 + x1);\n            y = fn(x);\n\n            // Check iteration count\n            ++iteration;\n            if (iteration > max_iterations) {\n                throw new Error(\"Too many iterations\");\n            }\n        }\n        return x;\n    }\n","import {ConverterContext} from \"./context\"\nimport {LogLevel} from \"../log\"\nimport {AnimationTarget} from \"./animation\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport * as SourceLoader from \"../loader/source\"\nimport { Channel } from \"../loader/channel\"\nimport { EElement } from \"../loader/element\"\nimport { Input } from \"../loader/input\"\nimport { SidLink } from \"../loader/link\"\nimport { Sampler } from \"../loader/sampler\"\n\n    export interface AnimationChannelIndices {\n        /** left index */\n        i0: number;\n        /** right index */\n        i1: number;\n    }\n\n    export class AnimationChannel {\n        target: AnimationTarget;\n        interpolation: string[];\n        input: Float32Array;\n        output: Float32Array;\n        inTangent: Float32Array;\n        outTangent: Float32Array;\n        dataOffset: number;\n        dataCount: number;\n\n        constructor() {\n            this.target = null;\n            this.interpolation = null;\n            this.input = null;\n            this.output = null;\n            this.inTangent = null;\n            this.outTangent = null;\n            this.dataOffset = null;\n            this.dataCount = null;\n        }\n\n        // TODO: This is the most expensive function in the whole project. Use a binary search or find out why it's so slow.\n        findInputIndices(t: number, context: ConverterContext): AnimationChannelIndices {\n            var input: Float32Array = this.input;\n\n            var warnInvalidTime = (str: string) => {\n                var warningCount = context.messageCount[\"findInputIndices-invalidTime\"] || 0;\n                if (warningCount < 10) {\n                    context.log.write(str, LogLevel.Warning);\n                } else if (warningCount == 10) {\n                    context.log.write(\"Further warnings about invalid time suppressed.\", LogLevel.Warning);\n                }\n                context.messageCount[\"findInputIndices-invalidTime\"] = warningCount + 1;\n            };\n\n            // Handle borders and special cases\n            if (input.length === 1) {\n                if (t !== input[0]) {\n                    warnInvalidTime(\"Resampling input with only one keyframe: t=\" + t + \", t_begin=\" + input[0] + \", using first keyframe\");\n                }\n                return { i0: 0, i1: 0 };\n            } else if (t < input[0]) {\n                warnInvalidTime(\"Invalid time for resampling: t=\" + t + \", t_begin=\" + input[0] + \", using first keyframe\");\n                return { i0: 0, i1: 1 };\n            } else if (t > input[input.length - 1]) {\n                warnInvalidTime(\"Invalid time for resampling: t=\" + t + \", t_end=\" + input[input.length - 1] + \", using last keyframe\");\n                return { i0: input.length - 2, i1: input.length - 1 };\n            }\n\n            // Find correct keyframes\n            for (var i = 0; i < input.length - 1; ++i) {\n                var t0: number = input[i];\n                var t1: number = input[i + 1];\n                if (t0 <= t && t <= t1) {\n                    return { i0: i, i1: i + 1 };\n                }\n            }\n\n            // Should never get to this\n            context.log.write(\"Keyframes for time \" + t + \"not found, using first keyframe\", LogLevel.Warning);\n            return { i0: 0, i1: 1 };\n        }\n\n        static createInputData(input: Input, inputName: string, dataDim: number, context: ConverterContext): Float32Array {\n            // Input\n            if (!input) {\n                return null;\n            }\n\n            // Source\n            var source: SourceLoader.Source = SourceLoader.Source.fromLink(input.source, context);\n            if (!source) {\n                context.log.write(\"Animation channel has no \" + inputName + \" input data, data ignored\", LogLevel.Warning);\n                return null;\n            }\n\n            // Data\n            if (dataDim != source.stride) {\n                context.log.write(\"Animation channel has a nonstandard dimensionality for \" + inputName + \", data ignored\", LogLevel.Warning);\n                return null;\n            }\n            return Utils.createFloatArray(source, inputName, dataDim, context);\n        }\n\n        static createInputDataFromArray(inputs: Input[], inputName: string, dataDim: number, context: ConverterContext): Float32Array {\n            // Samplers can have more than one output if they describe multiple curves at once.\n            // I don't understand from the spec how a single channel could describe the animation of multiple parameters,\n            // since each channel references a single SID target\n            if (inputs.length > 0) {\n                if (inputs.length > 1) {\n                    context.log.write(\"Animation channel has more than one \" + inputName + \" input, using only the first one\", LogLevel.Warning);\n                }\n                return AnimationChannel.createInputData(inputs[0], inputName, dataDim, context);\n            } else {\n                return null;\n            }\n        }\n\n        static create(channel: Channel, context: ConverterContext): AnimationChannel {\n            var result: AnimationChannel = new AnimationChannel();\n\n            // Element\n            var element: EElement = EElement.fromLink(channel.target, context);\n            if (!element) {\n                context.log.write(\"Animation channel has an invalid target '\" + channel.target.url + \"', animation ignored\", LogLevel.Warning);\n                return null;\n            }\n\n            // Target\n            var target: AnimationTarget = context.animationTargets.findConverter(element);\n            if (!target) {\n                context.log.write(\"Animation channel has no converter target '\" + channel.target.url + \"', animation ignored\", LogLevel.Warning);\n                return null;\n            }\n            result.target = target;\n\n            // Sampler\n            var sampler: Sampler = Sampler.fromLink(channel.source, context);\n            if (!sampler) {\n                context.log.write(\"Animation channel has an invalid sampler '\" + channel.source.url + \"', animation ignored\", LogLevel.Warning);\n                return null;\n            }\n\n            // Target dimensionality\n            var targetDataRows: number = target.getTargetDataRows();\n            var targetDataColumns: number = target.getTargetDataColumns();\n            var targetDataDim: number = targetDataRows * targetDataColumns;\n\n            // Destination data offset and count\n            var targetLink: SidLink = channel.target;\n            if (targetLink.dotSyntax) {\n                // Member syntax: single named element\n                result.dataCount = 1;\n                switch (targetLink.member) {\n                    case \"X\":\n                        result.dataOffset = 0;\n                        break;\n                    case \"Y\":\n                        result.dataOffset = 1;\n                        break;\n                    case \"Z\":\n                        result.dataOffset = 2;\n                        break;\n                    case \"W\":\n                        result.dataOffset = 3;\n                        break;\n                    case \"R\":\n                        result.dataOffset = 0;\n                        break;\n                    case \"G\":\n                        result.dataOffset = 1;\n                        break;\n                    case \"B\":\n                        result.dataOffset = 2;\n                        break;\n                    case \"U\":\n                        result.dataOffset = 0;\n                        break;\n                    case \"V\":\n                        result.dataOffset = 1;\n                        break;\n                    case \"S\":\n                        result.dataOffset = 0;\n                        break;\n                    case \"T\":\n                        result.dataOffset = 1;\n                        break;\n                    case \"P\":\n                        result.dataOffset = 2;\n                        break;\n                    case \"Q\":\n                        result.dataOffset = 3;\n                        break;\n                    case \"ANGLE\":\n                        result.dataOffset = 3;\n                        break;\n                    default:\n                        context.log.write(\"Unknown semantic for '\" + targetLink.url + \"', animation ignored\", LogLevel.Warning);\n                        return null;\n                }\n            } else if (channel.target.arrSyntax) {\n                // Array syntax: single element at a given index\n                result.dataCount = 1;\n                switch (targetLink.indices.length) {\n                    case 1:\n                        result.dataOffset = targetLink.indices[0];\n                        break;\n                    case 2:\n                        result.dataOffset = targetLink.indices[0] * targetDataRows + targetLink.indices[1];\n                        break;\n                    default:\n                        context.log.write(\"Invalid number of indices for '\" + targetLink.url + \"', animation ignored\", LogLevel.Warning);\n                        return null;\n                }\n            } else {\n                // Default: data for the whole vector/array\n                result.dataOffset = 0;\n                result.dataCount = targetDataColumns * targetDataRows;\n            }\n\n\n            // Interpolation data\n            result.input = AnimationChannel.createInputData(sampler.input, \"input\", 1, context);\n            result.output = AnimationChannel.createInputDataFromArray(sampler.outputs, \"output\", result.dataCount, context);\n            result.inTangent = AnimationChannel.createInputDataFromArray(sampler.inTangents, \"intangent\", result.dataCount + 1, context);\n            result.outTangent = AnimationChannel.createInputDataFromArray(sampler.outTangents, \"outtangent\", result.dataCount + 1, context);\n\n            if (!result.input) {\n                context.log.write(\"Animation channel has no input data, animation ignored\", LogLevel.Warning);\n                return null;\n            }\n            if (!result.output) {\n                context.log.write(\"Animation channel has no output data, animation ignored\", LogLevel.Warning);\n                return null;\n            }\n\n            // Interpolation type\n            var interpolationInput = sampler.interpolation;\n            if (!interpolationInput) {\n                context.log.write(\"Animation channel has no interpolation input, animation ignored\", LogLevel.Warning);\n                return null;\n            }\n            var interpolationSource: SourceLoader.Source = SourceLoader.Source.fromLink(interpolationInput.source, context);\n            if (!interpolationSource) {\n                context.log.write(\"Animation channel has no interpolation source, animation ignored\", LogLevel.Warning);\n                return null;\n            }\n            result.interpolation = Utils.createStringArray(interpolationSource, \"interpolation type\", 1, context);\n\n            target.registerAnimation(result);\n            return result;\n        }\n\n        static interpolateLinear(time: number, t0: number, t1: number, i0: number, i1: number, dataCount: number, dataOffset: number,\n            channel: AnimationChannel, destData: Float32Array) {\n\n            // Find s\n            var s: number = (time - t0) / (t1 - t0);\n\n            // Evaluate\n            for (var i = 0; i < dataCount; ++i) {\n                var p0: number = channel.output[i0 * dataCount + i];\n                var p1: number = channel.output[i1 * dataCount + i];\n                destData[dataOffset + i] = p0 + s * (p1 - p0);\n            }\n        }\n\n        static interpolateBezier(time: number, t0: number, t1: number, i0: number, i1: number, dataCount: number, dataOffset: number,\n            channel: AnimationChannel, destData: Float32Array) {\n\n            // Find s\n            var tc0: number = channel.outTangent[i0 * (dataCount + 1)];\n            var tc1: number = channel.inTangent[i1 * (dataCount + 1)];\n            var tol: number = Math.abs(t1 - t0) * 1e-4;\n            var s: number = MathUtils.bisect(time, (s) => MathUtils.bezier(t0, tc0, tc1, t1, s), tol, 100);\n            var t_err: number = Math.abs(time - MathUtils.bezier(t0, tc0, tc1, t1, s));\n\n            // Evaluate bezier\n            for (var i = 0; i < dataCount; ++i) {\n                var p0: number = channel.output[i0 * dataCount + i];\n                var p1: number = channel.output[i1 * dataCount + i];\n                var c0: number = channel.outTangent[i0 * (dataCount + 1) + i + 1];\n                var c1: number = channel.inTangent[i1 * (dataCount + 1) + i + 1];\n                destData[dataOffset + i] = MathUtils.bezier(p0, c0, c1, p1, s);\n            }\n        }\n\n        static interpolateHermite(time: number, t0: number, t1: number, i0: number, i1: number, dataCount: number, dataOffset: number,\n            channel: AnimationChannel, destData: Float32Array) {\n\n            // Find s\n            var tt0: number = channel.outTangent[i0 * (dataCount + 1)];\n            var tt1: number = channel.inTangent[i1 * (dataCount + 1)];\n            var tol: number = Math.abs(t1 - t0) * 1e-5;\n            var s: number = MathUtils.bisect(time, (s) => MathUtils.hermite(t0, tt0, tt1, t1, s), tol, 100);\n\n            // Evaluate hermite\n            for (var i = 0; i < dataCount; ++i) {\n                var p0: number = channel.output[i0 * dataCount + i];\n                var p1: number = channel.output[i1 * dataCount + i];\n                var t0: number = channel.outTangent[i0 * (dataCount + 1) + i + 1];\n                var t1: number = channel.inTangent[i1 * (dataCount + 1) + i + 1];\n                destData[dataOffset + i] = MathUtils.hermite(p0, t0, t1, p1, s);\n            }\n        }\n\n        static applyToData(channel: AnimationChannel, destData: Float32Array, time: number, context: ConverterContext) {\n            // Do nothing if the channel does not contain a minimum of information\n            if (!channel.input || !channel.output) {\n                return;\n            }\n\n            var indices: AnimationChannelIndices = channel.findInputIndices(time, context);\n            var i0: number = indices.i0;\n            var i1: number = indices.i1;\n            var t0: number = channel.input[i0];\n            var t1: number = channel.input[i1];\n            var dataCount: number = channel.dataCount;\n            var dataOffset: number = channel.dataOffset;\n\n            var interpolation = channel.interpolation[indices.i0];\n            if (i0 === i1) interpolation = \"STEP\";\n            switch (interpolation) {\n                case \"STEP\":\n                    for (var i = 0; i < dataCount; ++i) {\n                        destData[dataOffset + i] = channel.output[i0 * dataCount + i];\n                    }\n                    break;\n                case \"LINEAR\":\n                    AnimationChannel.interpolateLinear(time, t0, t1, i0, i1, dataCount, dataOffset, channel, destData);\n                    break;\n                case \"BEZIER\":\n                    if (channel.inTangent !== null && channel.outTangent !== null) {\n                        AnimationChannel.interpolateBezier(time, t0, t1, i0, i1, dataCount, dataOffset, channel, destData);\n                    } else {\n                        AnimationChannel.interpolateLinear(time, t0, t1, i0, i1, dataCount, dataOffset, channel, destData);\n                    }\n                    break;\n                case \"HERMITE\":\n                    if (channel.inTangent !== null && channel.outTangent !== null) {\n                        AnimationChannel.interpolateHermite(time, t0, t1, i0, i1, dataCount, dataOffset, channel, destData);\n                    } else {\n                        AnimationChannel.interpolateLinear(time, t0, t1, i0, i1, dataCount, dataOffset, channel, destData);\n                    }\n                    break;\n                case \"CARDINAL\":\n                case \"BSPLINE\":\n                    context.log.write(\"Interpolation type \" + interpolation + \" not supported, using STEP\", LogLevel.Warning);\n                    for (var i = 0; i < dataCount; ++i) {\n                        destData[dataOffset + i] = channel.input[i0 * dataCount + i];\n                    }\n                    break;\n                default:\n                    context.log.write(\"Unknown interpolation type \" + interpolation + \" at time \" + time + \", using STEP\", LogLevel.Warning);\n                    for (var i = 0; i < dataCount; ++i) {\n                        destData[dataOffset + i] = channel.input[i0 * dataCount + i];\n                    }\n            }\n        }\n    }\n","import {Context} from \"../context\"\nimport {LogLevel} from \"../log\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport { AnimationChannel } from \"./animation_channel\"\nimport { ConverterContext } from \"./context\"\nimport * as LoaderAnimation from '../loader/animation';\n\n    export interface AnimationTarget {\n        applyAnimation(channel: AnimationChannel, time: number, context: Context): void;\n        registerAnimation(channel: AnimationChannel): void;\n        getTargetDataRows(): number;\n        getTargetDataColumns(): number;\n    }\n\n    export class AnimationTimeStatistics {\n        beginTime: Statistics;\n        endTime: Statistics;\n        duration: Statistics;\n        keyframes: Statistics;\n        fps: Statistics;\n\n        constructor() {\n            this.beginTime = new Statistics();\n            this.endTime = new Statistics();\n            this.duration = new Statistics();\n            this.keyframes = new Statistics();\n            this.fps = new Statistics();\n        }\n\n        addDataPoint(beginTime: number, endTime: number, keyframes: number) {\n            var duration = endTime - beginTime;\n\n            this.beginTime.addDataPoint(beginTime);\n            this.endTime.addDataPoint(endTime);\n            this.duration.addDataPoint(duration);\n            this.keyframes.addDataPoint(keyframes);\n\n            if (duration > 0) {\n                var fps = (keyframes - 1) / duration;\n                this.fps.addDataPoint(fps);\n            }\n        }\n    }\n\n    export class Statistics {\n        data: number[];\n        sorted: boolean;\n\n        constructor() {\n            this.data = [];\n            this.sorted = true;\n        }\n\n        addDataPoint(value: number) {\n            this.data.push(value);\n            this.sorted = false;\n        }\n\n        private sort() {\n            if (!this.sorted) {\n                this.sorted = true;\n                this.data = this.data.sort((a, b) => a - b);\n            }\n        }\n\n        private compute(fn: (data:number[])=>number) {\n            if (this.data.length > 0) {\n                this.sort();\n                return fn(this.data);\n            } else {\n                return null;\n            }\n        }\n\n        count(): number {\n            return this.compute((data) => data.length);\n        }\n\n        min(): number {\n            return this.compute((data) => data[0]);\n        }\n\n        max(): number {\n            return this.compute((data) => data[data.length - 1]);\n        }\n\n        median(): number {\n            return this.compute((data) => {\n                var m = (this.data.length - 1) / 2;\n                var l = this.data[Math.floor(m)];\n                var r = this.data[Math.ceil(m)];\n                return (l + r) / 2;\n            });\n        }\n\n        sum(): number {\n            return this.compute((data) => data.reduce((prev, cur) => prev + cur, 0));\n        }\n\n        mean(): number {\n            return this.compute((data) => this.sum() / this.count());\n        }\n    }\n\n    export class Animation {\n        id: string;\n        name: string;\n        channels: AnimationChannel[];\n\n        constructor() {\n            this.id = null;\n            this.name = null;\n            this.channels = [];\n        }\n\n        static create(animation: LoaderAnimation.Animation, context: ConverterContext): Animation {\n            var result: Animation = new Animation();\n            result.id = animation.id;\n            result.name = animation.name;\n\n            Animation.addChannelsToAnimation(animation, result, context);\n\n            return result;\n        }\n\n        static addChannelsToAnimation(collada_animation: LoaderAnimation.Animation, converter_animation: Animation, context: ConverterContext) {\n            // Channels\n            for (var i: number = 0; i < collada_animation.channels.length; ++i) {\n                var channel: AnimationChannel = AnimationChannel.create(collada_animation.channels[i], context);\n                converter_animation.channels.push(channel);\n            }\n\n            // Children\n            for (var i: number = 0; i < collada_animation.children.length; ++i) {\n                var child = collada_animation.children[i];\n                Animation.addChannelsToAnimation(child, converter_animation, context);\n            }\n        }\n\n        /**\n        * Returns the time and fps statistics of this animation\n        */\n        static getTimeStatistics(animation: Animation, index_begin: number, index_end: number, result: AnimationTimeStatistics, context: ConverterContext) {\n            // Channels\n            for (var i: number = 0; i < animation.channels.length; ++i) {\n                var channel: AnimationChannel = animation.channels[i];\n\n                if (channel) {\n                    var begin = (index_begin !== null) ? index_begin : -Infinity;\n                    begin = Math.min(Math.max(begin, 0), channel.input.length - 1);\n                    var end = (index_end !== null) ? index_end : Infinity;\n                    end = Math.min(Math.max(end, 0), channel.input.length - 1);\n\n                    var channelMinTime: number = channel.input[begin];\n                    var channelMaxTime: number = channel.input[end];\n                    var channelKeyframes: number = end - begin + 1;\n\n                    result.addDataPoint(channelMinTime, channelMaxTime, channelKeyframes);\n                }\n            }\n        }\n    }\n","import {Context} from \"../context\"\nimport {LogLevel} from \"../log\"\nimport {Animation, AnimationTarget, AnimationTimeStatistics, Statistics} from \"./animation\"\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport * as BABYLON from \"babylonjs\";\nimport { AnimationChannel } from \"./animation_channel\"\nimport { ConverterContext } from \"./context\"\nimport { Skeleton } from \"./skeleton\"\nimport { Bone } from \"./bone\"\n\n    export interface AnimationLabel {\n        name: string;\n        begin: number;\n        end: number;\n        fps: number;\n    }\n\n    export class AnimationDataTrack {\n        /** Position (relative to parent) */\n        pos: Float32Array = new Float32Array();\n        /** Rotation (relative to parent) */\n        rot: Float32Array = new Float32Array();\n        /** Scale (relative to parent) */\n        scl: Float32Array = new Float32Array();\n        /** Position (relative to rest pose) */\n        rel_pos: Float32Array = new Float32Array();\n        /** Rotation (relative to rest pose) */\n        rel_rot: Float32Array = new Float32Array();\n        /** Scale (relative to rest pose) */\n        rel_scl: Float32Array = new Float32Array();\n\n        constructor() {\n        }\n    }\n\n    function logStatistics(name: string, stat: Statistics, precision: number, context: Context): void {\n        context.log.write(name + \": \"\n            + stat.mean().toFixed(precision)\n            + \" (\"\n            + \"min: \" + stat.min().toFixed(precision)\n            + \", \"\n            + \"med: \" + stat.median().toFixed(precision)\n            + \", \"\n            + \"max: \" + stat.max().toFixed(precision)\n            + \")\",\n            LogLevel.Debug);\n    };\n\n    export class AnimationData {\n        name: string;\n        duration: number = 0;\n        keyframes: number = 0;\n        fps: number = 0;\n        original_fps: number = 0;\n        tracks: AnimationDataTrack[];\n\n        constructor() {\n            this.name = \"\";\n            this.tracks = [];\n        }\n\n        static create(skeleton: Skeleton, animation: Animation, index_begin: number, index_end: number, fps: number, context: ConverterContext): AnimationData {\n            var result: AnimationData = new AnimationData();\n            result.name = animation.name;\n\n            var src_channels: AnimationChannel[] = animation.channels;\n\n            // Get timeline statistics\n            var stat: AnimationTimeStatistics = new AnimationTimeStatistics();\n            Animation.getTimeStatistics(animation, index_begin, index_end, stat, context);\n\n\n            logStatistics(\"Original Duration\", stat.duration, 3, context);\n            logStatistics(\"Original Time Start\", stat.beginTime, 3, context);\n            logStatistics(\"Original Time Stop\", stat.endTime, 3, context);\n            logStatistics(\"Original Keyframes\", stat.keyframes, 3, context);\n            logStatistics(\"Original FPS\", stat.fps, 3, context);\n\n            // Default fps if none give: median fps of source data\n            if (!fps) {\n                fps = stat.fps.median();\n            }\n            if (!fps || fps <= 0) {\n                context.log.write(\"Could not determine FPS for animation, skipping animation\", LogLevel.Warning);\n                return result;\n            }\n\n            // Duration (in seconds)\n            var start_time: number = stat.beginTime.min();\n            var end_time: number = stat.endTime.max();\n            var duration: number = end_time - start_time;\n\n            // Keyframes\n            var keyframes: number = Math.max(Math.floor(fps * duration + 1e-4) + 1, 2);\n            if (context.options.truncateResampledAnimations.value) {\n                // Truncate duration, so that FPS is consistent with \"keyframes/duration\"\n                duration = (keyframes - 1) / fps;\n            } else {\n                // Stretch FPS, so that FPS is consistent with \"keyframes/duration\"\n                fps = (keyframes - 1) / duration;\n            }\n            var spf: number = 1 / fps;\n\n            context.log.write(\"Resampled duration: \" + duration.toFixed(3), LogLevel.Debug);\n            context.log.write(\"Resampled keyframes: \" + keyframes.toFixed(3), LogLevel.Debug);\n            context.log.write(\"Resampled FPS: \" + fps.toFixed(3), LogLevel.Debug);\n\n            // Store fps\n            result.fps = +fps.toFixed(3);\n            result.keyframes = keyframes;\n            result.duration = duration;\n            result.original_fps = stat.fps.median();\n\n            if (!(fps > 0)) {\n                context.log.write(\"Invalid FPS: \" + fps + \", skipping animation\", LogLevel.Warning);\n                return result;\n            }\n            if (!(duration > 0)) {\n                context.log.write(\"Invalid duration: \" + duration + \", skipping animation\", LogLevel.Warning);\n                return result;\n            }\n            if (!(keyframes > 0)) {\n                context.log.write(\"Invalid number of keyframes: \" + keyframes + \", skipping animation\", LogLevel.Warning);\n                return result;\n            }\n\n            // Init result\n            for (var i: number = 0; i < skeleton.bones.length; ++i) {\n                var bone: Bone = skeleton.bones[i];\n                var track: AnimationDataTrack = new AnimationDataTrack();\n\n                track.pos = new Float32Array(keyframes * 3);\n                track.rot = new Float32Array(keyframes * 4);\n                track.scl = new Float32Array(keyframes * 3);\n\n                track.rel_pos = new Float32Array(keyframes * 3);\n                track.rel_rot = new Float32Array(keyframes * 4);\n                track.rel_scl = new Float32Array(keyframes * 3);\n\n                result.tracks.push(track);\n            }\n            var result_tracks: AnimationDataTrack[] = result.tracks;\n\n            // Reset the bone poses\n            for (var i: number = 0; i < skeleton.bones.length; ++i) {\n                var bone: Bone = skeleton.bones[i];\n                bone.node.resetAnimation();\n            }\n\n            // Process all keyframes\n            var pos = new BABYLON.Vector3();\n            var rot = new BABYLON.Quaternion();\n            var scl = new BABYLON.Vector3();\n            for (var k: number = 0; k < keyframes; ++k) {\n                var time: number = start_time + k * spf;\n\n                // Apply all channels to the scene nodes\n                // This might be expensive as it resamples the animation\n                for (var c: number = 0; c < src_channels.length; ++c) {\n                    var channel: AnimationChannel = src_channels[c];\n                    if (channel) {\n                        channel.target.applyAnimation(channel, time, context);\n                    }\n                }\n\n                // Extract bone poses\n                for (var b: number = 0; b < skeleton.bones.length; ++b) {\n                    var bone: Bone = skeleton.bones[b];\n                    var track: AnimationDataTrack = result_tracks[b];\n\n                    var mat: BABYLON.Matrix = bone.node.getLocalMatrix(context);\n                    mat.decompose(scl, rot, pos);\n                    \n                    if (track.pos !== null) {\n                        track.pos[k * 3 + 0] = pos.x;\n                        track.pos[k * 3 + 1] = pos.y;\n                        track.pos[k * 3 + 2] = pos.z;\n                    }\n                    if (track.rot !== null) {\n                        track.rot[k * 4 + 0] = rot.x;\n                        track.rot[k * 4 + 1] = rot.y;\n                        track.rot[k * 4 + 2] = rot.z;\n                        track.rot[k * 4 + 3] = rot.w;\n                    }\n                    if (track.scl !== null) {\n                        track.scl[k * 3 + 0] = scl.x;\n                        track.scl[k * 3 + 1] = scl.y;\n                        track.scl[k * 3 + 2] = scl.z;\n                    }\n                }\n            }\n\n            // Reset the bone poses\n            for (var i: number = 0; i < skeleton.bones.length; ++i) {\n                var bone: Bone = skeleton.bones[i];\n                bone.node.resetAnimation();\n            }\n\n            // Remove unnecessary tracks\n            var output_relative: boolean = false;\n            var pos0 = new BABYLON.Vector3()\n            var inv_pos0 = new BABYLON.Vector3()\n            var rot0 = new BABYLON.Quaternion();\n            var inv_rot0 = new BABYLON.Quaternion();\n            var scl0 = new BABYLON.Vector3()\n            var inv_scl0 = new BABYLON.Vector3()\n            for (var b: number = 0; b < skeleton.bones.length; ++b) {\n                var bone: Bone = skeleton.bones[b];\n                var track: AnimationDataTrack = result_tracks[b];\n\n                // Get rest pose transformation of the current bone\n                var mat0 = bone.node.getLocalMatrix(context);\n                mat0.decompose(scl0, rot0, pos0);\n\n                inv_rot0 = rot0.invert();\n                inv_pos0 = pos0.negate();\n\n                inv_scl0.set(1 / scl0.x, 1 / scl0.y, 1 / scl0.z);\n\n                // Check whether there are any changes to the rest pose\n                var pos_change: number = 0;\n                var rot_change: number = 0;\n                var scl_change: number = 0;\n                var max_pos_change: number = 0; // max length\n                var max_rot_change: number = 0; // max rotation angle (in radians)\n                var max_scl_change: number = 0; // max scale along any axis\n\n                for (var k: number = 0; k < keyframes; ++k) {\n\n                    // Relative position\n                    pos.x = track.pos[k * 3 + 0];\n                    pos.y = track.pos[k * 3 + 1];\n                    pos.z = track.pos[k * 3 + 2];\n                    pos.addInPlace(inv_pos0);\n                    pos_change = pos.length();\n                    max_pos_change = Math.max(max_pos_change, pos_change);\n\n                    // Relative rotation\n                    rot.x = track.rot[k * 4 + 0];\n                    rot.y = track.rot[k * 4 + 1];\n                    rot.z = track.rot[k * 4 + 2];\n                    rot.w = track.rot[k * 4 + 3];\n                    rot.multiply(inv_rot0);\n                    rot_change = 2 * Math.acos(Math.min(Math.max(rot.w, -1), 1));\n                    max_rot_change = Math.max(max_rot_change, rot_change);\n\n                    // Relative scale\n                    scl.x = track.scl[k * 3 + 0];\n                    scl.y = track.scl[k * 3 + 1];\n                    scl.z = track.scl[k * 3 + 2];\n                    scl.multiplyInPlace(inv_scl0);\n                    scl_change = Math.max(Math.abs(1 - scl.x), Math.abs(1 - scl.y), Math.abs(1 - scl.z));\n                    max_scl_change = Math.max(max_scl_change, scl_change);\n\n                    // Store relative transformations\n                    track.rel_pos[k * 3 + 0] = pos.x;\n                    track.rel_pos[k * 3 + 1] = pos.y;\n                    track.rel_pos[k * 3 + 2] = pos.z;\n\n                    track.rel_scl[k * 3 + 0] = scl.x;\n                    track.rel_scl[k * 3 + 1] = scl.y;\n                    track.rel_scl[k * 3 + 2] = scl.z;\n\n                    track.rel_rot[k * 4 + 0] = rot.x;\n                    track.rel_rot[k * 4 + 1] = rot.y;\n                    track.rel_rot[k * 4 + 2] = rot.z;\n                    track.rel_rot[k * 4 + 3] = rot.w;\n                }\n\n                // Delete tracks that do not contain any animation\n                if (context.options.removeConstAnimationTracks.value === true) {\n                    // TODO: This needs better tolerances.\n                    // TODO: Maybe use relative instead of absolute tolerances?\n                    // TODO: For COLLADA files that use matrix animations, the decomposition will have low precision\n                    // TODO: and scale will have an absolute error of >1e-2 even if the scale never changes in the original modelling application.\n                    var tol_pos: number = 1e-4;\n                    var tol_rot: number = 0.05; // 0.05 radians (2.86 degrees) rotation\n                    var tol_scl: number = 0.5; // 5% scaling\n                    if (max_pos_change < tol_pos) {\n                        track.pos = new Float32Array();\n                        track.rel_pos = new Float32Array();\n                    }\n                    if (max_rot_change < tol_rot) {\n                        track.rot = new Float32Array();\n                        track.rel_rot = new Float32Array();\n                    }\n                    if (max_scl_change < tol_scl) {\n                        track.scl = new Float32Array();\n                        track.rel_scl = new Float32Array();\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        static createFromLabels(skeleton: Skeleton, animation: Animation,\n            labels: AnimationLabel[], defaultFps: number, context: ConverterContext): AnimationData[]{\n\n            if (!skeleton) {\n                context.log.write(\"No skeleton present, no animation data generated.\", LogLevel.Warning);\n                return [];\n            }\n\n            var result: AnimationData[] = [];\n\n            for (var i: number = 0; i < labels.length; ++i) {\n                var label: AnimationLabel = labels[i];\n                var data: AnimationData = AnimationData.create(skeleton, animation, label.begin, label.end, label.fps || defaultFps, context);\n                if (data !== null) {\n                    data.name = label.name;\n                    result.push(data);\n                }\n            }\n\n            return result;\n        }\n    }\n","import {Log, LogLevel} from \"../log\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Material} from \"./material\"\nimport * as LoaderMaterial from \"../loader/material\"\nimport {Texture} from \"./texture\"\nimport {AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport {Options} from \"./options\"\nimport { EElement } from \"../loader/element\"\nimport { VisualSceneNode } from \"../loader/visual_scene_node\"\nimport { Node } from \"../converter/node\"\nimport { Image } from \"../loader/image\"\n\n/**\n    * A map that maps various COLLADA objects to converter objects\n    * \n    * The converter does not store direct references to COLLADA objects,\n    * so that the old COLLADA document can be garbage collected.\n    */\n    export class ObjectMap<ColladaType, ConverterType> {\n        collada: ColladaType[];\n        converter: ConverterType[];\n\n        constructor() {\n            this.collada = [];\n            this.converter = [];\n        }\n\n        register(collada: ColladaType, converter: ConverterType) {\n            this.collada.push(collada);\n            this.converter.push(converter);\n        }\n\n        findConverter(collada: ColladaType): ConverterType {\n            for (var i: number = 0; i < this.collada.length; ++i) {\n                if (this.collada[i] === collada) return this.converter[i];\n            }\n            return null;\n        }\n\n        findCollada(converter: ConverterType): ColladaType {\n            for (var i: number = 0; i < this.collada.length; ++i) {\n                if (this.converter[i] === converter) return this.collada[i];\n            }\n            return null;\n        }\n    }\n\n    export class ConverterContext extends COLLADAContext.Context {\n        materials: ObjectMap<LoaderMaterial.Material, Material>;\n        textures: ObjectMap<Image, Texture>;\n        nodes: ObjectMap<VisualSceneNode, Node>;\n        animationTargets: ObjectMap<EElement, AnimationTarget>;\n        log: Log;\n        options: Options;\n        messageCount: { [name: string]: number };\n\n        constructor(log: Log, options: Options) {\n            super(log);\n            this.log = log;\n            this.options = options;\n            this.materials = new ObjectMap<LoaderMaterial.Material, Material>();\n            this.textures = new ObjectMap<Image, Texture>();\n            this.nodes = new ObjectMap<VisualSceneNode, Node>();\n            this.animationTargets = new ObjectMap<EElement, AnimationTarget>();\n            this.messageCount = {};\n        }\n    }\n","import {Log, LogLevel} from \"../log\"\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Bone} from \"./bone\"\nimport {AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport {Options} from \"./options\"\nimport {BoundingBox} from \"./bounding_box\"\nimport { ColorOrTexture } from \"../loader/color_or_texture\"\nimport { EffectParam } from \"../loader/effect_param\"\nimport { EffectSampler } from \"../loader/effect_sampler\"\nimport { EffectSurface } from \"../loader/effect_surface\"\nimport { ConverterContext } from \"./context\"\nimport {Image} from \"../loader/image\"\n\nexport class Texture {\n        id: string;\n        url: string;\n\n        constructor(img: Image) {\n            this.id = img.id;\n            this.url = \"\";\n        }\n\n        static createTexture(colorOrTexture: ColorOrTexture, context: ConverterContext): Texture {\n            if (!colorOrTexture || !colorOrTexture.textureSampler) {\n                return null;\n            }\n            var textureSamplerParam: EffectParam = EffectParam.fromLink(colorOrTexture.textureSampler, context);\n            if (!textureSamplerParam) {\n                context.log.write(\"Texture sampler not found, texture will be missing\", LogLevel.Warning);\n                return null;\n            }\n            var textureSampler: EffectSampler = textureSamplerParam.sampler;\n            if (!textureSampler) {\n                context.log.write(\"Texture sampler param has no sampler, texture will be missing\", LogLevel.Warning);\n                return null;\n            }\n            var textureImage: Image = null;\n            if (textureSampler.image != null) {\n                // Collada 1.5 path: texture -> sampler -> image\n                textureImage = Image.fromLink(textureSampler.image, context);\n                if (!textureImage) {\n                    context.log.write(\"Texture image not found, texture will be missing\", LogLevel.Warning);\n                    return null;\n                }\n            } else if (textureSampler.surface != null) {\n                // Collada 1.4 path: texture -> sampler -> surface -> image\n                var textureSurfaceParam: EffectParam = EffectParam.fromLink(textureSampler.surface, context);\n                if (!textureSurfaceParam) {\n                    context.log.write(\"Texture surface not found, texture will be missing\", LogLevel.Warning);\n                    return null;\n                }\n                var textureSurface: EffectSurface = textureSurfaceParam.surface;\n                if (!textureSurface) {\n                    context.log.write(\"Texture surface param has no surface, texture will be missing\", LogLevel.Warning);\n                    return null;\n                }\n                textureImage = Image.fromLink(textureSurface.initFrom, context);\n                if (!textureImage) {\n                    context.log.write(\"Texture image not found, texture will be missing\", LogLevel.Warning);\n                    return null;\n                }\n            }\n\n            var result: Texture = context.textures.findConverter(textureImage);\n            if (result) return result;\n\n            result = new Texture(textureImage);\n            result.url = textureImage.initFrom;\n            if (context.options.removeTexturePath.value === true) {\n                result.url = result.url.replace(/^.*[\\\\\\/]/, '');\n            }\n            context.textures.register(textureImage, result);\n\n            return result;\n        }\n    }\n","import {Log, LogLevel} from \"../log\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Texture} from \"./texture\"\nimport {AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport {Options} from \"./options\"\nimport {BoundingBox} from \"./bounding_box\"\nimport { Effect } from \"../loader/effect\"\nimport { EffectTechnique } from \"../loader/effect_technique\"\nimport { InstanceMaterial } from \"../loader/instance_material\"\nimport { ConverterContext } from \"./context\"\nimport * as MaterialLoader from \"../loader/material\"\n\n    export class MaterialMap {\n        symbols: { [symbol: string]: Material };\n\n        constructor() {\n            this.symbols = {};\n        }\n    }\n\n    export class Material {\n        name: string;\n        diffuse: Texture;\n        specular: Texture;\n        normal: Texture;\n\n        diffuseColor: number[] | undefined;\n        specularColor: number[] | undefined;\n        emissiveColor: number[] | undefined;\n\n        constructor() {\n            this.name = null;\n            this.diffuse = null;\n            this.specular = null;\n            this.normal = null;\n            this.diffuseColor = null;\n            this.specularColor = null;\n            this.emissiveColor = null;\n        }\n\n        static createDefaultMaterial(context: ConverterContext): Material {\n            var result: Material = context.materials.findConverter(null);\n            if (result) {\n                return result;\n            } else {\n                result = new Material();\n                context.materials.register(undefined, result);\n                return result;\n            }\n        }\n\n        static createMaterial(instanceMaterial: InstanceMaterial, context: ConverterContext): Material {\n\n            var material = MaterialLoader.Material.fromLink(instanceMaterial.material, context);\n            if (!material) {\n                context.log.write(\"Material not found, material skipped.\", LogLevel.Warning);\n                return Material.createDefaultMaterial(context);\n            }\n\n            var effect: Effect = Effect.fromLink(material.effect, context);\n            if (!effect) {\n                context.log.write(\"Material effect not found, using default material\", LogLevel.Warning);\n                return Material.createDefaultMaterial(context);\n            }\n\n            var technique: EffectTechnique = effect.technique;\n            if (!technique) {\n                context.log.write(\"Material effect not found, using default material\", LogLevel.Warning);\n                return Material.createDefaultMaterial(context);\n            }\n\n            var result: Material = context.materials.findConverter(material);\n            if (result) return result;\n\n            result = new Material();\n            result.name = material.id;\n            if (technique.diffuse != undefined && technique.diffuse.color != undefined) {\n                // convert Float32Array to number[]\n                result.diffuseColor = Array.prototype.slice.call(technique.diffuse.color);\n            } else {\n                result.diffuse = Texture.createTexture(technique.diffuse, context);\n\n            }\n\n            if (technique.specular != undefined && technique.specular.color != undefined) {\n                result.specularColor = Array.prototype.slice.call(technique.specular.color);\n            } else {\n                result.specular = Texture.createTexture(technique.specular, context);\n            }\n\n            if (technique.emission != undefined && technique.emission.color != undefined) {\n                result.emissiveColor = Array.prototype.slice.call(technique.emission.color);\n            }\n\n\n            result.normal = Texture.createTexture(technique.bump, context);\n            context.materials.register(material, result);\n\n            return result;\n        }\n\n        static getMaterialMap(instanceMaterials: InstanceMaterial[], context: ConverterContext): MaterialMap {\n            var result: MaterialMap = new MaterialMap();\n\n            var numMaterials: number = 0;\n            for (var i: number = 0; i < instanceMaterials.length; i++) {\n                var instanceMaterial: InstanceMaterial = instanceMaterials[i];\n\n                var symbol: string = instanceMaterial.symbol;\n                if (!symbol) {\n                    context.log.write(\"Material instance has no symbol, material skipped.\", LogLevel.Warning);\n                    continue;\n                }\n\n                if (result.symbols[symbol] != null) {\n                    context.log.write(\"Material symbol \" + symbol + \" used multiple times\", LogLevel.Error);\n                    continue;\n                }\n\n                result.symbols[symbol] = Material.createMaterial(instanceMaterial, context);\n            }\n            return result;\n        }\n    }\n","import * as BABYLON from 'babylonjs';\n/// <reference path=\"../math.ts\" />\n\n    export class BoundingBox {\n        public min: BABYLON.Vector3 = new BABYLON.Vector3();\n        public max: BABYLON.Vector3 = new BABYLON.Vector3();\n\n        constructor() {\n            this.reset();\n        }\n\n        reset() {\n            this.min.set(Infinity, Infinity, Infinity);\n            this.max.set(-Infinity, -Infinity, -Infinity);\n        }\n\n        fromPositions(p: Float32Array, offset: number, count: number) {\n            this.reset();\n            for (var i: number = 0; i < count; ++i) {\n                    var value = p[(offset + i) * 3 + 0];\n                    this.min.x = Math.min(this.min.x, value);\n                    this.max.x = Math.max(this.max.x, value);\n\n                    value = p[(offset + i) * 3 + 1];\n                    this.min.y = Math.min(this.min.y, value);\n                    this.max.y = Math.max(this.max.y, value);\n\n                    value = p[(offset + i) * 3 + 2];\n                    this.min.z = Math.min(this.min.z, value);\n                    this.max.z = Math.max(this.max.z, value);\n                }\n        }\n\n        extend(p: BABYLON.Vector3) {\n            this.min.x = Math.min(this.min.x, p.x);\n            this.max.x = Math.max(this.max.x, p.x);\n\n            this.min.y = Math.min(this.min.y, p.y);\n            this.max.y = Math.max(this.max.y, p.y);\n\n            this.min.z = Math.min(this.min.z, p.z);\n            this.max.z = Math.max(this.max.z, p.z);\n        }\n\n        extendBox(b: BoundingBox) {\n            this.extend(b.max);\n            this.extend(b.min);\n        }\n    }\n","import {Log, LogLevel} from \"../log\"\n\nimport * as SourceLoader from \"../loader/source\"\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Material} from \"./material\"\nimport {Texture} from \"./texture\"\nimport {AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport {Options} from \"./options\"\nimport {BoundingBox} from \"./bounding_box\"\nimport * as BABYLON from 'babylonjs';\nimport { Input } from \"../loader/input\"\nimport { Triangles } from \"../loader/triangles\"\nimport { Vertices } from \"../loader/vertices\"\nimport * as LoaderGeometry from \"../loader/geometry\"\nimport { ConverterContext } from \"./context\"\n\n    export class GeometryData {\n        indices: Uint32Array = new Uint32Array();\n        position: Float32Array = new Float32Array();\n        normal: Float32Array = new Float32Array();\n        texcoord: Float32Array = new Float32Array();\n        boneweight: Float32Array = new Float32Array();\n        boneindex: Uint8Array = new Uint8Array();\n    }\n\n    export class GeometryChunkSourceIndices {\n        /** Original indices, contained in <triangles>/<p> */\n        indices: Uint32Array = new Uint32Array();\n        /** The stride of the original indices (number of independent indices per vertex) */\n        indexStride: number = 0;\n        /** The offset of the main (position) index in the original vertices */\n        indexOffset: number = 0;\n    }\n\n    export class GeometryChunk {\n        public name: string = \"\";\n        /** Number of elements in the vertex buffer (i.e., number of unique vertices) */\n        public vertexCount: number = 0;\n        /** Number of triangles */\n        public triangleCount: number = 0;\n        /** Vertices for this chunk start at data.vertices[vertexBufferOffset] */\n        public vertexBufferOffset: number = 0;\n        /** Indices for this chunk start at data.indices[indexBufferOffset] */\n        public indexBufferOffset: number = 0;\n        /** Geometry data buffer */\n        public data: GeometryData = new GeometryData();\n        public material: Material = new Material();\n        public boundingBox: BoundingBox= new BoundingBox();;\n        /** Bind shape matrix (skinned geometry only) */\n        public bindShapeMatrix: BABYLON.Matrix = new BABYLON.Matrix();\n        /** Backup of the original COLLADA indices, for internal use only */\n        public _colladaIndices: GeometryChunkSourceIndices = new GeometryChunkSourceIndices();\n\n        /**\n        * Creates a geometry chunk with its own geometry data buffers.\n        *\n        * This de-indexes the COLLADA data, so that it is usable by GPUs.\n        */\n        static createChunk(geometry: LoaderGeometry.Geometry, triangles: Triangles, context: ConverterContext): GeometryChunk | undefined{\n            if (!triangles?.inputs) {\n                return undefined;\n            }\n\n            // Per-triangle data input\n            var inputTriVertices: Input | undefined;\n            var inputTriNormal: Input | undefined;\n            var inputTriColor: Input | undefined;\n            var inputTriTexcoord: Input[] = [];\n            for (var i: number = 0; i < triangles.inputs.length; i++) {\n                var input: Input = triangles.inputs[i];\n                switch (input.semantic) {\n                    case \"VERTEX\":\n                        inputTriVertices = input;\n                        break;\n                    case \"NORMAL\":\n                        inputTriNormal = input;\n                        break;\n                    case \"COLOR\":\n                        inputTriColor = input;\n                        break;\n                    case \"TEXCOORD\":\n                        inputTriTexcoord.push(input);\n                        break;\n                    default:\n                        context.log.write(\"Unknown triangles input semantic \" + input.semantic + \" ignored\", LogLevel.Warning);\n                }\n            }\n\n            if (!inputTriVertices || !inputTriVertices.source) {\n                return undefined;\n            }\n\n            // Per-triangle data source\n            var srcTriVertices = Vertices.fromLink(inputTriVertices.source, context);\n            if (!srcTriVertices) {\n                context.log.write(\"Geometry \" + geometry.id + \" has no vertices, geometry ignored\", LogLevel.Warning);\n                return undefined;\n            }\n            var srcTriNormal = SourceLoader.Source.fromLink(inputTriNormal != null ? inputTriNormal.source : undefined, context);\n            var srcTriColor = SourceLoader.Source.fromLink(inputTriColor != null ? inputTriColor.source : undefined, context);\n            var srcTriTexcoord = inputTriTexcoord.map((x: Input) => SourceLoader.Source.fromLink(x != null ? x.source : undefined, context));\n\n            // Per-vertex data input\n            var inputVertPos = null;\n            var inputVertNormal = null;\n            var inputVertColor = null;\n            var inputVertTexcoord: Input[] = [];\n            for (var i: number = 0; i < srcTriVertices.inputs.length; i++) {\n                var input: Input = srcTriVertices.inputs[i];\n                switch (input.semantic) {\n                    case \"POSITION\":\n                        inputVertPos = input;\n                        break;\n                    case \"NORMAL\":\n                        inputVertNormal = input;\n                        break;\n                    case \"COLOR\":\n                        inputVertColor = input;\n                        break;\n                    case \"TEXCOORD\":\n                        inputVertTexcoord.push(input);\n                        break;\n                    default:\n                        context.log.write(\"Unknown vertices input semantic \" + input.semantic + \" ignored\", LogLevel.Warning);\n                }\n            }\n\n            if (!inputVertPos || !inputVertPos.source) {\n                return undefined;\n            }\n\n            // Per-vertex data source\n            var srcVertPos = SourceLoader.Source.fromLink(inputVertPos.source, context);\n            if (!srcVertPos) {\n                context.log.write(\"Geometry \" + geometry.id + \" has no vertex positions, geometry ignored\", LogLevel.Warning);\n                return undefined;\n            }\n            var srcVertNormal = SourceLoader.Source.fromLink(inputVertNormal != null ? inputVertNormal.source : undefined, context);\n            var srcVertColor = SourceLoader.Source.fromLink(inputVertColor != null ? inputVertColor.source : undefined, context);\n            var srcVertTexcoord = inputVertTexcoord.map((x: Input) => SourceLoader.Source.fromLink(x != null ? x.source : undefined, context));\n\n            // Raw data\n            var dataVertPos: Float32Array = Utils.createFloatArray(srcVertPos, \"vertex position\", 3, context);\n            var dataVertNormal: Float32Array = Utils.createFloatArray(srcVertNormal, \"vertex normal\", 3, context);\n            var dataTriNormal: Float32Array = Utils.createFloatArray(srcTriNormal, \"vertex normal (indexed)\", 3, context);\n            var dataVertColor: Float32Array = Utils.createFloatArray(srcVertColor, \"vertex color\", 4, context);\n            var dataTriColor: Float32Array = Utils.createFloatArray(srcTriColor, \"vertex color (indexed)\", 4, context);\n            var dataVertTexcoord: Float32Array[] = srcVertTexcoord.map((x) => Utils.createFloatArray(x, \"texture coordinate\", 2, context));\n            var dataTriTexcoord: Float32Array[] = srcTriTexcoord.map((x) => Utils.createFloatArray(x, \"texture coordinate (indexed)\", 2, context));\n\n            // Make sure the geometry only contains triangles\n            if (triangles.type !== \"triangles\") {\n                var vcount = triangles.vcount;\n                if (vcount) {\n                    for (var i: number = 0; i < vcount.length; i++) {\n                        var c: number = vcount[i];\n                        if (c !== 3) {\n                            context.log.write(\"Geometry \" + geometry.id + \" has non-triangle polygons, geometry ignored.\", LogLevel.Warning);\n                            return undefined;\n                        }\n                    }\n                } else {\n                    context.log.write(\"Geometry \" + geometry.id + \" has polygons with an unknown number of vertices per polygon. Assuming all triangles.\", LogLevel.Warning);\n                }\n            }\n\n            // Security checks\n            if (srcVertPos.stride !== 3) {\n                context.log.write(\"Geometry \" + geometry.id + \" vertex positions are not 3D vectors, geometry ignored\", LogLevel.Warning);\n                return undefined;\n            }\n\n            // Extract indices used by this chunk\n            var colladaIndices = triangles.indices;\n            var trianglesCount = triangles.count;\n            var triangleStride = colladaIndices.length / triangles.count;\n            var triangleVertexStride = triangleStride / 3;\n            var indices = Utils.compactIndices(colladaIndices, triangleVertexStride, inputTriVertices.offset);\n\n            if ((!indices) || (indices.length === 0)) {\n                context.log.write(\"Geometry \" + geometry.id + \" does not contain any indices, geometry ignored\", LogLevel.Error);\n                return undefined;\n            }\n\n            // The vertex count (size of the vertex buffer) is the number of unique indices in the index buffer\n            var vertexCount: number = Utils.maxIndex(indices) + 1;\n            var triangleCount: number = indices.length / 3;\n\n            if (triangleCount !== trianglesCount) {\n                context.log.write(\"Geometry \" + geometry.id + \" has an inconsistent number of indices, geometry ignored\", LogLevel.Error);\n                return undefined;\n            }\n\n            // Position buffer\n            var position = new Float32Array(vertexCount * 3);\n            var indexOffsetPosition: number = inputTriVertices.offset;\n            Utils.reIndex(dataVertPos, colladaIndices, triangleVertexStride, indexOffsetPosition, 3, position, indices, 1, 0, 3);\n\n            // Normal buffer\n            var normal = new Float32Array(vertexCount * 3);\n            var indexOffsetNormal = inputTriNormal !== null ? inputTriNormal?.offset : null;\n            if (dataVertNormal !== null) {\n                Utils.reIndex(dataVertNormal, colladaIndices, triangleVertexStride, indexOffsetPosition, 3, normal, indices, 1, 0, 3);\n            } else if (dataTriNormal !== null) {\n                Utils.reIndex(dataTriNormal, colladaIndices, triangleVertexStride, indexOffsetNormal, 3, normal, indices, 1, 0, 3);\n            } else {\n                context.log.write(\"Geometry \" + geometry.id + \" has no normal data, using zero vectors\", LogLevel.Warning);\n            }\n\n            // Texture coordinate buffer\n            var texcoord = new Float32Array(vertexCount * 2);\n            var indexOffsetTexcoord = inputTriTexcoord.length > 0 ? inputTriTexcoord[0].offset : null;\n            if (dataVertTexcoord.length > 0) {\n                Utils.reIndex(dataVertTexcoord[0], colladaIndices, triangleVertexStride, indexOffsetPosition, 2, texcoord, indices, 1, 0, 2);\n            } else if (dataTriTexcoord.length > 0) {\n                Utils.reIndex(dataTriTexcoord[0], colladaIndices, triangleVertexStride, indexOffsetTexcoord, 2, texcoord, indices, 1, 0, 2);\n            } else {\n                context.log.write(\"Geometry \" + geometry.id + \" has no texture coordinate data, using zero vectors\", LogLevel.Warning);\n            }\n\n            // Geometry data buffers\n            var geometryData: GeometryData = new GeometryData();\n            geometryData.indices = indices;\n            geometryData.position = position;\n            geometryData.normal = normal;\n            geometryData.texcoord = texcoord;\n\n            // Backup of the original COLLADA indices\n            var sourceIndices: GeometryChunkSourceIndices = new GeometryChunkSourceIndices();\n            sourceIndices.indices = colladaIndices;\n            sourceIndices.indexStride = triangleVertexStride;\n            sourceIndices.indexOffset = indexOffsetPosition;\n\n            // Geometry chunk\n            var result: GeometryChunk = new GeometryChunk();\n            result.vertexCount = vertexCount;\n            result.vertexBufferOffset = 0;\n            result.triangleCount = triangleCount;\n            result.indexBufferOffset = 0;\n            result.data = geometryData;\n            result._colladaIndices = sourceIndices; \n\n            return result;\n        }\n\n        /**\n        * Computes the bounding box of the static (unskinned) geometry\n        */\n        static computeBoundingBox(chunk: GeometryChunk, context: ConverterContext) {\n            chunk.boundingBox.fromPositions(chunk.data.position, chunk.vertexBufferOffset, chunk.vertexCount);\n        }\n\n\n        static transformEachVector(position: Float32Array, transform: BABYLON.Matrix) {\n            let vec = new BABYLON.Vector3();\n            for (let i = 0; i < position.length; i += 3) {\n                vec.set(position[i], position[i + 1], position[i + 2]);\n\n                BABYLON.Vector3.TransformCoordinates(vec, transform);\n\n                position[i] = vec.x;\n                position[i + 1] = vec.y;\n                position[i + 2] = vec.z;\n            }\n        }\n\n        /**\n        * Transforms the positions and normals of the given Chunk by the given matrices\n        */\n        static transformChunk(chunk: GeometryChunk, positionMatrix: BABYLON.Matrix, normalMatrix: BABYLON.Matrix, context: ConverterContext) {\n            var position: Float32Array = chunk.data.position;\n            if (position !== null) {\n                GeometryChunk.transformEachVector(position, positionMatrix);\n            }\n\n            var normal: Float32Array = chunk.data.normal;\n            if (normal !== null) {\n                GeometryChunk.transformEachVector(normal, normalMatrix);\n            }\n        }\n\n        /**\n        * Scales the positions of the given Chunk\n        */\n        static scaleChunk(chunk: GeometryChunk, scale: number, context: ConverterContext) {\n            var position: Float32Array = chunk.data.position;\n            if (position !== null) {\n                for (var i = 0; i < position.length; ++i) {\n                    position[i] = position[i] * scale;\n                }\n            }\n        }\n\n\n        /**\n        * Merges the geometric data from all the chunks into a single set of buffers.\n        * The old buffers of the chunks are discarded and replaced by the new (bigger) buffers.\n        * Each chunk then uses the same buffers, but uses a different portion of the buffers, according to the triangleCount and triangleOffset.\n        * A single new chunk containing all the geometry is returned.\n        */\n        static mergeChunkData(chunks: GeometryChunk[], context: ConverterContext) {\n\n            if (chunks.length < 2) {\n                return;\n            }\n\n            // Count number of data elements\n            var vertexCount = 0;\n            var triangleCount = 0;\n\n            var has_position: boolean = (chunks.length > 0);\n            var has_normal: boolean = (chunks.length > 0);\n            var has_texcoord: boolean = (chunks.length > 0);\n            var has_boneweight: boolean = (chunks.length > 0);\n            var has_boneindex: boolean = (chunks.length > 0);\n            for (var i: number = 0; i < chunks.length; ++i) {\n                var chunk: GeometryChunk = chunks[i];\n                var chunkData: GeometryData = chunk.data;\n\n                vertexCount += chunk.vertexCount;\n                triangleCount += chunk.triangleCount;\n\n                has_position = has_position && (chunkData.position !== null);\n                has_normal = has_normal && (chunkData.normal !== null);\n                has_texcoord = has_texcoord && (chunkData.texcoord !== null);\n                has_boneweight = has_boneweight && (chunkData.boneweight !== null);\n                has_boneindex = has_boneindex && (chunkData.boneindex !== null);\n            }\n\n            // Create data buffers\n            var resultData = new GeometryData();\n            resultData.indices = new Uint32Array(triangleCount * 3);\n            if (has_position) {\n                resultData.position = new Float32Array(vertexCount * 3);\n            }\n            if (has_normal) {\n                resultData.normal = new Float32Array(vertexCount * 3);\n            }\n            if (has_texcoord) {\n                resultData.texcoord = new Float32Array(vertexCount * 2);\n            }\n            if (has_boneindex) {\n                resultData.boneindex = new Uint8Array(vertexCount * 4);\n            }\n            if (has_boneweight) {\n                resultData.boneweight = new Float32Array(vertexCount * 4);\n            }\n\n            // Copy data\n            var indexBufferOffset: number = 0;\n            var vertexBufferOffset: number = 0;\n            for (var i: number = 0; i < chunks.length; ++i) {\n                var chunk: GeometryChunk = chunks[i];\n                var chunkData: GeometryData = chunk.data;\n\n                // Copy index data\n                for (var j: number = 0; j < chunk.triangleCount * 3; ++j) {\n                    resultData.indices[indexBufferOffset + j] = chunkData.indices[j + chunk.indexBufferOffset] + vertexBufferOffset;\n                }\n\n                // Copy vertex data\n                if (has_position) {\n                    MathUtils.copyNumberArrayOffset(chunkData.position, chunk.vertexBufferOffset * 3, resultData.position, vertexBufferOffset * 3,\n                        chunk.vertexCount * 3);\n                }\n                if (has_normal) {\n                    MathUtils.copyNumberArrayOffset(chunkData.normal, chunk.vertexBufferOffset * 3, resultData.normal, vertexBufferOffset * 3,\n                        chunk.vertexCount * 3);\n                }\n                if (has_texcoord) {\n                    MathUtils.copyNumberArrayOffset(chunkData.texcoord, chunk.vertexBufferOffset * 2, resultData.texcoord, vertexBufferOffset * 2,\n                        chunk.vertexCount * 2);\n                }\n                if (has_boneweight) {\n                    MathUtils.copyNumberArrayOffset(chunkData.boneweight, chunk.vertexBufferOffset * 4, resultData.boneweight, vertexBufferOffset * 4,\n                        chunk.vertexCount * 4);\n                }\n                if (has_boneindex) {\n                    MathUtils.copyNumberArrayOffset(chunkData.boneindex, chunk.vertexBufferOffset * 4, resultData.boneindex, vertexBufferOffset * 4,\n                        chunk.vertexCount * 4);\n                }\n\n                // Discard the original chunk data\n                chunk.data = resultData;\n                chunk.vertexBufferOffset = vertexBufferOffset;\n                chunk.indexBufferOffset = indexBufferOffset;\n\n                // Update offset\n                vertexBufferOffset += chunk.vertexCount;\n                indexBufferOffset += chunk.triangleCount * 3;\n            }\n\n        }\n\n    }\n\n","import {Context} from \"../context\"\nimport {LogLevel} from \"../log\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport * as BABYLON from 'babylonjs';\nimport {Node} from \"./node\"\nimport { EElement } from \"../loader/element\";\nimport { SidLink } from \"../loader/link\";\nimport { VisualSceneNode } from \"../loader/visual_scene_node\";\nimport { ConverterContext } from \"./context\";\n\n    export class Bone {\n        node: Node;\n        name: string;\n        parent: Bone | undefined;\n        invBindMatrix: BABYLON.Matrix = BABYLON.Matrix.Identity();\n        attachedToSkin: boolean;\n\n        constructor(node: Node) {\n            this.node = node;\n            this.name = node.name || \"\";\n            this.attachedToSkin = false;\n        }\n\n        clone(): Bone {\n            var result = new Bone(this.node);\n            result.name = this.name;\n            result.parent = this.parent;\n            result.invBindMatrix = this.invBindMatrix.clone();\n            result.attachedToSkin = this.attachedToSkin;\n            return result;\n        }\n\n        depth(): number {\n            return !this.parent ? 0 : (this.parent.depth() + 1);\n        }\n\n        static create(node: Node): Bone {\n            return new Bone(node);\n        }\n\n        /**\n        * Finds the visual scene node that is referenced by the joint SID.\n        * The skin element contains the skeleton root nodes.\n        */\n        static findBoneNode(boneSid: string, skeletonRootNodes: VisualSceneNode[], context: ConverterContext): VisualSceneNode | undefined {\n            // The spec is inconsistent here.\n            // The joint ids do not seem to be real scoped identifiers(chapter 3.3, \"COLLADA Target Addressing\"), since they lack the first part (the anchor id)\n            // The skin element(chapter 5, \"skin\" element) *implies* that the joint ids are scoped identifiers relative to the skeleton root node,\n            // so perform a SID-like breadth-first search.\n            var boneNode: EElement | undefined = undefined;\n            var warnings: string[] = [];\n            for (var i: number = 0; i < skeletonRootNodes.length; i++) {\n                var skeletonRoot: VisualSceneNode = skeletonRootNodes[i];\n                var sids: string[] = boneSid.split(\"/\");\n                var result = SidLink.findSidTarget(boneSid, skeletonRoot, sids, context);\n                if (result.result != null) {\n                    boneNode = result.result;\n                    break;\n                } else if (result.warning) {\n                    warnings.push(result.warning);\n                }\n            }\n            if (!boneNode) {\n                context.log.write(\"Joint with SID \" + boneSid + \" not found, joint ignored. Related warnings:\\n\" + warnings.join(\"\\n\"), LogLevel.Warning);\n                return undefined;\n            } else if (context.isInstanceOf(boneNode, \"VisualSceneNode\")) {\n                return <VisualSceneNode> boneNode;\n            } else {\n                context.log.write(\"Joint \" + boneSid + \" does not point to a visual scene node, joint ignored\", LogLevel.Warning);\n                return undefined;\n            }\n        }\n\n        static sameInvBindMatrix(a: Bone, b: Bone, tolerance: number): boolean {\n            if (!a || !b) {\n                return false;\n            }\n            for (var i = 0; i < 16; ++i) {\n                var ai = a.invBindMatrix.asArray()[i];\n                var bi = b.invBindMatrix.asArray()[i];\n                if (Math.abs(ai - bi) > tolerance) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n\n        /**\n        * Returns true if the two bones can safely be merged, i.e.,\n        * they reference the same scene graph node and have the same inverse bind matrix\n        */\n        static safeToMerge(a: Bone, b: Bone): boolean {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            if (a.node !== b.node) {\n                return false;\n            }\n            if (a.attachedToSkin && b.attachedToSkin && !Bone.sameInvBindMatrix(a, b, 1e-5)) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n        * Merges the two given bones. Returns null if they cannot be merged.\n        */\n        static mergeBone(a: Bone, b: Bone): Bone | undefined {\n            if (!Bone.safeToMerge(a, b)) {\n                return undefined;\n            }\n            if (a.attachedToSkin) {\n                return a.clone();\n            } else if (b.attachedToSkin) {\n                return b.clone();\n            } else {\n                return a.clone();\n            }\n        }\n\n    }\n","import {Context} from \"../context\"\nimport {Log, LogLevel} from \"../log\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Bone} from \"./bone\"\nimport {Node} from \"./node\"\nimport {Texture} from \"./texture\"\nimport {AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport {Options} from \"./options\"\nimport {BoundingBox} from \"./bounding_box\"\nimport * as BABYLON from 'babylonjs';\nimport { Link } from \"../loader/link\"\nimport { VisualSceneNode } from \"../loader/visual_scene_node\"\nimport { ConverterContext } from \"./context\"\n\n    export class Skeleton {\n        /** All bones */\n        bones: Bone[];\n\n        constructor(bones: Bone[]) {\n            this.bones = bones;\n        }\n\n        /**\n        * In the given list, finds a bone that can be merged with the given bone\n        */\n        static findBone(bones: Bone[], bone: Bone): Bone {\n            for (var i = 0; i < bones.length; ++i) {\n                if (Bone.safeToMerge(bones[i], bone)) {\n                    return bones[i];\n                }\n            }\n            return null;\n        }\n\n        /**\n        * Find the parent bone of the given bone\n        */\n        static findParent(bones: Bone[], bone: Bone): Bone {\n            if (!bone.parent) {\n                return null;\n            }\n            for (var i = 0; i < bones.length; ++i) {\n                if (bones[i].node === bone.parent.node) {\n                    return bones[i];\n                }\n            }\n            return null;\n        }\n\n        static checkConsistency(skeleton: Skeleton, context: Context): void {\n            if (!skeleton.bones) {\n                return;\n            }\n\n            skeleton.bones.forEach((b1, i1) => {\n                skeleton.bones.forEach((b2, i2) => {\n                    if (i1 !== i2 && Bone.safeToMerge(b1, b2)) {\n                        throw new Error(\"Duplicate bone\");\n                    }\n                });\n            });\n\n            skeleton.bones.forEach((b) => {\n                if (b.parent && !b.node.parent) {\n                    throw new Error(\"Missing parent\");\n                }\n            });\n\n            skeleton.bones.forEach((b) => {\n                if (b.parent && skeleton.bones.indexOf(b.parent) === -1) {\n                    throw new Error(\"Invalid parent\");\n                }\n            });\n        }\n\n        /**\n        * Creates a skeleton from a skin\n        */\n        static createFromSkin(jointSids: string[], skeletonRootNodes: VisualSceneNode[], bindShapeMatrix: BABYLON.Matrix,\n            invBindMatrices: Float32Array, context: ConverterContext): Skeleton {\n            var bones: Bone[] = [];\n\n            // Add all bones referenced by the skin\n            for (var i: number = 0; i < jointSids.length; i++) {\n                var jointSid: string = jointSids[i];\n                var jointNode = Bone.findBoneNode(jointSid, skeletonRootNodes, context);\n                if (!jointNode) {\n                    context.log.write(\"Joint \" + jointSid + \" not found for skeleton, no bones created\", LogLevel.Warning);\n                    return new Skeleton([]);\n                }\n                var converterNode = context.nodes.findConverter(jointNode);\n                if (!converterNode) {\n                    context.log.write(\"Joint \" + jointSid + \" not converted for skeleton, no bones created\", LogLevel.Warning);\n                    return new Skeleton([]);\n                }\n                var bone: Bone = Bone.create(converterNode);\n                bone.attachedToSkin = true;\n\n                MathUtils.mat4Extract(invBindMatrices, i, bone.invBindMatrix);\n                // Collada skinning equation: boneWeight*boneMatrix*invBindMatrix*bindShapeMatrix*vertexPos\n                // (see chapter 4: \"Skin Deformation (or Skinning) in COLLADA\")\n                // Here we could pre-multiply the inverse bind matrix and the bind shape matrix\n                // We do not pre-multiply the bind shape matrix, because the same bone could be bound to\n                // different meshes using different bind shape matrices and we would have to duplicate the bones\n                // mat4.multiply(bone.invBindMatrix, bone.invBindMatrix, bindShapeMatrix);\n                bones.push(bone);\n            }\n\n            var result = new Skeleton(bones);\n\n            // Add all missing bones of the skeleton\n            result = Skeleton.addBoneParents(result, context);\n\n            Skeleton.checkConsistency(result, context);\n            return result;\n        }\n\n        /**\n        * Creates a skeleton from a node\n        */\n        static createFromNode(node: Node, context: ConverterContext): Skeleton {\n            // Create a single node\n            var colladaNode: VisualSceneNode = context.nodes.findCollada(node);\n            var bone: Bone = Bone.create(node);\n            bone.invBindMatrix = BABYLON.Matrix.Identity()\n            bone.attachedToSkin = true;\n\n            var result = new Skeleton([bone]);\n\n            // Add all parent bones of the skeleton\n            result = Skeleton.addBoneParents(result, context);\n\n            Skeleton.checkConsistency(result, context);\n            return result;\n        }\n\n\n        static replaceBone(bones: Bone[], index: number, bone: Bone): Bone[]{\n            var result = bones.slice(0);\n            var oldBone = result[index];\n            result[index] = bone;\n            result.forEach((b) => {\n                if (b.parent === oldBone) {\n                    b.parent = bone;\n                }\n            });\n            return result;\n        }\n\n        /**\n        * Add a bone to the list of bones, merging bones where possible\n        */\n        static mergeBone(bones: Bone[], bone: Bone): Bone[]{\n            \n            for (var i = 0; i < bones.length; ++i) {\n                if (Bone.safeToMerge(bones[i], bone)) {\n                    var mergedBone = Bone.mergeBone(bones[i], bone);\n                    return Skeleton.replaceBone(bones, i, mergedBone);\n                }\n            }\n\n            // No merge possible\n            var result = bones.slice(0);\n            var newBone = bone.clone();\n            result.push(newBone);\n            newBone.parent = Skeleton.findParent(result, newBone);\n            return result;\n        }\n\n        /**\n        * Merges the two skeletons\n        */\n        static mergeSkeletons(skeleton1: Skeleton, skeleton2: Skeleton, context: Context): Skeleton {\n            var bones: Bone[] = [];\n            var skinBones: Bone[] = [];\n\n            // Add all bones from skeleton1\n            skeleton1.bones.forEach((b) => {\n                bones = Skeleton.mergeBone(bones, b);\n            });\n\n            // Add all bones from skeleton2 (if not already present)\n            skeleton2.bones.forEach((b) => {\n                bones = Skeleton.mergeBone(bones, b);\n            });\n\n            var result = new Skeleton(bones);\n\n            Skeleton.checkConsistency(result, context);\n            return result;\n        }\n\n        /**\n        * Assembles a list of skeleton root nodes\n        */\n        static getSkeletonRootNodes(skeletonLinks: Link[], context: ConverterContext): VisualSceneNode[] {\n            var skeletonRootNodes: VisualSceneNode[] = [];\n            for (var i: number = 0; i < skeletonLinks.length; i++) {\n                var skeletonLink: Link = skeletonLinks[i];\n                var skeletonRootNode: VisualSceneNode = VisualSceneNode.fromLink(skeletonLink, context);\n                if (!skeletonRootNode) {\n                    context.log.write(\"Skeleton root node \" + skeletonLink.getUrl() + \" not found, skeleton root ignored\", LogLevel.Warning);\n                    continue;\n                }\n                skeletonRootNodes.push(skeletonRootNode);\n            }\n\n            if (skeletonRootNodes.length === 0) {\n                context.log.write(\"Controller has no skeleton, using the whole scene as the skeleton root\", LogLevel.Warning);\n                skeletonRootNodes = context.nodes.collada.filter((node: VisualSceneNode) => (context.isInstanceOf(node.parent, \"VisualScene\")));\n            }\n\n            return skeletonRootNodes;\n        }\n\n        /**\n        * Find the parent for each bone\n        * The skeleton(s) may contain more bones than referenced by the skin\n        * This function also adds all bones that are not referenced but used for the skeleton transformation\n        */\n        static addBoneParents(skeleton: Skeleton, context: ConverterContext): Skeleton {\n            var bones = skeleton.bones.slice(0);\n\n            var i: number = 0;\n            // The bones array will grow during traversal, therefore the while loop\n            while (i < bones.length) {\n                // Select the next unprocessed bone\n                var bone: Bone = bones[i];\n                ++i;\n\n                // Find a bone that corresponds to this bone's node parent\n                for (var k: number = 0; k < bones.length; k++) {\n                    var parentBone: Bone = bones[k];\n                    if (bone.node.parent === parentBone.node) {\n                        bone.parent = parentBone;\n                        break;\n                    }\n                }\n\n                // If no parent bone found, add it to the list\n                if (bone.node.parent && !bone.parent) {\n                    bone.parent = Bone.create(bone.node.parent);\n                    bones.push(bone.parent);\n                }\n            }\n\n            var result = new Skeleton(bones);\n\n            Skeleton.checkConsistency(result, context);\n            return result;\n        }\n\n        /**\n        * Given two arrays a and b, such that each bone from a is contained in b,\n        * compute a map that maps the old index (a) of each bone to the new index (b).\n        */\n        static getBoneIndexMap(a: Skeleton, b: Skeleton): Uint32Array {\n            var result: Uint32Array = new Uint32Array(a.bones.length);\n            for (var i: number = 0; i < a.bones.length; ++i) {\n                var bone_a: Bone = a.bones[i];\n\n                // Find the index of the current bone in b\n                var new_index: number = -1;\n                for (var j: number = 0; j < b.bones.length; ++j) {\n                    var bone_b: Bone = b.bones[j];\n                    if (Bone.safeToMerge(bone_a, bone_b)) {\n                        new_index = j;\n                        break;\n                    }\n                }\n\n                if (new_index < 0) {\n                    var a_name: string = bone_a.name;\n                    var b_names: string[] = b.bones.map((b: Bone) => b.name);\n                    throw new Error(\"Bone \" + a_name + \" not found in \" + b_names);\n                }\n                result[i] = new_index;\n            }\n            return result;\n        }\n\n\n        /**\n        * Sorts bones so that child bones appear after their parents in the list.\n        */\n        static sortBones(skeleton: Skeleton, context: Context): Skeleton {\n            var bones = skeleton.bones.slice(0);\n\n            bones = bones.sort((a, b) => {\n                // First, sort by depth\n                var ad = a.depth();\n                var bd = b.depth();\n                if (ad !== bd) {\n                    return ad - bd;\n                }\n\n                // Next, sort by previous position of parent\n                if (a.parent !== b.parent && a.parent !== null) {\n                    var ai = skeleton.bones.indexOf(a.parent);\n                    var bi = skeleton.bones.indexOf(b.parent);\n                    return ai - bi;\n                }\n\n                // Finally, sort by previous position of the bone\n                var ai = skeleton.bones.indexOf(a);\n                var bi = skeleton.bones.indexOf(b);\n                return ai - bi;\n            });\n\n            if (bones.length != skeleton.bones.length || Skeleton.bonesSorted(bones) == false) {\n                throw new Error(\"Error while sorting bones\");\n            }\n\n            var result = new Skeleton(bones);\n\n            Skeleton.checkConsistency(result, context);\n            return result;\n        }\n\n\n        /**\n        * Returns true if the bones are sorted so that child bones appear after their parents in the list.\n        */\n        static bonesSorted(bones: Bone[]): boolean {\n            var errors: number = 0;\n            bones.forEach((bone) => {\n                if (bone.parent !== null) {\n                    var boneIndex = bones.indexOf(bone);\n                    var parentIndex = bones.indexOf(bone.parent);\n                    if (boneIndex < parentIndex) {\n                        ++errors;\n                    }\n                }\n            });\n            return errors === 0;\n        }\n    }\n","import {Log, LogLevel} from \"../log\"\n\nimport * as SourceLoader from \"../loader/source\"\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Material, MaterialMap} from \"./material\"\nimport {Texture} from \"./texture\"\nimport {AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport * as BABYLON from \"babylonjs\"\nimport {Options} from \"./options\"\nimport {BoundingBox} from \"./bounding_box\"\nimport { Controller } from \"../loader/controller\"\nimport { Input } from \"../loader/input\"\nimport { InstanceController } from \"../loader/instance_controller\"\nimport { InstanceGeometry } from \"../loader/instance_geometry\"\nimport { InstanceMaterial } from \"../loader/instance_material\"\nimport { Joints } from \"../loader/joints\"\nimport { Link } from \"../loader/link\"\nimport { Skin } from \"../loader/skin\"\nimport { Skeleton } from \"../converter/skeleton\"\nimport { Triangles } from \"../loader/triangles\"\nimport { VisualSceneNode } from \"../loader/visual_scene_node\"\nimport { ConverterContext } from \"./context\"\nimport { Node } from \"./node\"\nimport { GeometryChunk, GeometryData, GeometryChunkSourceIndices } from \"./geometry_chunk\"\nimport * as LoaderGeometry from \"../loader/geometry\"\n\n    export class Geometry {\n        name: string;\n        chunks: GeometryChunk[];\n        private skeleton: Skeleton | undefined ;\n        boundingBox: BoundingBox;\n\n        constructor() {\n            this.name = \"\";\n            this.chunks = [];\n            this.boundingBox = new BoundingBox();\n        }\n\n        getSkeleton(): Skeleton | undefined{\n            return this.skeleton;\n        }\n\n        /**\n        * Creates a static (non-animated) geometry\n        */\n        static createStatic(instanceGeometry: InstanceGeometry, node: Node, context: ConverterContext): Geometry | undefined{\n            if (!instanceGeometry || !instanceGeometry.geometry) {\n                return undefined;\n            }\n            var geometry = LoaderGeometry.Geometry.fromLink(instanceGeometry.geometry, context);\n            if (!geometry) {\n                context.log.write(\"Geometry instance has no geometry, mesh ignored\", LogLevel.Warning);\n                return undefined;\n            }\n\n            var result = Geometry.createGeometry(geometry, instanceGeometry.materials, context);\n            if (context.options.createSkeleton.value) {\n                Geometry.addSkeleton(result, node, context);\n            }\n            return result;\n        }\n\n        /**\n        * Creates an animated (skin or morph) geometry\n        */\n        static createAnimated(instanceController: InstanceController, node: Node, context: ConverterContext): Geometry | undefined{\n            if (!instanceController || !instanceController.controller) {\n                return undefined;\n            }\n            var controller = Controller.fromLink(instanceController.controller, context);\n            if (!controller) {\n                context.log.write(\"Controller instance has no controller, mesh ignored\", LogLevel.Warning);\n                return undefined;\n            }\n\n            if (controller.skin !== null) {\n                return Geometry.createSkin(instanceController, controller, context);\n            } else if (controller.morph !== null) {\n                return Geometry.createMorph(instanceController, controller, context);\n            }\n\n            return undefined;\n        }\n\n        /**\n        * Creates a skin-animated geometry\n        */\n        static createSkin(instanceController: InstanceController, controller: Controller, context: ConverterContext): Geometry | undefined{\n            if (!instanceController || !instanceController.controller) {\n                return undefined;\n            }\n            // Controller element\n            var controller = Controller.fromLink(instanceController.controller, context) as Controller;\n            if (!controller) {\n                context.log.write(\"Controller instance has no controller, mesh ignored\", LogLevel.Error);\n                return undefined;\n            }\n\n            // Skin element\n            var skin = controller.skin;\n            if (!skin || !skin.source) {\n                context.log.write(\"Controller has no skin, mesh ignored\", LogLevel.Error);\n                return undefined;\n            }\n\n            // Geometry element\n            var loaderGeometry = LoaderGeometry.Geometry.fromLink(skin.source, context);\n            if (!loaderGeometry) {\n                context.log.write(\"Controller has no geometry, mesh ignored\", LogLevel.Error);\n                return undefined;\n            }\n\n            // Create skin geometry\n            var geometry: Geometry = Geometry.createGeometry(loaderGeometry, instanceController.materials, context);\n\n            if (!context.options.createSkeleton.value) {\n                context.log.write(\"Geometry \" + geometry.name + \" contains skinning data, but the creation of skeletons is disabled in the options. Using static geometry only.\", LogLevel.Warning);\n                return geometry;\n            }\n\n            // Find skeleton root nodes\n            var skeletonRootNodes = Geometry.getSkeletonRootNodes(instanceController.skeletons, context);\n            if (skeletonRootNodes.length === 0) {\n                context.log.write(\"Controller still has no skeleton, using unskinned geometry\", LogLevel.Warning);\n                return geometry;\n            }\n\n            // Joints\n            var jointsElement: Joints | undefined = skin.joints;\n            if (!jointsElement) {\n                context.log.write(\"Skin has no joints element, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var jointsInput: Input | undefined = jointsElement.joints;\n            if (!jointsInput || !jointsInput.source) {\n                context.log.write(\"Skin has no joints input, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var jointsSource: SourceLoader.Source | undefined = SourceLoader.Source.fromLink(jointsInput.source, context);\n            if (!jointsSource) {\n                context.log.write(\"Skin has no joints source, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var jointSids: string[] = <string[]>jointsSource.data;\n\n            // Bind shape matrix\n            var bindShapeMatrix: BABYLON.Matrix = new BABYLON.Matrix();\n            if (skin.bindShapeMatrix !== null) {\n                MathUtils.mat4Extract(skin.bindShapeMatrix, 0, bindShapeMatrix);\n            }\n\n            // InvBindMatrices\n            var invBindMatricesInput: Input | undefined = jointsElement?.invBindMatrices;\n            if (!invBindMatricesInput || !invBindMatricesInput.source) {\n                context.log.write(\"Skin has no inverse bind matrix input, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var invBindMatricesSource = SourceLoader.Source.fromLink(invBindMatricesInput.source, context);\n            if (!invBindMatricesSource) {\n                context.log.write(\"Skin has no inverse bind matrix source, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            if ((!invBindMatricesSource.data || !jointsSource.data) ||\n                 invBindMatricesSource.data.length !== jointsSource.data.length * 16) {\n                context.log.write(\"Skin has an inconsistent length of joint data sources, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            if (!(invBindMatricesSource.data instanceof Float32Array)) {\n                context.log.write(\"Skin inverse bind matrices data does not contain floating point data, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var invBindMatrices: Float32Array = <Float32Array> invBindMatricesSource.data;\n\n            // Vertex weights\n            var weightsElement = skin.vertexWeights;\n            if (!weightsElement) {\n                context.log.write(\"Skin contains no bone weights element, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var weightsInput = weightsElement.weights;\n            if (!weightsInput || !weightsInput.source) {\n                context.log.write(\"Skin contains no bone weights input, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var weightsSource = SourceLoader.Source.fromLink(weightsInput.source, context);\n            if (!weightsSource) {\n                context.log.write(\"Skin has no bone weights source, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            if (!(weightsSource.data instanceof Float32Array)) {\n                context.log.write(\"Bone weights data does not contain floating point data, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            var weightsData: Float32Array = <Float32Array> weightsSource.data;\n\n            // Indices\n            if (skin?.vertexWeights?.joints?.source?.url !== skin?.joints?.joints?.source?.url) {\n                // Holy crap, how many indirections does this stupid format have?!?\n                // If the data sources differ, we would have to reorder the elements of the \"bones\" array.\n                context.log.write(\"Skin uses different data sources for joints in <joints> and <vertex_weights>, this is not supported. Using unskinned mesh.\", LogLevel.Warning);\n                return geometry;\n            }\n\n            // Bones\n            var skeleton = Skeleton.createFromSkin(jointSids, skeletonRootNodes, bindShapeMatrix, invBindMatrices, context);\n            if (skeleton.bones.length === 0) {\n                context.log.write(\"Skin contains no bones, using unskinned mesh\", LogLevel.Warning);\n                return geometry;\n            }\n            Geometry.setSkeleton(geometry, skeleton, context);\n\n            // Compact skinning data\n            var bonesPerVertex = 4;\n            var skinningData = Geometry.compactSkinningData(skin, weightsData, bonesPerVertex, context);\n            var skinIndices = skinningData.indices;\n            var skinWeights = skinningData.weights;\n\n            // Distribute skin data to chunks\n            for (var i = 0; i < geometry.chunks.length; ++i) {\n                var chunk: GeometryChunk = geometry.chunks[i];\n                var chunkData: GeometryData = chunk.data;\n                var chunkSrcIndices: GeometryChunkSourceIndices = chunk._colladaIndices;\n\n                // Distribute indices to chunks\n                chunkData.boneindex = new Uint8Array(chunk.vertexCount * bonesPerVertex);\n                Utils.reIndex(skinIndices, chunkSrcIndices.indices, chunkSrcIndices.indexStride, chunkSrcIndices.indexOffset,\n                    bonesPerVertex, chunkData.boneindex, chunkData.indices, 1, 0, bonesPerVertex);\n\n                // Distribute weights to chunks\n                chunkData.boneweight = new Float32Array(chunk.vertexCount * bonesPerVertex);\n                Utils.reIndex(skinWeights, chunkSrcIndices.indices, chunkSrcIndices.indexStride, chunkSrcIndices.indexOffset,\n                    bonesPerVertex, chunkData.boneweight, chunkData.indices, 1, 0, bonesPerVertex);\n            }\n\n            // Copy bind shape matrices\n            for (var i = 0; i < geometry.chunks.length; ++i) {\n                var chunk: GeometryChunk = geometry.chunks[i];\n                chunk.bindShapeMatrix = new BABYLON.Matrix();\n                chunk.bindShapeMatrix.copyFrom(bindShapeMatrix);\n            }\n\n            // Apply bind shape matrices\n            if (context.options.applyBindShape.value === true) {\n                Geometry.applyBindShapeMatrices(geometry, context);\n            }\n\n            // Sort bones if necessary\n            if (context.options.sortBones.value) {\n                skeleton = Skeleton.sortBones(skeleton, context);\n            }\n            Geometry.setSkeleton(geometry, skeleton, context);\n            return geometry;\n        }\n\n        static compactSkinningData(skin: Skin, weightsData: Float32Array, bonesPerVertex: number,\n            context: ConverterContext): { weights: Float32Array; indices:Uint8Array} {\n            var weightsIndices: Int32Array | undefined = skin.vertexWeights?.v;\n            var weightsCounts: Int32Array | undefined = skin.vertexWeights?.vcount;\n            var skinVertexCount: number = weightsCounts?.length || 0;\n            var skinWeights: Float32Array = new Float32Array(skinVertexCount * bonesPerVertex);\n            var skinIndices: Uint8Array = new Uint8Array(skinVertexCount * bonesPerVertex);\n\n            if (!weightsCounts || !weightsIndices) {\n                return  { weights: skinWeights, indices: skinIndices };\n            }\n\n            var vindex: number = 0;\n            var verticesWithTooManyInfluences: number = 0;\n            var verticesWithInvalidTotalWeight: number = 0;\n            var weightCounts: Float32Array = new Float32Array(32);\n            for (var i = 0; i < skinVertexCount; ++i) {\n\n                // Number of bone references for the current vertex\n                var weightCount: number = weightsCounts[i];\n                if (weightCount > bonesPerVertex) {\n                    verticesWithTooManyInfluences++;\n                }\n                weightCounts[Math.min(weightCount, weightCounts.length - 1)]++;\n\n                // Insert all bone references\n                for (var w: number = 0; w < weightCount; ++w) {\n                    var boneIndex: number = weightsIndices[vindex];\n                    var boneWeightIndex: number = weightsIndices[vindex + 1];\n                    vindex += 2;\n                    var boneWeight: number = weightsData[boneWeightIndex];\n\n                    var offsetBegin: number = i * bonesPerVertex;\n                    var offsetEnd: number = i * bonesPerVertex + bonesPerVertex - 1;\n                    Utils.insertBone(skinIndices, skinWeights, boneIndex, boneWeight, offsetBegin, offsetEnd);\n                }\n\n                // Total weight\n                var totalWeight: number = 0;\n                for (var w: number = 0; w < bonesPerVertex; ++w) {\n                    totalWeight += skinWeights[i * bonesPerVertex + w];\n                }\n\n                // Normalize weights (COLLADA weights should be already normalized)\n                if (totalWeight < 1e-6 || totalWeight > 1e6) {\n                    verticesWithInvalidTotalWeight++;\n                } else {\n                    for (var w: number = 0; w < weightCount; ++w) {\n                        skinWeights[i * bonesPerVertex + w] /= totalWeight;\n                    }\n                }\n            }\n\n            if (verticesWithTooManyInfluences > 0) {\n                context.log.write(\"\" + verticesWithTooManyInfluences + \" vertices are influenced by too many bones, some influences were ignored. Only \" + bonesPerVertex + \" bones per vertex are supported.\", LogLevel.Warning);\n            }\n            if (verticesWithInvalidTotalWeight > 0) {\n                context.log.write(\"\" + verticesWithInvalidTotalWeight + \" vertices have zero or infinite total weight, skin will be broken.\", LogLevel.Warning);\n            }\n            return { weights: skinWeights, indices: skinIndices };\n        }\n\n        static getSkeletonRootNodes(skeletonLinks: Link[], context: ConverterContext): VisualSceneNode[] {\n            var skeletonRootNodes: VisualSceneNode[] = [];\n            for (var i: number = 0; i < skeletonLinks.length; i++) {\n                var skeletonLink: Link = skeletonLinks[i];\n                var skeletonRootNode: VisualSceneNode | undefined = VisualSceneNode.fromLink(skeletonLink, context);\n                if (!skeletonRootNode) {\n                    context.log.write(\"Skeleton root node \" + skeletonLink.getUrl() + \" not found, skeleton root ignored\", LogLevel.Warning);\n                    continue;\n                }\n                skeletonRootNodes.push(skeletonRootNode);\n            }\n            if (skeletonRootNodes.length === 0) {\n                context.log.write(\"Controller has no skeleton, using the whole scene as the skeleton root\", LogLevel.Warning);\n                skeletonRootNodes = context.nodes.collada.filter((node: VisualSceneNode) => (context.isInstanceOf(node.parent, \"VisualScene\")));\n            }\n            return skeletonRootNodes;\n        }\n\n        static createMorph(instanceController: InstanceController, controller: Controller, context: ConverterContext): Geometry | undefined{\n            context.log.write(\"Morph animated meshes not supported, mesh ignored\", LogLevel.Warning);\n            return undefined;\n        }\n\n        static createGeometry(geometry: LoaderGeometry.Geometry, instanceMaterials: InstanceMaterial[], context: ConverterContext): Geometry {\n            var materialMap: MaterialMap = Material.getMaterialMap(instanceMaterials, context);\n\n            var result: Geometry = new Geometry();\n            result.name = geometry.name || geometry.id || geometry.sid || \"geometry\";\n\n            // Loop over all <triangle> elements\n            var trianglesList: Triangles[] = geometry.triangles;\n            for (var i: number = 0; i < trianglesList.length; i++) {\n                var triangles = trianglesList[i];\n\n                // Find the used material\n                var material: Material;\n                if (triangles.material !== null) {\n                    material = materialMap.symbols[triangles.material];\n                    if (!material) {\n                        context.log.write(\"Material symbol \" + triangles.material + \" has no bound material instance, using default material\", LogLevel.Warning);\n                        material = Material.createDefaultMaterial(context);\n                    }\n                } else {\n                    context.log.write(\"Missing material index, using default material\", LogLevel.Warning);\n                    material = Material.createDefaultMaterial(context);\n                }\n\n                // Create a geometry chunk\n                var chunk = GeometryChunk.createChunk(geometry, triangles, context);\n                if (chunk) {\n                    chunk.name = result.name;\n                    if (trianglesList.length > 1) {\n                        chunk.name += (\" #\" + i)\n                    }\n                    chunk.material = material;\n                    result.chunks.push(chunk);\n                }\n            }\n\n            return result;\n        }\n\n        /**\n        * Transforms the given geometry (position and normals) by the given matrix\n        */\n        static transformGeometry(geometry: Geometry, transformMatrix: BABYLON.Matrix, context: ConverterContext) {\n            // Create the normal transformation matrix\n            var normalMatrix: BABYLON.Matrix = new BABYLON.Matrix;\n            transformMatrix.toNormalMatrix(normalMatrix);\n\n            // Transform normals and positions of all chunks\n            for (var i = 0; i < geometry.chunks.length; ++i) {\n                var chunk: GeometryChunk = geometry.chunks[i];\n\n                GeometryChunk.transformChunk(chunk, transformMatrix, normalMatrix, context);\n            }\n        }\n\n        /**\n        * Adapts inverse bind matrices to account for any additional transformations due to the world transform\n        */\n        static setupWorldTransform(geometry: Geometry, context: ConverterContext) {\n            if (!geometry.skeleton) return;\n\n            // Skinning equation:                [worldMatrix]     * [invBindMatrix]        * [pos]\n            // Same with transformation A added: [worldMatrix]     * [invBindMatrix * A^-1] * [A * pos]\n            // Same with transformation B added: [worldMatrix * B] * [B^-1 * invBindMatrix] * [pos]\n            geometry.skeleton?.bones.forEach((bone) => {\n                \n                // Transformation A (the world scale)\n                if (context.options.worldTransformBake) {\n                    bone.invBindMatrix = bone.invBindMatrix.multiply(Utils.getWorldInvTransform(context));\n                }\n\n                // Transformation B (the post-transformation of the corresponding node)\n                if (context.options.worldTransformUnitScale) {\n                    var mat = BABYLON.Matrix.Invert(bone.node.transformation_post);\n                    bone.invBindMatrix = mat.multiply(bone.invBindMatrix);\n                }\n            });\n        }\n\n        /**\n        * Scales the given geometry\n        */\n        static scaleGeometry(geometry: Geometry, scale: number, context: ConverterContext) {\n            for (var i = 0; i < geometry.chunks.length; ++i) {\n                var chunk: GeometryChunk = geometry.chunks[i];\n                GeometryChunk.scaleChunk(chunk, scale, context);\n            }\n\n            if (geometry.skeleton && geometry.skeleton.bones) {\n                geometry.skeleton.bones.forEach((bone) => {\n                    bone.invBindMatrix[12] *= scale;\n                    bone.invBindMatrix[13] *= scale;\n                    bone.invBindMatrix[14] *= scale;\n                });\n            }\n        }\n\n        /**\n        * Applies the bind shape matrix to the given geometry.\n        *\n        * This transforms the geometry by the bind shape matrix, and resets the bind shape matrix to identity.\n        */\n        static applyBindShapeMatrices(geometry: Geometry, context: ConverterContext) {\n\n            // Transform normals and positions of all chunks by the corresponding bind shape matrix\n            for (var i = 0; i < geometry.chunks.length; ++i) {\n                var chunk: GeometryChunk = geometry.chunks[i];\n\n                var bindShapeMatrix: BABYLON.Matrix = chunk.bindShapeMatrix;\n                if (bindShapeMatrix) {\n                    var normalMatrix: BABYLON.Matrix = new BABYLON.Matrix();\n                    bindShapeMatrix.toNormalMatrix(normalMatrix);\n\n                    // Pre-multiply geometry data by the bind shape matrix\n                    GeometryChunk.transformChunk(chunk, bindShapeMatrix, normalMatrix, context);\n\n                    // Reset the bind shape matrix\n                    chunk.bindShapeMatrix = BABYLON.Matrix.Identity();\n                }\n            }\n        }\n\n        /**\n        * Computes the bounding box of the static (unskinned) geometry\n        */\n        static computeBoundingBox(geometry: Geometry, context: ConverterContext) {\n            geometry.boundingBox.reset();\n\n            for (var i: number = 0; i < geometry.chunks.length; ++i) {\n                var chunk: GeometryChunk = geometry.chunks[i];\n                GeometryChunk.computeBoundingBox(chunk, context);\n                geometry.boundingBox.extendBox(chunk.boundingBox);\n            }\n        }\n\n        static addSkeleton(geometry: Geometry, node: Node, context: ConverterContext) {\n            // Create a skeleton from a single node\n            var skeleton = Skeleton.createFromNode(node, context);\n            Geometry.setSkeleton(geometry, skeleton, context);\n\n            // Attach all geometry to the bone representing the given node\n            for (var i = 0; i < geometry.chunks.length; ++i) {\n                var chunk: GeometryChunk = geometry.chunks[i];\n                var chunkData: GeometryData = chunk.data;\n\n                chunkData.boneindex = new Uint8Array(chunk.vertexCount * 4);\n                chunkData.boneweight = new Float32Array(chunk.vertexCount * 4);\n                for (var v = 0; v < chunk.vertexCount; ++v) {\n                    chunkData.boneindex[4 * v + 0] = 0;\n                    chunkData.boneindex[4 * v + 1] = 0;\n                    chunkData.boneindex[4 * v + 2] = 0;\n                    chunkData.boneindex[4 * v + 3] = 0;\n\n                    chunkData.boneweight[4 * v + 0] = 1;\n                    chunkData.boneweight[4 * v + 1] = 0;\n                    chunkData.boneweight[4 * v + 2] = 0;\n                    chunkData.boneweight[4 * v + 3] = 0;\n                }\n            }\n\n            // Sort bones if necessary\n            if (context.options.sortBones.value) {\n                skeleton = Skeleton.sortBones(skeleton, context);\n            }\n            Geometry.setSkeleton(geometry, skeleton, context);\n        }\n\n        /**\n        * Moves all data from given geometries into one merged geometry.\n        * The original geometries will be empty after this operation (lazy design to avoid data duplication).\n        */\n        static mergeGeometries(geometries: Geometry[], context: ConverterContext): Geometry | undefined {\n            if (geometries.length === 0) {\n                context.log.write(\"No geometries to merge\", LogLevel.Warning);\n                return undefined;\n            } else if (geometries.length === 1) {\n                return geometries[0];\n            }\n\n            var result: Geometry = new Geometry();\n            result.name = \"merged_geometry\";\n\n            // Merge skeleton bones\n            var skeleton = new Skeleton([]);\n            geometries.forEach((g) => {\n                if (g.skeleton !== null) {\n                    skeleton = Skeleton.mergeSkeletons(skeleton, g.skeleton, context);\n                }\n            });\n\n            // Sort bones if necessary\n            if (context.options.sortBones.value) {\n                skeleton = Skeleton.sortBones(skeleton, context);\n            }\n            Geometry.setSkeleton(result, skeleton, context);\n\n            // Recode bone indices\n            geometries.forEach((geometry) => {\n                Geometry.setSkeleton(geometry, skeleton, context);\n            });\n\n            // Merge geometry chunks\n            geometries.forEach((geometry) => {\n                result.chunks = result.chunks.concat(geometry.chunks);\n            });\n\n            // We modified the original data, unlink it from the original geometries\n            geometries.forEach((geometry) => {\n                geometry.chunks = [];\n            });\n\n            return result;\n        }\n\n        /**\n        * Set the new skeleton for the given geometry.\n        * Changes all vertex bone indices so that they point to the given skeleton bones, instead of the current geometry.skeleton bones\n        */\n        static setSkeleton(geometry: Geometry, skeleton: Skeleton, context: ConverterContext) {\n\n            // Adapt bone indices\n            if (geometry.skeleton) {\n                // Compute the index map\n                var index_map: Uint32Array = Skeleton.getBoneIndexMap(geometry.skeleton, skeleton);\n\n                // Recode indices\n                for (var i = 0; i < geometry.chunks.length; ++i) {\n                    var chunk: GeometryChunk = geometry.chunks[i];\n                    var boneindex = chunk.data.boneindex;\n\n                    if (boneindex) {\n                        for (var j = 0; j < boneindex.length; ++j) {\n                            boneindex[j] = index_map[boneindex[j]];\n                        }\n                    }\n                }\n            }\n\n            geometry.skeleton = skeleton;\n        }\n\n    }\n","import { AnimationLabel } from \"./animation_data\";\n\n\nexport interface Option {\n        type: string;\n        title: string;\n        value: any;\n        description: string;\n    }\n\n    export class OptionBool implements Option {\n        type: string;\n        title: string;\n        value: boolean;\n        description: string;\n\n        constructor(title: string, defaultValue: boolean, description: string) {\n            this.type = \"boolean\";\n            this.title = title;\n            this.value = defaultValue;\n            this.description = description;\n        }\n    }\n\n    export class OptionFloat implements Option {\n        type: string;\n        title: string;\n        value: number;\n        min: number;\n        max: number;\n        description: string;\n\n        constructor(title: string, defaultValue: number, min: number, max: number, description: string) {\n            this.type = \"number\";\n            this.title = title;\n            this.value = defaultValue;\n            this.min = min;\n            this.max = max;\n            this.description = description;\n        }\n    }\n\n    export class OptionSelect implements Option {\n        type: string;\n        title: string;\n        value: string;\n        description: string;\n        options: string[]\n\n        constructor(title: string, defaultValue: string, options: string[], description: string) {\n            this.type = \"select\";\n            this.title = title;\n            this.value = defaultValue;\n            this.options = options;\n            this.description = description;\n        }\n    }\n\n    export class OptionArray<T> implements Option {\n        type: string;\n        title: string;\n        value: T[];\n        description: string;\n\n        constructor(title: string, defaultValue: T[], description: string) {\n            this.type = \"array\";\n            this.title = title;\n            this.value = defaultValue;\n            this.description = description;\n        }\n    }\n\n    export class Options {\n        singleAnimation: OptionBool;\n        singleGeometry: OptionBool;\n        singleBufferPerGeometry: OptionBool;\n        enableAnimations: OptionBool;\n        useAnimationLabels: OptionBool;\n        enableExtractGeometry: OptionBool;\n        enableResampledAnimations: OptionBool;\n        animationLabels: OptionArray<AnimationLabel>;\n        animationFps: OptionFloat;\n        removeConstAnimationTracks: OptionBool;\n        applyBindShape: OptionBool;\n        removeTexturePath: OptionBool;\n        sortBones: OptionBool;\n        truncateResampledAnimations: OptionBool;\n        worldTransform: OptionBool;\n        worldTransformBake: OptionBool;\n        worldTransformUnitScale: OptionBool;\n        worldTransformScale: OptionFloat;\n        worldTransformRotationAxis: OptionSelect;\n        worldTransformRotationAngle: OptionFloat;\n        createSkeleton: OptionBool;\n\n        constructor() {\n            this.singleAnimation = new OptionBool(\"Single animation\", true,\n                \"Enabled: all animations are merged into a single animation (useful if each bone has a separate top level animation).<br/>\" +\n                \"Disabled: animations are not merged.\");\n            this.singleGeometry = new OptionBool(\"Single geometry\", true,\n                \"Enabled: all geometries are merged into a single geometry. Only has an effect if 'enableExtractGeometry' is enabled.<br/>\" +\n                \"Disabled: geometries are not merged.\");\n            this.singleBufferPerGeometry = new OptionBool(\"Single buffer\", false,\n                \"Enabled: all chunks within one geometry use one set of vertex buffers, each chunk occupying a different part of the buffer set.<br/>\" +\n                \"Disabled: each chunk has its own set of buffers.\");\n            this.enableAnimations = new OptionBool(\"Animations\", true,\n                \"Enabled: animations are exported.<br/>\" +\n                \"Disabled: all animations are ignored.\");\n            this.enableExtractGeometry = new OptionBool(\"Extract geometry\", true,\n                \"Enabled: extract all geometries from the scene and detach them from their scene graph nodes.<br/>\" +\n                \"Disabled: geometries remain attached to nodes.\");\n            this.enableResampledAnimations = new OptionBool(\"Resampled animations\", true,\n                \"Enabled: generate resampled animations for all skeleton bones.<br/>\" +\n                \"Disabled: do not generate resampled animations.\");\n            this.useAnimationLabels = new OptionBool(\"Animation labels\", false,\n                \"Enabled: animations labels are used to split the global animation into separete animations.<br/>\" +\n                \"Disabled: only one global animation is exported.\");\n            this.animationLabels = new OptionArray<AnimationLabel>(\"Animation labels\", [],\n                \"An array of animation labels ({name, begin, end, fps)} that describes how the global animation is split.<br/>\" +\n                \"Only has an effect if 'useAnimationLabels' is enabled.\");\n            this.animationFps = new OptionFloat(\"Animation samples per second\", 10, 0, 100,\n                \"Default FPS for resampled animations.\");\n            this.removeConstAnimationTracks = new OptionBool(\"Remove static animations\", true,\n                \"Enabled: animation tracks are removed if they only contain the rest pose transformation for all times.<br/>\" +\n                \"Disabled: all animation tracks are exported.\");\n            this.applyBindShape = new OptionBool(\"Apply bind shape\", true,\n                \"Enabled: the positions and normals of skin-animated meshes are pre-multiplied by the bind shape matrix.<br/>\" +\n                \"Disabled: the bind shape matrix needs to be manually exported and applied during rendering.\");\n            this.removeTexturePath = new OptionBool(\"Remove texture path\", true,\n                \"Enabled: only the filename and extension of textures are kept and the remaining path is discarded.<br/>\" +\n                \"Disabled: original texture paths are kept.\");\n            this.sortBones = new OptionBool(\"Sort bones\", true,\n                \"Enabled: bones are sorted so that child bones always appear after their parent bone in the list of bones.<br/>\" +\n                \"Disabled: bones appear in their original order.\");\n            this.worldTransform = new OptionBool(\"World transform\", false,\n                \"Enabled: all objects (geometries, animations, skeletons) are transformed as specified by the corresponding world transform options.<br/>\" +\n                \"Disabled: the world transform options are ignored.\");\n            this.worldTransformBake = new OptionBool(\"Bake world transform\", true,\n                \"Enabled: the world transformation is applied to skinned geometry.<br/>\" +\n                \"Disabled: the world transformation is applied to the bones.\");\n            this.worldTransformUnitScale = new OptionBool(\"World transform no node scale\", true,\n                \"If enabled, the world scale will not add any scaling transformation to any nodes.\" +\n                \"The world scale will instead be distributed to the translation part of all local transformations.\");\n            this.worldTransformScale = new OptionFloat(\"World transform: scale\", 1.0, 1e-6, 1e6,\n                \"Scale factor. See the 'worldTransform' option.\");\n            this.worldTransformRotationAxis = new OptionSelect(\"World transform: rotation axis\", \"none\", [\"none\", \"x\", \"y\", \"z\"],\n                \"Rotation axis. See the 'worldTransform' option.\");\n            this.worldTransformRotationAngle = new OptionFloat(\"World transform: rotation angle\", 0, 0, 360,\n                \"Rotation angle (in degrees). See the 'worldTransform' option.\");\n            this.truncateResampledAnimations = new OptionBool(\"Truncate resampled animations\", true,\n                \"Enabled: animation durations are truncated in order to keep the requested FPS.<br/>\" +\n                \"Disabled: requested FPS is slightly modified to keep the original duration.\");\n            this.createSkeleton = new OptionBool(\"Generate skeleton\", true,\n                \"Enabled: a skeleton is generated and all geometry is attached to skeleton bones.<br/>\" +\n                \"Disabled: no skeleton is generated and all geometry is static.\");\n        }\n\n    }\n","import {Context} from \"../context\"\nimport {Log, LogLevel} from \"../log\"\n\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {Material} from \"./material\"\nimport {Texture} from \"./texture\"\nimport {Animation, AnimationTarget} from \"./animation\"\nimport * as COLLADAContext from \"../context\"\nimport {Options} from \"./options\"\nimport {BoundingBox} from \"./bounding_box\"\nimport * as BABYLON from 'babylonjs';\nimport { InstanceController } from \"../loader/instance_controller\"\nimport { InstanceGeometry } from \"../loader/instance_geometry\"\nimport { NodeTransform } from \"../loader/node_transform\"\nimport { VisualSceneNode } from \"../loader/visual_scene_node\"\nimport { ConverterContext } from \"./context\"\nimport { Transform, TransformMatrix, TransformRotate, TransformTranslate, TransformScale } from \"./transform\"\nimport {Geometry} from \"./geometry\"\n\n    export class Node {\n        name: string;\n        parent: Node | undefined;\n        children: Node[];\n        geometries: Geometry[];\n        transformations: Transform[];\n        transformation_pre: BABYLON.Matrix = new BABYLON.Matrix();\n        transformation_post: BABYLON.Matrix = new BABYLON.Matrix();\n        matrix: BABYLON.Matrix = new BABYLON.Matrix();\n        worldMatrix: BABYLON.Matrix = new BABYLON.Matrix();\n        initialLocalMatrix: BABYLON.Matrix = new BABYLON.Matrix();\n        initialWorldMatrix: BABYLON.Matrix = new BABYLON.Matrix();\n\n        constructor() {\n            this.name = \"\";\n            this.children = [];\n            this.geometries = [];\n            this.transformations = [];\n            this.transformation_pre = BABYLON.Matrix.Identity();\n            this.transformation_post = BABYLON.Matrix.Identity()\n        }\n\n        addTransform(mat: BABYLON.Matrix) {\n            var loader_transform = new NodeTransform();\n            loader_transform.data = new Float32Array();\n            mat.copyToArray(loader_transform.data);\n            loader_transform.type = \"matrix\";\n            loader_transform.name = \"virtual static transform\";\n            var transform = new TransformMatrix(loader_transform);\n            this.transformations.unshift(transform);\n        }\n\n        /**\n        * Returns the world transformation matrix of this node\n        */\n        getWorldMatrix(context: ConverterContext): BABYLON.Matrix {\n            if (this.parent != null) {\n                this.worldMatrix = this.parent.getWorldMatrix(context).multiply(this.getLocalMatrix(context));\n            } else {\n                this.worldMatrix.copyFrom(this.getLocalMatrix(context));\n            }\n            return this.worldMatrix;\n        }\n\n        /**\n        * Returns the local transformation matrix of this node\n        */\n        getLocalMatrix(context: ConverterContext) {\n            \n            // Static pre-transform\n            this.matrix.copyFrom(this.transformation_pre);\n\n            // Original transformations\n            for (var i: number = 0; i < this.transformations.length; i++) {\n                var transform: Transform = this.transformations[i];\n                transform.applyTransformation(this.matrix);\n            }\n\n            // Static post-transform\n           this.matrix = this.matrix.multiply(this.transformation_post);\n\n            return this.matrix;\n        }\n\n        /**\n        * Returns true if this node contains any scene graph items (geometry, lights, cameras, ...)\n        */\n        containsSceneGraphItems(): boolean {\n            if (this.geometries.length > 0) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        /**\n        * Returns whether there exists any animation that targets the transformation of this node\n        */\n        isAnimated(recursive: boolean): boolean {\n            return this.isAnimatedBy(undefined, recursive);\n        }\n\n        /**\n        * Returns whether there the given animation targets the transformation of this node\n        */\n        isAnimatedBy(animation: Animation, recursive: boolean): boolean {\n\n            for (var i: number = 0; i < this.transformations.length; i++) {\n                var transform: Transform = this.transformations[i];\n                if (transform.isAnimatedBy(animation)) return true;\n            }\n            if (recursive && this.parent) {\n                return this.parent.isAnimatedBy(animation, recursive);\n            }\n            return false;\n        }\n\n        resetAnimation(): void {\n            for (var i: number = 0; i < this.transformations.length; i++) {\n                var transform: Transform = this.transformations[i];\n                transform.resetAnimation();\n            }\n        }\n\n        /**\n        * Removes all nodes from that list that are not relevant for the scene graph\n        */\n        static pruneNodes(nodes: Node[], context: Context) {\n            // Prune all children recursively\n            for (var n: number = 0; n < nodes.length; ++n) {\n                var node: Node = nodes[n];\n                Node.pruneNodes(node.children, context);\n            }\n\n            // Remove all nodes from the list that are not relevant\n            nodes = nodes.filter((value: Node, index: number, array: Node[]) =>\n                (value.containsSceneGraphItems() || value.children.length > 0));\n        }\n\n        /**\n        * Recursively creates a converter node tree from the given collada node root node\n        */\n        static createNode(node: VisualSceneNode, parent: Node, context: ConverterContext): Node {\n            // Create new node\n            var converterNode: Node = new Node();\n            converterNode.parent = parent;\n            if (parent) {\n                parent.children.push(converterNode);\n            }\n            context.nodes.register(node, converterNode);\n\n            converterNode.name = node.name || node.id || node.sid || \"Unnamed node\";\n\n            // Node transform\n            for (var i = 0; i < node.transformations.length; ++i) {\n                var transform: NodeTransform = node.transformations[i];\n                var converterTransform: Transform = null;\n                switch (transform.type) {\n                    case \"matrix\":\n                        converterTransform = new TransformMatrix(transform);\n                        break;\n                    case \"rotate\":\n                        converterTransform = new TransformRotate(transform);\n                        break;\n                    case \"translate\":\n                        converterTransform = new TransformTranslate(transform);\n                        break;\n                    case \"scale\":\n                        converterTransform = new TransformScale(transform);\n                        break;\n                    default:\n                        context.log.write(\"Transformation type \" + transform.type + \" not supported, transform ignored\", LogLevel.Warning);\n                }\n                if (converterTransform !== null) {\n                    context.animationTargets.register(transform, converterTransform);\n                    converterNode.transformations.push(converterTransform);\n                }\n            }\n\n            Node.updateInitialMatrices(converterNode, context);\n            \n            // Create children\n            for (var i: number = 0; i < node.children.length; i++) {\n                var colladaChild: VisualSceneNode = node.children[i];\n                var converterChild: Node = Node.createNode(colladaChild, converterNode, context);\n            }\n\n            return converterNode;\n        }\n\n        static updateInitialMatrices(node: Node, context: ConverterContext) {\n            node.getLocalMatrix(context);\n            node.initialLocalMatrix.copyFrom(node.matrix);\n\n            node.getWorldMatrix(context);\n            node.initialWorldMatrix.copyFrom(node.worldMatrix);\n        }\n\n        static createNodeData(converter_node: Node, context: ConverterContext) {\n\n            var collada_node: VisualSceneNode = context.nodes.findCollada(converter_node);\n\n            // Static geometries (<instance_geometry>)\n            for (var i: number = 0; i < collada_node.geometries.length; i++) {\n                var loaderGeometry: InstanceGeometry = collada_node.geometries[i];\n                var converterGeometry: Geometry = Geometry.createStatic(loaderGeometry, converter_node, context);\n                converter_node.geometries.push(converterGeometry);\n            }\n\n            // Animated geometries (<instance_controller>)\n            for (var i: number = 0; i < collada_node.controllers.length; i++) {\n                var loaderController: InstanceController = collada_node.controllers[i];\n                var converterGeometry: Geometry = Geometry.createAnimated(loaderController, converter_node, context);\n                converter_node.geometries.push(converterGeometry);\n            }\n\n            // Lights, cameras\n            if (collada_node.lights.length > 0) {\n                context.log.write(\"Node \" + collada_node.id + \" contains lights, lights are ignored\", LogLevel.Warning);\n            }\n            if (collada_node.cameras.length > 0) {\n                context.log.write(\"Node \" + collada_node.id + \" contains cameras, cameras are ignored\", LogLevel.Warning);\n            }\n\n            // Children\n            for (var i: number = 0; i < converter_node.children.length; i++) {\n                var child: Node = converter_node.children[i];\n                Node.createNodeData(child, context);\n            }\n        }\n\n        /**\n        * Calls the given function for all given nodes and their children (recursively)\n        */\n        static forEachNode(nodes: Node[], fn: (node: Node) => void) {\n\n            for (var i: number = 0; i < nodes.length; ++i) {\n                var node: Node = nodes[i];\n                fn(node);\n                Node.forEachNode(node.children, fn);\n            }\n        }\n\n        /**\n        * Extracts all geometries in the given scene and merges them into a single geometry.\n        * The geometries are detached from their original nodes in the process.\n        */\n        static extractGeometries(scene_nodes: Node[], context: ConverterContext): Geometry[] {\n\n            // Collect all geometries and the corresponding nodes\n            // Detach geometries from nodes in the process\n            var result: { node: Node; geometry: Geometry }[] = [];\n            Node.forEachNode(scene_nodes, (node) => {\n                for (var i: number = 0; i < node.geometries.length; ++i) {\n                    result.push({ node: node, geometry: node.geometries[i] });\n                }\n                node.geometries = [];\n            });\n\n            if (result.length === 0) {\n                context.log.write(\"No geometry found in the scene, returning an empty geometry\", LogLevel.Warning);\n                var geometry: Geometry = new Geometry();\n                geometry.name = \"empty_geometry\";\n                return [geometry];\n            }\n\n            // Check whether the geometries need a skeleton\n            var skinnedGeometries: number = 0;\n            var animatedNodeGeometries: number = 0;\n            result.forEach((element) => {\n                if (element.geometry.getSkeleton() !== null) skinnedGeometries++; \n                if (element.node.isAnimated(true)) animatedNodeGeometries++;\n            });\n\n            if (!context.options.createSkeleton.value) {\n                if (skinnedGeometries > 0) {\n                    context.log.write(\"Scene contains \" + skinnedGeometries + \" skinned geometries, but skeleton creation is disabled. Static geometry was generated.\", LogLevel.Warning);\n                }\n                if (animatedNodeGeometries > 0) {\n                    context.log.write(\"Scene contains \" + animatedNodeGeometries + \" static geometries attached to animated nodes, but skeleton creation is disabled. Static geometry was generated.\", LogLevel.Warning);\n                }\n                // Apply the node transformation to static geometries\n                result.forEach((element) => {\n                    var world_matrix = element.node.getWorldMatrix(context);\n                    if (context.options.worldTransformUnitScale) {\n                        var mat: BABYLON.Matrix = new BABYLON.Matrix()\n                        mat = BABYLON.Matrix.Invert(element.node.transformation_post);\n                        world_matrix = world_matrix.multiply(mat);\n                    }\n                    Geometry.transformGeometry(element.geometry, world_matrix, context);\n                });\n            }\n\n            // Merge all geometries\n            if (context.options.singleGeometry) {\n                var geometries = result.map((element) => { return element.geometry });\n                var geometry: Geometry = Geometry.mergeGeometries(geometries, context);\n                return [geometry];\n            } else {\n                return result.map((element) => { return element.geometry });\n            }\n        }\n\n        static setupWorldTransform(node: Node, context: ConverterContext) {\n            var worldInvScale: BABYLON.Vector3 = Utils.getWorldInvScale(context);\n            var worldTransform: BABYLON.Matrix = Utils.getWorldTransform(context);\n\n            var uniform_scale: boolean = context.options.worldTransformUnitScale.value;\n\n            // Pre-transformation\n            // Root nodes: the world transformation\n            // All other nodes: undo whatever post-transformation the parent has added\n            if (node.parent == null) {  \n                node.transformation_pre.copyFrom(worldTransform);\n            } else if (uniform_scale) {\n                node.transformation_pre = BABYLON.Matrix.Invert(node.parent.transformation_post);\n            }\n\n            // Post-transformation\n            if (uniform_scale) {\n                // This way, the node transformation will not contain any scaling\n                // Only the translation part will be scaled\n                node.transformation_post = BABYLON.Matrix.Scaling(worldInvScale.x, worldInvScale.y, worldInvScale.z);\n            }\n\n            Node.updateInitialMatrices(node, context);\n\n            // Recursively set up children\n            for (var i = 0; i < node.children.length; ++i) {\n                Node.setupWorldTransform(node.children[i], context);\n            }\n        }\n    }\n","import { Geometry } from \"./geometry\";\nimport { AnimationData } from \"./animation_data\";\nimport { Node } from \"./node\";\nimport { Animation } from \"./animation\";\n\nexport class Document {\n        /** The scene graph */\n        nodes: Node[];\n        /** Animations (all original animation curves) */\n        animations: Animation[];\n        /** Animations (resampled node animations) */\n        resampled_animations: AnimationData[];\n        /** Geometries (detached from the scene graph) */\n        geometries: Geometry[];\n\n        constructor() {\n            this.nodes = [];\n            this.animations = [];\n            this.geometries = [];\n            this.resampled_animations = [];\n        }\n    }\n","import { promises as fs } from 'fs';\nimport {RMXModelLoader} from \"../model-loader\"\nimport {RMXModel} from \"../model\"\nimport * as Utils from \"./utils\"\nimport {Log, LogLevel, LogConsole, LogCallback, LogFilter} from \"../log\"\nimport { VisualScene } from '../loader/visual_scene';\nimport { VisualSceneNode } from '../loader/visual_scene_node';\nimport { AnimationData, AnimationLabel } from './animation_data';\nimport { Animation } from './animation';\nimport * as LoaderAnimation from '../loader/animation';\nimport { ConverterContext } from './context';\nimport { GeometryChunk } from './geometry_chunk';\nimport { Geometry } from './geometry';\nimport { Options } from './options';\nimport {Node} from \"./node\"\nimport {Document} from \"./file\"\nimport * as LoaderDocument from \"../loader/document\"\n\nexport class ColladaConverter {\n    log: Log;\n    options: Options;\n\n    constructor() {\n        this.log = new LogConsole();\n        this.options = new Options();\n    }\n\n    private forEachGeometry(doc: Document, fn: (geometry: Geometry) => void): void {\n        for (var i: number = 0; i < doc.geometries.length; ++i) {\n            fn(doc.geometries[i]);\n        }\n        Node.forEachNode(doc.nodes, (node: Node) => {\n            for (var i: number = 0; i < node.geometries.length; ++i) {\n                fn(node.geometries[i]);\n            }\n        });\n    }\n\n    convert(doc: LoaderDocument.Document): Document {\n        var context: ConverterContext = new ConverterContext(this.log, this.options);\n\n        if (!doc) {\n            context.log.write(\"No document to convert\", LogLevel.Warning);\n            return null;\n        }\n\n        var result = new Document();\n\n        // Scene nodes\n        result.nodes = ColladaConverter.createScene(doc, context);\n\n        // Set up the world transform\n        if (context.options.worldTransform.value) {\n\n            // Add the world transform to scene nodes\n            for (var i: number = 0; i < result.nodes.length; ++i) {\n                Node.setupWorldTransform(result.nodes[i], context);\n            }\n\n            // Adapt inverse bind matrices\n            this.forEachGeometry(result, (geometry) => {\n                Geometry.setupWorldTransform(geometry, context);\n            });\n\n            // Bake: Apply the world transform to skinned geometries\n            if (context.options.worldTransformBake.value) {\n                var mat = Utils.getWorldTransform(context);\n                this.forEachGeometry(result, (geometry) => {\n                    if (geometry.getSkeleton() !== null) {\n                        Geometry.transformGeometry(geometry, mat, context);\n                    }\n                });\n            }\n        }\n\n        // Original animations curves\n        if (context.options.enableAnimations.value === true) {\n            result.animations = ColladaConverter.createAnimations(doc, context);\n        }\n\n        // Extract geometries\n        if (context.options.enableExtractGeometry.value === true) {\n            result.geometries = Node.extractGeometries(result.nodes, context);\n        }\n\n        // Merge chunk data\n        if (context.options.singleBufferPerGeometry.value === true) {\n            this.forEachGeometry(result, (geometry) => {\n                GeometryChunk.mergeChunkData(geometry.chunks, context);\n            });\n        }\n\n        // Resampled animations\n        if (context.options.enableResampledAnimations.value === true) {\n            result.resampled_animations = ColladaConverter.createResampledAnimations(doc, result, context);\n        }\n\n        // Compute bounding boxes\n        Node.forEachNode(result.nodes, (node: Node) => {\n            this.forEachGeometry(result, (geometry) => {\n                Geometry.computeBoundingBox(geometry, context);\n            });\n        });\n\n        return result;\n    }\n\n    static createScene(doc: LoaderDocument.Document, context: ConverterContext): Node[] {\n        var result: Node[] = [];\n\n        // Get the COLLADA scene\n        if (!doc.scene) {\n            context.log.write(\"Collada document has no scene\", LogLevel.Warning);\n            return result;\n        }\n        var scene: VisualScene = VisualScene.fromLink(doc.scene.instance, context);\n        if (!scene) {\n            context.log.write(\"Collada document has no scene\", LogLevel.Warning);\n            return result;\n        }\n\n        // Create converted nodes\n        for (var i: number = 0; i < scene.children.length; ++i) {\n            var topLevelNode: VisualSceneNode = scene.children[i];\n            result.push(Node.createNode(topLevelNode, null, context));\n        }\n\n        // Create data (geometries, ...) for the converted nodes\n        for (var i: number = 0; i < result.length; ++i) {\n            var node: Node = result[i];\n            Node.createNodeData(node, context);\n        }\n\n        return result;\n    }\n\n    static createAnimations(doc: LoaderDocument.Document, context: ConverterContext): Animation[] {\n        var result: Animation[] = [];\n\n        // Create converted animations\n        for (var i: number = 0; i < doc.libAnimations.children.length; ++i) {\n            var animation = doc.libAnimations.children[i];\n            result.push(Animation.create(animation, context));\n        }\n\n        // If requested, create a single animation\n        if (context.options.singleAnimation.value === true && result.length > 1) {\n            var topLevelAnimation = new Animation();\n            topLevelAnimation.id = \"\";\n            topLevelAnimation.name = \"animation\";\n\n            // Steal all channels from previous animations\n            for (var i: number = 0; i < result.length; ++i) {\n                var child: Animation = result[i];\n                topLevelAnimation.channels = topLevelAnimation.channels.concat(child.channels);\n                child.channels = [];\n            }\n            result = [topLevelAnimation];\n        }\n\n        return result;\n    }\n\n    static createResampledAnimations(doc: LoaderDocument.Document, file: Document, context: ConverterContext): AnimationData[] {\n        var result: AnimationData[] = [];\n        if (file.animations.length === 0) {\n            // context.log.write(\"No original animations available, no resampled animations generated.\", LogLevel.Warning);\n            return [];\n        }\n\n        // Get the geometry\n        if (file.geometries.length > 1) {\n            context.log.write(\"Converted document contains multiple geometries, resampled animations are only generated for single geometries.\", LogLevel.Warning);\n            return [];\n        }\n        if (file.geometries.length === 0) {\n            context.log.write(\"Converted document does not contain any geometries, no resampled animations generated.\", LogLevel.Warning);\n            return [];\n        }\n        var geometry: Geometry = file.geometries[0];\n\n        // Process all animations in the document\n        var fps: number = +context.options.animationFps.value;\n        for (var i: number = 0; i < file.animations.length; ++i) {\n            var animation: Animation = file.animations[i];\n\n            if (context.options.useAnimationLabels.value === true) {\n                var labels: AnimationLabel[] = context.options.animationLabels.value;\n                var datas: AnimationData[] = AnimationData.createFromLabels(geometry.getSkeleton(), animation, labels, fps, context);\n                result = result.concat(datas);\n            } else {\n                var data: AnimationData = AnimationData.create(geometry.getSkeleton(), animation, null, null, fps, context);\n                if (data !== null) {\n                    result.push(data);\n                }\n            }\n        }\n\n        return result;\n    }\n}\n","import * as COLLADAContext from \"../context\"\nimport {Log, LogLevel} from \"../log\"\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {AnimationTrack} from \"./animation_track\"\nimport { DataChunk } from \"./data_chunk\"\n\n\n    export class ExporterContext extends COLLADAContext.Context {\n        log: Log;\n        chunks: DataChunk[];\n        chunk_data: Uint8Array[];\n        bytes_written: number;\n\n        constructor(log: Log) {\n            super(log);\n            this.log = log;\n            this.chunks = [];\n            this.chunk_data = [];\n            this.bytes_written = 0;\n        }\n\n        registerChunk(chunk: DataChunk) {\n            this.chunks.push(chunk);\n            chunk.byte_offset = this.bytes_written;\n            this.bytes_written += chunk.getBytesCount();\n        }\n\n        assembleData(): Uint8Array {\n            // Allocate result\n            var buffer: ArrayBuffer = new ArrayBuffer(this.bytes_written);\n            var result: Uint8Array = new Uint8Array(buffer);\n\n            // Copy data from all chunks\n            for (var i: number = 0; i < this.chunks.length; ++i) {\n                var chunk: DataChunk = this.chunks[i];\n                var chunk_data: Uint8Array = chunk.getDataView();\n                var chunk_data_length: number = chunk_data.length;\n                var chunk_data_offet: number = chunk.byte_offset;\n\n                for (var j: number = 0; j < chunk_data_length; ++j) {\n                    result[j + chunk_data_offet] = chunk_data[j];\n                }\n            }\n\n            return result;\n        }\n    }\n","import { ExporterContext } from \"./context\";\nimport { MaterialJSON } from \"./format\";\nimport * as ConverterMaterial from \"../converter/material\";\n\n    export class Material {\n\n        static toJSON(material: ConverterMaterial.Material, context: ExporterContext): MaterialJSON | undefined{\n            if (!material) {\n                return null;\n            }\n\n            return {\n                name: material.name,\n                diffuse: (material.diffuse !== null) ? (material.diffuse.url) : \"\",\n                specular: (material.specular !== null) ? (material.specular.url) : \"\",\n                normal: (material.normal !== null) ? (material.normal.url) : \"\",\n                diffuseColor: material.diffuseColor,\n                specularColor: material.specularColor,\n                emissiveColor: material.emissiveColor\n            };\n        }\n    };\n","import {Log, LogLevel} from \"../log\"\nimport { ExporterContext } from \"./context\";\nimport { DataChunkJSON } from \"./format\";\n\n\n\n    export class DataChunk {\n        data: any;\n        type: string | undefined;\n        byte_offset: number = 0;\n        stride: number = 0;\n        count: number = 0;\n        bytes_per_element: number = 0;\n\n        constructor() {\n            this.data = null;\n\n        }\n\n        getDataView(): Uint8Array {\n            return new Uint8Array(this.data.buffer, 0, this.stride * this.count * this.bytes_per_element);\n        }\n\n        getBytesCount(): number {\n            return this.data.length * this.bytes_per_element;\n        }\n\n        static toJSON(chunk: DataChunk): DataChunkJSON {\n            if (!chunk || !chunk.type) {\n                chunk.type = \"\";\n            }\n\n            var result: DataChunkJSON = {\n                type: chunk.type,\n                byte_offset: chunk.byte_offset,\n                stride: chunk.stride,\n                count: chunk.count\n            }\n\n            return result;\n        }\n\n        static create(data: any, stride: number, context: ExporterContext): DataChunk{\n            var result: DataChunk = new DataChunk();\n            if (!data) {\n                return result;\n            }\n\n            result.data = data;\n            result.stride = stride;\n            result.count = data.length / stride;\n\n            if (data instanceof Float32Array) {\n                result.type = \"float\";\n                result.bytes_per_element = 4;\n            } else if (data instanceof Float64Array) {\n                result.type = \"double\";\n                result.bytes_per_element = 8;\n            } else if (data instanceof Uint8Array) {\n                result.type = \"uint8\";\n                result.bytes_per_element = 1;\n            } else if (data instanceof Uint16Array) {\n                result.type = \"uint16\";\n                result.bytes_per_element = 2;\n            } else if (data instanceof Uint32Array) {\n                result.type = \"uint32\";\n                result.bytes_per_element = 4;\n            } else if (data instanceof Int8Array) {\n                result.type = \"int8\";\n                result.bytes_per_element = 1;\n            } else if (data instanceof Int16Array) {\n                result.type = \"int16\";\n                result.bytes_per_element = 2;\n            } else if (data instanceof Int32Array) {\n                result.type = \"int32\";\n                result.bytes_per_element = 4;\n            } else {\n                context.log.write(\"Unknown data type, data chunk ignored\", LogLevel.Warning);\n                return result;\n            }\n\n            context.registerChunk(result);\n            return result;\n        }\n    };\n","import * as COLLADAContext from \"../context\"\nimport {Log, LogLevel} from \"../log\"\n\nimport * as Utils from \"./utils\"\nimport {BoundingBoxJSON, GeometryJSON} from \"./format\"\nimport { GeometryChunk } from \"../converter/geometry_chunk\";\nimport { ExporterContext } from \"./context\";\nimport { DataChunk } from \"./data_chunk\";\nimport * as ConverterBoundingBox from \"../converter/bounding_box\";\n\n    export class BoundingBox {\n\n        static toJSON(box: ConverterBoundingBox.BoundingBox): BoundingBoxJSON {\n            if (!box) {\n                return {\n                    min: [0, 0, 0],\n                    max: [0, 0, 0]\n                };\n                }\n\n            return {\n                min: [box.min[0], box.min[1], box.min[2]],\n                max: [box.max[0], box.max[1], box.max[2]]\n            };\n        }\n    }\n\n    export class Geometry {\n\n        static toJSON(chunk: GeometryChunk, material_index: number, context: ExporterContext): GeometryJSON {\n\n            var indices: DataChunk = DataChunk.create(chunk.data.indices, 3, context);\n            var position: DataChunk = DataChunk.create(chunk.data.position, 3, context);\n            var normal: DataChunk = DataChunk.create(chunk.data.normal, 3, context);\n            var texcoord: DataChunk = DataChunk.create(chunk.data.texcoord, 2, context);\n            var boneweight: DataChunk = DataChunk.create(chunk.data.boneweight, 4, context);\n            var boneindex: DataChunk = DataChunk.create(chunk.data.boneindex, 4, context);\n\n            return {\n                name: chunk.name,\n                material: material_index,\n                vertex_count: chunk.vertexCount,\n                triangle_count: chunk.triangleCount,\n                indices: DataChunk.toJSON(indices),\n                position: DataChunk.toJSON(position),\n                normal: DataChunk.toJSON(normal),\n                texcoord: DataChunk.toJSON(texcoord),\n                boneweight: DataChunk.toJSON(boneweight),\n                boneindex: DataChunk.toJSON(boneindex),\n                bounding_box: BoundingBox.toJSON(chunk.boundingBox)\n            }\n        }\n    }\n","import * as BABYLON from 'babylonjs';\nimport * as COLLADAContext from \"../context\"\nimport {Log, LogLevel} from \"../log\"\n\nimport * as Utils from \"./utils\"\nimport {BoneJSON, BoundingBoxJSON} from \"./format\"\nimport * as MathUtils from '../math'\nimport { ExporterContext } from \"./context\";\nimport { Bone } from \"../converter/bone\";\nimport * as ConverterSkeleton from \"../converter/skeleton\";\n\n\n\n    export class Skeleton {\n\n        static toJSON(skeleton: ConverterSkeleton.Skeleton, context: ExporterContext): BoneJSON[] | undefined{\n            if (!skeleton) {\n                return undefined ;\n            }\n\n            // TODO: options for this\n            var mat_tol: number = 6;\n            var pos_tol: number = 6;\n            var scl_tol: number = 6;\n            var rot_tol: number = 6;\n\n            var result: BoneJSON[] = [];\n            skeleton.bones.forEach((bone) => {\n\n                // Bone default transform\n                var mat: BABYLON.Matrix = bone.node.initialLocalMatrix;\n                var pos = new BABYLON.Vector3(0, 0, 0);\n                var rot= new BABYLON.Quaternion(0, 0, 0, 1);\n                var scl= new BABYLON.Vector3(1, 1, 1);\n                mat.decompose(scl, rot, pos);\n\n                // Bone inverse bind matrix\n                var inv_bind_mat: number[] = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n                bone.invBindMatrix = BABYLON.Matrix.FromArray(inv_bind_mat);\n\n                result.push({\n                    name: bone.name,\n                    parent: skeleton.bones.indexOf(bone.parent),\n                    skinned: bone.attachedToSkin,\n                    inv_bind_mat: inv_bind_mat,\n                    matrix: mat.asArray() as number[],\n                    pos: pos.asArray(),\n                    rot: rot.asArray(),\n                    scl: scl.asArray()\n                });\n            });\n\n            return result;\n        }\n    }\n","import {Context} from \"../context\"\nimport {LogLevel} from \"../log\"\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport { AnimationDataTrack } from \"../converter/animation_data\";\nimport { ExporterContext } from \"./context\";\nimport { DataChunk } from \"./data_chunk\";\nimport { AnimationTrackJSON } from \"./format\";\n\n    export class AnimationTrack {\n\n        static toJSON(track: AnimationDataTrack, index: number, context: ExporterContext): AnimationTrackJSON {\n            if (!track) {\n                return null;\n            }\n\n            var pos = DataChunk.create(track.pos, 3, context);\n            var rot = DataChunk.create(track.rot, 4, context);\n            var scl = DataChunk.create(track.scl, 3, context);\n\n            return {\n                bone: index,\n                pos: DataChunk.toJSON(pos),\n                rot: DataChunk.toJSON(rot),\n                scl: DataChunk.toJSON(scl)\n            };\n        }\n    }\n","import {Context} from \"../context\"\nimport {LogLevel} from \"../log\"\n\nimport * as Utils from \"./utils\"\nimport * as MathUtils from \"../math\"\nimport {AnimationTrack} from \"./animation_track\"\nimport { AnimationData } from \"../converter/animation_data\"\nimport { ExporterContext } from \"./context\"\nimport { AnimationJSON } from \"./format\"\n\n    export class Animation {\n\n        static toJSON(animation: AnimationData, context: ExporterContext): AnimationJSON {\n            if (!animation) {\n                return {\n                    name: \"\",\n                    frames: 0,\n                    fps: 0,\n                    tracks: undefined\n                }\n            }\n\n            return {\n                name: animation.name,\n                frames: animation.keyframes,\n                fps: animation.fps,\n                tracks: animation.tracks.map((e, i) => AnimationTrack.toJSON(e, i, context))\n            };\n        }\n    }\n","import { DocumentJSON } from \"./format\";\n\n    export class Document {\n        json: DocumentJSON;\n        data: Uint8Array;\n\n        constructor() {\n            this.json = null;\n            this.data = null;\n        }\n    }\n","import { promises as fs } from 'fs';\nimport * as BABYLON from \"babylonjs\";\nimport {RMXModelLoader} from \"../model-loader\"\nimport {RMXModel} from \"../model\"\nimport * as Utils from \"./utils\"\nimport {Log, LogLevel, LogConsole, LogCallback, LogFilter} from \"../log\"\nimport { GeometryChunk } from '../converter/geometry_chunk';\nimport { ExporterContext } from './context';\nimport { MaterialJSON, GeometryJSON, InfoJSON, BoneJSON, AnimationJSON } from './format';\nimport * as ConverterDocument from '../converter/file';\nimport * as ExporterDocument from '../exporter/document';\nimport { Geometry } from '../converter/geometry';\nimport { Material } from './material';\nimport { BoundingBox } from './geometry';\nimport { Skeleton } from './skeleton';\nimport { Animation } from './animation';\nimport * as ExporterGeometry from \"../exporter/geometry\"\nimport { Document } from './document';\n\n    export class ColladaExporter {\n        log: Log;\n\n        constructor() {\n            this.log = new LogConsole();\n        }\n\n        export(doc: ConverterDocument.Document): ExporterDocument.Document {\n            var context: ExporterContext = new ExporterContext(this.log);\n\n            if (!doc) {\n                context.log.write(\"No document to convert\", LogLevel.Warning);\n                return null;\n            }\n\n            if (doc.geometries.length === 0) {\n                context.log.write(\"Document contains no geometry, nothing exported\", LogLevel.Warning);\n                return null;\n            } else if (doc.geometries.length > 1) {\n                context.log.write(\"Document contains multiple geometries, only the first geometry is exported\", LogLevel.Warning);\n            }\n\n            // Geometry and materials\n            var converter_materials: Material[] = [];\n            var materials: MaterialJSON[] = [];\n            var converter_geometry: Geometry = doc.geometries[0];\n            var chunks: GeometryJSON[] = [];\n\n            for (var c: number = 0; c < converter_geometry.chunks.length; ++c) {\n                var chunk: GeometryChunk = converter_geometry.chunks[c];\n\n                // Create the material, if it does not exist yet\n                var material_index: number = converter_materials.indexOf(chunk.material);\n                if (material_index === -1) {\n                    var material: MaterialJSON = Material.toJSON(chunk.material, context);\n                    material_index = materials.length;\n\n                    converter_materials.push(chunk.material);\n                    materials.push(material);\n                }\n\n                // Create the geometry\n                chunks.push(ExporterGeometry.Geometry.toJSON(chunk, material_index, context));\n            }\n\n            // Result\n            var result: Document = new Document();\n\n            var info: InfoJSON = {\n                bounding_box: BoundingBox.toJSON(converter_geometry.boundingBox)\n            };\n            var bones: BoneJSON[] = Skeleton.toJSON(converter_geometry.getSkeleton(), context);\n            var animations: AnimationJSON[] = doc.resampled_animations.map((e) => Animation.toJSON(e, context));\n\n            // Assemble result: JSON part\n            result.json = {\n                info: info,\n                materials: materials,\n                chunks: chunks,\n                bones: bones,\n                animations: animations\n            };\n\n            // Assemble result: Binary data part\n            result.data = context.assembleData();\n            //result.json.data = Utils.bufferToString(result.data);\n\n            return result;\n        }\n    }\n","import { promises as fs } from 'fs';\nimport * as BABYLON from \"babylonjs\";\nimport * as Loader from \"./loader\"\nimport {RMXModelLoader} from \"./model-loader\"\nimport * as BabylonLoader from \"./babylon-loader\"\nimport {RMXModel} from \"./model\"\nimport {LogLevel, LogCallback, LogFilter} from \"./log\"\nimport { ColladaConverter } from './converter/colladaconverter';\nimport { ColladaExporter } from './exporter/colladaexporter';\nimport { Document } from './loader/document';\n\n\nexport class DAEFileLoader implements BABYLON.ISceneLoaderPluginAsync, BABYLON.ISceneLoaderPluginFactory {\n  public name = \"dae\";\n  public extensions = \".dae\";\n\n  private _assetContainer: BABYLON.Nullable<BABYLON.AssetContainer> = null;\n\n  createPlugin(): BABYLON.ISceneLoaderPluginAsync | BABYLON.ISceneLoaderPlugin {\n    return new DAEFileLoader();\n  }\n\n  public importMeshAsync(meshesNames: any, scene: BABYLON.Scene, data: any, rootUrl: string): Promise<BABYLON.ISceneLoaderAsyncResult> {\n    var loader = new Loader.ColladaLoader();\n    var loaderlog = new LogCallback;\n    loaderlog.onmessage = (message: string, level: LogLevel) => { console.log(message); }      \n    loader.log = new LogFilter(loaderlog, LogLevel.Debug);\n    \n    var parser = new DOMParser();\n    var colladaXml = parser.parseFromString(data, \"text/xml\");\n\n    var colladaDoc = loader.loadFromXML(\"id\", colladaXml);\n\n    var converter = new ColladaConverter();\n    var convertedDoc = converter.convert(colladaDoc);\n\n    var exporter = new ColladaExporter();\n    var exportedDoc = exporter.export(convertedDoc);\n\n    var modelLoader = new RMXModelLoader;\n    var model: RMXModel = modelLoader.loadModel(exportedDoc.json, exportedDoc.data.buffer);\n\n    var loader2 = new BabylonLoader.BabylonModelLoader;\n    var model2 = loader2.createBabylonModel(model, scene);\n\n\n    const result: BABYLON.ISceneLoaderAsyncResult = {\n      meshes: model2.meshes,\n      particleSystems: [],\n      skeletons: [],\n      animationGroups: [],\n      transformNodes: model2.transformNodes || [],\n      geometries: [],\n      lights: [],\n      spriteManagers: [],\n    };\n    return Promise.resolve(result);\n  }  \n\n  public loadAsync(scene: BABYLON.Scene, data: string, rootUrl: string): Promise<void> {\n    //Get the 3D model\n    return this.importMeshAsync(undefined, scene, data, rootUrl).then(() => {\n        // return void\n    });\n  }\n\n    public loadAssetContainerAsync(scene: BABYLON.Scene, data: string, rootUrl: string): Promise<BABYLON.AssetContainer> {\n        const container = new BABYLON.AssetContainer(scene);\n        this._assetContainer = container;\n\n        return this.importMeshAsync(undefined, scene, data, rootUrl)\n            .then((result) => {\n                result.meshes.forEach((mesh) => {\n                  container.meshes.push(mesh)\n                });\n                result.meshes.forEach((mesh) => {\n                    const material = mesh.material;\n                    if (material) {\n                        // Materials\n                        if (container.materials.indexOf(material) == -1) {\n                            container.materials.push(material);\n\n                            // Textures\n                            const textures = material.getActiveTextures();\n                            textures.forEach((t) => {\n                                if (container.textures.indexOf(t) == -1) {\n                                    container.textures.push(t);\n                                }\n                            });\n                        }\n                    }\n                });\n\n                this._assetContainer = null;\n                return container;\n            })\n            .catch((ex) => {\n                this._assetContainer = null;\n                throw ex;\n            });\n    }\n\n}\n\nexport function Register() {\n  if (BABYLON.SceneLoader) {\n    //Add this loader into the register plugin\n    BABYLON.SceneLoader.RegisterPlugin(new DAEFileLoader());\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__43__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","LogLevel","Context","constructor","l","log","isInstanceOf","el","typeName","_className","indexOf","LogCallback","onmessage","write","message","level","LogConsole","console","Debug","Trace","Info","Warning","Error","Exception","LogLevelToString","LogFilter","Link","url","getUrl","resolve","context","UrlLink","super","trim","replace","object","ids","target","FxLink","scope","fxChildren","fxParent","SidLink","parentId","sids","indices","dotSyntax","arrSyntax","_parseUrl","parts","split","id","shift","length","s","push","lastSid","member","index","arrIndices","idx","i","len","parseInt","findSidTarget","result","warning","join","parentObject","childObject","ilen","sid","queue","front","frontChildren","sidChildren","j","jlen","sidChild","LoaderContext","totalBytes","loadedBytes","links","getAttributeNamed","name","getAttributeNode","getAttributeFromChildNodesNamed","cn","forEach","a","getTextContent","textContent","firstChild","getNodeValue","getFloatsContent","strToFloats","getFloatContent","parseFloat","getIntsContent","strToInts","getUintsContent","strToUints","getIntContent","getBoolsContent","strToBools","getStringsContent","strToStrings","getAttributeAsFloat","defaultValue","required","attr","childNodes","nodeName","getAttributeAsInt","getAttributeAsString","createUrlLink","link","createSidLink","createFxLink","getAttributeAsUrlLink","getAttributeAsSidLink","getAttributeAsFxLink","str","strings","data","Float32Array","Int32Array","Uint32Array","Uint8Array","strToColor","rgba","registerUrlTarget","needsId","registerFxTarget","registerSidTarget","parent","getNodePath","node","path","parentNode","toUpperCase","reportUnexpectedChild","child","reportUnhandledChild","resolveAllLinks","linksLen","EElement","fromLink","_fromLink","forEachChild","fn","childNodesLength","item","nodeType","Scene","instance","parse","Channel","source","Input","semantic","offset","set","shared","Sampler","outputs","inTangents","outTangents","input","addInput","sampler","interpolation","Source","count","stride","params","sourceId","parseSourceTechniqueCommon","parseAccessor","parseAccessorParam","type","keys","Animation","children","sources","samplers","channels","animation","AnimationLibrary","Asset","unit","upAxis","charAt","CameraParam","Camera","parseOptics","camera","parseTechniqueCommon","parseParams","param","CameraLibrary","Morph","Joints","inputs","joints","invBindMatrices","VertexWeights","vcount","v","weights","Skin","bindShapeMatrix","vertexWeights","Controller","skin","morph","ControllerLibrary","EffectSampler","wrapS","wrapT","minFilter","magFilter","mipmapMaxLevel","mipmapBias","surface","image","borderColor","EffectSurface","format","size","viewportRatio","mipLevels","mipmapGenerate","initFrom","toLowerCase","EffectParam","floats","ColorOrTexture","texcoord","opaque","bumptype","color","textureSampler","EffectTechnique","shading","shininess","transparency","reflectivity","index_of_refraction","double_sided","parseParam","parseExtra","technique","profile","emission","ambient","diffuse","specular","reflective","transparent","bump","Effect","parseProfileCommon","effect","EffectLibrary","Triangles","material","Vertices","vertices","triangles","parseMesh","parseGeometryExtra","geometry","parseGeometryExtraTechnique","GeometryLibrary","Image","ImageLibrary","LightParam","Light","light","LightLibrary","MaterialLibrary","InstanceCamera","InstanceMaterial","symbol","vertexInputs","parseBindVertexInput","parseBind","instanceMaterial","inputSemantic","inputSet","BindMaterial","materials","InstanceController","skeletons","controller","InstanceGeometry","InstanceLight","NodeTransform","expectedDataLength","VisualSceneNode","layer","transformations","geometries","controllers","lights","cameras","registerParent","childNode","VisualSceneNodeLibrary","VisualScene","VisualSceneLibrary","Document","libEffects","libMaterials","libGeometries","libControllers","libLights","libCameras","libImages","libVisualScenes","libAnimations","libNodes","doc","colladaNodes","getElementsByTagName","parseCOLLADA","asset","scene","ColladaLoader","_reportError","onFinished","_reportSuccess","_reportProgress","onProgress","loadFromXML","_loadFromXML","err","stack","loadFromURL","loader","document","implementation","createDocument","req","XMLHttpRequest","overrideMimeType","onreadystatechange","readyState","status","responseXML","getResponseHeader","responseText","open","send","RMXModel","chunks","skeleton","RMXSkeleton","animations","RMXModelChunk","triangle_count","vertex_count","index_offset","material_index","RMXMaterial","normal","hash","diffuseColor","specularColor","emissiveColor","bones","RMXBone","skinned","pos","rot","scl","RMXAnimation","frames","fps","tracks","RMXAnimationTrack","bone","RMXModelLoader","loadFloatData","json","byte_offset","loadUint8Data","loadUint32Data","loadModelChunk","data_position","position","data_normal","data_texcoord","data_boneweight","boneweight","data_boneindex","boneindex","data_indices","loadModel","map","chunk","loadSkeleton","loadAnimation","loadMaterial","loadBone","inv_bind_mat","matrix","loadAnimationTrack","track","BabylonModelLoader","materialCache","createGeometry","vertexData","positions","normals","uvs","tmp","createTexture","parseColor","createMaterial","cached_material","backFaceCulling","diffuseTexture","specularTexture","createBabylonModel","model","BabylonModel","transformNodes","boneMatrix","FromArray","transformNode","setPreTransformMatrix","rmx_chunk","BabylonModelChunk","m","applyToMesh","meshes","getVerticesData","NormalKind","PositionKind","ComputeNormals","getIndices","useRightHandedSystem","updateVerticesData","convertToFlatShadedMesh","sideOrientation","CounterClockWiseSideOrientation","bone_indices","bone_count","bone_index","reIndex","srcData","srcIndices","srcStride","srcOffset","srcDim","destData","destIndices","destStride","destOffset","destDim","dim","Math","min","srcIndexCount","srcIndexIndex","destIndexIndex","srcIndex","destIndex","createFloatArray","outDim","src_offset","src_stride","dest_stride","spawElements","array","i1","i2","temp","insertBone","weight","offsetBegin","offsetEnd","identityMatrix","worldTransform","getWorldTransform","mat","copyFrom","getWorldRotation","scale","options","worldTransformScale","getWorldScale","matScale","Scaling","x","y","z","multiply","worldInvTransform","TransformType","worldRotation","rotationAxis","worldTransformRotationAxis","rotationAngle","worldTransformRotationAngle","PI","RotationX","RotationY","RotationZ","copyNumberArrayOffset","src","dest","mat4Extract","srcOff","transpose","bezier","p0","c0","c1","p1","hermite","t0","t1","s2","s3","bisect","target_y","tol_y","max_iterations","x0","x1","y0","y1","iteration","abs","AnimationChannel","output","inTangent","outTangent","dataOffset","dataCount","findInputIndices","t","warnInvalidTime","warningCount","messageCount","i0","createInputData","inputName","dataDim","createInputDataFromArray","create","channel","element","animationTargets","findConverter","targetDataRows","getTargetDataRows","targetDataColumns","getTargetDataColumns","targetLink","interpolationInput","interpolationSource","Array","registerAnimation","interpolateLinear","time","interpolateBezier","tc0","tc1","interpolateHermite","tt0","tt1","applyToData","AnimationTimeStatistics","beginTime","Statistics","endTime","duration","keyframes","addDataPoint","sorted","sort","b","compute","max","median","floor","ceil","sum","reduce","prev","cur","mean","addChannelsToAnimation","collada_animation","converter_animation","getTimeStatistics","index_begin","index_end","begin","end","Infinity","channelMinTime","channelMaxTime","channelKeyframes","AnimationDataTrack","rel_pos","rel_rot","rel_scl","logStatistics","stat","precision","toFixed","AnimationData","original_fps","src_channels","start_time","truncateResampledAnimations","spf","result_tracks","resetAnimation","k","c","applyAnimation","getLocalMatrix","decompose","w","pos0","inv_pos0","rot0","inv_rot0","scl0","inv_scl0","invert","negate","pos_change","rot_change","scl_change","max_pos_change","max_rot_change","max_scl_change","addInPlace","acos","multiplyInPlace","removeConstAnimationTracks","createFromLabels","labels","defaultFps","label","ObjectMap","collada","converter","register","findCollada","ConverterContext","textures","nodes","Texture","img","colorOrTexture","textureSamplerParam","textureImage","textureSurfaceParam","textureSurface","removeTexturePath","MaterialMap","symbols","Material","createDefaultMaterial","slice","getMaterialMap","instanceMaterials","BoundingBox","reset","fromPositions","p","extend","extendBox","GeometryData","GeometryChunkSourceIndices","indexStride","indexOffset","GeometryChunk","vertexCount","triangleCount","vertexBufferOffset","indexBufferOffset","boundingBox","_colladaIndices","createChunk","inputTriVertices","inputTriNormal","inputTriColor","inputTriTexcoord","srcTriVertices","srcTriNormal","srcTriColor","srcTriTexcoord","inputVertPos","inputVertNormal","inputVertColor","inputVertTexcoord","srcVertPos","srcVertNormal","srcVertColor","srcVertTexcoord","dataVertPos","dataVertNormal","dataTriNormal","dataVertTexcoord","dataTriTexcoord","colladaIndices","trianglesCount","triangleVertexStride","indexCount","uniqueMap","invalidIndex","previousIndex","nextIndex","indexOffsetPosition","indexOffsetNormal","indexOffsetTexcoord","geometryData","sourceIndices","computeBoundingBox","transformEachVector","transform","vec","TransformCoordinates","transformChunk","positionMatrix","normalMatrix","scaleChunk","mergeChunkData","has_position","has_normal","has_texcoord","has_boneweight","has_boneindex","chunkData","resultData","Bone","invBindMatrix","Identity","attachedToSkin","clone","depth","findBoneNode","boneSid","skeletonRootNodes","boneNode","warnings","skeletonRoot","sameInvBindMatrix","tolerance","ai","asArray","bi","safeToMerge","mergeBone","Skeleton","findBone","findParent","checkConsistency","b1","b2","createFromSkin","jointSids","jointSid","jointNode","converterNode","addBoneParents","createFromNode","replaceBone","oldBone","mergedBone","newBone","mergeSkeletons","skeleton1","skeleton2","getSkeletonRootNodes","skeletonLinks","skeletonLink","skeletonRootNode","filter","parentBone","getBoneIndexMap","bone_a","new_index","bone_b","a_name","b_names","sortBones","ad","bd","bonesSorted","errors","Geometry","getSkeleton","createStatic","instanceGeometry","createSkeleton","addSkeleton","createAnimated","instanceController","createSkin","createMorph","loaderGeometry","jointsElement","jointsInput","jointsSource","invBindMatricesInput","invBindMatricesSource","weightsElement","weightsInput","weightsSource","weightsData","setSkeleton","skinningData","compactSkinningData","skinIndices","skinWeights","chunkSrcIndices","applyBindShape","applyBindShapeMatrices","bonesPerVertex","weightsIndices","weightsCounts","skinVertexCount","vindex","verticesWithTooManyInfluences","verticesWithInvalidTotalWeight","weightCounts","weightCount","boneIndex","boneWeightIndex","totalWeight","materialMap","trianglesList","transformGeometry","transformMatrix","toNormalMatrix","setupWorldTransform","worldTransformBake","worldTransformUnitScale","Invert","transformation_post","scaleGeometry","mergeGeometries","g","concat","index_map","OptionBool","title","description","OptionFloat","OptionSelect","OptionArray","Options","singleAnimation","singleGeometry","singleBufferPerGeometry","enableAnimations","enableExtractGeometry","enableResampledAnimations","useAnimationLabels","animationLabels","animationFps","Transform","rows","columns","colums","data_elements","original_data","updateFromData","isAnimated","isAnimatedBy","applyTransformation","hasTransformType","TransformMatrix","TransformRotate","axis","radians","RotationAxis","Rotation","TransformTranslate","Translation","TransformScale","Scale","Node","transformation_pre","worldMatrix","initialLocalMatrix","initialWorldMatrix","addTransform","loader_transform","copyToArray","unshift","getWorldMatrix","containsSceneGraphItems","recursive","pruneNodes","n","createNode","converterTransform","updateInitialMatrices","colladaChild","createNodeData","converter_node","collada_node","converterGeometry","loaderController","forEachNode","extractGeometries","scene_nodes","skinnedGeometries","animatedNodeGeometries","world_matrix","worldInvScale","invScale","uniform_scale","resampled_animations","ColladaConverter","forEachGeometry","convert","createScene","createAnimations","createResampledAnimations","topLevelNode","topLevelAnimation","file","datas","ExporterContext","chunk_data","bytes_written","registerChunk","getBytesCount","assembleData","buffer","ArrayBuffer","getDataView","chunk_data_length","chunk_data_offet","toJSON","DataChunk","bytes_per_element","Float64Array","Uint16Array","Int8Array","Int16Array","box","bounding_box","AnimationTrack","e","ColladaExporter","converter_materials","converter_geometry","info","DAEFileLoader","extensions","_assetContainer","createPlugin","importMeshAsync","meshesNames","rootUrl","loaderlog","colladaXml","DOMParser","parseFromString","colladaDoc","convertedDoc","exportedDoc","export","model2","particleSystems","animationGroups","spriteManagers","Promise","loadAsync","then","loadAssetContainerAsync","container","mesh","getActiveTextures","catch","ex","Register","RegisterPlugin"],"sourceRoot":""}