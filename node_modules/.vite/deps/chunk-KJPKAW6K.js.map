{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/serialization.ts", "../../../dev/core/src/FlowGraph/flowGraphConnection.ts", "../../../dev/core/src/FlowGraph/flowGraphDataConnection.ts", "../../../dev/core/src/FlowGraph/flowGraphBlock.ts"],
  "sourcesContent": ["import type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { FlowGraphTypes, getRichTypeByFlowGraphType } from \"./flowGraphRichTypes\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\r\n\r\nfunction IsMeshClassName(className: string) {\r\n    return (\r\n        className === \"Mesh\" ||\r\n        className === \"AbstractMesh\" ||\r\n        className === \"GroundMesh\" ||\r\n        className === \"InstanceMesh\" ||\r\n        className === \"LinesMesh\" ||\r\n        className === \"GoldbergMesh\" ||\r\n        className === \"GreasedLineMesh\" ||\r\n        className === \"TrailMesh\"\r\n    );\r\n}\r\n\r\nfunction IsVectorClassName(className: string) {\r\n    return (\r\n        className === FlowGraphTypes.Vector2 ||\r\n        className === FlowGraphTypes.Vector3 ||\r\n        className === FlowGraphTypes.Vector4 ||\r\n        className === FlowGraphTypes.Quaternion ||\r\n        className === FlowGraphTypes.Color3 ||\r\n        className === FlowGraphTypes.Color4\r\n    );\r\n}\r\n\r\nfunction IsMatrixClassName(className: string) {\r\n    return className === FlowGraphTypes.Matrix || className === FlowGraphTypes.Matrix2D || className === FlowGraphTypes.Matrix3D;\r\n}\r\n\r\nfunction IsAnimationGroupClassName(className: string) {\r\n    return className === \"AnimationGroup\";\r\n}\r\n\r\nfunction ParseVector(className: string, value: Array<number>, flipHandedness = false) {\r\n    if (className === FlowGraphTypes.Vector2) {\r\n        return Vector2.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector3) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n        }\r\n        return Vector3.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector4) {\r\n        return Vector4.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Quaternion) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n            value[3] *= -1;\r\n        }\r\n        return Quaternion.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Color3) {\r\n        return new Color3(value[0], value[1], value[2]);\r\n    } else if (className === FlowGraphTypes.Color4) {\r\n        return new Color4(value[0], value[1], value[2], value[3]);\r\n    } else {\r\n        throw new Error(`Unknown vector class name ${className}`);\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that serializes values in a context object to a serialization object\r\n * @param key the key where the value should be stored in the serialization object\r\n * @param value the value to store\r\n * @param serializationObject the object where the value will be stored\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function defaultValueSerializationFunction(key: string, value: any, serializationObject: any) {\r\n    const className = value?.getClassName?.() ?? \"\";\r\n    if (IsVectorClassName(className) || IsMatrixClassName(className)) {\r\n        serializationObject[key] = {\r\n            value: value.asArray(),\r\n            className,\r\n        };\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        serializationObject[key] = {\r\n            value: value.value,\r\n            className,\r\n        };\r\n    } else {\r\n        if (className && (value.id || value.name)) {\r\n            serializationObject[key] = {\r\n                id: value.id,\r\n                name: value.name,\r\n                className,\r\n            };\r\n        } else {\r\n            // only if it is not an object\r\n            if (typeof value !== \"object\") {\r\n                serializationObject[key] = value;\r\n            } else {\r\n                throw new Error(`Could not serialize value ${value}`);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that parses values stored in a serialization object\r\n * @param key the key to the value that will be parsed\r\n * @param serializationObject the object that will be parsed\r\n * @param assetsContainer the assets container that will be used to find the objects\r\n * @param scene\r\n * @returns\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function defaultValueParseFunction(key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) {\r\n    const intermediateValue = serializationObject[key];\r\n    let finalValue;\r\n    const className = intermediateValue?.type ?? intermediateValue?.className;\r\n    if (IsMeshClassName(className)) {\r\n        let nodes: TransformNode[] = scene.meshes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        if (nodes.length === 0) {\r\n            nodes = scene.transformNodes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        }\r\n        finalValue = intermediateValue.uniqueId ? nodes.find((m) => m.uniqueId === intermediateValue.uniqueId) : nodes[0];\r\n    } else if (IsVectorClassName(className)) {\r\n        finalValue = ParseVector(className, intermediateValue.value);\r\n    } else if (IsAnimationGroupClassName(className)) {\r\n        // do not use the scene.getAnimationGroupByName because it is possible that two AGs will have the same name\r\n        const ags = scene.animationGroups.filter((ag) => ag.name === intermediateValue.name);\r\n        // uniqueId changes on each load. this is used for the glTF loader, that uses serialization after the scene was loaded.\r\n        finalValue = ags.length === 1 ? ags[0] : ags.find((ag) => ag.uniqueId === intermediateValue.uniqueId);\r\n    } else if (className === FlowGraphTypes.Matrix) {\r\n        finalValue = Matrix.FromArray(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix2D) {\r\n        finalValue = new FlowGraphMatrix2D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix3D) {\r\n        finalValue = new FlowGraphMatrix3D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        finalValue = FlowGraphInteger.FromValue(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Number || className === FlowGraphTypes.String || className === FlowGraphTypes.Boolean) {\r\n        finalValue = intermediateValue.value[0];\r\n    } else if (intermediateValue && intermediateValue.value !== undefined) {\r\n        finalValue = intermediateValue.value;\r\n    } else {\r\n        if (Array.isArray(intermediateValue)) {\r\n            // configuration data of an event\r\n            finalValue = intermediateValue.reduce((acc, val) => {\r\n                if (!val.eventData) {\r\n                    return acc;\r\n                }\r\n                acc[val.id] = {\r\n                    type: getRichTypeByFlowGraphType(val.type),\r\n                };\r\n                if (typeof val.value !== \"undefined\") {\r\n                    acc[val.id].value = defaultValueParseFunction(\"value\", val, assetsContainer, scene);\r\n                }\r\n                return acc;\r\n            }, {});\r\n        } else {\r\n            finalValue = intermediateValue;\r\n        }\r\n    }\r\n    return finalValue;\r\n}\r\n\r\n/**\r\n * Given a name of a flow graph block class, return if this\r\n * class needs to be created with a path converter. Used in\r\n * parsing.\r\n * @param className the name of the flow graph block class\r\n * @returns a boolean indicating if the class needs a path converter\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function needsPathConverter(className: string) {\r\n    // I am not using the ClassName property here because it was causing a circular dependency\r\n    // that jest didn't like!\r\n    return className === FlowGraphBlockNames.JsonPointerParser;\r\n}\r\n", "import { RandomGUID } from \"../Misc/guid\";\r\n\r\n/**\r\n * The type of a connection point - input or output.\r\n */\r\nexport const enum FlowGraphConnectionType {\r\n    Input,\r\n    Output,\r\n}\r\n\r\n/**\r\n * An interface for a connectable point in the flow graph.\r\n */\r\nexport interface IConnectable {\r\n    /**\r\n     * A uniquely identifying string for the connection.\r\n     */\r\n    uniqueId: string;\r\n    /**\r\n     * An array of the points that this point is connected to.\r\n     */\r\n    _connectedPoint: Array<IConnectable>;\r\n    /**\r\n     * Returns if the connection can only be connected to one other point.\r\n     */\r\n    _isSingularConnection(): boolean;\r\n    /**\r\n     * The type of the connection\r\n     */\r\n    _connectionType: FlowGraphConnectionType;\r\n    /**\r\n     * Connect this point to another point.\r\n     * @param point the point to connect to.\r\n     */\r\n    connectTo(point: IConnectable): void;\r\n}\r\n\r\n/**\r\n * The base connection class.\r\n */\r\nexport class FlowGraphConnection<BlockT, ConnectedToT extends IConnectable> implements IConnectable {\r\n    /** @internal */\r\n    public _connectedPoint: Array<ConnectedToT> = [];\r\n    /**\r\n     * A uniquely identifying string for the connection.\r\n     */\r\n    public uniqueId = RandomGUID();\r\n\r\n    /**\r\n     * The name of the connection.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _connectionType: FlowGraphConnectionType;\r\n\r\n    /**\r\n     * Used for parsing connections.\r\n     * @internal\r\n     */\r\n    // disable warning as this is used for parsing\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public connectedPointIds: any[] = [];\r\n\r\n    public constructor(\r\n        name: string,\r\n        _connectionType: FlowGraphConnectionType,\r\n        /* @internal */ public _ownerBlock: BlockT\r\n    ) {\r\n        this.name = name;\r\n        this._connectionType = _connectionType;\r\n    }\r\n\r\n    /**\r\n     * The type of the connection\r\n     */\r\n    public get connectionType() {\r\n        return this._connectionType;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Override this to indicate if a point can connect to more than one point.\r\n     */\r\n    public _isSingularConnection(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns if a point is connected to any other point.\r\n     * @returns boolean indicating if the point is connected.\r\n     */\r\n    public isConnected(): boolean {\r\n        return this._connectedPoint.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Connects two connections together.\r\n     * @param point the connection to connect to.\r\n     */\r\n    public connectTo(point: ConnectedToT): void {\r\n        if (this._connectionType === point._connectionType) {\r\n            throw new Error(`Cannot connect two points of type ${this.connectionType}`);\r\n        }\r\n        if ((this._isSingularConnection() && this._connectedPoint.length > 0) || (point._isSingularConnection() && point._connectedPoint.length > 0)) {\r\n            throw new Error(\"Max number of connections for point reached\");\r\n        }\r\n        this._connectedPoint.push(point);\r\n        point._connectedPoint.push(this);\r\n    }\r\n\r\n    /**\r\n     * Disconnects two connections.\r\n     * @param point the connection to disconnect from.\r\n     * @param removeFromLocal if true, the connection will be removed from the local connection list.\r\n     */\r\n    public disconnectFrom(point: ConnectedToT, removeFromLocal = true): void {\r\n        const indexLocal = this._connectedPoint.indexOf(point);\r\n        const indexConnected = point._connectedPoint.indexOf(this);\r\n        if (indexLocal === -1 || indexConnected === -1) {\r\n            return;\r\n        }\r\n        if (removeFromLocal) {\r\n            this._connectedPoint.splice(indexLocal, 1);\r\n        }\r\n        point._connectedPoint.splice(indexConnected, 1);\r\n    }\r\n\r\n    /**\r\n     * Disconnects all connected points.\r\n     */\r\n    public disconnectFromAll() {\r\n        for (const point of this._connectedPoint) {\r\n            this.disconnectFrom(point, false);\r\n        }\r\n        this._connectedPoint.length = 0;\r\n    }\r\n\r\n    public dispose() {\r\n        for (const point of this._connectedPoint) {\r\n            this.disconnectFrom(point);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the connection to a JSON object.\r\n     * @param serializationObject the object to serialize to.\r\n     */\r\n    public serialize(serializationObject: any = {}) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject._connectionType = this._connectionType;\r\n        serializationObject.connectedPointIds = [];\r\n        serializationObject.className = this.getClassName();\r\n        for (const point of this._connectedPoint) {\r\n            serializationObject.connectedPointIds.push(point.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the connection.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FGConnection\";\r\n    }\r\n\r\n    /**\r\n     * Deserialize from a object into this\r\n     * @param serializationObject the object to deserialize from.\r\n     */\r\n    deserialize(serializationObject: any) {\r\n        this.uniqueId = serializationObject.uniqueId;\r\n        this.name = serializationObject.name;\r\n        this._connectionType = serializationObject._connectionType;\r\n        this.connectedPointIds = serializationObject.connectedPointIds;\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphConnection, FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { RichType } from \"./flowGraphRichTypes\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\n/**\r\n * Represents a connection point for data.\r\n * An unconnected input point can have a default value.\r\n * An output point will only have a value if it is connected to an input point. Furthermore,\r\n * if the point belongs to a \"function\" node, the node will run its function to update the value.\r\n */\r\nexport class FlowGraphDataConnection<T> extends FlowGraphConnection<FlowGraphBlock, FlowGraphDataConnection<T>> {\r\n    private _isDisabled: boolean = false;\r\n    /**\r\n     * This is used for debugging purposes! It is the last value that was set to this connection with ANY context.\r\n     * Do not use this value for anything else, as it might be wrong if used in a different context.\r\n     */\r\n    private _lastValue: Nullable<T> = null;\r\n\r\n    /**\r\n     * a data transformer function, if needed.\r\n     * This can be used, for example, to force seconds into milliseconds output, if it makes sense in your case.\r\n     */\r\n    public dataTransformer: Nullable<(value: T) => T> = null;\r\n\r\n    /**\r\n     * An observable that is triggered when the value of the connection changes.\r\n     */\r\n    public onValueChangedObservable = new Observable<T>();\r\n    /**\r\n     * Create a new data connection point.\r\n     * @param name the name of the connection\r\n     * @param connectionType the type of the connection\r\n     * @param ownerBlock the block that owns this connection\r\n     * @param richType the type of the data in this block\r\n     * @param _defaultValue the default value of the connection\r\n     * @param _optional if the connection is optional\r\n     */\r\n    public constructor(\r\n        name: string,\r\n        connectionType: FlowGraphConnectionType,\r\n        ownerBlock: FlowGraphBlock,\r\n        /**\r\n         * the type of the data in this block\r\n         */\r\n        public richType: RichType<T>,\r\n        /**\r\n         * [any] the default value of the connection\r\n         */\r\n        private _defaultValue: T = richType.defaultValue,\r\n        /**\r\n         * [false] if the connection is optional\r\n         */\r\n        private _optional: boolean = false\r\n    ) {\r\n        super(name, connectionType, ownerBlock);\r\n    }\r\n\r\n    /**\r\n     * Whether or not the connection is optional.\r\n     * Currently only used for UI control.\r\n     */\r\n    public get optional(): boolean {\r\n        return this._optional;\r\n    }\r\n\r\n    /**\r\n     * is this connection disabled\r\n     * If the connection is disabled you will not be able to connect anything to it.\r\n     */\r\n    public get isDisabled(): boolean {\r\n        return this._isDisabled;\r\n    }\r\n\r\n    public set isDisabled(value: boolean) {\r\n        if (this._isDisabled === value) {\r\n            return;\r\n        }\r\n        this._isDisabled = value;\r\n        if (this._isDisabled) {\r\n            this.disconnectFromAll();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An output data block can connect to multiple input data blocks,\r\n     * but an input data block can only connect to one output data block.\r\n     * @returns true if the connection is singular\r\n     */\r\n    public override _isSingularConnection(): boolean {\r\n        return this.connectionType === FlowGraphConnectionType.Input;\r\n    }\r\n\r\n    /**\r\n     * Set the value of the connection in a specific context.\r\n     * @param value the value to set\r\n     * @param context the context to which the value is set\r\n     */\r\n    public setValue(value: T, context: FlowGraphContext): void {\r\n        // check if the value is different\r\n        if (context._getConnectionValue(this) === value) {\r\n            return;\r\n        }\r\n        context._setConnectionValue(this, value);\r\n        this.onValueChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Reset the value of the connection to the default value.\r\n     * @param context the context in which the value is reset\r\n     */\r\n    public resetToDefaultValue(context: FlowGraphContext): void {\r\n        context._setConnectionValue(this, this._defaultValue);\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another point.\r\n     * @param point the point to connect to.\r\n     */\r\n    public override connectTo(point: FlowGraphDataConnection<T>): void {\r\n        if (this._isDisabled) {\r\n            return;\r\n        }\r\n        super.connectTo(point);\r\n    }\r\n\r\n    private _getValueOrDefault(context: FlowGraphContext): T {\r\n        const val = context._getConnectionValue(this) ?? this._defaultValue;\r\n        return this.dataTransformer ? this.dataTransformer(val) : val;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the connection in a specific context.\r\n     * @param context the context from which the value is retrieved\r\n     * @returns the value of the connection\r\n     */\r\n    public getValue(context: FlowGraphContext): T {\r\n        if (this.connectionType === FlowGraphConnectionType.Output) {\r\n            context._notifyExecuteNode(this._ownerBlock);\r\n            this._ownerBlock._updateOutputs(context);\r\n            const value = this._getValueOrDefault(context);\r\n            this._lastValue = value;\r\n            return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\r\n        }\r\n        const value = !this.isConnected() ? this._getValueOrDefault(context) : this._connectedPoint[0].getValue(context);\r\n        this._lastValue = value;\r\n        return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLastValue(): Nullable<T> {\r\n        return this._lastValue;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the object.\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FlowGraphDataConnection\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this object.\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    public override serialize(serializationObject: any = {}) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.richType = {};\r\n        this.richType.serialize(serializationObject.richType);\r\n        serializationObject.optional = this._optional;\r\n        defaultValueSerializationFunction(\"defaultValue\", this._defaultValue, serializationObject);\r\n    }\r\n}\r\n\r\nRegisterClass(\"FlowGraphDataConnection\", FlowGraphDataConnection);\r\n", "import { RandomGUID } from \"../Misc/guid\";\r\nimport { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport type { RichType } from \"./flowGraphRichTypes\";\r\nimport type { ISerializedFlowGraphBlock, IObjectAccessor } from \"./typeDefinitions\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { FlowGraphAction } from \"./flowGraphLogger\";\r\n\r\n/**\r\n * Options for parsing a block.\r\n */\r\nexport interface IFlowGraphBlockParseOptions {\r\n    /**\r\n     * A function that parses a value from a serialization object.\r\n     * @param key the key of the property\r\n     * @param serializationObject the serialization object where the property is located\r\n     * @param scene the scene that the block is being parsed in\r\n     * @returns the parsed value\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The assets container to use when loading assets.\r\n     */\r\n    assetsContainer?: IAssetContainer;\r\n    /**\r\n     * The scene that the block is being parsed in.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The path converter to use to convert the path to an object accessor.\r\n     */\r\n    pathConverter?: IPathToObjectConverter<IObjectAccessor>;\r\n}\r\n\r\n/**\r\n * Configuration for a block.\r\n */\r\nexport interface IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The name of the block.\r\n     */\r\n    name?: string;\r\n    [extraPropertyKey: string]: any;\r\n}\r\n\r\n/**\r\n * A block in a flow graph. The most basic form\r\n * of a block has inputs and outputs that contain\r\n * data.\r\n */\r\nexport class FlowGraphBlock {\r\n    /**\r\n     * A randomly generated GUID for each block.\r\n     */\r\n    public uniqueId = RandomGUID();\r\n    /**\r\n     * The name of the block.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The data inputs of the block.\r\n     */\r\n    public dataInputs: FlowGraphDataConnection<any>[];\r\n    /**\r\n     * The data outputs of the block.\r\n     */\r\n    public dataOutputs: FlowGraphDataConnection<any>[];\r\n\r\n    /**\r\n     * Metadata that can be used by the block.\r\n     */\r\n    public metadata: any;\r\n\r\n    /** Constructor is protected so only subclasses can be instantiated\r\n     * @param config optional configuration for this block\r\n     * @internal - do not use directly. Extend this class instead.\r\n     */\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        this.name = this.config?.name ?? this.getClassName();\r\n        this.dataInputs = [];\r\n        this.dataOutputs = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * This function is called when the block needs to update its output flows.\r\n     * @param _context the context in which it is running\r\n     */\r\n    public _updateOutputs(_context: FlowGraphContext): void {\r\n        // empty by default, overridden in data blocks\r\n    }\r\n\r\n    /**\r\n     * Registers a data input on the block.\r\n     * @param name the name of the input\r\n     * @param richType the type of the input\r\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\r\n     * @returns the created connection\r\n     */\r\n    public registerDataInput<T>(name: string, richType: RichType<T>, defaultValue?: T): FlowGraphDataConnection<T> {\r\n        const input = new FlowGraphDataConnection(name, FlowGraphConnectionType.Input, this, richType, defaultValue);\r\n        this.dataInputs.push(input);\r\n        return input;\r\n    }\r\n\r\n    /**\r\n     * Registers a data output on the block.\r\n     * @param name the name of the input\r\n     * @param richType the type of the input\r\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\r\n     * @returns the created connection\r\n     */\r\n    public registerDataOutput<T>(name: string, richType: RichType<T>, defaultValue?: T): FlowGraphDataConnection<T> {\r\n        const output = new FlowGraphDataConnection(name, FlowGraphConnectionType.Output, this, richType, defaultValue);\r\n        this.dataOutputs.push(output);\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Given the name of a data input, returns the connection if it exists\r\n     * @param name the name of the input\r\n     * @returns the connection if it exists, undefined otherwise\r\n     */\r\n    public getDataInput(name: string): FlowGraphDataConnection<any> | undefined {\r\n        return this.dataInputs.find((i) => i.name === name);\r\n    }\r\n\r\n    /**\r\n     * Given the name of a data output, returns the connection if it exists\r\n     * @param name the name of the output\r\n     * @returns the connection if it exists, undefined otherwise\r\n     */\r\n    public getDataOutput(name: string): FlowGraphDataConnection<any> | undefined {\r\n        return this.dataOutputs.find((i) => i.name === name);\r\n    }\r\n\r\n    /**\r\n     * Serializes this block\r\n     * @param serializationObject the object to serialize to\r\n     * @param _valueSerializeFunction a function that serializes a specific value\r\n     */\r\n    public serialize(serializationObject: any = {}, _valueSerializeFunction: (key: string, value: any, serializationObject: any) => any = defaultValueSerializationFunction) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.config = {};\r\n        if (this.config) {\r\n            const config = this.config;\r\n            const keys = Object.keys(config);\r\n            for (const key of keys) {\r\n                _valueSerializeFunction(key, config[key], serializationObject.config);\r\n            }\r\n        }\r\n        serializationObject.dataInputs = [];\r\n        serializationObject.dataOutputs = [];\r\n        serializationObject.className = this.getClassName();\r\n        for (const input of this.dataInputs) {\r\n            const serializedInput: any = {};\r\n            input.serialize(serializedInput);\r\n            serializationObject.dataInputs.push(serializedInput);\r\n        }\r\n        for (const output of this.dataOutputs) {\r\n            const serializedOutput: any = {};\r\n            output.serialize(serializedOutput);\r\n            serializationObject.dataOutputs.push(serializedOutput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserializes this block\r\n     * @param _serializationObject the object to deserialize from\r\n     */\r\n    public deserialize(_serializationObject: ISerializedFlowGraphBlock) {\r\n        // no-op by default\r\n    }\r\n\r\n    protected _log(context: FlowGraphContext, action: FlowGraphAction, payload?: any) {\r\n        context.logger?.addLogItem({\r\n            action,\r\n            payload,\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of this block\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FlowGraphBlock\";\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["FlowGraphConnectionType", "value"]
}
