{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts"],
  "sourcesContent": ["import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\ninterface ITransmissionHelperHolder {\r\n    /**\r\n     * @internal\r\n     */\r\n    _transmissionHelper: TransmissionHelper | undefined;\r\n}\r\n\r\ninterface ITransmissionHelperOptions {\r\n    /**\r\n     * The size of the render buffers (default: 1024)\r\n     */\r\n    renderSize: number;\r\n\r\n    /**\r\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\r\n     */\r\n    samples: number;\r\n\r\n    /**\r\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\r\n     */\r\n    lodGenerationScale: number;\r\n\r\n    /**\r\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\r\n     */\r\n    lodGenerationOffset: number;\r\n\r\n    /**\r\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\r\n     */\r\n    renderTargetTextureType: number;\r\n\r\n    /**\r\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\r\n     */\r\n    generateMipmaps: boolean;\r\n\r\n    /**\r\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\r\n     * If provided, should be in linear space\r\n     */\r\n    clearColor?: Color4;\r\n}\r\n\r\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\r\nclass TransmissionHelper {\r\n    /**\r\n     * Creates the default options for the helper.\r\n     * @returns the default options\r\n     */\r\n    private static _GetDefaultOptions(): ITransmissionHelperOptions {\r\n        return {\r\n            renderSize: 1024,\r\n            samples: 4,\r\n            lodGenerationScale: 1,\r\n            lodGenerationOffset: -4,\r\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            generateMipmaps: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene & ITransmissionHelperHolder;\r\n\r\n    private _options: ITransmissionHelperOptions;\r\n\r\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _opaqueMeshesCache: AbstractMesh[] = [];\r\n    private _transparentMeshesCache: AbstractMesh[] = [];\r\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...TransmissionHelper._GetDefaultOptions(),\r\n            ...options,\r\n        };\r\n        this._scene = scene as any;\r\n        this._scene._transmissionHelper = this;\r\n\r\n        this.onErrorObservable = new Observable();\r\n        this._scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._parseScene();\r\n        this._setupRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\r\n        // First check if any options are actually being changed. If not, exit.\r\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\r\n        if (!newValues.length) {\r\n            return;\r\n        }\r\n\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        const oldOptions = this._options;\r\n        this._options = newOptions;\r\n\r\n        // If size changes, recreate everything\r\n        if (\r\n            newOptions.renderSize !== oldOptions.renderSize ||\r\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\r\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\r\n            !this._opaqueRenderTarget\r\n        ) {\r\n            this._setupRenderTargets();\r\n        } else {\r\n            this._opaqueRenderTarget.samples = newOptions.samples;\r\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\r\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the opaque render target texture or null if not available.\r\n     */\r\n    public getOpaqueTarget(): Nullable<Texture> {\r\n        return this._opaqueRenderTarget;\r\n    }\r\n\r\n    private _shouldRenderAsTransmission(material: Nullable<Material>): boolean {\r\n        if (!material) {\r\n            return false;\r\n        }\r\n        if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _addMesh(mesh: AbstractMesh): void {\r\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\r\n\r\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\r\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\r\n        Tools.SetImmediate(() => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n                if (this._transparentMeshesCache.indexOf(mesh) === -1) {\r\n                    this._transparentMeshesCache.push(mesh);\r\n                }\r\n            } else {\r\n                if (this._opaqueMeshesCache.indexOf(mesh) === -1) {\r\n                    this._opaqueMeshesCache.push(mesh);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _removeMesh(mesh: AbstractMesh): void {\r\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\r\n        delete this._materialObservers[mesh.uniqueId];\r\n        let idx = this._transparentMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._transparentMeshesCache.splice(idx, 1);\r\n        }\r\n        idx = this._opaqueMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._opaqueMeshesCache.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    private _parseScene(): void {\r\n        this._scene.meshes.forEach(this._addMesh.bind(this));\r\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\r\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\r\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\r\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\r\n    }\r\n\r\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\r\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\r\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\r\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\r\n\r\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\r\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\r\n        if (useTransmission) {\r\n            if (mesh.material instanceof PBRMaterial) {\r\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n            if (opaqueIdx !== -1) {\r\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else if (transparentIdx === -1) {\r\n                this._transparentMeshesCache.push(mesh);\r\n            }\r\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\r\n        } else {\r\n            if (transparentIdx !== -1) {\r\n                this._transparentMeshesCache.splice(transparentIdx, 1);\r\n                this._opaqueMeshesCache.push(mesh);\r\n            } else if (opaqueIdx === -1) {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Check if the opaque render target has not been disposed and can still be used.\r\n     * @returns\r\n     */\r\n    public _isRenderTargetValid() {\r\n        return this._opaqueRenderTarget?.getInternalTexture() !== null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Setup the render targets according to the specified options.\r\n     */\r\n    public _setupRenderTargets(): void {\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n        }\r\n        this._opaqueRenderTarget = new RenderTargetTexture(\r\n            \"opaqueSceneTexture\",\r\n            this._options.renderSize,\r\n            this._scene,\r\n            this._options.generateMipmaps,\r\n            undefined,\r\n            this._options.renderTargetTextureType\r\n        );\r\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\r\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\r\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\r\n        this._opaqueRenderTarget.gammaSpace = false;\r\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\r\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\r\n        this._opaqueRenderTarget.samples = this._options.samples;\r\n        this._opaqueRenderTarget.renderSprites = true;\r\n        this._opaqueRenderTarget.renderParticles = true;\r\n        this._opaqueRenderTarget.disableImageProcessing = true;\r\n\r\n        let saveSceneEnvIntensity: number;\r\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\r\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\r\n            this._scene.environmentIntensity = 1.0;\r\n            if (!this._options.clearColor) {\r\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, this._scene.getEngine().useExactSrgbConversions);\r\n            } else {\r\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\r\n            }\r\n        });\r\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\r\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\r\n        });\r\n\r\n        for (const mesh of this._transparentMeshesCache) {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        this._scene._transmissionHelper = undefined;\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n            this._opaqueRenderTarget = null;\r\n        }\r\n        this._transparentMeshesCache = [];\r\n        this._opaqueMeshesCache = [];\r\n    }\r\n}\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_transmission extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_transmission\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 175;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n        const pbrMaterial = babylonMaterial;\r\n\r\n        // Enables \"refraction\" texture which represents transmitted light.\r\n        pbrMaterial.subSurface.isRefractionEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n\r\n        // Albedo colour will tint transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\r\n\r\n        if (extension.transmissionFactor !== undefined) {\r\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\r\n            const scene = pbrMaterial.getScene() as unknown as ITransmissionHelperHolder;\r\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\r\n                new TransmissionHelper({}, pbrMaterial.getScene());\r\n            } else if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper?._isRenderTargetValid()) {\r\n                // If the render target is not valid, recreate it.\r\n                scene._transmissionHelper?._setupRenderTargets();\r\n            }\r\n        } else {\r\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\r\n            pbrMaterial.subSurface.isRefractionEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n        if (extension.transmissionTexture) {\r\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\r\n            // eslint-disable-next-line github/no-then\r\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then((texture: BaseTexture) => {\r\n                texture.name = `${babylonMaterial.name} (Transmission)`;\r\n                pbrMaterial.subSurface.refractionIntensityTexture = texture;\r\n                pbrMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_transmission(loader));\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEA,IAAM,qBAAN,MAAM,oBAAkB;;;;;EAKZ,OAAO,qBAAkB;AAC7B,WAAO;MACH,YAAY;MACZ,SAAS;MACT,oBAAoB;MACpB,qBAAqB;MACrB,yBAAyB,UAAU;MACnC,iBAAiB;;EAEzB;;;;;;EAyBA,YAAY,SAA8C,OAAY;AAhB9D,SAAA,sBAAqD;AACrD,SAAA,qBAAqC,CAAA;AACrC,SAAA,0BAA0C,CAAA;AAC1C,SAAA,qBAAyE,CAAA;AAc7E,SAAK,WAAW;MACZ,GAAG,oBAAmB,mBAAkB;MACxC,GAAG;;AAEP,SAAK,SAAS;AACd,SAAK,OAAO,sBAAsB;AAElC,SAAK,oBAAoB,IAAI,WAAU;AACvC,SAAK,OAAO,oBAAoB,QAAQ,MAAK;AACzC,WAAK,QAAO;IAChB,CAAC;AAED,SAAK,YAAW;AAChB,SAAK,oBAAmB;EAC5B;;;;;EAMO,cAAc,SAA4C;AAE7D,UAAM,YAAY,OAAO,KAAK,OAAO,EAAE,OAAO,CAAC,QAAiB,KAAK,SAAiB,GAAG,MAAO,QAAgB,GAAG,CAAC;AACpH,QAAI,CAAC,UAAU,QAAQ;AACnB;IACJ;AAEA,UAAM,aAAa;MACf,GAAG,KAAK;MACR,GAAG;;AAGP,UAAM,aAAa,KAAK;AACxB,SAAK,WAAW;AAGhB,QACI,WAAW,eAAe,WAAW,cACrC,WAAW,4BAA4B,WAAW,2BAClD,WAAW,oBAAoB,WAAW,mBAC1C,CAAC,KAAK,qBACR;AACE,WAAK,oBAAmB;IAC5B,OAAO;AACH,WAAK,oBAAoB,UAAU,WAAW;AAC9C,WAAK,oBAAoB,qBAAqB,WAAW;AACzD,WAAK,oBAAoB,sBAAsB,WAAW;IAC9D;EACJ;;;;EAKO,kBAAe;AAClB,WAAO,KAAK;EAChB;EAEQ,4BAA4B,UAA4B;AAC5D,QAAI,CAAC,UAAU;AACX,aAAO;IACX;AACA,QAAI,oBAAoB,eAAe,SAAS,WAAW,qBAAqB;AAC5E,aAAO;IACX;AACA,WAAO;EACX;EAEQ,SAAS,MAAkB;AAC/B,SAAK,mBAAmB,KAAK,QAAQ,IAAI,KAAK,4BAA4B,IAAI,KAAK,uBAAuB,KAAK,IAAI,CAAC;AAIpH,UAAM,aAAa,MAAK;AACpB,UAAI,KAAK,4BAA4B,KAAK,QAAQ,GAAG;AAChD,aAAK,SAAyB,oBAAoB,KAAK;AACxD,YAAI,KAAK,wBAAwB,QAAQ,IAAI,MAAM,IAAI;AACnD,eAAK,wBAAwB,KAAK,IAAI;QAC1C;MACJ,OAAO;AACH,YAAI,KAAK,mBAAmB,QAAQ,IAAI,MAAM,IAAI;AAC9C,eAAK,mBAAmB,KAAK,IAAI;QACrC;MACJ;IACJ,CAAC;EACL;EAEQ,YAAY,MAAkB;AAClC,SAAK,4BAA4B,OAAO,KAAK,mBAAmB,KAAK,QAAQ,CAAC;AAC9E,WAAO,KAAK,mBAAmB,KAAK,QAAQ;AAC5C,QAAI,MAAM,KAAK,wBAAwB,QAAQ,IAAI;AACnD,QAAI,QAAQ,IAAI;AACZ,WAAK,wBAAwB,OAAO,KAAK,CAAC;IAC9C;AACA,UAAM,KAAK,mBAAmB,QAAQ,IAAI;AAC1C,QAAI,QAAQ,IAAI;AACZ,WAAK,mBAAmB,OAAO,KAAK,CAAC;IACzC;EACJ;EAEQ,cAAW;AACf,SAAK,OAAO,OAAO,QAAQ,KAAK,SAAS,KAAK,IAAI,CAAC;AAEnD,SAAK,OAAO,yBAAyB,IAAI,KAAK,SAAS,KAAK,IAAI,CAAC;AAEjE,SAAK,OAAO,wBAAwB,IAAI,KAAK,YAAY,KAAK,IAAI,CAAC;EACvE;;EAGQ,uBAAuB,MAAkB;AAC7C,UAAM,iBAAiB,KAAK,wBAAwB,QAAQ,IAAI;AAChE,UAAM,YAAY,KAAK,mBAAmB,QAAQ,IAAI;AAGtD,UAAM,kBAAkB,KAAK,4BAA4B,KAAK,QAAQ;AACtE,QAAI,iBAAiB;AACjB,UAAI,KAAK,oBAAoB,aAAa;AACtC,aAAK,SAAS,WAAW,oBAAoB,KAAK;MACtD;AACA,UAAI,cAAc,IAAI;AAClB,aAAK,mBAAmB,OAAO,WAAW,CAAC;AAC3C,aAAK,wBAAwB,KAAK,IAAI;MAC1C,WAAW,mBAAmB,IAAI;AAC9B,aAAK,wBAAwB,KAAK,IAAI;MAC1C;IAEJ,OAAO;AACH,UAAI,mBAAmB,IAAI;AACvB,aAAK,wBAAwB,OAAO,gBAAgB,CAAC;AACrD,aAAK,mBAAmB,KAAK,IAAI;MACrC,WAAW,cAAc,IAAI;AACzB,aAAK,mBAAmB,KAAK,IAAI;MACrC;IACJ;EACJ;;;;;;EAOO,uBAAoB;AAtP/B;AAuPQ,aAAO,UAAK,wBAAL,mBAA0B,0BAAyB;EAC9D;;;;;EAMO,sBAAmB;AA9P9B;AA+PQ,QAAI,KAAK,qBAAqB;AAC1B,WAAK,oBAAoB,QAAO;IACpC;AACA,SAAK,sBAAsB,IAAI,oBAC3B,sBACA,KAAK,SAAS,YACd,KAAK,QACL,KAAK,SAAS,iBACd,QACA,KAAK,SAAS,uBAAuB;AAEzC,SAAK,oBAAoB,uBAAuB;AAChD,SAAK,oBAAoB,aAAa,KAAK;AAC3C,SAAK,oBAAoB,eAAa,UAAK,SAAS,eAAd,mBAA0B,YAAW,KAAK,OAAO,WAAW,MAAK;AACvG,SAAK,oBAAoB,aAAa;AACtC,SAAK,oBAAoB,qBAAqB,KAAK,SAAS;AAC5D,SAAK,oBAAoB,sBAAsB,KAAK,SAAS;AAC7D,SAAK,oBAAoB,UAAU,KAAK,SAAS;AACjD,SAAK,oBAAoB,gBAAgB;AACzC,SAAK,oBAAoB,kBAAkB;AAC3C,SAAK,oBAAoB,yBAAyB;AAElD,QAAI;AACJ,SAAK,oBAAoB,uBAAuB,IAAI,CAAC,uBAAsB;AACvE,8BAAwB,KAAK,OAAO;AACpC,WAAK,OAAO,uBAAuB;AACnC,UAAI,CAAC,KAAK,SAAS,YAAY;AAC3B,aAAK,OAAO,WAAW,mBAAmB,mBAAmB,YAAY,KAAK,OAAO,UAAS,EAAG,uBAAuB;MAC5H,OAAO;AACH,2BAAmB,WAAW,SAAS,KAAK,SAAS,UAAU;MACnE;IACJ,CAAC;AACD,SAAK,oBAAoB,wBAAwB,IAAI,MAAK;AACtD,WAAK,OAAO,uBAAuB;IACvC,CAAC;AAED,eAAW,QAAQ,KAAK,yBAAyB;AAC7C,UAAI,KAAK,4BAA4B,KAAK,QAAQ,GAAG;AAChD,aAAK,SAAyB,oBAAoB,KAAK;MAC5D;IACJ;EACJ;;;;EAKO,UAAO;AACV,SAAK,OAAO,sBAAsB;AAClC,QAAI,KAAK,qBAAqB;AAC1B,WAAK,oBAAoB,QAAO;AAChC,WAAK,sBAAsB;IAC/B;AACA,SAAK,0BAA0B,CAAA;AAC/B,SAAK,qBAAqB,CAAA;EAC9B;;AAGJ,IAAM,OAAO;AAiBP,IAAO,6BAAP,MAAiC;;;;EAqBnC,YAAY,QAAkB;AAjBd,SAAA,OAAO;AAUhB,SAAA,QAAQ;AAQX,SAAK,UAAU;AACf,SAAK,UAAU,KAAK,QAAQ,gBAAgB,IAAI;AAChD,QAAI,KAAK,SAAS;AACd,aAAO,OAAO,yBAAyB;IAC3C;EACJ;;EAGO,UAAO;AACT,SAAK,UAAkB;EAC5B;;;;;EAMO,4BAA4B,SAAiB,UAAqB,iBAAyB;AAC9F,WAAO,WAAW,mBAA8C,SAAS,UAAU,KAAK,MAAM,OAAO,kBAAkB,cAAa;AAChI,YAAM,WAAW,IAAI,MAAK;AAC1B,eAAS,KAAK,KAAK,QAAQ,4BAA4B,SAAS,UAAU,eAAe,CAAC;AAC1F,eAAS,KAAK,KAAK,gCAAgC,kBAAkB,UAAU,iBAAiB,SAAS,CAAC;AAE1G,aAAO,MAAM,QAAQ,IAAI,QAAQ,EAAE,KAAK,MAAK;MAAE,CAAC;IACpD,CAAC;EACL;;EAGQ,gCAAgC,SAAiB,UAAqB,iBAA2B,WAAoC;AA1XjJ;AA2XQ,QAAI,EAAE,2BAA2B,cAAc;AAC3C,YAAM,IAAI,MAAM,GAAG,OAAO,+BAA+B;IAC7D;AACA,UAAM,cAAc;AAGpB,gBAAY,WAAW,sBAAsB;AAG7C,gBAAY,WAAW,0BAA0B;AAGjD,gBAAY,WAAW,4BAA4B;AAEnD,QAAI,UAAU,uBAAuB,QAAW;AAC5C,kBAAY,WAAW,sBAAsB,UAAU;AACvD,YAAM,QAAQ,YAAY,SAAQ;AAClC,UAAI,YAAY,WAAW,uBAAuB,CAAC,MAAM,qBAAqB;AAC1E,YAAI,mBAAmB,CAAA,GAAI,YAAY,SAAQ,CAAE;MACrD,WAAW,YAAY,WAAW,uBAAuB,GAAC,WAAM,wBAAN,mBAA2B,yBAAwB;AAEzG,oBAAM,wBAAN,mBAA2B;MAC/B;IACJ,OAAO;AACH,kBAAY,WAAW,sBAAsB;AAC7C,kBAAY,WAAW,sBAAsB;AAC7C,aAAO,QAAQ,QAAO;IAC1B;AAEA,gBAAY,WAAW,mBAAmB;AAC1C,gBAAY,WAAW,mBAAmB;AAC1C,QAAI,UAAU,qBAAqB;AAC9B,gBAAU,oBAAqC,eAAe;AAE/D,aAAO,KAAK,QAAQ,qBAAqB,GAAG,OAAO,wBAAwB,UAAU,qBAAqB,MAAS,EAAE,KAAK,CAAC,YAAwB;AAC/I,gBAAQ,OAAO,GAAG,gBAAgB,IAAI;AACtC,oBAAY,WAAW,6BAA6B;AACpD,oBAAY,WAAW,uBAAuB;MAClD,CAAC;IACL,OAAO;AACH,aAAO,QAAQ,QAAO;IAC1B;EACJ;;AAGJ,wBAAwB,IAAI;AAC5B,sBAAsB,MAAM,MAAM,CAAC,WAAW,IAAI,2BAA2B,MAAM,CAAC;",
  "names": []
}
