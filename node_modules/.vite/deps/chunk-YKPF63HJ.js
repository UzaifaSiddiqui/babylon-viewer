import {
  SPLATFileLoaderMetadata
} from "./chunk-YNV2IMVX.js";
import {
  GaussianSplattingMesh,
  PointsCloudSystem
} from "./chunk-MRHXUGSC.js";
import {
  Scalar
} from "./chunk-E4FFGQ24.js";
import {
  AssetContainer
} from "./chunk-W66XTUVP.js";
import {
  Mesh,
  VertexData
} from "./chunk-D5TD3MFB.js";
import {
  RegisterSceneLoaderPlugin
} from "./chunk-LKIVOIS4.js";
import {
  Color4
} from "./chunk-ZUPBS36P.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  Vector3
} from "./chunk-5BUGPWC4.js";

// node_modules/@babylonjs/loaders/SPLAT/splatFileLoader.js
var Mode;
(function(Mode2) {
  Mode2[Mode2["Splat"] = 0] = "Splat";
  Mode2[Mode2["PointCloud"] = 1] = "PointCloud";
  Mode2[Mode2["Mesh"] = 2] = "Mesh";
  Mode2[Mode2["Reject"] = 3] = "Reject";
})(Mode || (Mode = {}));
var SPLATFileLoader = class _SPLATFileLoader {
  /**
   * Creates loader for gaussian splatting files
   * @param loadingOptions options for loading and parsing splat and PLY files.
   */
  constructor(loadingOptions = _SPLATFileLoader._DefaultLoadingOptions) {
    this.name = SPLATFileLoaderMetadata.name;
    this._assetContainer = null;
    this.extensions = SPLATFileLoaderMetadata.extensions;
    this._loadingOptions = loadingOptions;
  }
  /** @internal */
  createPlugin(options) {
    return new _SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);
  }
  /**
   * Imports  from the loaded gaussian splatting data and adds them to the scene
   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
   * @param scene the scene the meshes should be added to
   * @param data the gaussian splatting data to load
   * @param rootUrl root url to load from
   * @param _onProgress callback called while file is loading
   * @param _fileName Defines the name of the file to load
   * @returns a promise containing the loaded meshes, particles, skeletons and animations
   */
  async importMeshAsync(meshesNames, scene, data, rootUrl, _onProgress, _fileName) {
    return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {
      return {
        meshes,
        particleSystems: [],
        skeletons: [],
        animationGroups: [],
        transformNodes: [],
        geometries: [],
        lights: [],
        spriteManagers: []
      };
    });
  }
  static _BuildPointCloud(pointcloud, data) {
    if (!data.byteLength) {
      return false;
    }
    const uBuffer = new Uint8Array(data);
    const fBuffer = new Float32Array(data);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    const pointcloudfunc = function(particle, i) {
      const x = fBuffer[8 * i + 0];
      const y = fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      particle.position = new Vector3(x, y, z);
      const r = uBuffer[rowLength * i + 24 + 0] / 255;
      const g = uBuffer[rowLength * i + 24 + 1] / 255;
      const b = uBuffer[rowLength * i + 24 + 2] / 255;
      particle.color = new Color4(r, g, b, 1);
    };
    pointcloud.addPoints(vertexCount, pointcloudfunc);
    return true;
  }
  static _BuildMesh(scene, parsedPLY) {
    const mesh = new Mesh("PLYMesh", scene);
    const uBuffer = new Uint8Array(parsedPLY.data);
    const fBuffer = new Float32Array(parsedPLY.data);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    const positions = [];
    const vertexData = new VertexData();
    for (let i = 0; i < vertexCount; i++) {
      const x = fBuffer[8 * i + 0];
      const y = fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      positions.push(x, y, z);
    }
    if (parsedPLY.hasVertexColors) {
      const colors = new Float32Array(vertexCount * 4);
      for (let i = 0; i < vertexCount; i++) {
        const r = uBuffer[rowLength * i + 24 + 0] / 255;
        const g = uBuffer[rowLength * i + 24 + 1] / 255;
        const b = uBuffer[rowLength * i + 24 + 2] / 255;
        colors[i * 4 + 0] = r;
        colors[i * 4 + 1] = g;
        colors[i * 4 + 2] = b;
        colors[i * 4 + 3] = 1;
      }
      vertexData.colors = colors;
    }
    vertexData.positions = positions;
    vertexData.indices = parsedPLY.faces;
    vertexData.applyToMesh(mesh);
    return mesh;
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _parseSPZAsync(data, scene) {
    const ubuf = new Uint8Array(data);
    const ubufu32 = new Uint32Array(data.slice(0, 12));
    const splatCount = ubufu32[2];
    const shDegree = ubuf[12];
    const fractionalBits = ubuf[13];
    const flags = ubuf[14];
    const reserved = ubuf[15];
    if (reserved || ubufu32[0] != 1347635022 || ubufu32[1] != 2) {
      return new Promise((resolve) => {
        resolve({ mode: 3, data: buffer, hasVertexColors: false });
      });
    }
    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4;
    const buffer = new ArrayBuffer(rowOutputLength * splatCount);
    const positionScale = 1 / (1 << fractionalBits);
    const int32View = new Int32Array(1);
    const uint8View = new Uint8Array(int32View.buffer);
    const read24bComponent = function(u8, offset) {
      uint8View[0] = u8[offset + 0];
      uint8View[1] = u8[offset + 1];
      uint8View[2] = u8[offset + 2];
      uint8View[3] = u8[offset + 2] & 128 ? 255 : 0;
      return int32View[0] * positionScale;
    };
    let byteOffset = 16;
    const position = new Float32Array(buffer);
    const scale = new Float32Array(buffer);
    const rgba = new Uint8ClampedArray(buffer);
    const rot = new Uint8ClampedArray(buffer);
    let coordinateSign = 1;
    let quaternionOffset = 0;
    if (!this._loadingOptions.flipY) {
      coordinateSign = -1;
      quaternionOffset = 255;
    }
    for (let i = 0; i < splatCount; i++) {
      position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);
      position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);
      position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);
      byteOffset += 9;
    }
    const shC0 = 0.282;
    for (let i = 0; i < splatCount; i++) {
      for (let component = 0; component < 3; component++) {
        const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];
        const value = (byteValue - 127.5) / (0.15 * 255);
        rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);
      }
      rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];
    }
    byteOffset += splatCount * 4;
    for (let i = 0; i < splatCount; i++) {
      scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16 - 10);
      scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16 - 10);
      scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16 - 10);
      byteOffset += 3;
    }
    for (let i = 0; i < splatCount; i++) {
      const x = ubuf[byteOffset + 0];
      const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;
      const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;
      const nx = x / 127.5 - 1;
      const ny = y / 127.5 - 1;
      const nz = z / 127.5 - 1;
      rot[i * 32 + 28 + 1] = x;
      rot[i * 32 + 28 + 2] = y;
      rot[i * 32 + 28 + 3] = z;
      const v = 1 - (nx * nx + ny * ny + nz * nz);
      rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;
      byteOffset += 3;
    }
    if (shDegree) {
      const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;
      const shComponentCount = shVectorCount * 3;
      const textureCount = Math.ceil(shComponentCount / 16);
      let shIndexRead = byteOffset;
      const sh = [];
      const engine = scene.getEngine();
      const width = engine.getCaps().maxTextureSize;
      const height = Math.ceil(splatCount / width);
      for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {
        const texture = new Uint8Array(height * width * 4 * 4);
        sh.push(texture);
      }
      for (let i = 0; i < splatCount; i++) {
        for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {
          const shValue = ubuf[shIndexRead++];
          const textureIndex = Math.floor(shIndexWrite / 16);
          const shArray = sh[textureIndex];
          const byteIndexInTexture = shIndexWrite % 16;
          const offsetPerSplat = i * 16;
          shArray[byteIndexInTexture + offsetPerSplat] = shValue;
        }
      }
      return new Promise((resolve) => {
        resolve({ mode: 0, data: buffer, hasVertexColors: false, sh, trainedWithAntialiasing: !!flags });
      });
    }
    return new Promise((resolve) => {
      resolve({ mode: 0, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _parseAsync(meshesNames, scene, data, _rootUrl) {
    const babylonMeshesArray = [];
    const readableStream = new ReadableStream({
      start(controller) {
        controller.enqueue(new Uint8Array(data));
        controller.close();
      }
    });
    const decompressionStream = new DecompressionStream("gzip");
    const decompressedStream = readableStream.pipeThrough(decompressionStream);
    return new Promise((resolve) => {
      new Response(decompressedStream).arrayBuffer().then((buffer) => {
        this._parseSPZAsync(buffer, scene).then((parsedSPZ) => {
          scene._blockEntityCollection = !!this._assetContainer;
          const gaussianSplatting = new GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
          if (parsedSPZ.trainedWithAntialiasing) {
            const gsMaterial = gaussianSplatting.material;
            gsMaterial.kernelSize = 0.1;
            gsMaterial.compensation = true;
          }
          gaussianSplatting._parentContainer = this._assetContainer;
          babylonMeshesArray.push(gaussianSplatting);
          gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);
          scene._blockEntityCollection = false;
          resolve(babylonMeshesArray);
        });
      }).catch(() => {
        _SPLATFileLoader._ConvertPLYToSplat(data).then(async (parsedPLY) => {
          scene._blockEntityCollection = !!this._assetContainer;
          switch (parsedPLY.mode) {
            case 0:
              {
                const gaussianSplatting = new GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
                gaussianSplatting._parentContainer = this._assetContainer;
                babylonMeshesArray.push(gaussianSplatting);
                gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);
                if (parsedPLY.compressed || !parsedPLY.rawSplat) {
                  gaussianSplatting.viewDirectionFactor.set(-1, -1, 1);
                }
              }
              break;
            case 1:
              {
                const pointcloud = new PointsCloudSystem("PointCloud", 1, scene);
                if (_SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {
                  await pointcloud.buildMeshAsync().then((mesh) => {
                    babylonMeshesArray.push(mesh);
                  });
                } else {
                  pointcloud.dispose();
                }
              }
              break;
            case 2:
              {
                if (parsedPLY.faces) {
                  babylonMeshesArray.push(_SPLATFileLoader._BuildMesh(scene, parsedPLY));
                } else {
                  throw new Error("PLY mesh doesn't contain face informations.");
                }
              }
              break;
            default:
              throw new Error("Unsupported Splat mode");
          }
          scene._blockEntityCollection = false;
          resolve(babylonMeshesArray);
        });
      });
    });
  }
  /**
   * Load into an asset container.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns The loaded asset container
   */
  // eslint-disable-next-line no-restricted-syntax
  loadAssetContainerAsync(scene, data, rootUrl) {
    const container = new AssetContainer(scene);
    this._assetContainer = container;
    return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {
      for (const mesh of result.meshes) {
        container.meshes.push(mesh);
      }
      this._assetContainer = null;
      return container;
    }).catch((ex) => {
      this._assetContainer = null;
      throw ex;
    });
  }
  /**
   * Imports all objects from the loaded OBJ data and adds them to the scene
   * @param scene the scene the objects should be added to
   * @param data the OBJ data to load
   * @param rootUrl root url to load from
   * @returns a promise which completes when objects have been loaded to the scene
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  loadAsync(scene, data, rootUrl) {
    return this.importMeshAsync(null, scene, data, rootUrl).then(() => {
    });
  }
  /**
   * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license
   * Converts a .ply data array buffer to splat
   * if data array buffer is not ply, returns the original buffer
   * @param data the .ply data to load
   * @returns the loaded splat buffer
   */
  static _ConvertPLYToSplat(data) {
    const ubuf = new Uint8Array(data);
    const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
    const headerEnd = "end_header\n";
    const headerEndIndex = header.indexOf(headerEnd);
    if (headerEndIndex < 0 || !header) {
      return new Promise((resolve) => {
        resolve({ mode: 0, data, rawSplat: true });
      });
    }
    const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
    const faceElement = /element face (\d+)\n/.exec(header);
    let faceCount = 0;
    if (faceElement) {
      faceCount = parseInt(faceElement[1]);
    }
    const chunkElement = /element chunk (\d+)\n/.exec(header);
    let chunkCount = 0;
    if (chunkElement) {
      chunkCount = parseInt(chunkElement[1]);
    }
    let rowVertexOffset = 0;
    let rowChunkOffset = 0;
    const offsets = {
      double: 8,
      int: 4,
      uint: 4,
      float: 4,
      short: 2,
      ushort: 2,
      uchar: 1,
      list: 0
    };
    let ElementMode;
    (function(ElementMode2) {
      ElementMode2[ElementMode2["Vertex"] = 0] = "Vertex";
      ElementMode2[ElementMode2["Chunk"] = 1] = "Chunk";
      ElementMode2[ElementMode2["SH"] = 2] = "SH";
    })(ElementMode || (ElementMode = {}));
    let chunkMode = 1;
    const vertexProperties = [];
    const chunkProperties = [];
    const filtered = header.slice(0, headerEndIndex).split("\n");
    for (const prop of filtered) {
      if (prop.startsWith("property ")) {
        const [, type, name] = prop.split(" ");
        if (chunkMode == 1) {
          chunkProperties.push({ name, type, offset: rowChunkOffset });
          rowChunkOffset += offsets[type];
        } else if (chunkMode == 0) {
          vertexProperties.push({ name, type, offset: rowVertexOffset });
          rowVertexOffset += offsets[type];
        } else if (chunkMode == 2) {
          vertexProperties.push({ name, type, offset: rowVertexOffset });
        }
        if (!offsets[type]) {
          Logger.Warn(`Unsupported property type: ${type}.`);
        }
      } else if (prop.startsWith("element ")) {
        const [, type] = prop.split(" ");
        if (type == "chunk") {
          chunkMode = 1;
        } else if (type == "vertex") {
          chunkMode = 0;
        } else if (type == "sh") {
          chunkMode = 2;
        }
      }
    }
    const rowVertexLength = rowVertexOffset;
    const rowChunkLength = rowChunkOffset;
    return GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then(async (splatsData) => {
      const dataView = new DataView(data, headerEndIndex + headerEnd.length);
      let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;
      const faces = [];
      if (faceCount) {
        for (let i = 0; i < faceCount; i++) {
          const faceVertexCount = dataView.getUint8(offset);
          if (faceVertexCount != 3) {
            continue;
          }
          offset += 1;
          for (let j = 0; j < faceVertexCount; j++) {
            const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true);
            faces.push(vertexIndex);
          }
          offset += 12;
        }
      }
      if (chunkCount) {
        return await new Promise((resolve) => {
          resolve({ mode: 0, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: false, compressed: true, rawSplat: false });
        });
      }
      let propertyCount = 0;
      let propertyColorCount = 0;
      const splatProperties = ["x", "y", "z", "scale_0", "scale_1", "scale_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3"];
      const splatColorProperties = ["red", "green", "blue", "f_dc_0", "f_dc_1", "f_dc_2"];
      for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {
        const property = vertexProperties[propertyIndex];
        if (splatProperties.includes(property.name)) {
          propertyCount++;
        }
        if (splatColorProperties.includes(property.name)) {
          propertyColorCount++;
        }
      }
      const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;
      const currentMode = faceCount ? 2 : hasMandatoryProperties ? 0 : 1;
      return await new Promise((resolve) => {
        resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: !!propertyColorCount, compressed: false, rawSplat: false });
      });
    });
  }
};
SPLATFileLoader._DefaultLoadingOptions = {
  keepInRam: false,
  flipY: false
};
RegisterSceneLoaderPlugin(new SPLATFileLoader());

export {
  SPLATFileLoader
};
//# sourceMappingURL=chunk-YKPF63HJ.js.map
