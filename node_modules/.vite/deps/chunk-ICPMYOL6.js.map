{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts"],
  "sourcesContent": ["import { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport type { GLTFLoader } from \"../glTFLoader\";\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport { addNewInteractivityFlowGraphMapping } from \"./KHR_interactivity/declarationMapper\";\nimport type { INode } from \"../glTFLoaderInterfaces\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\n\nconst NAME = \"KHR_node_hoverability\";\n\ndeclare module \"../../glTFFileLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface GLTFLoaderExtensionOptions {\n        /**\n         * Defines options for the KHR_node_hoverability extension.\n         */\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\n        [\"KHR_node_hoverability\"]: {};\n    }\n}\n\n// interactivity\nconst MeshPointerOverPrefix = \"targetMeshPointerOver_\";\naddNewInteractivityFlowGraphMapping(\"event/onHoverIn\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.PointerOverEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [MeshPointerOverPrefix + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            hoverNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"targetMesh\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"meshUnderPointer\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n        // find the listener nodeIndex value\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = MeshPointerOverPrefix + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\nconst MeshPointerOutPrefix = \"targetMeshPointerOut_\";\naddNewInteractivityFlowGraphMapping(\"event/onHoverOut\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.PointerOutEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [MeshPointerOutPrefix + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            hoverNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"targetMesh\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"meshOutOfPointer\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = MeshPointerOutPrefix + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_hoverability/hoverable\", {\n    get: (node: INode) => {\n        const tn = node._babylonTransformNode as any;\n        if (tn && tn.pointerOverDisableMeshTesting !== undefined) {\n            return tn.pointerOverDisableMeshTesting;\n        }\n        return true;\n    },\n    set: (value: boolean, node: INode) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.pointerOverDisableMeshTesting = !value;\n        });\n    },\n    getTarget: (node: INode) => node._babylonTransformNode,\n    getPropertyName: [() => \"pointerOverDisableMeshTesting\"],\n    type: \"boolean\",\n});\n\n/**\n * Loader extension for KHR_node_hoverability\n * @see https://github.com/KhronosGroup/glTF/pull/2426\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_hoverability implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n\n    /**\n     * @internal\n     */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises\n    public async onReady(): Promise<void> {\n        this._loader.gltf.nodes?.forEach((node) => {\n            // default is true, so only apply if false\n            if (node.extensions?.KHR_node_hoverability && node.extensions?.KHR_node_hoverability.hoverable === false) {\n                node._babylonTransformNode?.getChildMeshes().forEach((mesh) => {\n                    mesh.pointerOverDisableMeshTesting = true;\n                });\n            }\n        });\n    }\n\n    public dispose() {\n        (this._loader as any) = null;\n    }\n}\n\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_hoverability(loader));\n"],
  "mappings": "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",
  "names": ["_a"]
}
