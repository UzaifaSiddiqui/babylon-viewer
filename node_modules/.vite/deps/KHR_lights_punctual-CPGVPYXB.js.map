{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IKHRLightsPunctual_LightReference } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { INode, IKHRLightsPunctual_Light } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_lights_punctual extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_lights_punctual\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IKHRLightsPunctual_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name];\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRLightsPunctual_LightReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                let babylonLight: Light;\r\n\r\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                switch (light.type) {\r\n                    case KHRLightsPunctual_LightType.DIRECTIONAL: {\r\n                        const babylonDirectionalLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\r\n                        babylonDirectionalLight.position.setAll(0);\r\n                        babylonLight = babylonDirectionalLight;\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.POINT: {\r\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.SPOT: {\r\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\r\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\r\n                        babylonLight = babylonSpotLight;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        this._loader.babylonScene._blockEntityCollection = false;\r\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\r\n                    }\r\n                }\r\n\r\n                babylonLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonLight;\r\n\r\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\r\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\r\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\r\n                babylonLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_lights(loader));\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,IAAM,OAAO;AAiBP,IAAO,aAAP,MAAiB;;;;EAkBnB,YAAY,QAAkB;AAdd,SAAA,OAAO;AAenB,SAAK,UAAU;AACf,SAAK,UAAU,KAAK,QAAQ,gBAAgB,IAAI;EACpD;;EAGO,UAAO;AACT,SAAK,UAAkB;AACxB,WAAO,KAAK;EAChB;;EAGO,YAAS;AACZ,UAAM,aAAa,KAAK,QAAQ,KAAK;AACrC,QAAI,cAAc,WAAW,KAAK,IAAI,GAAG;AACrC,YAAM,YAAY,WAAW,KAAK,IAAI;AACtC,WAAK,UAAU,UAAU;AACzB,gBAAU,OAAO,KAAK,OAAO;IACjC;EACJ;;;;;EAMO,cAAc,SAAiB,MAAa,QAAqD;AACpG,WAAO,WAAW,mBAAqE,SAAS,MAAM,KAAK,MAAM,OAAO,kBAAkB,cAAa;AACnJ,WAAK,QAAQ,6BAA6B;AAE1C,aAAO,MAAM,KAAK,QAAQ,cAAc,SAAS,MAAM,CAAC,gBAAe;AACnE,YAAI;AAEJ,cAAM,QAAQ,UAAU,IAAI,kBAAkB,KAAK,SAAS,UAAU,KAAK;AAC3E,cAAM,OAAO,MAAM,QAAQ,YAAY;AAEvC,aAAK,QAAQ,aAAa,yBAAyB,CAAC,CAAC,KAAK,QAAQ;AAElE,gBAAQ,MAAM,MAAM;UAChB,KAAA,eAA8C;AAC1C,kBAAM,0BAA0B,IAAI,iBAAiB,MAAM,QAAQ,SAAQ,GAAI,KAAK,QAAQ,YAAY;AACxG,oCAAwB,SAAS,OAAO,CAAC;AACzC,2BAAe;AACf;UACJ;UACA,KAAA,SAAwC;AACpC,2BAAe,IAAI,WAAW,MAAM,QAAQ,KAAI,GAAI,KAAK,QAAQ,YAAY;AAC7E;UACJ;UACA,KAAA,QAAuC;AACnC,kBAAM,mBAAmB,IAAI,UAAU,MAAM,QAAQ,KAAI,GAAI,QAAQ,SAAQ,GAAI,GAAG,GAAG,KAAK,QAAQ,YAAY;AAChH,6BAAiB,SAAU,MAAM,QAAQ,MAAM,KAAK,kBAAmB,KAAK,KAAK,KAAK;AACtF,6BAAiB,cAAe,MAAM,QAAQ,MAAM,KAAK,kBAAmB,KAAK;AACjF,2BAAe;AACf;UACJ;UACA,SAAS;AACL,iBAAK,QAAQ,aAAa,yBAAyB;AACnD,kBAAM,IAAI,MAAM,GAAG,gBAAgB,yBAAyB,MAAM,IAAI,GAAG;UAC7E;QACJ;AAEA,qBAAa,mBAAmB,KAAK,QAAQ;AAC7C,aAAK,QAAQ,aAAa,yBAAyB;AACnD,cAAM,gBAAgB;AAEtB,qBAAa,cAAc,MAAM;AACjC,qBAAa,UAAU,MAAM,QAAQ,OAAO,UAAU,MAAM,KAAK,IAAI,OAAO,MAAK;AACjF,qBAAa,YAAY,MAAM,aAAa,SAAY,IAAI,MAAM;AAClE,qBAAa,QAAQ,MAAM,SAAS,SAAY,OAAO,YAAY,MAAM;AACzE,qBAAa,SAAS;AAEtB,aAAK,QAAQ,eAAe,KAAK,YAAY;AAE7C,mBAAW,mBAAmB,cAAc,gBAAgB;AAE5D,eAAO,WAAW;MACtB,CAAC;IACL,CAAC;EACL;;AAGJ,wBAAwB,IAAI;AAC5B,sBAAsB,MAAM,MAAM,CAAC,WAAW,IAAI,WAAW,MAAM,CAAC;",
  "names": []
}
