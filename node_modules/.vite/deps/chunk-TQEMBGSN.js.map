{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/flowGraphBlockFactory.ts", "../../../dev/core/src/FlowGraph/flowGraphParser.ts"],
  "sourcesContent": ["import type { FlowGraphBlock } from \"../flowGraphBlock\";\nimport { FlowGraphBlockNames } from \"./flowGraphBlockNames\";\n\n/**\n * Any external module that wishes to add a new block to the flow graph can add to this object using the helper function.\n */\nconst CustomBlocks: Record<string, () => Promise<typeof FlowGraphBlock>> = {};\n\n/**\n * If you want to add a new block to the block factory, you should use this function.\n * Please be sure to choose a unique name and define the responsible module.\n * @param module the name of the module that is responsible for the block\n * @param blockName the name of the block. This should be unique.\n * @param factory an async factory function to generate the block\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function addToBlockFactory(module: string, blockName: string, factory: () => Promise<typeof FlowGraphBlock>): void {\n    CustomBlocks[`${module}/${blockName}`] = factory;\n}\n\n/**\n * a function to get a factory function for a block.\n * @param blockName the block name to initialize. If the block comes from an external module, the name should be in the format \"module/blockName\"\n * @returns an async factory function that will return the block class when called.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function blockFactory(blockName: FlowGraphBlockNames | string): () => Promise<typeof FlowGraphBlock> {\n    switch (blockName) {\n        case FlowGraphBlockNames.PlayAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPlayAnimationBlock\")).FlowGraphPlayAnimationBlock;\n        case FlowGraphBlockNames.StopAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphStopAnimationBlock\")).FlowGraphStopAnimationBlock;\n        case FlowGraphBlockNames.PauseAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPauseAnimationBlock\")).FlowGraphPauseAnimationBlock;\n        case FlowGraphBlockNames.ValueInterpolation:\n            return async () => (await import(\"./Execution/Animation/flowGraphInterpolationBlock\")).FlowGraphInterpolationBlock;\n        case FlowGraphBlockNames.SceneReadyEvent:\n            return async () => (await import(\"./Event/flowGraphSceneReadyEventBlock\")).FlowGraphSceneReadyEventBlock;\n        case FlowGraphBlockNames.SceneTickEvent:\n            return async () => (await import(\"./Event/flowGraphSceneTickEventBlock\")).FlowGraphSceneTickEventBlock;\n        case FlowGraphBlockNames.SendCustomEvent:\n            return async () => (await import(\"./Event/flowGraphSendCustomEventBlock\")).FlowGraphSendCustomEventBlock;\n        case FlowGraphBlockNames.ReceiveCustomEvent:\n            return async () => (await import(\"./Event/flowGraphReceiveCustomEventBlock\")).FlowGraphReceiveCustomEventBlock;\n        case FlowGraphBlockNames.MeshPickEvent:\n            return async () => (await import(\"./Event/flowGraphMeshPickEventBlock\")).FlowGraphMeshPickEventBlock;\n        case FlowGraphBlockNames.E:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEBlock;\n        case FlowGraphBlockNames.PI:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPiBlock;\n        case FlowGraphBlockNames.Inf:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphInfBlock;\n        case FlowGraphBlockNames.NaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNaNBlock;\n        case FlowGraphBlockNames.Random:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRandomBlock;\n        case FlowGraphBlockNames.Add:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAddBlock;\n        case FlowGraphBlockNames.Subtract:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSubtractBlock;\n        case FlowGraphBlockNames.Multiply:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMultiplyBlock;\n        case FlowGraphBlockNames.Divide:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDivideBlock;\n        case FlowGraphBlockNames.Abs:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAbsBlock;\n        case FlowGraphBlockNames.Sign:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSignBlock;\n        case FlowGraphBlockNames.Trunc:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTruncBlock;\n        case FlowGraphBlockNames.Floor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFloorBlock;\n        case FlowGraphBlockNames.Ceil:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCeilBlock;\n        case FlowGraphBlockNames.Round:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRoundBlock;\n        case FlowGraphBlockNames.Fraction:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFractionBlock;\n        case FlowGraphBlockNames.Negation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNegationBlock;\n        case FlowGraphBlockNames.Modulo:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphModuloBlock;\n        case FlowGraphBlockNames.Min:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMinBlock;\n        case FlowGraphBlockNames.Max:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMaxBlock;\n        case FlowGraphBlockNames.Clamp:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphClampBlock;\n        case FlowGraphBlockNames.Saturate:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSaturateBlock;\n        case FlowGraphBlockNames.MathInterpolation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMathInterpolationBlock;\n        case FlowGraphBlockNames.Equality:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEqualityBlock;\n        case FlowGraphBlockNames.LessThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanBlock;\n        case FlowGraphBlockNames.LessThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanOrEqualBlock;\n        case FlowGraphBlockNames.GreaterThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanBlock;\n        case FlowGraphBlockNames.GreaterThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanOrEqualBlock;\n        case FlowGraphBlockNames.IsNaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsNanBlock;\n        case FlowGraphBlockNames.IsInfinity:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsInfinityBlock;\n        case FlowGraphBlockNames.DegToRad:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDegToRadBlock;\n        case FlowGraphBlockNames.RadToDeg:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRadToDegBlock;\n        case FlowGraphBlockNames.Sin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinBlock;\n        case FlowGraphBlockNames.Cos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCosBlock;\n        case FlowGraphBlockNames.Tan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanBlock;\n        case FlowGraphBlockNames.Asin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinBlock;\n        case FlowGraphBlockNames.Acos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcosBlock;\n        case FlowGraphBlockNames.Atan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanBlock;\n        case FlowGraphBlockNames.Atan2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtan2Block;\n        case FlowGraphBlockNames.Sinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinhBlock;\n        case FlowGraphBlockNames.Cosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCoshBlock;\n        case FlowGraphBlockNames.Tanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanhBlock;\n        case FlowGraphBlockNames.Asinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinhBlock;\n        case FlowGraphBlockNames.Acosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcoshBlock;\n        case FlowGraphBlockNames.Atanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanhBlock;\n        case FlowGraphBlockNames.Exponential:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphExpBlock;\n        case FlowGraphBlockNames.Log:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLogBlock;\n        case FlowGraphBlockNames.Log2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog2Block;\n        case FlowGraphBlockNames.Log10:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog10Block;\n        case FlowGraphBlockNames.SquareRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSquareRootBlock;\n        case FlowGraphBlockNames.Power:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPowerBlock;\n        case FlowGraphBlockNames.CubeRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCubeRootBlock;\n        case FlowGraphBlockNames.BitwiseAnd:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseAndBlock;\n        case FlowGraphBlockNames.BitwiseOr:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseOrBlock;\n        case FlowGraphBlockNames.BitwiseNot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseNotBlock;\n        case FlowGraphBlockNames.BitwiseXor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseXorBlock;\n        case FlowGraphBlockNames.BitwiseLeftShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseLeftShiftBlock;\n        case FlowGraphBlockNames.BitwiseRightShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseRightShiftBlock;\n        case FlowGraphBlockNames.Length:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphLengthBlock;\n        case FlowGraphBlockNames.Normalize:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphNormalizeBlock;\n        case FlowGraphBlockNames.Dot:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphDotBlock;\n        case FlowGraphBlockNames.Cross:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphCrossBlock;\n        case FlowGraphBlockNames.Rotate2D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate2DBlock;\n        case FlowGraphBlockNames.Rotate3D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate3DBlock;\n        case FlowGraphBlockNames.Transpose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphTransposeBlock;\n        case FlowGraphBlockNames.Determinant:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphDeterminantBlock;\n        case FlowGraphBlockNames.InvertMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphInvertMatrixBlock;\n        case FlowGraphBlockNames.MatrixMultiplication:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixMultiplicationBlock;\n        case FlowGraphBlockNames.Branch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphBranchBlock\")).FlowGraphBranchBlock;\n        case FlowGraphBlockNames.SetDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSetDelayBlock\")).FlowGraphSetDelayBlock;\n        case FlowGraphBlockNames.CancelDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCancelDelayBlock\")).FlowGraphCancelDelayBlock;\n        case FlowGraphBlockNames.CallCounter:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCounterBlock\")).FlowGraphCallCounterBlock;\n        case FlowGraphBlockNames.Debounce:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDebounceBlock\")).FlowGraphDebounceBlock;\n        case FlowGraphBlockNames.Throttle:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphThrottleBlock\")).FlowGraphThrottleBlock;\n        case FlowGraphBlockNames.DoN:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDoNBlock\")).FlowGraphDoNBlock;\n        case FlowGraphBlockNames.FlipFlop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphFlipFlopBlock\")).FlowGraphFlipFlopBlock;\n        case FlowGraphBlockNames.ForLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphForLoopBlock\")).FlowGraphForLoopBlock;\n        case FlowGraphBlockNames.MultiGate:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphMultiGateBlock\")).FlowGraphMultiGateBlock;\n        case FlowGraphBlockNames.Sequence:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSequenceBlock\")).FlowGraphSequenceBlock;\n        case FlowGraphBlockNames.Switch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSwitchBlock\")).FlowGraphSwitchBlock;\n        case FlowGraphBlockNames.WaitAll:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWaitAllBlock\")).FlowGraphWaitAllBlock;\n        case FlowGraphBlockNames.WhileLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWhileLoopBlock\")).FlowGraphWhileLoopBlock;\n        case FlowGraphBlockNames.ConsoleLog:\n            return async () => (await import(\"./Execution/flowGraphConsoleLogBlock\")).FlowGraphConsoleLogBlock;\n        case FlowGraphBlockNames.Conditional:\n            return async () => (await import(\"./Data/flowGraphConditionalDataBlock\")).FlowGraphConditionalDataBlock;\n        case FlowGraphBlockNames.Constant:\n            return async () => (await import(\"./Data/flowGraphConstantBlock\")).FlowGraphConstantBlock;\n        case FlowGraphBlockNames.TransformCoordinatesSystem:\n            return async () => (await import(\"./Data/flowGraphTransformCoordinatesSystemBlock\")).FlowGraphTransformCoordinatesSystemBlock;\n        case FlowGraphBlockNames.GetAsset:\n            return async () => (await import(\"./Data/flowGraphGetAssetBlock\")).FlowGraphGetAssetBlock;\n        case FlowGraphBlockNames.GetProperty:\n            return async () => (await import(\"./Data/flowGraphGetPropertyBlock\")).FlowGraphGetPropertyBlock;\n        case FlowGraphBlockNames.SetProperty:\n            return async () => (await import(\"./Execution/flowGraphSetPropertyBlock\")).FlowGraphSetPropertyBlock;\n        case FlowGraphBlockNames.GetVariable:\n            return async () => (await import(\"./Data/flowGraphGetVariableBlock\")).FlowGraphGetVariableBlock;\n        case FlowGraphBlockNames.SetVariable:\n            return async () => (await import(\"./Execution/flowGraphSetVariableBlock\")).FlowGraphSetVariableBlock;\n        case FlowGraphBlockNames.JsonPointerParser:\n            return async () => (await import(\"./Data/Transformers/flowGraphJsonPointerParserBlock\")).FlowGraphJsonPointerParserBlock;\n        case FlowGraphBlockNames.LeadingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLeadingZerosBlock;\n        case FlowGraphBlockNames.TrailingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTrailingZerosBlock;\n        case FlowGraphBlockNames.OneBitsCounter:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphOneBitsCounterBlock;\n        case FlowGraphBlockNames.CombineVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector2Block;\n        case FlowGraphBlockNames.CombineVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector3Block;\n        case FlowGraphBlockNames.CombineVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector4Block;\n        case FlowGraphBlockNames.CombineMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineMatrixBlock;\n        case FlowGraphBlockNames.ExtractVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector2Block;\n        case FlowGraphBlockNames.ExtractVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector3Block;\n        case FlowGraphBlockNames.ExtractVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector4Block;\n        case FlowGraphBlockNames.ExtractMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractMatrixBlock;\n        case FlowGraphBlockNames.TransformVector:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformBlock;\n        case FlowGraphBlockNames.TransformCoordinates:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformCoordinatesBlock;\n        case FlowGraphBlockNames.Conjugate:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphConjugateBlock;\n        case FlowGraphBlockNames.AngleBetween:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAngleBetweenBlock;\n        case FlowGraphBlockNames.QuaternionFromAxisAngle:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromAxisAngleBlock;\n        case FlowGraphBlockNames.AxisAngleFromQuaternion:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAxisAngleFromQuaternionBlock;\n        case FlowGraphBlockNames.QuaternionFromDirections:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromDirectionsBlock;\n        case FlowGraphBlockNames.MatrixDecompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixDecomposeBlock;\n        case FlowGraphBlockNames.MatrixCompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixComposeBlock;\n        case FlowGraphBlockNames.BooleanToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToFloat;\n        case FlowGraphBlockNames.BooleanToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToInt;\n        case FlowGraphBlockNames.FloatToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToBoolean;\n        case FlowGraphBlockNames.IntToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToBoolean;\n        case FlowGraphBlockNames.IntToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToFloat;\n        case FlowGraphBlockNames.FloatToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToInt;\n        case FlowGraphBlockNames.Easing:\n            return async () => (await import(\"./Execution/Animation/flowGraphEasingBlock\")).FlowGraphEasingBlock;\n        case FlowGraphBlockNames.BezierCurveEasing:\n            return async () => (await import(\"./Execution/Animation/flowGraphBezierCurveEasingBlock\")).FlowGraphBezierCurveEasingBlock;\n        case FlowGraphBlockNames.PointerOverEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOverEventBlock\")).FlowGraphPointerOverEventBlock;\n        case FlowGraphBlockNames.PointerOutEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOutEventBlock\")).FlowGraphPointerOutEventBlock;\n        case FlowGraphBlockNames.Context:\n            return async () => (await import(\"./Data/Utils/flowGraphContextBlock\")).FlowGraphContextBlock;\n        case FlowGraphBlockNames.ArrayIndex:\n            return async () => (await import(\"./Data/Utils/flowGraphArrayIndexBlock\")).FlowGraphArrayIndexBlock;\n        case FlowGraphBlockNames.CodeExecution:\n            return async () => (await import(\"./Data/Utils/flowGraphCodeExecutionBlock\")).FlowGraphCodeExecutionBlock;\n        case FlowGraphBlockNames.IndexOf:\n            return async () => (await import(\"./Data/Utils/flowGraphIndexOfBlock\")).FlowGraphIndexOfBlock;\n        case FlowGraphBlockNames.FunctionReference:\n            return async () => (await import(\"./Data/Utils/flowGraphFunctionReferenceBlock\")).FlowGraphFunctionReferenceBlock;\n        case FlowGraphBlockNames.DataSwitch:\n            return async () => (await import(\"./Data/flowGraphDataSwitchBlock\")).FlowGraphDataSwitchBlock;\n        default:\n            // check if the block is a custom block\n            if (CustomBlocks[blockName]) {\n                return CustomBlocks[blockName];\n            }\n            throw new Error(`Unknown block name ${blockName}`);\n    }\n}\n", "import type { IAssetContainer } from \"core/IAssetContainer\";\nimport { blockFactory } from \"./Blocks/flowGraphBlockFactory\";\nimport type { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\nimport type { FlowGraph, IFlowGraphParseOptions } from \"./flowGraph\";\nimport type { FlowGraphBlock, IFlowGraphBlockParseOptions } from \"./flowGraphBlock\";\nimport type { FlowGraphContext, IFlowGraphContextParseOptions } from \"./flowGraphContext\";\nimport type { IFlowGraphCoordinatorParseOptions } from \"./flowGraphCoordinator\";\nimport { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\nimport { defaultValueParseFunction, needsPathConverter } from \"./serialization\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"./typeDefinitions\";\nimport type { Node } from \"core/node\";\nimport { getRichTypeByFlowGraphType, RichType } from \"./flowGraphRichTypes\";\nimport type { FlowGraphConnection } from \"./flowGraphConnection\";\n\n/**\n * Given a list of blocks, find an output data connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetDataOutConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphDataConnection<any> {\n    for (const block of blocks) {\n        for (const dataOut of block.dataOutputs) {\n            if (dataOut.uniqueId === uniqueId) {\n                return dataOut;\n            }\n        }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n}\n\n/**\n * Given a list of blocks, find an input signal connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetSignalInConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphSignalConnection {\n    for (const block of blocks) {\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalIn of block.signalInputs) {\n                if (signalIn.uniqueId === uniqueId) {\n                    return signalIn;\n                }\n            }\n        }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n}\n\n/**\n * Parses a serialized coordinator.\n * @param serializedObject the object to parse\n * @param options the options to use when parsing\n * @returns the parsed coordinator\n */\nexport async function ParseCoordinatorAsync(serializedObject: any, options: IFlowGraphCoordinatorParseOptions) {\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    const coordinator = new FlowGraphCoordinator({ scene: options.scene });\n\n    if (serializedObject.dispatchEventsSynchronously) {\n        coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;\n    }\n\n    await options.scene.whenReadyAsync();\n    // if custom default values are defined, set them in the global context\n    if (serializedObject._defaultValues) {\n        for (const key in serializedObject._defaultValues) {\n            // key is the FlowGraphType, value is the default value\n            const value = serializedObject._defaultValues[key];\n            getRichTypeByFlowGraphType(key).defaultValue = value;\n        }\n    }\n    // async-parse the flow graphs. This can be done in parallel\n    await Promise.all(\n        serializedObject._flowGraphs?.map(\n            async (serializedGraph: any) => await ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter })\n        )\n    );\n    return coordinator;\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @returns the parsed graph\n */\nexport async function ParseFlowGraphAsync(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions): Promise<FlowGraph> {\n    // get all classes types needed for the blocks using the block factory\n    const resolvedClasses = await Promise.all(\n        serializationObject.allBlocks.map(async (serializedBlock) => {\n            const classFactory = blockFactory(serializedBlock.className as FlowGraphBlockNames);\n            return await classFactory();\n        })\n    );\n    // async will be used when we start using the block async factory\n    return ParseFlowGraph(serializationObject, options, resolvedClasses);\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @param resolvedClasses the resolved classes for the blocks\n * @returns the parsed graph\n */\nexport function ParseFlowGraph(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions, resolvedClasses: (typeof FlowGraphBlock)[]) {\n    const graph = options.coordinator.createGraph();\n    const blocks: FlowGraphBlock[] = [];\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    // Parse all blocks\n    // for (const serializedBlock of serializationObject.allBlocks) {\n    for (let i = 0; i < serializationObject.allBlocks.length; i++) {\n        const serializedBlock = serializationObject.allBlocks[i];\n        const block = ParseFlowGraphBlockWithClassType(\n            serializedBlock,\n            { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction },\n            resolvedClasses[i]\n        );\n        blocks.push(block);\n        if (block instanceof FlowGraphEventBlock) {\n            graph.addEventBlock(block);\n        }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n        for (const dataIn of block.dataInputs) {\n            for (const serializedConnection of dataIn.connectedPointIds) {\n                const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n                dataIn.connectTo(connection);\n            }\n        }\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalOut of block.signalOutputs) {\n                for (const serializedConnection of signalOut.connectedPointIds) {\n                    const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n                    signalOut.connectTo(connection);\n                }\n            }\n        }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n        ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);\n    }\n    return graph;\n}\n\n/**\n * Parses a context\n * @param serializationObject the object containing the context serialization values\n * @param options the options for parsing the context\n * @param rightHanded whether the serialized data is right handed\n * @returns\n */\nexport function ParseFlowGraphContext(serializationObject: ISerializedFlowGraphContext, options: IFlowGraphContextParseOptions, rightHanded?: boolean): FlowGraphContext {\n    const result = options.graph.createContext();\n    if (serializationObject.enableLogging) {\n        result.enableLogging = true;\n    }\n    result.treatDataAsRightHanded = rightHanded || false;\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    result.uniqueId = serializationObject.uniqueId;\n    const scene = result.getScene();\n    // check if assets context is available\n    if (serializationObject._assetsContext) {\n        const ac = serializationObject._assetsContext;\n        const assetsContext: IAssetContainer = {\n            meshes: ac.meshes?.map((m: string) => scene.getMeshById(m)),\n            lights: ac.lights?.map((l: string) => scene.getLightByName(l)),\n            cameras: ac.cameras?.map((c: string) => scene.getCameraByName(c)),\n            materials: ac.materials?.map((m: string) => scene.getMaterialById(m)),\n            textures: ac.textures?.map((t: string) => scene.getTextureByName(t)),\n            animations: ac.animations?.map((a: string) => scene.animations.find((anim) => anim.name === a)),\n            skeletons: ac.skeletons?.map((s: string) => scene.getSkeletonByName(s)),\n            particleSystems: ac.particleSystems?.map((ps: string) => scene.getParticleSystemById(ps)),\n            animationGroups: ac.animationGroups?.map((ag: string) => scene.getAnimationGroupByName(ag)),\n            transformNodes: ac.transformNodes?.map((tn: string) => scene.getTransformNodeById(tn)),\n            rootNodes: [],\n            multiMaterials: [],\n            morphTargetManagers: [],\n            geometries: [],\n            actionManagers: [],\n            environmentTexture: null,\n            postProcesses: [],\n            sounds: null,\n            effectLayers: [],\n            layers: [],\n            reflectionProbes: [],\n            lensFlareSystems: [],\n            proceduralTextures: [],\n            getNodes: function (): Array<Node> {\n                throw new Error(\"Function not implemented.\");\n            },\n        };\n        result.assetsContext = assetsContext;\n    }\n    for (const key in serializationObject._userVariables) {\n        const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);\n        result.userVariables[key] = value;\n    }\n    for (const key in serializationObject._connectionValues) {\n        const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);\n        result._setConnectionValueByKey(key, value);\n    }\n\n    return result;\n}\n\n/**\n * Parses a block from a serialization object\n * This function is async due to the factory method that is used to create the block's class. If you load the class externally use ParseBlockWithClassType\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @returns the parsed block\n */\nexport async function ParseBlockAsync(serializationObject: ISerializedFlowGraphBlock, parseOptions: IFlowGraphBlockParseOptions): Promise<FlowGraphBlock> {\n    const classFactory = blockFactory(serializationObject.className as FlowGraphBlockNames);\n    const classType = await classFactory();\n    return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);\n}\n\n/**\n * Parses a block from a serialization object\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @param classType the class type of the block. This is used when the class is not loaded asynchronously\n * @returns the parsed block\n */\nexport function ParseFlowGraphBlockWithClassType(\n    serializationObject: ISerializedFlowGraphBlock,\n    parseOptions: IFlowGraphBlockParseOptions,\n    classType: typeof FlowGraphBlock\n): FlowGraphBlock {\n    const parsedConfig: any = {};\n    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;\n    if (serializationObject.config) {\n        for (const key in serializationObject.config) {\n            parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);\n        }\n    }\n    if (needsPathConverter(serializationObject.className)) {\n        if (!parseOptions.pathConverter) {\n            throw new Error(\"Path converter is required for this block\");\n        }\n        parsedConfig.pathConverter = parseOptions.pathConverter;\n    }\n    const obj = new classType(parsedConfig);\n    obj.uniqueId = serializationObject.uniqueId;\n    for (let i = 0; i < serializationObject.dataInputs.length; i++) {\n        const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);\n        if (dataInput) {\n            dataInput.deserialize(serializationObject.dataInputs[i]);\n        } else {\n            throw new Error(\"Could not find data input with name \" + serializationObject.dataInputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {\n        const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);\n        if (dataOutput) {\n            dataOutput.deserialize(serializationObject.dataOutputs[i]);\n        } else {\n            throw new Error(\"Could not find data output with name \" + serializationObject.dataOutputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    obj.metadata = serializationObject.metadata;\n    obj.deserialize && obj.deserialize(serializationObject);\n    return obj;\n}\n\n/**\n * Parses a connection from an object\n * @param serializationObject the object to parse from.\n * @param ownerBlock the block that owns the connection.\n * @param classType the class type of the connection.\n * @returns the parsed connection.\n */\nexport function ParseGraphConnectionWithClassType<BlockT extends FlowGraphBlock>(serializationObject: any = {}, ownerBlock: BlockT, classType: typeof FlowGraphConnection) {\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a data connection from a serialized object.\n * @param serializationObject the object to parse from\n * @param ownerBlock the block that owns the connection\n * @param classType the class type of the data connection\n * @returns the parsed connection\n */\nexport function ParseGraphDataConnection(serializationObject: any, ownerBlock: FlowGraphBlock, classType: typeof FlowGraphDataConnection): FlowGraphDataConnection<any> {\n    const richType = ParseRichType(serializationObject.richType);\n    const defaultValue = serializationObject.defaultValue;\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a rich type from a serialization object.\n * @param serializationObject a serialization object\n * @returns the parsed rich type\n */\nfunction ParseRichType(serializationObject: any): RichType<any> {\n    return new RichType(serializationObject.typeName, serializationObject.defaultValue);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAMA,IAAM,eAAqE,CAAA;AAUrE,SAAU,kBAAkB,QAAgB,WAAmB,SAA6C;AAC9G,eAAa,GAAG,MAAM,IAAI,SAAS,EAAE,IAAI;AAC7C;AAQM,SAAU,aAAa,WAAuC;AAChE,UAAQ,WAAW;IACf,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,2CAAsD,GAAA;IAC3F,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,2CAAsD,GAAA;IAC3F,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,4CAAuD,GAAA;IAC5F,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,2CAAsD,GAAA;IAC3F,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,6CAA0C,GAAA;IAC/E,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,4CAAyC,GAAA;IAC9E,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,6CAA0C,GAAA;IAC/E,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,gDAA6C,GAAA;IAClF,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,2CAAwC,GAAA;IAC7E,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OA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",
  "names": []
}
