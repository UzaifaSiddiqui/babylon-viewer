import {
  TimingTools
} from "./chunk-2P6TTFAX.js";

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper = class {
  static GetEffect(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  }
  constructor(engine, createMaterialContext = true) {
    this._wasPreviouslyReady = false;
    this._forceRebindOnNextCall = true;
    this._wasPreviouslyUsingInstances = null;
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  setEffect(effect, defines, resetContext = true) {
    var _a;
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      (_a = this.drawContext) == null ? void 0 : _a.reset();
    }
  }
  /**
   * Dispose the effect wrapper and its resources
   * @param immediate if the effect should be disposed immediately or on the next frame.
   * If dispose() is not called during a scene or engine dispose, we want to delay the dispose of the underlying effect. Mostly to give a chance to user code to reuse the effect in some way.
   */
  dispose(immediate = false) {
    var _a;
    if (this.effect) {
      const effect = this.effect;
      if (immediate) {
        effect.dispose();
      } else {
        TimingTools.SetImmediate(() => {
          effect.getEngine().onEndFrameObservable.addOnce(() => {
            effect.dispose();
          });
        });
      }
      this.effect = null;
    }
    (_a = this.drawContext) == null ? void 0 : _a.dispose();
  }
};

export {
  DrawWrapper
};
//# sourceMappingURL=chunk-N5BIV2WJ.js.map
