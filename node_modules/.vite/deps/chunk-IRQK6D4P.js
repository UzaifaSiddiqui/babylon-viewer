import {
  Tools
} from "./chunk-XKDR2MBU.js";

// node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js
var NumberOfWorkers = 0;
var WorkerTimeout = null;
var MeshoptCompression = class _MeshoptCompression {
  /**
   * Default instance for the meshoptimizer object.
   */
  static get Default() {
    if (!_MeshoptCompression._Default) {
      _MeshoptCompression._Default = new _MeshoptCompression();
    }
    return _MeshoptCompression._Default;
  }
  /**
   * Constructor
   */
  constructor() {
    const decoder = _MeshoptCompression.Configuration.decoder;
    this._decoderModulePromise = Tools.LoadBabylonScriptAsync(decoder.url).then(() => {
      return MeshoptDecoder.ready;
    });
  }
  /**
   * Stop all async operations and release resources.
   */
  dispose() {
    delete this._decoderModulePromise;
  }
  /**
   * Decode meshopt data.
   * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder
   * @param source The input data.
   * @param count The number of elements.
   * @param stride The stride in bytes.
   * @param mode The compression mode.
   * @param filter The compression filter.
   * @returns a Promise<Uint8Array> that resolves to the decoded data
   */
  async decodeGltfBufferAsync(source, count, stride, mode, filter) {
    await this._decoderModulePromise;
    if (NumberOfWorkers === 0) {
      MeshoptDecoder.useWorkers(1);
      NumberOfWorkers = 1;
    }
    const result = await MeshoptDecoder.decodeGltfBufferAsync(count, stride, source, mode, filter);
    if (WorkerTimeout !== null) {
      clearTimeout(WorkerTimeout);
    }
    WorkerTimeout = setTimeout(() => {
      MeshoptDecoder.useWorkers(0);
      NumberOfWorkers = 0;
      WorkerTimeout = null;
    }, 1e3);
    return result;
  }
};
MeshoptCompression.Configuration = {
  decoder: {
    url: `${Tools._DefaultCdnUrl}/meshopt_decoder.js`
  }
};
MeshoptCompression._Default = null;

export {
  MeshoptCompression
};
//# sourceMappingURL=chunk-IRQK6D4P.js.map
