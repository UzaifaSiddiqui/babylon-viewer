import {
  getMappingForDeclaration,
  getMappingForFullOperationName
} from "./chunk-3B3CYPTM.js";
import {
  AddObjectAccessorToKey,
  GetPathToObjectConverter
} from "./chunk-UU3CS7MV.js";
import {
  ParseFlowGraphAsync,
  addToBlockFactory
} from "./chunk-TQEMBGSN.js";
import "./chunk-2VZLPTT4.js";
import "./chunk-FEZ4AZAI.js";
import {
  FlowGraphCoordinator
} from "./chunk-3FBTZ75P.js";
import "./chunk-2TY2RX26.js";
import "./chunk-HKARB7RB.js";
import "./chunk-QU4SENKS.js";
import "./chunk-WRC5LFTK.js";
import "./chunk-VO42GCQE.js";
import "./chunk-T7DWCINE.js";
import "./chunk-KJPKAW6K.js";
import "./chunk-EGZAI6OC.js";
import "./chunk-2ZZCOA4S.js";
import "./chunk-7LAWCXNF.js";
import "./chunk-NBEEHJT4.js";
import "./chunk-YC7U4GEU.js";
import {
  registerGLTFExtension,
  unregisterGLTFExtension
} from "./chunk-QGBHPVKU.js";
import "./chunk-Q4NWZFNQ.js";
import "./chunk-VECXS57A.js";
import "./chunk-ZXVFJ3IO.js";
import "./chunk-HEJT6QLT.js";
import "./chunk-AZ5ZQKUU.js";
import "./chunk-P6JJKNRD.js";
import "./chunk-KU4OFD2T.js";
import "./chunk-XKDR2MBU.js";
import "./chunk-UEXKFJPR.js";
import "./chunk-2ZEUD233.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import "./chunk-NJKHZWGX.js";
import "./chunk-OWCZTH5B.js";
import "./chunk-AZNEH5GV.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import "./chunk-FX6MN5HL.js";
import {
  Quaternion,
  Vector3
} from "./chunk-YCWH5W4G.js";
import "./chunk-S7NDMBDF.js";
import "./chunk-LDFLUTDO.js";
import "./chunk-ZVW3KNNR.js";
import "./chunk-2YUEJ7I2.js";
import "./chunk-SSYGV25P.js";

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.js
var gltfTypeToBabylonType = {
  float: { length: 1, flowGraphType: "number", elementType: "number" },
  bool: { length: 1, flowGraphType: "boolean", elementType: "boolean" },
  float2: { length: 2, flowGraphType: "Vector2", elementType: "number" },
  float3: { length: 3, flowGraphType: "Vector3", elementType: "number" },
  float4: { length: 4, flowGraphType: "Vector4", elementType: "number" },
  float4x4: { length: 16, flowGraphType: "Matrix", elementType: "number" },
  float2x2: { length: 4, flowGraphType: "Matrix2D", elementType: "number" },
  float3x3: { length: 9, flowGraphType: "Matrix3D", elementType: "number" },
  int: { length: 1, flowGraphType: "FlowGraphInteger", elementType: "number" }
};
var InteractivityGraphToFlowGraphParser = class {
  constructor(_interactivityGraph, _gltf, _animationTargetFps = 60) {
    this._interactivityGraph = _interactivityGraph;
    this._gltf = _gltf;
    this._animationTargetFps = _animationTargetFps;
    this._types = [];
    this._mappings = [];
    this._staticVariables = [];
    this._events = [];
    this._internalEventsCounter = 0;
    this._nodes = [];
    this._parseTypes();
    this._parseDeclarations();
    this._parseVariables();
    this._parseEvents();
    this._parseNodes();
  }
  get arrays() {
    return {
      types: this._types,
      mappings: this._mappings,
      staticVariables: this._staticVariables,
      events: this._events,
      nodes: this._nodes
    };
  }
  _parseTypes() {
    if (!this._interactivityGraph.types) {
      return;
    }
    for (const type of this._interactivityGraph.types) {
      this._types.push(gltfTypeToBabylonType[type.signature]);
    }
  }
  _parseDeclarations() {
    if (!this._interactivityGraph.declarations) {
      return;
    }
    for (const declaration of this._interactivityGraph.declarations) {
      const mapping = getMappingForDeclaration(declaration);
      if (!mapping) {
        Logger.Error(["No mapping found for declaration", declaration]);
        throw new Error("Error parsing declarations");
      }
      this._mappings.push({
        flowGraphMapping: mapping,
        fullOperationName: declaration.extension ? declaration.op + ":" + declaration.extension : declaration.op
      });
    }
  }
  _parseVariables() {
    if (!this._interactivityGraph.variables) {
      return;
    }
    for (const variable of this._interactivityGraph.variables) {
      const parsed = this._parseVariable(variable);
      this._staticVariables.push(parsed);
    }
  }
  _parseVariable(variable, dataTransform) {
    const type = this._types[variable.type];
    if (!type) {
      Logger.Error(["No type found for variable", variable]);
      throw new Error("Error parsing variables");
    }
    if (variable.value) {
      if (variable.value.length !== type.length) {
        Logger.Error(["Invalid value length for variable", variable, type]);
        throw new Error("Error parsing variables");
      }
    }
    const value = variable.value || [];
    if (!value.length) {
      switch (type.flowGraphType) {
        case "boolean":
          value.push(false);
          break;
        case "FlowGraphInteger":
          value.push(0);
          break;
        case "number":
          value.push(NaN);
          break;
        case "Vector2":
          value.push(NaN, NaN);
          break;
        case "Vector3":
          value.push(NaN, NaN, NaN);
          break;
        case "Vector4":
        case "Matrix2D":
        case "Quaternion":
          value.fill(NaN, 0, 4);
          break;
        case "Matrix":
          value.fill(NaN, 0, 16);
          break;
        case "Matrix3D":
          value.fill(NaN, 0, 9);
          break;
        default:
          break;
      }
    }
    if (type.elementType === "number" && typeof value[0] === "string") {
      value[0] = parseFloat(value[0]);
    }
    return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };
  }
  _parseEvents() {
    if (!this._interactivityGraph.events) {
      return;
    }
    for (const event of this._interactivityGraph.events) {
      const converted = {
        eventId: event.id || "internalEvent_" + this._internalEventsCounter++
      };
      if (event.values) {
        converted.eventData = Object.keys(event.values).map((key) => {
          var _a;
          const eventValue = (_a = event.values) == null ? void 0 : _a[key];
          if (!eventValue) {
            Logger.Error(["No value found for event key", key]);
            throw new Error("Error parsing events");
          }
          const type = this._types[eventValue.type];
          if (!type) {
            Logger.Error(["No type found for event value", eventValue]);
            throw new Error("Error parsing events");
          }
          const value = typeof eventValue.value !== "undefined" ? this._parseVariable(eventValue) : void 0;
          return {
            id: key,
            type: type.flowGraphType,
            eventData: true,
            value
          };
        });
      }
      this._events.push(converted);
    }
  }
  _parseNodes() {
    var _a;
    if (!this._interactivityGraph.nodes) {
      return;
    }
    for (const node of this._interactivityGraph.nodes) {
      if (typeof node.declaration !== "number") {
        Logger.Error(["No declaration found for node", node]);
        throw new Error("Error parsing nodes");
      }
      const mapping = this._mappings[node.declaration];
      if (!mapping) {
        Logger.Error(["No mapping found for node", node]);
        throw new Error("Error parsing nodes");
      }
      if (mapping.flowGraphMapping.validation) {
        const validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);
        if (!validationResult.valid) {
          throw new Error(`Error validating interactivity node ${(_a = this._interactivityGraph.declarations) == null ? void 0 : _a[node.declaration].op} - ${validationResult.error}`);
        }
      }
      const blocks = [];
      for (const blockType of mapping.flowGraphMapping.blocks) {
        const block = this._getEmptyBlock(blockType, mapping.fullOperationName);
        this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);
        blocks.push(block);
      }
      this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });
    }
  }
  _getEmptyBlock(className, type) {
    const uniqueId = RandomGUID();
    const dataInputs = [];
    const dataOutputs = [];
    const signalInputs = [];
    const signalOutputs = [];
    const config = {};
    const metadata = {};
    return {
      uniqueId,
      className,
      dataInputs,
      dataOutputs,
      signalInputs,
      signalOutputs,
      config,
      type,
      metadata
    };
  }
  _parseNodeConfiguration(node, block, nodeMapping, blockType) {
    var _a, _b;
    const configuration = block.config;
    if (node.configuration) {
      const keys = Object.keys(node.configuration);
      for (const key of keys) {
        const value = (_a = node.configuration) == null ? void 0 : _a[key];
        if (!value) {
          Logger.Error(["No value found for node configuration", key]);
          throw new Error("Error parsing node configuration");
        }
        const configMapping = (_b = nodeMapping.configuration) == null ? void 0 : _b[key];
        const belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;
        if (belongsToBlock) {
          const configKey = (configMapping == null ? void 0 : configMapping.name) || key;
          if ((!value || typeof value.value === "undefined") && typeof (configMapping == null ? void 0 : configMapping.defaultValue) !== "undefined") {
            configuration[configKey] = {
              value: configMapping.defaultValue
            };
          } else if (value.value.length >= 0) {
            configuration[configKey] = {
              value: value.value.length === 1 ? value.value[0] : value.value
            };
          } else {
            Logger.Warn(["Invalid value for node configuration", value]);
          }
          if (configMapping && configMapping.dataTransformer) {
            configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];
          }
        }
      }
    }
  }
  _parseNodeConnections(context) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    for (let i = 0; i < this._nodes.length; i++) {
      const gltfNode = (_a = this._interactivityGraph.nodes) == null ? void 0 : _a[i];
      if (!gltfNode) {
        Logger.Error(["No node found for interactivity node", this._nodes[i]]);
        throw new Error("Error parsing node connections");
      }
      const flowGraphBlocks = this._nodes[i];
      const outputMapper = this._mappings[gltfNode.declaration];
      if (!outputMapper) {
        Logger.Error(["No mapping found for node", gltfNode]);
        throw new Error("Error parsing node connections");
      }
      const flowsFromGLTF = gltfNode.flows || {};
      const flowsKeys = Object.keys(flowsFromGLTF).sort();
      for (const flowKey of flowsKeys) {
        const flow = flowsFromGLTF[flowKey];
        const flowMapping = (_c = (_b = outputMapper.flowGraphMapping.outputs) == null ? void 0 : _b.flows) == null ? void 0 : _c[flowKey];
        const socketOutName = (flowMapping == null ? void 0 : flowMapping.name) || flowKey;
        const socketOut = this._createNewSocketConnection(socketOutName, true);
        const block = flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock) || flowGraphBlocks.blocks[0];
        block.signalOutputs.push(socketOut);
        const inputNodeId = flow.node;
        const nodeIn = this._nodes[inputNodeId];
        if (!nodeIn) {
          Logger.Error(["No node found for input node id", inputNodeId]);
          throw new Error("Error parsing node connections");
        }
        const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);
        if (!inputMapper) {
          Logger.Error(["No mapping found for input node", nodeIn]);
          throw new Error("Error parsing node connections");
        }
        let flowInMapping = (_e = (_d = inputMapper.inputs) == null ? void 0 : _d.flows) == null ? void 0 : _e[flow.socket || "in"];
        let arrayMapping = false;
        if (!flowInMapping) {
          for (const key in (_f = inputMapper.inputs) == null ? void 0 : _f.flows) {
            if (key.startsWith("[") && key.endsWith("]")) {
              arrayMapping = true;
              flowInMapping = (_h = (_g = inputMapper.inputs) == null ? void 0 : _g.flows) == null ? void 0 : _h[key];
            }
          }
        }
        const nodeInSocketName = flowInMapping ? arrayMapping ? flowInMapping.name.replace("$1", flow.socket || "") : flowInMapping.name : flow.socket || "in";
        const inputBlock = flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock) || nodeIn.blocks[0];
        let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);
        if (!socketIn) {
          socketIn = this._createNewSocketConnection(nodeInSocketName);
          inputBlock.signalInputs.push(socketIn);
        }
        socketIn.connectedPointIds.push(socketOut.uniqueId);
        socketOut.connectedPointIds.push(socketIn.uniqueId);
      }
      const valuesFromGLTF = gltfNode.values || {};
      const valuesKeys = Object.keys(valuesFromGLTF);
      for (const valueKey of valuesKeys) {
        const value = valuesFromGLTF[valueKey];
        let valueMapping = (_j = (_i = outputMapper.flowGraphMapping.inputs) == null ? void 0 : _i.values) == null ? void 0 : _j[valueKey];
        let arrayMapping = false;
        if (!valueMapping) {
          for (const key in (_k = outputMapper.flowGraphMapping.inputs) == null ? void 0 : _k.values) {
            if (key.startsWith("[") && key.endsWith("]")) {
              arrayMapping = true;
              valueMapping = (_m = (_l = outputMapper.flowGraphMapping.inputs) == null ? void 0 : _l.values) == null ? void 0 : _m[key];
            }
          }
        }
        const socketInName = valueMapping ? arrayMapping ? valueMapping.name.replace("$1", valueKey) : valueMapping.name : valueKey;
        const socketIn = this._createNewSocketConnection(socketInName);
        const block = valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping.toBlock) || flowGraphBlocks.blocks[0];
        block.dataInputs.push(socketIn);
        if (value.value !== void 0) {
          const convertedValue = this._parseVariable(value, valueMapping && valueMapping.dataTransformer);
          context._connectionValues[socketIn.uniqueId] = convertedValue;
        } else if (typeof value.node !== "undefined") {
          const nodeOutId = value.node;
          const nodeOutSocketName = value.socket || "value";
          const nodeOut = this._nodes[nodeOutId];
          if (!nodeOut) {
            Logger.Error(["No node found for output socket reference", value]);
            throw new Error("Error parsing node connections");
          }
          const outputMapper2 = getMappingForFullOperationName(nodeOut.fullOperationName);
          if (!outputMapper2) {
            Logger.Error(["No mapping found for output socket reference", value]);
            throw new Error("Error parsing node connections");
          }
          let valueMapping2 = (_o = (_n = outputMapper2.outputs) == null ? void 0 : _n.values) == null ? void 0 : _o[nodeOutSocketName];
          let arrayMapping2 = false;
          if (!valueMapping2) {
            for (const key in (_p = outputMapper2.outputs) == null ? void 0 : _p.values) {
              if (key.startsWith("[") && key.endsWith("]")) {
                arrayMapping2 = true;
                valueMapping2 = (_r = (_q = outputMapper2.outputs) == null ? void 0 : _q.values) == null ? void 0 : _r[key];
              }
            }
          }
          const socketOutName = valueMapping2 ? arrayMapping2 ? valueMapping2.name.replace("$1", nodeOutSocketName) : valueMapping2 == null ? void 0 : valueMapping2.name : nodeOutSocketName;
          const outBlock = valueMapping2 && valueMapping2.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping2.toBlock) || nodeOut.blocks[0];
          let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);
          if (!socketOut) {
            socketOut = this._createNewSocketConnection(socketOutName, true);
            outBlock.dataOutputs.push(socketOut);
          }
          socketIn.connectedPointIds.push(socketOut.uniqueId);
          socketOut.connectedPointIds.push(socketIn.uniqueId);
        } else {
          Logger.Error(["Invalid value for value connection", value]);
          throw new Error("Error parsing node connections");
        }
      }
      if (outputMapper.flowGraphMapping.interBlockConnectors) {
        for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {
          const input = connector.input;
          const output = connector.output;
          const isVariable = connector.isVariable;
          this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);
        }
      }
      if (outputMapper.flowGraphMapping.extraProcessor) {
        const declaration = (_s = this._interactivityGraph.declarations) == null ? void 0 : _s[gltfNode.declaration];
        if (!declaration) {
          Logger.Error(["No declaration found for extra processor", gltfNode]);
          throw new Error("Error parsing node connections");
        }
        flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(gltfNode, declaration, outputMapper.flowGraphMapping, this, flowGraphBlocks.blocks, context, this._gltf);
      }
    }
  }
  _createNewSocketConnection(name, isOutput) {
    return {
      uniqueId: RandomGUID(),
      name,
      _connectionType: isOutput ? 1 : 0,
      connectedPointIds: []
    };
  }
  _connectFlowGraphNodes(input, output, serializedInput, serializedOutput, isVariable) {
    const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;
    const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;
    const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);
    const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);
    if (!inputArray.find((s) => s.name === input)) {
      inputArray.push(inputConnection);
    }
    if (!outputArray.find((s) => s.name === output)) {
      outputArray.push(outputConnection);
    }
    inputConnection.connectedPointIds.push(outputConnection.uniqueId);
    outputConnection.connectedPointIds.push(inputConnection.uniqueId);
  }
  getVariableName(index) {
    return "staticVariable_" + index;
  }
  serializeToFlowGraph() {
    const context = {
      uniqueId: RandomGUID(),
      _userVariables: {},
      _connectionValues: {}
    };
    this._parseNodeConnections(context);
    for (let i = 0; i < this._staticVariables.length; i++) {
      const variable = this._staticVariables[i];
      context._userVariables[this.getVariableName(i)] = variable;
    }
    const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), []);
    return {
      rightHanded: true,
      allBlocks,
      executionContexts: [context]
    };
  }
};

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_interactivity.js
var NAME = "KHR_interactivity";
var KHR_interactivity = class {
  /**
   * @internal
   * @param _loader
   */
  constructor(_loader) {
    this._loader = _loader;
    this.name = NAME;
    this.enabled = this._loader.isExtensionUsed(NAME);
    this._pathConverter = GetPathToObjectConverter(this._loader.gltf);
    _loader._skipStartAnimationStep = true;
    const scene = _loader.babylonScene;
    if (scene) {
      _AddInteractivityObjectModel(scene);
    }
  }
  dispose() {
    this._loader = null;
    delete this._pathConverter;
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises
  async onReady() {
    var _a;
    if (!this._loader.babylonScene || !this._pathConverter) {
      return;
    }
    const scene = this._loader.babylonScene;
    const interactivityDefinition = (_a = this._loader.gltf.extensions) == null ? void 0 : _a.KHR_interactivity;
    if (!interactivityDefinition) {
      return;
    }
    const coordinator = new FlowGraphCoordinator({ scene });
    coordinator.dispatchEventsSynchronously = false;
    const graphs = interactivityDefinition.graphs.map((graph) => {
      const parser = new InteractivityGraphToFlowGraphParser(graph, this._loader.gltf, this._loader.parent.targetFps);
      return parser.serializeToFlowGraph();
    });
    await Promise.all(graphs.map(async (graph) => await ParseFlowGraphAsync(graph, { coordinator, pathConverter: this._pathConverter })));
    coordinator.start();
  }
};
function _AddInteractivityObjectModel(scene) {
  AddObjectAccessorToKey("/extensions/KHR_interactivity/?/activeCamera/rotation", {
    get: () => {
      if (!scene.activeCamera) {
        return new Quaternion(NaN, NaN, NaN, NaN);
      }
      const quat = Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();
      if (!scene.useRightHandedSystem) {
        quat.w *= -1;
        quat.x *= -1;
      }
      return quat;
    },
    type: "Quaternion",
    getTarget: () => scene.activeCamera
  });
  AddObjectAccessorToKey("/extensions/KHR_interactivity/?/activeCamera/position", {
    get: () => {
      if (!scene.activeCamera) {
        return new Vector3(NaN, NaN, NaN);
      }
      const pos = scene.activeCamera.getWorldMatrix().getTranslation();
      if (!scene.useRightHandedSystem) {
        pos.x *= -1;
      }
      return pos;
    },
    type: "Vector3",
    getTarget: () => scene.activeCamera
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/isPlaying", {
    get: (animation) => {
      var _a;
      return ((_a = animation._babylonAnimationGroup) == null ? void 0 : _a.isPlaying) ?? false;
    },
    type: "boolean",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/minTime", {
    get: (animation) => {
      var _a;
      return (((_a = animation._babylonAnimationGroup) == null ? void 0 : _a.from) ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/maxTime", {
    get: (animation) => {
      var _a;
      return (((_a = animation._babylonAnimationGroup) == null ? void 0 : _a.to) ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/playhead", {
    get: (animation) => {
      var _a;
      return (((_a = animation._babylonAnimationGroup) == null ? void 0 : _a.getCurrentFrame()) ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/virtualPlayhead", {
    get: (animation) => {
      var _a;
      return (((_a = animation._babylonAnimationGroup) == null ? void 0 : _a.getCurrentFrame()) ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
}
addToBlockFactory(NAME, "FlowGraphGLTFDataProvider", async () => {
  return (await import("./flowGraphGLTFDataProvider-WITO72OD.js")).FlowGraphGLTFDataProvider;
});
unregisterGLTFExtension(NAME);
registerGLTFExtension(NAME, true, (loader) => new KHR_interactivity(loader));
export {
  KHR_interactivity,
  _AddInteractivityObjectModel
};
//# sourceMappingURL=KHR_interactivity-WQUDP3CX.js.map
