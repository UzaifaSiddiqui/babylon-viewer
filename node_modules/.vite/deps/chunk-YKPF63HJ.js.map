{
  "version": 3,
  "sources": ["../../../dev/loaders/src/SPLAT/splatFileLoader.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderAsyncResult, ISceneLoaderProgressEvent, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata\";\r\nimport { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { PointsCloudSystem } from \"core/Particles/pointsCloudSystem\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { SPLATLoadingOptions } from \"./splatLoadingOptions\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport type { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the splat loader.\r\n         */\r\n        [SPLATFileLoaderMetadata.name]: Partial<SPLATLoadingOptions>;\r\n    }\r\n}\r\n\r\n/**\r\n * Indicator of the parsed ply buffer. A standard ready to use splat or an array of positions for a point cloud\r\n */\r\nconst enum Mode {\r\n    Splat = 0,\r\n    PointCloud = 1,\r\n    Mesh = 2,\r\n    Reject = 3,\r\n}\r\n\r\n/**\r\n * A parsed buffer and how to use it\r\n */\r\ninterface IParsedPLY {\r\n    data: ArrayBuffer;\r\n    mode: Mode;\r\n    faces?: number[];\r\n    hasVertexColors?: boolean;\r\n    sh?: Uint8Array[];\r\n    trainedWithAntialiasing?: boolean;\r\n    compressed?: boolean;\r\n    rawSplat?: boolean;\r\n}\r\n\r\n/**\r\n * @experimental\r\n * SPLAT file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class SPLATFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = SPLATFileLoaderMetadata.name;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private readonly _loadingOptions: Readonly<SPLATLoadingOptions>;\r\n    /**\r\n     * Defines the extensions the splat loader is able to load.\r\n     * force data to come in as an ArrayBuffer\r\n     */\r\n    public readonly extensions = SPLATFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Creates loader for gaussian splatting files\r\n     * @param loadingOptions options for loading and parsing splat and PLY files.\r\n     */\r\n    constructor(loadingOptions: Partial<Readonly<SPLATLoadingOptions>> = SPLATFileLoader._DefaultLoadingOptions) {\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    private static readonly _DefaultLoadingOptions = {\r\n        keepInRam: false,\r\n        flipY: false,\r\n    } as const satisfies SPLATLoadingOptions;\r\n\r\n    /** @internal */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the gaussian splatting data to load\r\n     * @param rootUrl root url to load from\r\n     * @param _onProgress callback called while file is loading\r\n     * @param _fileName Defines the name of the file to load\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public async importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        _onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        _fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        // eslint-disable-next-line github/no-then\r\n        return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    private static _BuildPointCloud(pointcloud: PointsCloudSystem, data: ArrayBuffer): boolean {\r\n        if (!data.byteLength) {\r\n            return false;\r\n        }\r\n        const uBuffer = new Uint8Array(data);\r\n        const fBuffer = new Float32Array(data);\r\n\r\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const pointcloudfunc = function (particle: any, i: number) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            particle.position = new Vector3(x, y, z);\r\n\r\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n            particle.color = new Color4(r, g, b, 1);\r\n        };\r\n\r\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\r\n        return true;\r\n    }\r\n\r\n    private static _BuildMesh(scene: Scene, parsedPLY: IParsedPLY): Mesh {\r\n        const mesh = new Mesh(\"PLYMesh\", scene);\r\n\r\n        const uBuffer = new Uint8Array(parsedPLY.data);\r\n        const fBuffer = new Float32Array(parsedPLY.data);\r\n\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const positions = [];\r\n\r\n        const vertexData = new VertexData();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            positions.push(x, y, z);\r\n        }\r\n\r\n        if (parsedPLY.hasVertexColors) {\r\n            const colors = new Float32Array(vertexCount * 4);\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n                colors[i * 4 + 0] = r;\r\n                colors[i * 4 + 1] = g;\r\n                colors[i * 4 + 2] = b;\r\n                colors[i * 4 + 3] = 1;\r\n            }\r\n            vertexData.colors = colors;\r\n        }\r\n\r\n        vertexData.positions = positions;\r\n        vertexData.indices = parsedPLY.faces!;\r\n\r\n        vertexData.applyToMesh(mesh);\r\n        return mesh;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _parseSPZAsync(data: ArrayBuffer, scene: Scene): Promise<IParsedPLY> {\r\n        const ubuf = new Uint8Array(data);\r\n        const ubufu32 = new Uint32Array(data.slice(0, 12)); // Only need ubufu32[0] to [2]\r\n        // debug infos\r\n        const splatCount = ubufu32[2];\r\n\r\n        const shDegree = ubuf[12];\r\n        const fractionalBits = ubuf[13];\r\n        const flags = ubuf[14];\r\n        const reserved = ubuf[15];\r\n\r\n        // check magic and version\r\n        if (reserved || ubufu32[0] != 0x5053474e || ubufu32[1] != 2) {\r\n            // reserved must be 0\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Reject, data: buffer, hasVertexColors: false });\r\n            });\r\n        }\r\n\r\n        const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\r\n        const buffer = new ArrayBuffer(rowOutputLength * splatCount);\r\n\r\n        const positionScale = 1.0 / (1 << fractionalBits);\r\n\r\n        const int32View = new Int32Array(1);\r\n        const uint8View = new Uint8Array(int32View.buffer);\r\n        const read24bComponent = function (u8: Uint8Array, offset: number) {\r\n            uint8View[0] = u8[offset + 0];\r\n            uint8View[1] = u8[offset + 1];\r\n            uint8View[2] = u8[offset + 2];\r\n            uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\r\n            return int32View[0] * positionScale;\r\n        };\r\n\r\n        let byteOffset = 16;\r\n\r\n        const position = new Float32Array(buffer);\r\n        const scale = new Float32Array(buffer);\r\n        const rgba = new Uint8ClampedArray(buffer);\r\n        const rot = new Uint8ClampedArray(buffer);\r\n\r\n        let coordinateSign = 1;\r\n        let quaternionOffset = 0;\r\n        if (!this._loadingOptions.flipY) {\r\n            coordinateSign = -1;\r\n            quaternionOffset = 255;\r\n        }\r\n        // positions\r\n        for (let i = 0; i < splatCount; i++) {\r\n            position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\r\n            position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);\r\n            position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);\r\n            byteOffset += 9;\r\n        }\r\n\r\n        // colors\r\n        const shC0 = 0.282;\r\n        for (let i = 0; i < splatCount; i++) {\r\n            for (let component = 0; component < 3; component++) {\r\n                const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\r\n                // 0.15 is hard coded value from spz\r\n                // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\r\n                // be useful to represent base colors that are out of range if the higher spherical harmonics bands\r\n                // bring them back into range so we multiply by a smaller value.\r\n                const value = (byteValue - 127.5) / (0.15 * 255);\r\n                rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);\r\n            }\r\n\r\n            rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\r\n        }\r\n        byteOffset += splatCount * 4;\r\n\r\n        // scales\r\n        for (let i = 0; i < splatCount; i++) {\r\n            scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\r\n            scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\r\n            scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\r\n            byteOffset += 3;\r\n        }\r\n\r\n        // convert quaternion\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const x = ubuf[byteOffset + 0];\r\n            const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;\r\n            const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;\r\n            const nx = x / 127.5 - 1;\r\n            const ny = y / 127.5 - 1;\r\n            const nz = z / 127.5 - 1;\r\n            rot[i * 32 + 28 + 1] = x;\r\n            rot[i * 32 + 28 + 2] = y;\r\n            rot[i * 32 + 28 + 3] = z;\r\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\r\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\r\n\r\n            byteOffset += 3;\r\n        }\r\n\r\n        //SH\r\n        if (shDegree) {\r\n            // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\r\n            // number of vec3 vector needed per splat\r\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\r\n            // number of component values : 3 per vector3 (45)\r\n            const shComponentCount = shVectorCount * 3;\r\n\r\n            const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n            let shIndexRead = byteOffset;\r\n\r\n            // sh is an array of uint8array that will be used to create sh textures\r\n            const sh: Uint8Array[] = [];\r\n\r\n            const engine = scene.getEngine();\r\n            const width = engine.getCaps().maxTextureSize;\r\n            const height = Math.ceil(splatCount / width);\r\n            // create array for the number of textures needed.\r\n            for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n                const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n                sh.push(texture);\r\n            }\r\n\r\n            for (let i = 0; i < splatCount; i++) {\r\n                for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\r\n                    const shValue = ubuf[shIndexRead++];\r\n\r\n                    const textureIndex = Math.floor(shIndexWrite / 16);\r\n                    const shArray = sh[textureIndex];\r\n\r\n                    const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                    const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n                    shArray[byteIndexInTexture + offsetPerSplat] = shValue;\r\n                }\r\n            }\r\n\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, sh: sh, trainedWithAntialiasing: !!flags });\r\n            });\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _parseAsync(meshesNames: any, scene: Scene, data: any, _rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        const readableStream = new ReadableStream({\r\n            start(controller) {\r\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\r\n                controller.close();\r\n            },\r\n        });\r\n\r\n        // Use GZip DecompressionStream\r\n        const decompressionStream = new DecompressionStream(\"gzip\");\r\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\r\n\r\n        return new Promise((resolve) => {\r\n            new Response(decompressedStream)\r\n                .arrayBuffer()\r\n                // eslint-disable-next-line github/no-then\r\n                .then((buffer) => {\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    this._parseSPZAsync(buffer, scene).then((parsedSPZ) => {\r\n                        scene._blockEntityCollection = !!this._assetContainer;\r\n                        const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                        if (parsedSPZ.trainedWithAntialiasing) {\r\n                            const gsMaterial = gaussianSplatting.material as GaussianSplattingMaterial;\r\n                            gsMaterial.kernelSize = 0.1;\r\n                            gsMaterial.compensation = true;\r\n                        }\r\n                        gaussianSplatting._parentContainer = this._assetContainer;\r\n                        babylonMeshesArray.push(gaussianSplatting);\r\n                        gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);\r\n                        scene._blockEntityCollection = false;\r\n                        resolve(babylonMeshesArray);\r\n                    });\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch(() => {\r\n                    // Catch any decompression errors\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    SPLATFileLoader._ConvertPLYToSplat(data as ArrayBuffer).then(async (parsedPLY) => {\r\n                        scene._blockEntityCollection = !!this._assetContainer;\r\n                        switch (parsedPLY.mode) {\r\n                            case Mode.Splat:\r\n                                {\r\n                                    const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                                    gaussianSplatting._parentContainer = this._assetContainer;\r\n                                    babylonMeshesArray.push(gaussianSplatting);\r\n                                    gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);\r\n                                    if (parsedPLY.compressed || !parsedPLY.rawSplat) {\r\n                                        gaussianSplatting.viewDirectionFactor.set(-1, -1, 1);\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case Mode.PointCloud:\r\n                                {\r\n                                    const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\r\n                                    if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\r\n                                        // eslint-disable-next-line github/no-then\r\n                                        await pointcloud.buildMeshAsync().then((mesh) => {\r\n                                            babylonMeshesArray.push(mesh);\r\n                                        });\r\n                                    } else {\r\n                                        pointcloud.dispose();\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case Mode.Mesh:\r\n                                {\r\n                                    if (parsedPLY.faces) {\r\n                                        babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\r\n                                    } else {\r\n                                        throw new Error(\"PLY mesh doesn't contain face informations.\");\r\n                                    }\r\n                                }\r\n                                break;\r\n                            default:\r\n                                throw new Error(\"Unsupported Splat mode\");\r\n                        }\r\n                        scene._blockEntityCollection = false;\r\n                        resolve(babylonMeshesArray);\r\n                    });\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return (\r\n            this.importMeshAsync(null, scene, data, rootUrl)\r\n                // eslint-disable-next-line github/no-then\r\n                .then((result) => {\r\n                    for (const mesh of result.meshes) {\r\n                        container.meshes.push(mesh);\r\n                    }\r\n                    // mesh material will be null before 1st rendered frame.\r\n                    this._assetContainer = null;\r\n                    return container;\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((ex) => {\r\n                    this._assetContainer = null;\r\n                    throw ex;\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        // eslint-disable-next-line github/no-then\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer\r\n     */\r\n    private static _ConvertPLYToSplat(data: ArrayBuffer): Promise<IParsedPLY> {\r\n        const ubuf = new Uint8Array(data);\r\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\r\n        const headerEnd = \"end_header\\n\";\r\n        const headerEndIndex = header.indexOf(headerEnd);\r\n        if (headerEndIndex < 0 || !header) {\r\n            // standard splat\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Splat, data: data, rawSplat: true });\r\n            });\r\n        }\r\n\r\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)![1]);\r\n        const faceElement = /element face (\\d+)\\n/.exec(header);\r\n        let faceCount = 0;\r\n        if (faceElement) {\r\n            faceCount = parseInt(faceElement[1]);\r\n        }\r\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\r\n        let chunkCount = 0;\r\n        if (chunkElement) {\r\n            chunkCount = parseInt(chunkElement[1]);\r\n        }\r\n\r\n        let rowVertexOffset = 0;\r\n        let rowChunkOffset = 0;\r\n        const offsets: Record<string, number> = {\r\n            double: 8,\r\n            int: 4,\r\n            uint: 4,\r\n            float: 4,\r\n            short: 2,\r\n            ushort: 2,\r\n            uchar: 1,\r\n            list: 0,\r\n        };\r\n\r\n        type PlyProperty = {\r\n            name: string;\r\n            type: string;\r\n            offset: number;\r\n        };\r\n\r\n        const enum ElementMode {\r\n            Vertex = 0,\r\n            Chunk = 1,\r\n            SH = 2,\r\n        }\r\n\r\n        let chunkMode = ElementMode.Chunk;\r\n        const vertexProperties: PlyProperty[] = [];\r\n        const chunkProperties: PlyProperty[] = [];\r\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\r\n        for (const prop of filtered) {\r\n            if (prop.startsWith(\"property \")) {\r\n                const [, type, name] = prop.split(\" \");\r\n\r\n                if (chunkMode == ElementMode.Chunk) {\r\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\r\n                    rowChunkOffset += offsets[type];\r\n                } else if (chunkMode == ElementMode.Vertex) {\r\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\r\n                    rowVertexOffset += offsets[type];\r\n                } else if (chunkMode == ElementMode.SH) {\r\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\r\n                }\r\n                if (!offsets[type]) {\r\n                    Logger.Warn(`Unsupported property type: ${type}.`);\r\n                }\r\n            } else if (prop.startsWith(\"element \")) {\r\n                const [, type] = prop.split(\" \");\r\n                if (type == \"chunk\") {\r\n                    chunkMode = ElementMode.Chunk;\r\n                } else if (type == \"vertex\") {\r\n                    chunkMode = ElementMode.Vertex;\r\n                } else if (type == \"sh\") {\r\n                    chunkMode = ElementMode.SH;\r\n                }\r\n            }\r\n        }\r\n\r\n        const rowVertexLength = rowVertexOffset;\r\n        const rowChunkLength = rowChunkOffset;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return (GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data) as any).then(async (splatsData: any) => {\r\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\r\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\r\n            // faces\r\n            const faces: number[] = [];\r\n            if (faceCount) {\r\n                for (let i = 0; i < faceCount; i++) {\r\n                    const faceVertexCount = dataView.getUint8(offset);\r\n                    if (faceVertexCount != 3) {\r\n                        continue; // only support triangles\r\n                    }\r\n                    offset += 1;\r\n\r\n                    for (let j = 0; j < faceVertexCount; j++) {\r\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\r\n                        faces.push(vertexIndex);\r\n                    }\r\n                    offset += 12;\r\n                }\r\n            }\r\n\r\n            // early exit for chunked/quantized ply\r\n            if (chunkCount) {\r\n                return await new Promise((resolve) => {\r\n                    resolve({ mode: Mode.Splat, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false, compressed: true, rawSplat: false });\r\n                });\r\n            }\r\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\r\n            // if faces are found, then it's a standard mesh\r\n            let propertyCount = 0;\r\n            let propertyColorCount = 0;\r\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\r\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\r\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\r\n                const property = vertexProperties[propertyIndex];\r\n                if (splatProperties.includes(property.name)) {\r\n                    propertyCount++;\r\n                }\r\n                if (splatColorProperties.includes(property.name)) {\r\n                    propertyColorCount++;\r\n                }\r\n            }\r\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\r\n            const currentMode = faceCount ? Mode.Mesh : hasMandatoryProperties ? Mode.Splat : Mode.PointCloud;\r\n            // parsed ready ready to be used as a splat\r\n            return await new Promise((resolve) => {\r\n                resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: !!propertyColorCount, compressed: false, rawSplat: false });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n// Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\r\n"],
  "mappings": "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",
  "names": ["Mode", "ElementMode"]
}
