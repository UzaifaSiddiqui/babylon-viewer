import {
  getAnimationTypeByFlowGraphType
} from "./chunk-EGZAI6OC.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.js
function getMappingForFullOperationName(fullOperationName) {
  const [op, extension] = fullOperationName.split(":");
  return getMappingForDeclaration({ op, extension });
}
function getMappingForDeclaration(declaration, returnNoOpIfNotAvailable = true) {
  var _a;
  const mapping = declaration.extension ? (_a = gltfExtensionsToFlowGraphMapping[declaration.extension]) == null ? void 0 : _a[declaration.op] : gltfToFlowGraphMapping[declaration.op];
  if (!mapping) {
    Logger.Warn(`No mapping found for operation ${declaration.op} and extension ${declaration.extension || "KHR_interactivity"}`);
    if (returnNoOpIfNotAvailable) {
      const inputs = {};
      const outputs = {
        flows: {}
      };
      if (declaration.inputValueSockets) {
        inputs.values = {};
        for (const key in declaration.inputValueSockets) {
          inputs.values[key] = {
            name: key
          };
        }
      }
      if (declaration.outputValueSockets) {
        outputs.values = {};
        Object.keys(declaration.outputValueSockets).forEach((key) => {
          outputs.values[key] = {
            name: key
          };
        });
      }
      return {
        blocks: [],
        // no blocks, just mapping
        inputs,
        outputs
      };
    }
  }
  return mapping;
}
function addNewInteractivityFlowGraphMapping(key, extension, mapping) {
  gltfExtensionsToFlowGraphMapping[extension] || (gltfExtensionsToFlowGraphMapping[extension] = {});
  gltfExtensionsToFlowGraphMapping[extension][key] = mapping;
}
var gltfExtensionsToFlowGraphMapping = {
  /**
   * This is the BABYLON extension for glTF interactivity.
   * It defines babylon-specific blocks and operations.
   */
  BABYLON: {
    /**
     * flow/log is a flow node that logs input to the console.
     * It has "in" and "out" flows, and takes a message as input.
     * The message can be any type of value.
     * The message is logged to the console when the "in" flow is triggered.
     * The "out" flow is triggered when the message is logged.
     */
    "flow/log": {
      blocks: [
        "FlowGraphConsoleLogBlock"
        /* FlowGraphBlockNames.ConsoleLog */
      ],
      inputs: {
        values: {
          message: { name: "message" }
        }
      }
    }
  }
};
var gltfToFlowGraphMapping = {
  "event/onStart": {
    blocks: [
      "FlowGraphSceneReadyEventBlock"
      /* FlowGraphBlockNames.SceneReadyEvent */
    ],
    outputs: {
      flows: {
        out: { name: "done" }
      }
    }
  },
  "event/onTick": {
    blocks: [
      "FlowGraphSceneTickEventBlock"
      /* FlowGraphBlockNames.SceneTickEvent */
    ],
    inputs: {},
    outputs: {
      values: {
        timeSinceLastTick: {
          name: "deltaTime",
          gltfType: "number"
          /*, dataTransformer: (time: number) => time / 1000*/
        }
      },
      flows: {
        out: { name: "done" }
      }
    }
  },
  "event/send": {
    blocks: [
      "FlowGraphSendCustomEventBlock"
      /* FlowGraphBlockNames.SendCustomEvent */
    ],
    extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {
      if (declaration.op !== "event/send" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
        throw new Error("Receive event should have a single configuration object, the event itself");
      }
      const eventConfiguration = gltfBlock.configuration["event"];
      const eventId = eventConfiguration.value[0];
      if (typeof eventId !== "number") {
        throw new Error("Event id should be a number");
      }
      const event = parser.arrays.events[eventId];
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.eventId = event.eventId;
      serializedObject.config.eventData = event.eventData;
      return serializedObjects;
    }
  },
  "event/receive": {
    blocks: [
      "FlowGraphReceiveCustomEventBlock"
      /* FlowGraphBlockNames.ReceiveCustomEvent */
    ],
    outputs: {
      flows: {
        out: { name: "done" }
      }
    },
    validation(gltfBlock, interactivityGraph) {
      var _a;
      if (!gltfBlock.configuration) {
        Logger.Error("Receive event should have a configuration object");
        return { valid: false, error: "Receive event should have a configuration object" };
      }
      const eventConfiguration = gltfBlock.configuration["event"];
      if (!eventConfiguration) {
        Logger.Error("Receive event should have a single configuration object, the event itself");
        return { valid: false, error: "Receive event should have a single configuration object, the event itself" };
      }
      const eventId = eventConfiguration.value[0];
      if (typeof eventId !== "number") {
        Logger.Error("Event id should be a number");
        return { valid: false, error: "Event id should be a number" };
      }
      const event = (_a = interactivityGraph.events) == null ? void 0 : _a[eventId];
      if (!event) {
        Logger.Error(`Event with id ${eventId} not found`);
        return { valid: false, error: `Event with id ${eventId} not found` };
      }
      return { valid: true };
    },
    extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {
      if (declaration.op !== "event/receive" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
        throw new Error("Receive event should have a single configuration object, the event itself");
      }
      const eventConfiguration = gltfBlock.configuration["event"];
      const eventId = eventConfiguration.value[0];
      if (typeof eventId !== "number") {
        throw new Error("Event id should be a number");
      }
      const event = parser.arrays.events[eventId];
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.eventId = event.eventId;
      serializedObject.config.eventData = event.eventData;
      return serializedObjects;
    }
  },
  "math/e": getSimpleInputMapping(
    "FlowGraphEBlock"
    /* FlowGraphBlockNames.E */
  ),
  "math/pi": getSimpleInputMapping(
    "FlowGraphPIBlock"
    /* FlowGraphBlockNames.PI */
  ),
  "math/inf": getSimpleInputMapping(
    "FlowGraphInfBlock"
    /* FlowGraphBlockNames.Inf */
  ),
  "math/nan": getSimpleInputMapping(
    "FlowGraphNaNBlock"
    /* FlowGraphBlockNames.NaN */
  ),
  "math/abs": getSimpleInputMapping(
    "FlowGraphAbsBlock"
    /* FlowGraphBlockNames.Abs */
  ),
  "math/sign": getSimpleInputMapping(
    "FlowGraphSignBlock"
    /* FlowGraphBlockNames.Sign */
  ),
  "math/trunc": getSimpleInputMapping(
    "FlowGraphTruncBlock"
    /* FlowGraphBlockNames.Trunc */
  ),
  "math/floor": getSimpleInputMapping(
    "FlowGraphFloorBlock"
    /* FlowGraphBlockNames.Floor */
  ),
  "math/ceil": getSimpleInputMapping(
    "FlowGraphCeilBlock"
    /* FlowGraphBlockNames.Ceil */
  ),
  "math/round": {
    blocks: [
      "FlowGraphRoundBlock"
      /* FlowGraphBlockNames.Round */
    ],
    configuration: {},
    inputs: {
      values: {
        a: { name: "a" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.roundHalfAwayFromZero = true;
      return serializedObjects;
    }
  },
  "math/fract": getSimpleInputMapping(
    "FlowGraphFractBlock"
    /* FlowGraphBlockNames.Fraction */
  ),
  "math/neg": getSimpleInputMapping(
    "FlowGraphNegationBlock"
    /* FlowGraphBlockNames.Negation */
  ),
  "math/add": getSimpleInputMapping("FlowGraphAddBlock", ["a", "b"], true),
  "math/sub": getSimpleInputMapping("FlowGraphSubtractBlock", ["a", "b"], true),
  "math/mul": {
    blocks: [
      "FlowGraphMultiplyBlock"
      /* FlowGraphBlockNames.Multiply */
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.useMatrixPerComponent = true;
      serializedObjects[0].config.preventIntegerFloatArithmetic = true;
      let type = -1;
      Object.keys(_gltfBlock.values || {}).find((value) => {
        var _a2;
        if (((_a2 = _gltfBlock.values) == null ? void 0 : _a2[value].type) !== void 0) {
          type = _gltfBlock.values[value].type;
          return true;
        }
        return false;
      });
      if (type !== -1) {
        serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;
      }
      return serializedObjects;
    },
    validation(gltfBlock) {
      if (gltfBlock.values) {
        return ValidateTypes(gltfBlock);
      }
      return { valid: true };
    }
  },
  "math/div": getSimpleInputMapping("FlowGraphDivideBlock", ["a", "b"], true),
  "math/rem": getSimpleInputMapping("FlowGraphModuloBlock", ["a", "b"]),
  "math/min": getSimpleInputMapping("FlowGraphMinBlock", ["a", "b"]),
  "math/max": getSimpleInputMapping("FlowGraphMaxBlock", ["a", "b"]),
  "math/clamp": getSimpleInputMapping("FlowGraphClampBlock", ["a", "b", "c"]),
  "math/saturate": getSimpleInputMapping(
    "FlowGraphSaturateBlock"
    /* FlowGraphBlockNames.Saturate */
  ),
  "math/mix": getSimpleInputMapping("FlowGraphMathInterpolationBlock", ["a", "b", "c"]),
  "math/eq": getSimpleInputMapping("FlowGraphEqualityBlock", ["a", "b"]),
  "math/lt": getSimpleInputMapping("FlowGraphLessThanBlock", ["a", "b"]),
  "math/le": getSimpleInputMapping("FlowGraphLessThanOrEqualBlock", ["a", "b"]),
  "math/gt": getSimpleInputMapping("FlowGraphGreaterThanBlock", ["a", "b"]),
  "math/ge": getSimpleInputMapping("FlowGraphGreaterThanOrEqualBlock", ["a", "b"]),
  "math/isnan": getSimpleInputMapping(
    "FlowGraphIsNaNBlock"
    /* FlowGraphBlockNames.IsNaN */
  ),
  "math/isinf": getSimpleInputMapping(
    "FlowGraphIsInfBlock"
    /* FlowGraphBlockNames.IsInfinity */
  ),
  "math/select": {
    blocks: [
      "FlowGraphConditionalBlock"
      /* FlowGraphBlockNames.Conditional */
    ],
    inputs: {
      values: {
        condition: { name: "condition" },
        // Should we validate those have the same type here, or assume it is already validated?
        a: { name: "onTrue" },
        b: { name: "onFalse" }
      }
    },
    outputs: {
      values: {
        value: { name: "output" }
      }
    }
  },
  "math/random": {
    blocks: [
      "FlowGraphRandomBlock"
      /* FlowGraphBlockNames.Random */
    ],
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/sin": getSimpleInputMapping(
    "FlowGraphSinBlock"
    /* FlowGraphBlockNames.Sin */
  ),
  "math/cos": getSimpleInputMapping(
    "FlowGraphCosBlock"
    /* FlowGraphBlockNames.Cos */
  ),
  "math/tan": getSimpleInputMapping(
    "FlowGraphTanBlock"
    /* FlowGraphBlockNames.Tan */
  ),
  "math/asin": getSimpleInputMapping(
    "FlowGraphASinBlock"
    /* FlowGraphBlockNames.Asin */
  ),
  "math/acos": getSimpleInputMapping(
    "FlowGraphACosBlock"
    /* FlowGraphBlockNames.Acos */
  ),
  "math/atan": getSimpleInputMapping(
    "FlowGraphATanBlock"
    /* FlowGraphBlockNames.Atan */
  ),
  "math/atan2": getSimpleInputMapping("FlowGraphATan2Block", ["a", "b"]),
  "math/sinh": getSimpleInputMapping(
    "FlowGraphSinhBlock"
    /* FlowGraphBlockNames.Sinh */
  ),
  "math/cosh": getSimpleInputMapping(
    "FlowGraphCoshBlock"
    /* FlowGraphBlockNames.Cosh */
  ),
  "math/tanh": getSimpleInputMapping(
    "FlowGraphTanhBlock"
    /* FlowGraphBlockNames.Tanh */
  ),
  "math/asinh": getSimpleInputMapping(
    "FlowGraphASinhBlock"
    /* FlowGraphBlockNames.Asinh */
  ),
  "math/acosh": getSimpleInputMapping(
    "FlowGraphACoshBlock"
    /* FlowGraphBlockNames.Acosh */
  ),
  "math/atanh": getSimpleInputMapping(
    "FlowGraphATanhBlock"
    /* FlowGraphBlockNames.Atanh */
  ),
  "math/exp": getSimpleInputMapping(
    "FlowGraphExponentialBlock"
    /* FlowGraphBlockNames.Exponential */
  ),
  "math/log": getSimpleInputMapping(
    "FlowGraphLogBlock"
    /* FlowGraphBlockNames.Log */
  ),
  "math/log2": getSimpleInputMapping(
    "FlowGraphLog2Block"
    /* FlowGraphBlockNames.Log2 */
  ),
  "math/log10": getSimpleInputMapping(
    "FlowGraphLog10Block"
    /* FlowGraphBlockNames.Log10 */
  ),
  "math/sqrt": getSimpleInputMapping(
    "FlowGraphSquareRootBlock"
    /* FlowGraphBlockNames.SquareRoot */
  ),
  "math/cbrt": getSimpleInputMapping(
    "FlowGraphCubeRootBlock"
    /* FlowGraphBlockNames.CubeRoot */
  ),
  "math/pow": getSimpleInputMapping("FlowGraphPowerBlock", ["a", "b"]),
  "math/length": getSimpleInputMapping(
    "FlowGraphLengthBlock"
    /* FlowGraphBlockNames.Length */
  ),
  "math/normalize": getSimpleInputMapping(
    "FlowGraphNormalizeBlock"
    /* FlowGraphBlockNames.Normalize */
  ),
  "math/dot": getSimpleInputMapping("FlowGraphDotBlock", ["a", "b"]),
  "math/cross": getSimpleInputMapping("FlowGraphCrossBlock", ["a", "b"]),
  "math/rotate2D": getSimpleInputMapping("FlowGraphRotate2DBlock", ["a", "b"]),
  "math/rotate3D": getSimpleInputMapping("FlowGraphRotate3DBlock", ["a", "b"]),
  "math/transform": {
    // glTF transform is vectorN with matrixN
    blocks: [
      "FlowGraphTransformVectorBlock"
      /* FlowGraphBlockNames.TransformVector */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/combine2": {
    blocks: [
      "FlowGraphCombineVector2Block"
      /* FlowGraphBlockNames.CombineVector2 */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/combine3": {
    blocks: [
      "FlowGraphCombineVector3Block"
      /* FlowGraphBlockNames.CombineVector3 */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/combine4": {
    blocks: [
      "FlowGraphCombineVector4Block"
      /* FlowGraphBlockNames.CombineVector4 */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  // one input, N outputs! outputs named using numbers.
  "math/extract2": {
    blocks: [
      "FlowGraphExtractVector2Block"
      /* FlowGraphBlockNames.ExtractVector2 */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" }
      }
    }
  },
  "math/extract3": {
    blocks: [
      "FlowGraphExtractVector3Block"
      /* FlowGraphBlockNames.ExtractVector3 */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" }
      }
    }
  },
  "math/extract4": {
    blocks: [
      "FlowGraphExtractVector4Block"
      /* FlowGraphBlockNames.ExtractVector4 */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" }
      }
    }
  },
  "math/transpose": getSimpleInputMapping(
    "FlowGraphTransposeBlock"
    /* FlowGraphBlockNames.Transpose */
  ),
  "math/determinant": getSimpleInputMapping(
    "FlowGraphDeterminantBlock"
    /* FlowGraphBlockNames.Determinant */
  ),
  "math/inverse": getSimpleInputMapping(
    "FlowGraphInvertMatrixBlock"
    /* FlowGraphBlockNames.InvertMatrix */
  ),
  "math/matmul": getSimpleInputMapping("FlowGraphMatrixMultiplicationBlock", ["a", "b"]),
  "math/matCompose": {
    blocks: [
      "FlowGraphMatrixCompose"
      /* FlowGraphBlockNames.MatrixCompose */
    ],
    inputs: {
      values: {
        translation: { name: "position", gltfType: "float3" },
        rotation: { name: "rotationQuaternion", gltfType: "float4" },
        scale: { name: "scaling", gltfType: "float3" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      const d = serializedObjects[0].dataInputs.find((input) => input.name === "rotationQuaternion");
      if (!d) {
        throw new Error("Rotation quaternion input not found");
      }
      if (context._connectionValues[d.uniqueId]) {
        context._connectionValues[d.uniqueId].type = "Quaternion";
      }
      return serializedObjects;
    }
  },
  "math/matDecompose": {
    blocks: [
      "FlowGraphMatrixDecompose"
      /* FlowGraphBlockNames.MatrixDecompose */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        translation: { name: "position" },
        rotation: { name: "rotationQuaternion" },
        scale: { name: "scaling" }
      }
    }
  },
  "math/quatConjugate": getSimpleInputMapping("FlowGraphConjugateBlock", ["a"]),
  "math/quatMul": {
    blocks: [
      "FlowGraphMultiplyBlock"
      /* FlowGraphBlockNames.Multiply */
    ],
    inputs: {
      values: {
        a: { name: "a", gltfType: "vector4" },
        b: { name: "b", gltfType: "vector4" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.type = "Quaternion";
      return serializedObjects;
    }
  },
  "math/quatAngleBetween": getSimpleInputMapping("FlowGraphAngleBetweenBlock", ["a", "b"]),
  "math/quatFromAxisAngle": {
    blocks: [
      "FlowGraphQuaternionFromAxisAngleBlock"
      /* FlowGraphBlockNames.QuaternionFromAxisAngle */
    ],
    inputs: {
      values: {
        axis: { name: "a", gltfType: "float3" },
        angle: { name: "b", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/quatToAxisAngle": getSimpleInputMapping("FlowGraphAxisAngleFromQuaternionBlock", ["a"]),
  "math/quatFromDirections": getSimpleInputMapping("FlowGraphQuaternionFromDirectionsBlock", ["a", "b"]),
  "math/combine2x2": {
    blocks: [
      "FlowGraphCombineMatrix2DBlock"
      /* FlowGraphBlockNames.CombineMatrix2D */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.inputIsColumnMajor = true;
      return serializedObjects;
    }
  },
  "math/extract2x2": {
    blocks: [
      "FlowGraphExtractMatrix2DBlock"
      /* FlowGraphBlockNames.ExtractMatrix2D */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "float2x2" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" }
      }
    }
  },
  "math/combine3x3": {
    blocks: [
      "FlowGraphCombineMatrix3DBlock"
      /* FlowGraphBlockNames.CombineMatrix3D */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" },
        e: { name: "input_4", gltfType: "number" },
        f: { name: "input_5", gltfType: "number" },
        g: { name: "input_6", gltfType: "number" },
        h: { name: "input_7", gltfType: "number" },
        i: { name: "input_8", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.inputIsColumnMajor = true;
      return serializedObjects;
    }
  },
  "math/extract3x3": {
    blocks: [
      "FlowGraphExtractMatrix3DBlock"
      /* FlowGraphBlockNames.ExtractMatrix3D */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "float3x3" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" },
        "4": { name: "output_4" },
        "5": { name: "output_5" },
        "6": { name: "output_6" },
        "7": { name: "output_7" },
        "8": { name: "output_8" }
      }
    }
  },
  "math/combine4x4": {
    blocks: [
      "FlowGraphCombineMatrixBlock"
      /* FlowGraphBlockNames.CombineMatrix */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" },
        e: { name: "input_4", gltfType: "number" },
        f: { name: "input_5", gltfType: "number" },
        g: { name: "input_6", gltfType: "number" },
        h: { name: "input_7", gltfType: "number" },
        i: { name: "input_8", gltfType: "number" },
        j: { name: "input_9", gltfType: "number" },
        k: { name: "input_10", gltfType: "number" },
        l: { name: "input_11", gltfType: "number" },
        m: { name: "input_12", gltfType: "number" },
        n: { name: "input_13", gltfType: "number" },
        o: { name: "input_14", gltfType: "number" },
        p: { name: "input_15", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.inputIsColumnMajor = true;
      return serializedObjects;
    }
  },
  "math/extract4x4": {
    blocks: [
      "FlowGraphExtractMatrixBlock"
      /* FlowGraphBlockNames.ExtractMatrix */
    ],
    configuration: {},
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" },
        "4": { name: "output_4" },
        "5": { name: "output_5" },
        "6": { name: "output_6" },
        "7": { name: "output_7" },
        "8": { name: "output_8" },
        "9": { name: "output_9" },
        "10": { name: "output_10" },
        "11": { name: "output_11" },
        "12": { name: "output_12" },
        "13": { name: "output_13" },
        "14": { name: "output_14" },
        "15": { name: "output_15" }
      }
    }
  },
  "math/not": {
    blocks: [
      "FlowGraphBitwiseNotBlock"
      /* FlowGraphBlockNames.BitwiseNot */
    ],
    inputs: {
      values: {
        a: { name: "a" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a2;
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketIn = serializedObjects[0].dataInputs[0];
      serializedObjects[0].config.valueType = ((_a2 = context._connectionValues[socketIn.uniqueId]) == null ? void 0 : _a2.type) ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/and": {
    blocks: [
      "FlowGraphBitwiseAndBlock"
      /* FlowGraphBlockNames.BitwiseAnd */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a2, _b;
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketInA = serializedObjects[0].dataInputs[0];
      const socketInB = serializedObjects[0].dataInputs[1];
      serializedObjects[0].config.valueType = ((_a2 = context._connectionValues[socketInA.uniqueId]) == null ? void 0 : _a2.type) ?? ((_b = context._connectionValues[socketInB.uniqueId]) == null ? void 0 : _b.type) ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/or": {
    blocks: [
      "FlowGraphBitwiseOrBlock"
      /* FlowGraphBlockNames.BitwiseOr */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a2, _b;
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketInA = serializedObjects[0].dataInputs[0];
      const socketInB = serializedObjects[0].dataInputs[1];
      serializedObjects[0].config.valueType = ((_a2 = context._connectionValues[socketInA.uniqueId]) == null ? void 0 : _a2.type) ?? ((_b = context._connectionValues[socketInB.uniqueId]) == null ? void 0 : _b.type) ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/xor": {
    blocks: [
      "FlowGraphBitwiseXorBlock"
      /* FlowGraphBlockNames.BitwiseXor */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a2, _b;
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketInA = serializedObjects[0].dataInputs[0];
      const socketInB = serializedObjects[0].dataInputs[1];
      serializedObjects[0].config.valueType = ((_a2 = context._connectionValues[socketInA.uniqueId]) == null ? void 0 : _a2.type) ?? ((_b = context._connectionValues[socketInB.uniqueId]) == null ? void 0 : _b.type) ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/asr": getSimpleInputMapping("FlowGraphBitwiseRightShiftBlock", ["a", "b"]),
  "math/lsl": getSimpleInputMapping("FlowGraphBitwiseLeftShiftBlock", ["a", "b"]),
  "math/clz": getSimpleInputMapping(
    "FlowGraphLeadingZerosBlock"
    /* FlowGraphBlockNames.LeadingZeros */
  ),
  "math/ctz": getSimpleInputMapping(
    "FlowGraphTrailingZerosBlock"
    /* FlowGraphBlockNames.TrailingZeros */
  ),
  "math/popcnt": getSimpleInputMapping(
    "FlowGraphOneBitsCounterBlock"
    /* FlowGraphBlockNames.OneBitsCounter */
  ),
  "math/rad": getSimpleInputMapping(
    "FlowGraphDegToRadBlock"
    /* FlowGraphBlockNames.DegToRad */
  ),
  "math/deg": getSimpleInputMapping(
    "FlowGraphRadToDegBlock"
    /* FlowGraphBlockNames.RadToDeg */
  ),
  "type/boolToInt": getSimpleInputMapping(
    "FlowGraphBooleanToInt"
    /* FlowGraphBlockNames.BooleanToInt */
  ),
  "type/boolToFloat": getSimpleInputMapping(
    "FlowGraphBooleanToFloat"
    /* FlowGraphBlockNames.BooleanToFloat */
  ),
  "type/intToBool": getSimpleInputMapping(
    "FlowGraphIntToBoolean"
    /* FlowGraphBlockNames.IntToBoolean */
  ),
  "type/intToFloat": getSimpleInputMapping(
    "FlowGraphIntToFloat"
    /* FlowGraphBlockNames.IntToFloat */
  ),
  "type/floatToInt": getSimpleInputMapping(
    "FlowGraphFloatToInt"
    /* FlowGraphBlockNames.FloatToInt */
  ),
  "type/floatToBool": getSimpleInputMapping(
    "FlowGraphFloatToBoolean"
    /* FlowGraphBlockNames.FloatToBoolean */
  ),
  // flows
  "flow/sequence": {
    blocks: [
      "FlowGraphSequenceBlock"
      /* FlowGraphBlockNames.Sequence */
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows || []).length;
      serializedObject.signalOutputs.forEach((output, index) => {
        output.name = "out_" + index;
      });
      return serializedObjects;
    }
  },
  "flow/branch": {
    blocks: [
      "FlowGraphBranchBlock"
      /* FlowGraphBlockNames.Branch */
    ],
    outputs: {
      flows: {
        true: { name: "onTrue" },
        false: { name: "onFalse" }
      }
    }
  },
  "flow/switch": {
    blocks: [
      "FlowGraphSwitchBlock"
      /* FlowGraphBlockNames.Switch */
    ],
    configuration: {
      cases: { name: "cases", inOptions: true, defaultValue: [] }
    },
    inputs: {
      values: {
        selection: { name: "case" },
        default: { name: "default" }
      }
    },
    validation(gltfBlock) {
      if (gltfBlock.configuration && gltfBlock.configuration.cases) {
        const cases = gltfBlock.configuration.cases.value;
        const onlyIntegers = cases.every((caseValue) => {
          return typeof caseValue === "number" && /^-?\d+$/.test(caseValue.toString());
        });
        if (!onlyIntegers) {
          Logger.Warn("Switch cases should be integers. Using empty array instead.");
          gltfBlock.configuration.cases.value = [];
          return { valid: true };
        }
        const uniqueCases = new Set(cases);
        gltfBlock.configuration.cases.value = Array.from(uniqueCases);
      }
      return { valid: true };
    },
    extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
      if (declaration.op !== "flow/switch" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
        throw new Error("Switch should have a single configuration object, the cases array");
      }
      const serializedObject = serializedObjects[0];
      serializedObject.signalOutputs.forEach((output) => {
        if (output.name !== "default") {
          output.name = "out_" + output.name;
        }
      });
      return serializedObjects;
    }
  },
  "flow/while": {
    blocks: [
      "FlowGraphWhileLoopBlock"
      /* FlowGraphBlockNames.WhileLoop */
    ],
    outputs: {
      flows: {
        loopBody: { name: "executionFlow" }
      }
    }
  },
  "flow/for": {
    blocks: [
      "FlowGraphForLoopBlock"
      /* FlowGraphBlockNames.ForLoop */
    ],
    configuration: {
      initialIndex: { name: "initialIndex", gltfType: "number", inOptions: true, defaultValue: 0 }
    },
    inputs: {
      values: {
        startIndex: { name: "startIndex", gltfType: "number" },
        endIndex: { name: "endIndex", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        index: { name: "index" }
      },
      flows: {
        loopBody: { name: "executionFlow" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.incrementIndexWhenLoopDone = true;
      return serializedObjects;
    }
  },
  "flow/doN": {
    blocks: [
      "FlowGraphDoNBlock"
      /* FlowGraphBlockNames.DoN */
    ],
    configuration: {},
    inputs: {
      values: {
        n: { name: "maxExecutions", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        currentCount: { name: "executionCount" }
      }
    }
  },
  "flow/multiGate": {
    blocks: [
      "FlowGraphMultiGateBlock"
      /* FlowGraphBlockNames.MultiGate */
    ],
    configuration: {
      isRandom: { name: "isRandom", gltfType: "boolean", inOptions: true, defaultValue: false },
      isLoop: { name: "isLoop", gltfType: "boolean", inOptions: true, defaultValue: false }
    },
    extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
      if (declaration.op !== "flow/multiGate" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
        throw new Error("MultiGate should have a single configuration object, the number of output flows");
      }
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows).length;
      serializedObject.signalOutputs.forEach((output, index) => {
        output.name = "out_" + index;
      });
      return serializedObjects;
    }
  },
  "flow/waitAll": {
    blocks: [
      "FlowGraphWaitAllBlock"
      /* FlowGraphBlockNames.WaitAll */
    ],
    configuration: {
      inputFlows: { name: "inputSignalCount", gltfType: "number", inOptions: true, defaultValue: 0 }
    },
    inputs: {
      flows: {
        reset: { name: "reset" },
        "[segment]": { name: "in_$1" }
      }
    },
    validation(gltfBlock) {
      var _a, _b;
      if (typeof ((_b = (_a = gltfBlock.configuration) == null ? void 0 : _a.inputFlows) == null ? void 0 : _b.value[0]) !== "number") {
        gltfBlock.configuration = gltfBlock.configuration || {
          inputFlows: { value: [0] }
        };
        gltfBlock.configuration.inputFlows.value = [0];
      }
      return { valid: true };
    }
  },
  "flow/throttle": {
    blocks: [
      "FlowGraphThrottleBlock"
      /* FlowGraphBlockNames.Throttle */
    ],
    outputs: {
      flows: {
        err: { name: "error" }
      }
    }
  },
  "flow/setDelay": {
    blocks: [
      "FlowGraphSetDelayBlock"
      /* FlowGraphBlockNames.SetDelay */
    ],
    outputs: {
      flows: {
        err: { name: "error" }
      }
    }
  },
  "flow/cancelDelay": {
    blocks: [
      "FlowGraphCancelDelayBlock"
      /* FlowGraphBlockNames.CancelDelay */
    ]
  },
  "variable/get": {
    blocks: [
      "FlowGraphGetVariableBlock"
      /* FlowGraphBlockNames.GetVariable */
    ],
    validation(gltfBlock) {
      var _a, _b;
      if (!((_b = (_a = gltfBlock.configuration) == null ? void 0 : _a.variable) == null ? void 0 : _b.value)) {
        Logger.Error("Variable get block should have a variable configuration");
        return { valid: false, error: "Variable get block should have a variable configuration" };
      }
      return { valid: true };
    },
    configuration: {
      variable: {
        name: "variable",
        gltfType: "number",
        flowGraphType: "string",
        inOptions: true,
        isVariable: true,
        dataTransformer(index, parser) {
          return [parser.getVariableName(index[0])];
        }
      }
    }
  },
  "variable/set": {
    blocks: [
      "FlowGraphSetVariableBlock"
      /* FlowGraphBlockNames.SetVariable */
    ],
    configuration: {
      variable: {
        name: "variable",
        gltfType: "number",
        flowGraphType: "string",
        inOptions: true,
        isVariable: true,
        dataTransformer(index, parser) {
          return [parser.getVariableName(index[0])];
        }
      }
    }
  },
  "variable/setMultiple": {
    blocks: [
      "FlowGraphSetVariableBlock"
      /* FlowGraphBlockNames.SetVariable */
    ],
    configuration: {
      variables: {
        name: "variables",
        gltfType: "number",
        flowGraphType: "string",
        inOptions: true,
        dataTransformer(index, parser) {
          return [index[0].map((i) => parser.getVariableName(i))];
        }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      const serializedGetVariable = serializedObjects[0];
      serializedGetVariable.dataInputs.forEach((input) => {
        input.name = parser.getVariableName(+input.name);
      });
      return serializedObjects;
    }
  },
  "variable/interpolate": {
    blocks: [
      "FlowGraphInterpolationBlock",
      "FlowGraphContextBlock",
      "FlowGraphPlayAnimationBlock",
      "FlowGraphBezierCurveEasing",
      "FlowGraphGetVariableBlock"
    ],
    configuration: {
      variable: {
        name: "propertyName",
        inOptions: true,
        isVariable: true,
        dataTransformer(index, parser) {
          return [parser.getVariableName(index[0])];
        }
      },
      useSlerp: {
        name: "animationType",
        inOptions: true,
        defaultValue: false,
        dataTransformer: (value) => {
          if (value[0] === true) {
            return [
              "Quaternion"
              /* FlowGraphTypes.Quaternion */
            ];
          } else {
            return [void 0];
          }
        }
      }
    },
    inputs: {
      values: {
        value: { name: "value_1" },
        duration: { name: "duration_1", gltfType: "number" },
        p1: {
          name: "controlPoint1",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        },
        p2: {
          name: "controlPoint2",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        }
      },
      flows: {
        in: {
          name: "in",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    outputs: {
      flows: {
        err: {
          name: "error",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        out: {
          name: "out",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        done: {
          name: "done",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "userVariables",
        inputBlockIndex: 2,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "animation",
        output: "animation",
        inputBlockIndex: 2,
        outputBlockIndex: 0,
        isVariable: true
      },
      {
        input: "easingFunction",
        output: "easingFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 3,
        isVariable: true
      },
      {
        input: "value_0",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 4,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      var _a2;
      var _a, _b;
      const serializedValueInterpolation = serializedObjects[0];
      const propertyIndex = (_a2 = gltfBlock.configuration) == null ? void 0 : _a2.variable.value[0];
      if (typeof propertyIndex !== "number") {
        Logger.Error("Variable index is not defined for variable interpolation block");
        throw new Error("Variable index is not defined for variable interpolation block");
      }
      const variable = parser.arrays.staticVariables[propertyIndex];
      if (typeof serializedValueInterpolation.config.animationType.value === "undefined") {
        parser.arrays.staticVariables;
        serializedValueInterpolation.config.animationType.value = getAnimationTypeByFlowGraphType(variable.type);
      }
      const serializedGetVariable = serializedObjects[4];
      serializedGetVariable.config || (serializedGetVariable.config = {});
      (_a = serializedGetVariable.config).variable || (_a.variable = {});
      serializedGetVariable.config.variable.value = parser.getVariableName(propertyIndex);
      (_b = serializedObjects[3]).config || (_b.config = {});
      return serializedObjects;
    }
  },
  "pointer/get": {
    blocks: [
      "FlowGraphGetPropertyBlock",
      "FlowGraphJsonPointerParserBlock"
      /* FlowGraphBlockNames.JsonPointerParser */
    ],
    configuration: {
      pointer: {
        name: "jsonPointer",
        toBlock: "FlowGraphJsonPointerParserBlock"
        /* FlowGraphBlockNames.JsonPointerParser */
      }
    },
    inputs: {
      values: {
        "[segment]": {
          name: "$1",
          toBlock: "FlowGraphJsonPointerParserBlock"
          /* FlowGraphBlockNames.JsonPointerParser */
        }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "object",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "propertyName",
        output: "propertyName",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "customGetFunction",
        output: "getFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      serializedObjects.forEach((serializedObject) => {
        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
          serializedObject.config || (serializedObject.config = {});
          serializedObject.config.outputValue = true;
        }
      });
      return serializedObjects;
    }
  },
  "pointer/set": {
    blocks: [
      "FlowGraphSetPropertyBlock",
      "FlowGraphJsonPointerParserBlock"
      /* FlowGraphBlockNames.JsonPointerParser */
    ],
    configuration: {
      pointer: {
        name: "jsonPointer",
        toBlock: "FlowGraphJsonPointerParserBlock"
        /* FlowGraphBlockNames.JsonPointerParser */
      }
    },
    inputs: {
      values: {
        // must be defined due to the array taking over
        value: { name: "value" },
        "[segment]": {
          name: "$1",
          toBlock: "FlowGraphJsonPointerParserBlock"
          /* FlowGraphBlockNames.JsonPointerParser */
        }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "object",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "propertyName",
        output: "propertyName",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "customSetFunction",
        output: "setFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      serializedObjects.forEach((serializedObject) => {
        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
          serializedObject.config || (serializedObject.config = {});
          serializedObject.config.outputValue = true;
        }
      });
      return serializedObjects;
    }
  },
  "pointer/interpolate": {
    // interpolate, parse the pointer and play the animation generated. 3 blocks!
    blocks: [
      "FlowGraphInterpolationBlock",
      "FlowGraphJsonPointerParserBlock",
      "FlowGraphPlayAnimationBlock",
      "FlowGraphBezierCurveEasing"
      /* FlowGraphBlockNames.BezierCurveEasing */
    ],
    configuration: {
      pointer: {
        name: "jsonPointer",
        toBlock: "FlowGraphJsonPointerParserBlock"
        /* FlowGraphBlockNames.JsonPointerParser */
      }
    },
    inputs: {
      values: {
        value: { name: "value_1" },
        "[segment]": {
          name: "$1",
          toBlock: "FlowGraphJsonPointerParserBlock"
          /* FlowGraphBlockNames.JsonPointerParser */
        },
        duration: {
          name: "duration_1",
          gltfType: "number"
          /*, inOptions: true */
        },
        p1: {
          name: "controlPoint1",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        },
        p2: {
          name: "controlPoint2",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        }
      },
      flows: {
        in: {
          name: "in",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    outputs: {
      flows: {
        err: {
          name: "error",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        out: {
          name: "out",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        done: {
          name: "done",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "object",
        inputBlockIndex: 2,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "propertyName",
        output: "propertyName",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "customBuildAnimation",
        output: "generateAnimationsFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "animation",
        output: "animation",
        inputBlockIndex: 2,
        outputBlockIndex: 0,
        isVariable: true
      },
      {
        input: "easingFunction",
        output: "easingFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 3,
        isVariable: true
      },
      {
        input: "value_0",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      serializedObjects.forEach((serializedObject) => {
        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
          serializedObject.config || (serializedObject.config = {});
          serializedObject.config.outputValue = true;
        } else if (serializedObject.className === "FlowGraphInterpolationBlock") {
          serializedObject.config || (serializedObject.config = {});
          Object.keys(gltfBlock.values || []).forEach((key) => {
            var _a;
            const value = (_a = gltfBlock.values) == null ? void 0 : _a[key];
            if (key === "value" && value) {
              const type = value.type;
              if (type !== void 0) {
                serializedObject.config.animationType = parser.arrays.types[type].flowGraphType;
              }
            }
          });
        }
      });
      return serializedObjects;
    }
  },
  "animation/start": {
    blocks: ["FlowGraphPlayAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
    inputs: {
      values: {
        animation: {
          name: "index",
          gltfType: "number",
          toBlock: "FlowGraphArrayIndexBlock"
          /* FlowGraphBlockNames.ArrayIndex */
        },
        speed: { name: "speed", gltfType: "number" },
        startTime: { name: "from", gltfType: "number", dataTransformer: (time, parser) => [time[0] * parser._animationTargetFps] },
        endTime: { name: "to", gltfType: "number", dataTransformer: (time, parser) => [time[0] * parser._animationTargetFps] }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "animationGroup",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "array",
        output: "animationGroups",
        inputBlockIndex: 1,
        outputBlockIndex: 2,
        isVariable: true
      }
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
      const serializedObject = serializedObjects[serializedObjects.length - 1];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.glTF = globalGLTF;
      return serializedObjects;
    }
  },
  "animation/stop": {
    blocks: ["FlowGraphStopAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
    inputs: {
      values: {
        animation: {
          name: "index",
          gltfType: "number",
          toBlock: "FlowGraphArrayIndexBlock"
          /* FlowGraphBlockNames.ArrayIndex */
        }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "animationGroup",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "array",
        output: "animationGroups",
        inputBlockIndex: 1,
        outputBlockIndex: 2,
        isVariable: true
      }
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
      const serializedObject = serializedObjects[serializedObjects.length - 1];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.glTF = globalGLTF;
      return serializedObjects;
    }
  },
  "animation/stopAt": {
    blocks: ["FlowGraphStopAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
    configuration: {},
    inputs: {
      values: {
        animation: {
          name: "index",
          gltfType: "number",
          toBlock: "FlowGraphArrayIndexBlock"
          /* FlowGraphBlockNames.ArrayIndex */
        },
        stopTime: { name: "stopAtFrame", gltfType: "number", dataTransformer: (time, parser) => [time[0] * parser._animationTargetFps] }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "animationGroup",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "array",
        output: "animationGroups",
        inputBlockIndex: 1,
        outputBlockIndex: 2,
        isVariable: true
      }
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
      const serializedObject = serializedObjects[serializedObjects.length - 1];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.glTF = globalGLTF;
      return serializedObjects;
    }
  },
  "math/switch": {
    blocks: [
      "FlowGraphDataSwitchBlock"
      /* FlowGraphBlockNames.DataSwitch */
    ],
    configuration: {
      cases: { name: "cases", inOptions: true, defaultValue: [] }
    },
    inputs: {
      values: {
        selection: { name: "case" }
      }
    },
    validation(gltfBlock) {
      if (gltfBlock.configuration && gltfBlock.configuration.cases) {
        const cases = gltfBlock.configuration.cases.value;
        const onlyIntegers = cases.every((caseValue) => {
          return typeof caseValue === "number" && /^-?\d+$/.test(caseValue.toString());
        });
        if (!onlyIntegers) {
          Logger.Warn("Switch cases should be integers. Using empty array instead.");
          gltfBlock.configuration.cases.value = [];
          return { valid: true };
        }
        const uniqueCases = new Set(cases);
        gltfBlock.configuration.cases.value = Array.from(uniqueCases);
      }
      return { valid: true };
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
      const serializedObject = serializedObjects[0];
      serializedObject.dataInputs.forEach((input) => {
        if (input.name !== "default" && input.name !== "case") {
          input.name = "in_" + input.name;
        }
      });
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.treatCasesAsIntegers = true;
      return serializedObjects;
    }
  },
  "debug/log": {
    blocks: [
      "FlowGraphConsoleLogBlock"
      /* FlowGraphBlockNames.ConsoleLog */
    ],
    configuration: {
      message: { name: "messageTemplate", inOptions: true }
    }
  }
};
gltfToFlowGraphMapping["math/compose"] = gltfToFlowGraphMapping["math/matCompose"];
gltfToFlowGraphMapping["math/decompose"] = gltfToFlowGraphMapping["math/matDecompose"];
function getSimpleInputMapping(type, inputs = ["a"], inferType) {
  return {
    blocks: [type],
    inputs: {
      values: inputs.reduce((acc, input) => {
        acc[input] = { name: input };
        return acc;
      }, {})
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      if (inferType) {
        (_a = serializedObjects[0]).config || (_a.config = {});
        serializedObjects[0].config.preventIntegerFloatArithmetic = true;
        let type2 = -1;
        Object.keys(gltfBlock.values || {}).find((value) => {
          var _a2;
          if (((_a2 = gltfBlock.values) == null ? void 0 : _a2[value].type) !== void 0) {
            type2 = gltfBlock.values[value].type;
            return true;
          }
          return false;
        });
        if (type2 !== -1) {
          serializedObjects[0].config.type = _parser.arrays.types[type2].flowGraphType;
        }
      }
      return serializedObjects;
    },
    validation(gltfBlock) {
      if (inferType) {
        return ValidateTypes(gltfBlock);
      }
      return { valid: true };
    }
  };
}
function ValidateTypes(gltfBlock) {
  if (gltfBlock.values) {
    const types = Object.keys(gltfBlock.values).map((key) => gltfBlock.values[key].type).filter((type) => type !== void 0);
    const allSameType = types.every((type) => type === types[0]);
    if (!allSameType) {
      return { valid: false, error: "All inputs must be of the same type" };
    }
  }
  return { valid: true };
}

export {
  getMappingForFullOperationName,
  getMappingForDeclaration,
  addNewInteractivityFlowGraphMapping
};
//# sourceMappingURL=chunk-3B3CYPTM.js.map
