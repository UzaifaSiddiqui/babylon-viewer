import {
  FlowGraphInteger,
  FlowGraphMatrix2D,
  FlowGraphMatrix3D,
  getRichTypeByFlowGraphType
} from "./chunk-EGZAI6OC.js";
import {
  Color3,
  Color4
} from "./chunk-KU4OFD2T.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import {
  Matrix,
  Quaternion,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-YCWH5W4G.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";

// node_modules/@babylonjs/core/FlowGraph/serialization.js
function IsMeshClassName(className) {
  return className === "Mesh" || className === "AbstractMesh" || className === "GroundMesh" || className === "InstanceMesh" || className === "LinesMesh" || className === "GoldbergMesh" || className === "GreasedLineMesh" || className === "TrailMesh";
}
function IsVectorClassName(className) {
  return className === "Vector2" || className === "Vector3" || className === "Vector4" || className === "Quaternion" || className === "Color3" || className === "Color4";
}
function IsMatrixClassName(className) {
  return className === "Matrix" || className === "Matrix2D" || className === "Matrix3D";
}
function IsAnimationGroupClassName(className) {
  return className === "AnimationGroup";
}
function ParseVector(className, value, flipHandedness = false) {
  if (className === "Vector2") {
    return Vector2.FromArray(value);
  } else if (className === "Vector3") {
    if (flipHandedness) {
      value[2] *= -1;
    }
    return Vector3.FromArray(value);
  } else if (className === "Vector4") {
    return Vector4.FromArray(value);
  } else if (className === "Quaternion") {
    if (flipHandedness) {
      value[2] *= -1;
      value[3] *= -1;
    }
    return Quaternion.FromArray(value);
  } else if (className === "Color3") {
    return new Color3(value[0], value[1], value[2]);
  } else if (className === "Color4") {
    return new Color4(value[0], value[1], value[2], value[3]);
  } else {
    throw new Error(`Unknown vector class name ${className}`);
  }
}
function defaultValueSerializationFunction(key, value, serializationObject) {
  var _a;
  const className = ((_a = value == null ? void 0 : value.getClassName) == null ? void 0 : _a.call(value)) ?? "";
  if (IsVectorClassName(className) || IsMatrixClassName(className)) {
    serializationObject[key] = {
      value: value.asArray(),
      className
    };
  } else if (className === "FlowGraphInteger") {
    serializationObject[key] = {
      value: value.value,
      className
    };
  } else {
    if (className && (value.id || value.name)) {
      serializationObject[key] = {
        id: value.id,
        name: value.name,
        className
      };
    } else {
      if (typeof value !== "object") {
        serializationObject[key] = value;
      } else {
        throw new Error(`Could not serialize value ${value}`);
      }
    }
  }
}
function defaultValueParseFunction(key, serializationObject, assetsContainer, scene) {
  const intermediateValue = serializationObject[key];
  let finalValue;
  const className = (intermediateValue == null ? void 0 : intermediateValue.type) ?? (intermediateValue == null ? void 0 : intermediateValue.className);
  if (IsMeshClassName(className)) {
    let nodes = scene.meshes.filter((m) => intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name);
    if (nodes.length === 0) {
      nodes = scene.transformNodes.filter((m) => intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name);
    }
    finalValue = intermediateValue.uniqueId ? nodes.find((m) => m.uniqueId === intermediateValue.uniqueId) : nodes[0];
  } else if (IsVectorClassName(className)) {
    finalValue = ParseVector(className, intermediateValue.value);
  } else if (IsAnimationGroupClassName(className)) {
    const ags = scene.animationGroups.filter((ag) => ag.name === intermediateValue.name);
    finalValue = ags.length === 1 ? ags[0] : ags.find((ag) => ag.uniqueId === intermediateValue.uniqueId);
  } else if (className === "Matrix") {
    finalValue = Matrix.FromArray(intermediateValue.value);
  } else if (className === "Matrix2D") {
    finalValue = new FlowGraphMatrix2D(intermediateValue.value);
  } else if (className === "Matrix3D") {
    finalValue = new FlowGraphMatrix3D(intermediateValue.value);
  } else if (className === "FlowGraphInteger") {
    finalValue = FlowGraphInteger.FromValue(intermediateValue.value);
  } else if (className === "number" || className === "string" || className === "boolean") {
    finalValue = intermediateValue.value[0];
  } else if (intermediateValue && intermediateValue.value !== void 0) {
    finalValue = intermediateValue.value;
  } else {
    if (Array.isArray(intermediateValue)) {
      finalValue = intermediateValue.reduce((acc, val) => {
        if (!val.eventData) {
          return acc;
        }
        acc[val.id] = {
          type: getRichTypeByFlowGraphType(val.type)
        };
        if (typeof val.value !== "undefined") {
          acc[val.id].value = defaultValueParseFunction("value", val, assetsContainer, scene);
        }
        return acc;
      }, {});
    } else {
      finalValue = intermediateValue;
    }
  }
  return finalValue;
}
function needsPathConverter(className) {
  return className === "FlowGraphJsonPointerParserBlock";
}

// node_modules/@babylonjs/core/FlowGraph/flowGraphConnection.js
var FlowGraphConnectionType;
(function(FlowGraphConnectionType2) {
  FlowGraphConnectionType2[FlowGraphConnectionType2["Input"] = 0] = "Input";
  FlowGraphConnectionType2[FlowGraphConnectionType2["Output"] = 1] = "Output";
})(FlowGraphConnectionType || (FlowGraphConnectionType = {}));
var FlowGraphConnection = class {
  constructor(name, _connectionType, _ownerBlock) {
    this._ownerBlock = _ownerBlock;
    this._connectedPoint = [];
    this.uniqueId = RandomGUID();
    this.connectedPointIds = [];
    this.name = name;
    this._connectionType = _connectionType;
  }
  /**
   * The type of the connection
   */
  get connectionType() {
    return this._connectionType;
  }
  /**
   * @internal
   * Override this to indicate if a point can connect to more than one point.
   */
  _isSingularConnection() {
    return true;
  }
  /**
   * Returns if a point is connected to any other point.
   * @returns boolean indicating if the point is connected.
   */
  isConnected() {
    return this._connectedPoint.length > 0;
  }
  /**
   * Connects two connections together.
   * @param point the connection to connect to.
   */
  connectTo(point) {
    if (this._connectionType === point._connectionType) {
      throw new Error(`Cannot connect two points of type ${this.connectionType}`);
    }
    if (this._isSingularConnection() && this._connectedPoint.length > 0 || point._isSingularConnection() && point._connectedPoint.length > 0) {
      throw new Error("Max number of connections for point reached");
    }
    this._connectedPoint.push(point);
    point._connectedPoint.push(this);
  }
  /**
   * Disconnects two connections.
   * @param point the connection to disconnect from.
   * @param removeFromLocal if true, the connection will be removed from the local connection list.
   */
  disconnectFrom(point, removeFromLocal = true) {
    const indexLocal = this._connectedPoint.indexOf(point);
    const indexConnected = point._connectedPoint.indexOf(this);
    if (indexLocal === -1 || indexConnected === -1) {
      return;
    }
    if (removeFromLocal) {
      this._connectedPoint.splice(indexLocal, 1);
    }
    point._connectedPoint.splice(indexConnected, 1);
  }
  /**
   * Disconnects all connected points.
   */
  disconnectFromAll() {
    for (const point of this._connectedPoint) {
      this.disconnectFrom(point, false);
    }
    this._connectedPoint.length = 0;
  }
  dispose() {
    for (const point of this._connectedPoint) {
      this.disconnectFrom(point);
    }
  }
  /**
   * Saves the connection to a JSON object.
   * @param serializationObject the object to serialize to.
   */
  serialize(serializationObject = {}) {
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject._connectionType = this._connectionType;
    serializationObject.connectedPointIds = [];
    serializationObject.className = this.getClassName();
    for (const point of this._connectedPoint) {
      serializationObject.connectedPointIds.push(point.uniqueId);
    }
  }
  /**
   * @returns class name of the connection.
   */
  getClassName() {
    return "FGConnection";
  }
  /**
   * Deserialize from a object into this
   * @param serializationObject the object to deserialize from.
   */
  deserialize(serializationObject) {
    this.uniqueId = serializationObject.uniqueId;
    this.name = serializationObject.name;
    this._connectionType = serializationObject._connectionType;
    this.connectedPointIds = serializationObject.connectedPointIds;
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphDataConnection.js
var FlowGraphDataConnection = class extends FlowGraphConnection {
  /**
   * Create a new data connection point.
   * @param name the name of the connection
   * @param connectionType the type of the connection
   * @param ownerBlock the block that owns this connection
   * @param richType the type of the data in this block
   * @param _defaultValue the default value of the connection
   * @param _optional if the connection is optional
   */
  constructor(name, connectionType, ownerBlock, richType, _defaultValue = richType.defaultValue, _optional = false) {
    super(name, connectionType, ownerBlock);
    this.richType = richType;
    this._defaultValue = _defaultValue;
    this._optional = _optional;
    this._isDisabled = false;
    this._lastValue = null;
    this.dataTransformer = null;
    this.onValueChangedObservable = new Observable();
  }
  /**
   * Whether or not the connection is optional.
   * Currently only used for UI control.
   */
  get optional() {
    return this._optional;
  }
  /**
   * is this connection disabled
   * If the connection is disabled you will not be able to connect anything to it.
   */
  get isDisabled() {
    return this._isDisabled;
  }
  set isDisabled(value) {
    if (this._isDisabled === value) {
      return;
    }
    this._isDisabled = value;
    if (this._isDisabled) {
      this.disconnectFromAll();
    }
  }
  /**
   * An output data block can connect to multiple input data blocks,
   * but an input data block can only connect to one output data block.
   * @returns true if the connection is singular
   */
  _isSingularConnection() {
    return this.connectionType === 0;
  }
  /**
   * Set the value of the connection in a specific context.
   * @param value the value to set
   * @param context the context to which the value is set
   */
  setValue(value, context) {
    if (context._getConnectionValue(this) === value) {
      return;
    }
    context._setConnectionValue(this, value);
    this.onValueChangedObservable.notifyObservers(value);
  }
  /**
   * Reset the value of the connection to the default value.
   * @param context the context in which the value is reset
   */
  resetToDefaultValue(context) {
    context._setConnectionValue(this, this._defaultValue);
  }
  /**
   * Connect this point to another point.
   * @param point the point to connect to.
   */
  connectTo(point) {
    if (this._isDisabled) {
      return;
    }
    super.connectTo(point);
  }
  _getValueOrDefault(context) {
    const val = context._getConnectionValue(this) ?? this._defaultValue;
    return this.dataTransformer ? this.dataTransformer(val) : val;
  }
  /**
   * Gets the value of the connection in a specific context.
   * @param context the context from which the value is retrieved
   * @returns the value of the connection
   */
  getValue(context) {
    if (this.connectionType === 1) {
      context._notifyExecuteNode(this._ownerBlock);
      this._ownerBlock._updateOutputs(context);
      const value2 = this._getValueOrDefault(context);
      this._lastValue = value2;
      return this.richType.typeTransformer ? this.richType.typeTransformer(value2) : value2;
    }
    const value = !this.isConnected() ? this._getValueOrDefault(context) : this._connectedPoint[0].getValue(context);
    this._lastValue = value;
    return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;
  }
  /**
   * @internal
   */
  _getLastValue() {
    return this._lastValue;
  }
  /**
   * @returns class name of the object.
   */
  getClassName() {
    return "FlowGraphDataConnection";
  }
  /**
   * Serializes this object.
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject = {}) {
    super.serialize(serializationObject);
    serializationObject.richType = {};
    this.richType.serialize(serializationObject.richType);
    serializationObject.optional = this._optional;
    defaultValueSerializationFunction("defaultValue", this._defaultValue, serializationObject);
  }
};
RegisterClass("FlowGraphDataConnection", FlowGraphDataConnection);

// node_modules/@babylonjs/core/FlowGraph/flowGraphBlock.js
var FlowGraphBlock = class {
  /** Constructor is protected so only subclasses can be instantiated
   * @param config optional configuration for this block
   * @internal - do not use directly. Extend this class instead.
   */
  constructor(config) {
    var _a;
    this.config = config;
    this.uniqueId = RandomGUID();
    this.name = ((_a = this.config) == null ? void 0 : _a.name) ?? this.getClassName();
    this.dataInputs = [];
    this.dataOutputs = [];
  }
  /**
   * @internal
   * This function is called when the block needs to update its output flows.
   * @param _context the context in which it is running
   */
  _updateOutputs(_context) {
  }
  /**
   * Registers a data input on the block.
   * @param name the name of the input
   * @param richType the type of the input
   * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.
   * @returns the created connection
   */
  registerDataInput(name, richType, defaultValue) {
    const input = new FlowGraphDataConnection(name, 0, this, richType, defaultValue);
    this.dataInputs.push(input);
    return input;
  }
  /**
   * Registers a data output on the block.
   * @param name the name of the input
   * @param richType the type of the input
   * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.
   * @returns the created connection
   */
  registerDataOutput(name, richType, defaultValue) {
    const output = new FlowGraphDataConnection(name, 1, this, richType, defaultValue);
    this.dataOutputs.push(output);
    return output;
  }
  /**
   * Given the name of a data input, returns the connection if it exists
   * @param name the name of the input
   * @returns the connection if it exists, undefined otherwise
   */
  getDataInput(name) {
    return this.dataInputs.find((i) => i.name === name);
  }
  /**
   * Given the name of a data output, returns the connection if it exists
   * @param name the name of the output
   * @returns the connection if it exists, undefined otherwise
   */
  getDataOutput(name) {
    return this.dataOutputs.find((i) => i.name === name);
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize to
   * @param _valueSerializeFunction a function that serializes a specific value
   */
  serialize(serializationObject = {}, _valueSerializeFunction = defaultValueSerializationFunction) {
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.config = {};
    if (this.config) {
      const config = this.config;
      const keys = Object.keys(config);
      for (const key of keys) {
        _valueSerializeFunction(key, config[key], serializationObject.config);
      }
    }
    serializationObject.dataInputs = [];
    serializationObject.dataOutputs = [];
    serializationObject.className = this.getClassName();
    for (const input of this.dataInputs) {
      const serializedInput = {};
      input.serialize(serializedInput);
      serializationObject.dataInputs.push(serializedInput);
    }
    for (const output of this.dataOutputs) {
      const serializedOutput = {};
      output.serialize(serializedOutput);
      serializationObject.dataOutputs.push(serializedOutput);
    }
  }
  /**
   * Deserializes this block
   * @param _serializationObject the object to deserialize from
   */
  deserialize(_serializationObject) {
  }
  _log(context, action, payload) {
    var _a;
    (_a = context.logger) == null ? void 0 : _a.addLogItem({
      action,
      payload,
      className: this.getClassName(),
      uniqueId: this.uniqueId
    });
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return "FlowGraphBlock";
  }
};

export {
  defaultValueSerializationFunction,
  defaultValueParseFunction,
  needsPathConverter,
  FlowGraphConnectionType,
  FlowGraphConnection,
  FlowGraphDataConnection,
  FlowGraphBlock
};
//# sourceMappingURL=chunk-KJPKAW6K.js.map
