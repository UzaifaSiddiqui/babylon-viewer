{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/1.0/index.ts", "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts", "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts", "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts", "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts", "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts", "../../../dev/loaders/src/glTF/2.0/index.ts"],
  "sourcesContent": ["export * from \"./glTFBinaryExtension\";\r\nexport * from \"./glTFLoader\";\r\nexport * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./glTFLoaderUtils\";\r\nexport * from \"./glTFMaterialsCommonExtension\";\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Skeleton } from \"core/Bones/skeleton\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Enums\r\n * @internal\r\n */\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126,\r\n}\r\n\r\n/** @internal */\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633,\r\n}\r\n\r\n/** @internal */\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410,\r\n}\r\n\r\n/** @internal */\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032,\r\n}\r\n\r\n/** @internal */\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProperty {\r\n    extensions?: { [key: string]: any };\r\n    extras?: object;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: { [key: string]: IGLTFTechniqueParameter };\r\n    program: string;\r\n\r\n    attributes: { [key: string]: string };\r\n    uniforms: { [key: string]: string };\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: { [key: string]: string };\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?: { [key: string]: string };\r\n    samplers?: { [key: string]: IGLTFAnimationSampler };\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFRuntime {\r\n    extensions: { [key: string]: any };\r\n    accessors: { [key: string]: IGLTFAccessor };\r\n    buffers: { [key: string]: IGLTFBuffer };\r\n    bufferViews: { [key: string]: IGLTFBufferView };\r\n    meshes: { [key: string]: IGLTFMesh };\r\n    lights: { [key: string]: IGLTFLight };\r\n    cameras: { [key: string]: IGLTFCamera };\r\n    nodes: { [key: string]: IGLTFNode };\r\n    images: { [key: string]: IGLTFImage };\r\n    textures: { [key: string]: IGLTFTexture };\r\n    shaders: { [key: string]: IGLTFShader };\r\n    programs: { [key: string]: IGLTFProgram };\r\n    samplers: { [key: string]: IGLTFSampler };\r\n    techniques: { [key: string]: IGLTFTechnique };\r\n    materials: { [key: string]: IGLTFMaterial };\r\n    animations: { [key: string]: IGLTFAnimation };\r\n    skins: { [key: string]: IGLTFSkins };\r\n\r\n    currentScene?: object;\r\n    scenes: { [key: string]: IGLTFScene }; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n\r\n    assetContainer: Nullable<AssetContainer>;\r\n}\r\n\r\n/** @internal */\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n", "import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * Utils functions for GLTF\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene the Scene object\r\n     * @param source the source node where to pick the matrix\r\n     * @param parameter the GLTF technique parameter\r\n     * @param uniformName the name of the shader's uniform\r\n     * @param shaderMaterial the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        let mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        } else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        } else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        } else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        } else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        } else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2:\r\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT3:\r\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT4:\r\n                    shaderMaterial.setMatrix(uniformName, mat);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial the shader material\r\n     * @param uniform the name of the shader's uniform\r\n     * @param value the value of the uniform\r\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     * @returns true if set, else false\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT:\r\n                shaderMaterial.setFloat(uniform, value);\r\n                return true;\r\n            case EParameterType.FLOAT_VEC2:\r\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC3:\r\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC4:\r\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the wrap mode of the texture\r\n     * @param mode the mode value\r\n     * @returns the wrap mode (TEXTURE_WRAP_ADDRESSMODE, MIRROR_ADDRESSMODE or CLAMP_ADDRESSMODE)\r\n     */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor the GLTF accessor objet\r\n     * @returns the byte stride\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        const type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n            default:\r\n                return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode the filter mode value\r\n     * @returns the filter mode (TODO - needs to be a type?)\r\n     */\r\n    public static GetTextureFilterMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\r\n                return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\r\n                return Texture.NEAREST_SAMPLINGMODE;\r\n            default:\r\n                return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(\r\n        gltfRuntime: IGLTFRuntime,\r\n        bufferView: IGLTFBufferView,\r\n        byteOffset: number,\r\n        byteLength: number,\r\n        componentType: EComponentType\r\n    ): ArrayBufferView {\r\n        byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        const buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE:\r\n                return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE:\r\n                return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT:\r\n                return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT:\r\n                return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default:\r\n                return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime the GLTF runtime\r\n     * @param accessor the GLTF accessor\r\n     * @returns an array buffer view\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view the buffer view\r\n     * @returns a string\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        let result = \"\";\r\n        const length = view.byteLength;\r\n\r\n        for (let i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene the Babylon.js scene\r\n     * @returns the default Babylon material\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            const shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\",\r\n            };\r\n\r\n            const options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false,\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type {\r\n    IGLTFRuntime,\r\n    IGLTFTechniqueParameter,\r\n    IGLTFAnimation,\r\n    IGLTFAnimationSampler,\r\n    IGLTFNode,\r\n    IGLTFSkins,\r\n    INodeToRoot,\r\n    IJointNode,\r\n    IGLTFMesh,\r\n    IGLTFAccessor,\r\n    IGLTFLight,\r\n    IGLTFAmbienLight,\r\n    IGLTFDirectionalLight,\r\n    IGLTFPointLight,\r\n    IGLTFSpotLight,\r\n    IGLTFCamera,\r\n    IGLTFCameraPerspective,\r\n    IGLTFScene,\r\n    IGLTFTechnique,\r\n    IGLTFMaterial,\r\n    IGLTFProgram,\r\n    IGLTFBuffer,\r\n    IGLTFTexture,\r\n    IGLTFImage,\r\n    IGLTFSampler,\r\n    IGLTFShader,\r\n    IGLTFTechniqueStates,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\n/**\r\n * Tokenizer. Used for shaders compatibility\r\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3,\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) {\r\n            return ETokenType.END_OF_INPUT;\r\n        }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n * Values\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nconst BabylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nconst BabylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n * Parse\r\n * @param parsedBuffers\r\n * @param gltfRuntime\r\n */\r\nconst ParseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const buf in parsedBuffers) {\r\n        const parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nconst ParseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const sha in parsedShaders) {\r\n        const parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nconst ParseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (const object in parsedObjects) {\r\n        const parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n * Utils\r\n * @param buffer\r\n */\r\nconst NormalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nconst GetAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Loads and creates animations\r\n * @param gltfRuntime\r\n */\r\nconst LoadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (const anim in gltfRuntime.animations) {\r\n        const animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        let lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (let i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            const channel = animation.channels[i];\r\n            const sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            let inputData: Nullable<string> = null;\r\n            let outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            } else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            const targetId = channel.target.id;\r\n            let targetNode: any = gltfRuntime.scene.getNodeById(targetId);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            const isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            let targetPath = channel.target.path;\r\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = BabylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                } else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            let babylonAnimation: Nullable<Animation> = null;\r\n            const keys = [];\r\n            let arrayOffset = 0;\r\n            let modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (let j = 0; j < bufferInput.length; j++) {\r\n                let value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                } else {\r\n                    // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    const bone = <Bone>targetNode;\r\n                    let translation = Vector3.Zero();\r\n                    let rotationQuaternion = new Quaternion();\r\n                    let scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    let mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    } else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    } else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value,\r\n                    });\r\n                } else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @returns the bones transformation matrix\r\n * @param node\r\n */\r\nconst ConfigureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    let mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    } else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n * Returns the parent bone\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param jointName\r\n * @param newSkeleton\r\n * @returns the parent bone\r\n */\r\nconst GetParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    const nodes = gltfRuntime.nodes;\r\n    for (const nde in nodes) {\r\n        const node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                const mat = ConfigureBoneTransformation(node);\r\n                const bone = new Bone(node.name || \"\", newSkeleton, GetParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the appropriate root node\r\n * @param nodesToRoot\r\n * @param id\r\n * @returns the root node\r\n */\r\nconst GetNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n\r\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            const child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the node with the joint name\r\n * @param gltfRuntime\r\n * @param jointName\r\n * @returns the node with the joint name\r\n */\r\nconst GetJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    const nodes = gltfRuntime.nodes;\r\n    let node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName,\r\n        };\r\n    }\r\n\r\n    for (const nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde,\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Checks if a nodes is in joints\r\n * @param skins\r\n * @param id\r\n * @returns true if the node is in joints, else false\r\n */\r\nconst NodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Fills the nodes to root for bones and builds hierarchy\r\n * @param gltfRuntime\r\n * @param newSkeleton\r\n * @param skins\r\n * @param nodesToRoot\r\n */\r\nconst GetNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (const nde in gltfRuntime.nodes) {\r\n        const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        const id = nde;\r\n\r\n        if (!node.jointName || NodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n        const children = nodeToRoot.node.children;\r\n\r\n        for (let j = 0; j < children.length; j++) {\r\n            let child: Nullable<INodeToRoot> = null;\r\n\r\n            for (let k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Imports a skeleton\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param mesh\r\n * @param newSkeleton\r\n * @returns the bone name\r\n */\r\nconst ImportSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined): Skeleton => {\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    const nodesToRoot: INodeToRoot[] = [];\r\n    const nodesToRootToAdd: Bone[] = [];\r\n\r\n    GetNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        const node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        const id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        const existingBone = gltfRuntime.scene.getBoneById(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        let foundBone = false;\r\n        let parentBone: Nullable<Bone> = null;\r\n\r\n        for (let j = 0; j < i; j++) {\r\n            const jointNode = GetJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            const joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            const children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (let k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = GetParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = GetNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    const bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (let j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n * Imports a mesh and its geometries\r\n * @param gltfRuntime\r\n * @param node\r\n * @param meshes\r\n * @param id\r\n * @param newMesh\r\n * @returns the new mesh\r\n */\r\nconst ImportMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh._parentContainer = gltfRuntime.assetContainer;\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    let vertexData: Nullable<VertexData> = null;\r\n    const verticesStarts: number[] = [];\r\n    const verticesCounts: number[] = [];\r\n    const indexStarts: number[] = [];\r\n    const indexCounts: number[] = [];\r\n\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            const tempVertexData = new VertexData();\r\n\r\n            const primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            const attributes = primitive.attributes;\r\n            let accessor: Nullable<IGLTFAccessor> = null;\r\n            let buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (const semantic in attributes) {\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                } else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (let j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    } else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    const channel = Number(semantic.split(\"_\")[1]);\r\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\r\n                    const uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    NormalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                } else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                } else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                } else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            } else {\r\n                // Set indices on the fly\r\n                const indices: number[] = [];\r\n                for (let j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            } else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        material.subMaterials = subMaterials;\r\n    } else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = subMaterials[0] as StandardMaterial;\r\n    }\r\n\r\n    material._parentContainer = gltfRuntime.assetContainer;\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    let index = 0;\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n * Configure node transformation from position, rotation and scaling\r\n * @param newNode\r\n * @param position\r\n * @param rotation\r\n * @param scaling\r\n */\r\nconst ConfigureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n * Configures node from transformation matrix\r\n * @param newNode\r\n * @param node\r\n */\r\nconst ConfigureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode) => {\r\n    if (node.matrix) {\r\n        const position = new Vector3(0, 0, 0);\r\n        const rotation = new Quaternion();\r\n        const scaling = new Vector3(0, 0, 0);\r\n        const mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        ConfigureNode(newNode, position, rotation, scaling);\r\n    } else if (node.translation && node.rotation && node.scale) {\r\n        ConfigureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n * Imports a node\r\n * @param gltfRuntime\r\n * @param node\r\n * @param id\r\n * @returns the newly imported node\r\n */\r\nconst ImportNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string): Nullable<Node> => {\r\n    let lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            const skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            const newMesh = ImportMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = ImportSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    } else if (node.meshes) {\r\n        /**\r\n         * Improve meshes property\r\n         */\r\n        const newMesh = ImportMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                const ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            } else if (light.type === \"directional\") {\r\n                const directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            } else if (light.type === \"point\") {\r\n                const pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            } else if (light.type === \"spot\") {\r\n                const spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl();\r\n\r\n                lastNode = orthoCamera;\r\n\r\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\r\n            } else if (camera.type === \"perspective\") {\r\n                const perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl();\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n                persCamera._parentContainer = gltfRuntime.assetContainer;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        } else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            dummy._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            ConfigureNodeFromMatrix(lastNode, node);\r\n        } else {\r\n            const translation = node.translation || [0, 0, 0];\r\n            const rotation = node.rotation || [0, 0, 0, 1];\r\n            const scale = node.scale || [1, 1, 1];\r\n            ConfigureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n * Traverses nodes and creates them\r\n * @param gltfRuntime\r\n * @param id\r\n * @param parent\r\n * @param meshIncluded\r\n */\r\nconst TraverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    const node: IGLTFNode = gltfRuntime.nodes[id];\r\n    let newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        } else {\r\n            meshIncluded = false;\r\n        }\r\n    } else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = ImportNode(gltfRuntime, node, id);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            TraverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n * @param gltfRuntime\r\n */\r\nconst PostLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    let currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (let i = 0; i < currentScene.nodes.length; i++) {\r\n            TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    } else {\r\n        for (const thing in gltfRuntime.scenes) {\r\n            currentScene = gltfRuntime.scenes[thing];\r\n\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    LoadAnimations(gltfRuntime);\r\n\r\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        const skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n * onBind shaderrs callback to set uniforms and matrices\r\n * @param mesh\r\n * @param gltfRuntime\r\n * @param unTreatedUniforms\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param onSuccess\r\n */\r\nconst OnBindShaderMaterial = (\r\n    mesh: AbstractMesh,\r\n    gltfRuntime: IGLTFRuntime,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\r\n            } else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\r\n            }\r\n        } else {\r\n            const value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                shaderMaterial.getEffect().setTexture(unif, texture);\r\n            } else {\r\n                GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n * Prepare uniforms to send the only one time\r\n * Loads the appropriate textures\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n */\r\nconst PrepareShaderMaterialUniforms = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n    const techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n     * Prepare values here (not matrices)\r\n     */\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n        let value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        const onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Shader compilation failed\r\n * @param program\r\n * @param shaderMaterial\r\n * @param onError\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n * Shader compilation success\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param unTreatedUniforms\r\n * @param onSuccess\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileSuccess = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    return (_: Effect) => {\r\n        PrepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            OnBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the appropriate uniform if already handled by babylon\r\n * @param tokenizer\r\n * @param technique\r\n * @param unTreatedUniforms\r\n * @returns the name of the uniform handled by babylon\r\n */\r\nconst ParseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (const unif in technique.uniforms) {\r\n        const uniform = technique.uniforms[unif];\r\n        const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return BabylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n * All shaders loaded. Create materials one by one\r\n * @param gltfRuntime\r\n */\r\nconst ImportMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (const mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(\r\n            gltfRuntime,\r\n            mat,\r\n            () => {},\r\n            () => {}\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Implementation of the base glTF spec\r\n * @internal\r\n */\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        const gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            assetContainer: null,\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            ParseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            ParseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            ParseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            ParseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            ParseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            ParseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            ParseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            ParseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            ParseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            ParseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            ParseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            ParseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            ParseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            ParseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            ParseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            ParseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            ParseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            ParseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        const buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + buffer.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                onProgress,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + source.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                undefined,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        const sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        const createMipMaps =\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\r\n\r\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        const blobURL = URL.createObjectURL(blob);\r\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            const shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        } else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        const program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        const states: IGLTFTechniqueStates = technique.states;\r\n\r\n        const vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        const pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        let newVertexShader = \"\";\r\n        let newPixelShader = \"\";\r\n\r\n        const vertexTokenizer = new Tokenizer(vertexShader);\r\n        const pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        const unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        const uniforms: string[] = [];\r\n        const attributes: string[] = [];\r\n        const samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (const unif in technique.uniforms) {\r\n            const uniform = technique.uniforms[unif];\r\n            const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(BabylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                } else {\r\n                    uniforms.push(unif);\r\n                }\r\n            } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            } else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (const attr in technique.attributes) {\r\n            const attribute = technique.attributes[attr];\r\n            const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                const name = GetAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            const tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            let foundAttribute = false;\r\n\r\n            for (const attr in technique.attributes) {\r\n                const attribute = technique.attributes[attr];\r\n                const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += GetAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += ParseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            const tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += ParseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        const shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id,\r\n        };\r\n\r\n        const options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = OnShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = OnShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            const functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            const blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ONE &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ZERO &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.DST_COLOR &&\r\n                    blendFunc[1] === EBlendingFunction.ZERO &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * glTF V1 Loader\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                gltfRuntime.assetContainer = assetContainer;\r\n                gltfRuntime.importOnlyMeshes = true;\r\n\r\n                if (meshesNames === \"\") {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                } else if (typeof meshesNames === \"string\") {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                    Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n                }\r\n\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                const meshes: AbstractMesh[] = [];\r\n                const skeletons: Skeleton[] = [];\r\n\r\n                // Fill arrays of meshes and skeletons\r\n                for (const nde in gltfRuntime.nodes) {\r\n                    const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                    if (node.babylonNode instanceof AbstractMesh) {\r\n                        meshes.push(node.babylonNode);\r\n                    }\r\n                }\r\n\r\n                for (const skl in gltfRuntime.skins) {\r\n                    const skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                    if (skin.babylonSkeleton instanceof Skeleton) {\r\n                        skeletons.push(skin.babylonSkeleton);\r\n                    }\r\n                }\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        ImportMaterials(gltfRuntime);\r\n                        PostLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                            onSuccess(meshes, skeletons);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                    onSuccess(meshes, skeletons);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param assetContainer defines the asset container to use (can be null)\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(\r\n                meshesNames,\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                assetContainer,\r\n                (meshes, skeletons) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: [],\r\n                        skeletons: skeletons,\r\n                        animationGroups: [],\r\n                        lights: [],\r\n                        transformNodes: [],\r\n                        geometries: [],\r\n                        spriteManagers: [],\r\n                    });\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess: () => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                // Load runtime extensios\r\n                GLTFLoaderExtension.LoadRuntimeExtensionsAsync(\r\n                    gltfRuntime,\r\n                    () => {\r\n                        // Create nodes\r\n                        this._createNodes(gltfRuntime);\r\n\r\n                        // Load buffers, shaders, materials, etc.\r\n                        this._loadBuffersAsync(gltfRuntime, () => {\r\n                            this._loadShadersAsync(gltfRuntime, () => {\r\n                                ImportMaterials(gltfRuntime);\r\n                                PostLoad(gltfRuntime);\r\n\r\n                                if (!GLTFFileLoader.IncrementalLoading) {\r\n                                    onSuccess();\r\n                                }\r\n                            });\r\n                        });\r\n\r\n                        if (GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    },\r\n                    onError\r\n                );\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from a loaded gltf file and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public async loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void): Promise<void> {\r\n        return await new Promise((resolve, reject) => {\r\n            this._loadAsync(\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        let hasShaders = false;\r\n\r\n        const processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(\r\n                gltfRuntime,\r\n                sha,\r\n                (shaderString) => {\r\n                    if (shaderString instanceof ArrayBuffer) {\r\n                        return;\r\n                    }\r\n\r\n                    gltfRuntime.loadedShaderCount++;\r\n\r\n                    if (shaderString) {\r\n                        Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                        onload();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            const shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            } else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void): void {\r\n        let hasBuffers = false;\r\n\r\n        const processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(\r\n                gltfRuntime,\r\n                buf,\r\n                (bufferView) => {\r\n                    gltfRuntime.loadedBufferCount++;\r\n\r\n                    if (bufferView) {\r\n                        if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                        }\r\n\r\n                        gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                        onLoad();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            const buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            } else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        let currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        } else {\r\n            // Load all scenes\r\n            for (const thing in gltfRuntime.scenes) {\r\n                currentScene = gltfRuntime.scenes[thing];\r\n\r\n                for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                    TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading the runtime\r\n     * Return true to stop further extensions from loading the runtime\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     * @param gltfRuntime\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from creating the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading buffers\r\n     * Return true to stop further extensions from loading this buffer\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onProgress\r\n     * @returns true to stop further extensions from loading this buffer\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading texture buffers\r\n     * Return true to stop further extensions from loading this texture data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for creating textures\r\n     * Return true to stop further extensions from loading this texture\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param buffer\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading shader strings\r\n     * Return true to stop further extensions from loading this shader data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this shader data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading materials\r\n     * Return true to stop further extensions from loading this material\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess?: (gltfRuntime: IGLTFRuntime) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    if (!onSuccess) {\r\n                        return;\r\n                    }\r\n                    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    onSuccess();\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (bufferView: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _LoadTextureBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: Nullable<ArrayBufferView>) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _CreateTextureAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        buffer: ArrayBufferView,\r\n        onSuccess: (texture: Texture) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (const extensionName in GLTFLoader.Extensions) {\r\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n", "import { GLTFLoaderExtension, GLTFLoader, GLTFLoaderBase } from \"./glTFLoader\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport type { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\nimport { EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin: IDataBuffer;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void): boolean {\r\n        const extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void): boolean {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void): boolean {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFBinaryExtension());\r\n", "import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader\";\r\n\r\nimport type { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\n\r\ninterface IGLTFMaterialsCommonExtensionValues {\r\n    ambient?: number[] | string;\r\n    diffuse?: number[] | string;\r\n    emission?: number[] | string;\r\n    specular?: number[] | string;\r\n    shininess?: number;\r\n    transparency?: number;\r\n}\r\n\r\ninterface IGLTFMaterialsCommonExtension {\r\n    technique: string;\r\n    transparent?: number;\r\n    doubleSided?: boolean;\r\n    values: IGLTFMaterialsCommonExtensionValues;\r\n}\r\n\r\ninterface IGLTFRuntimeCommonExtension {\r\n    lights: { [key: string]: IGLTFLightCommonExtension };\r\n}\r\n\r\ninterface IGLTFLightCommonExtension {\r\n    name: string;\r\n    type: string;\r\n\r\n    ambient?: IGLTFAmbientLightCommonExtension;\r\n    point?: IGLTFPointLightCommonExtension;\r\n    directional?: IGLTFDirectionalLightCommonExtension;\r\n    spot?: IGLTFSpotLightCommonExtension;\r\n}\r\n\r\ninterface IGLTFPointLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\ninterface IGLTFAmbientLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFDirectionalLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFSpotLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    fallOffAngle: number;\r\n    fallOffExponent: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\r\n    constructor() {\r\n        super(\"KHR_materials_common\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean {\r\n        if (!gltfRuntime.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        // Create lights\r\n        const lights = extension.lights;\r\n        if (lights) {\r\n            for (const thing in lights) {\r\n                const light: IGLTFLightCommonExtension = lights[thing];\r\n\r\n                switch (light.type) {\r\n                    case \"ambient\": {\r\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\r\n                        const ambient = light.ambient;\r\n                        if (ambient) {\r\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"point\": {\r\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\r\n                        const point = light.point;\r\n                        if (point) {\r\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"directional\": {\r\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\r\n                        const directional = light.directional;\r\n                        if (directional) {\r\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"spot\": {\r\n                        const spot = light.spot;\r\n                        if (spot) {\r\n                            const spotLight = new SpotLight(\r\n                                light.name,\r\n                                new Vector3(0, 10, 0),\r\n                                new Vector3(0, -1, 0),\r\n                                spot.fallOffAngle || Math.PI,\r\n                                spot.fallOffExponent || 0.0,\r\n                                gltfRuntime.scene\r\n                            );\r\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \" not supported\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material || !material.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (extension.technique === \"CONSTANT\") {\r\n            standardMaterial.disableLighting = true;\r\n        }\r\n\r\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\r\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\r\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\r\n\r\n        // Ambient\r\n        if (typeof extension.values.ambient === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\r\n        } else {\r\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\r\n        }\r\n\r\n        // Diffuse\r\n        if (typeof extension.values.diffuse === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\r\n        } else {\r\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\r\n        }\r\n\r\n        // Emission\r\n        if (typeof extension.values.emission === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\r\n        } else {\r\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\r\n        }\r\n\r\n        // Specular\r\n        if (typeof extension.values.specular === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\r\n        } else {\r\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\r\n        // Create buffer from texture url\r\n        GLTFLoaderBase.LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                // Create texture from buffer\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => ((<any>material)[propertyPath] = texture));\r\n            },\r\n            onError\r\n        );\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\r\n", "/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nexport * from \"./glTFLoader\";\r\nexport * from \"./glTFLoaderExtension\";\r\nexport * from \"./glTFLoaderExtensionRegistry\";\r\nexport * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./glTFLoaderAnimation\";\r\nexport * from \"./Extensions/index\";\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;oBAAAA;EAAA;;;;;;;ACaA,IAAY;CAAZ,SAAYC,iBAAc;AACtB,EAAAA,gBAAAA,gBAAA,MAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,eAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,OAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,gBAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,OAAA,IAAA,IAAA,IAAA;AACJ,GANY,mBAAA,iBAAc,CAAA,EAAA;AAS1B,IAAY;CAAZ,SAAYC,cAAW;AACnB,EAAAA,aAAAA,aAAA,UAAA,IAAA,KAAA,IAAA;AACA,EAAAA,aAAAA,aAAA,QAAA,IAAA,KAAA,IAAA;AACJ,GAHY,gBAAA,cAAW,CAAA,EAAA;AAMvB,IAAY;CAAZ,SAAYC,iBAAc;AACtB,EAAAA,gBAAAA,gBAAA,MAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,eAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,OAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,gBAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,KAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,cAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,OAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,YAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,YAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,YAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,UAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,UAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,UAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,MAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,WAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,WAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,WAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,YAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,YAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,YAAA,IAAA,KAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,YAAA,IAAA,KAAA,IAAA;AACJ,GAtBY,mBAAA,iBAAc,CAAA,EAAA;AAyB1B,IAAY;CAAZ,SAAYC,mBAAgB;AACxB,EAAAA,kBAAAA,kBAAA,eAAA,IAAA,KAAA,IAAA;AACA,EAAAA,kBAAAA,kBAAA,iBAAA,IAAA,KAAA,IAAA;AACA,EAAAA,kBAAAA,kBAAA,QAAA,IAAA,KAAA,IAAA;AACJ,GAJY,qBAAA,mBAAgB,CAAA,EAAA;AAO5B,IAAY;CAAZ,SAAYC,qBAAkB;AAC1B,EAAAA,oBAAAA,oBAAA,SAAA,IAAA,IAAA,IAAA;AACA,EAAAA,oBAAAA,oBAAA,QAAA,IAAA,IAAA,IAAA;AACA,EAAAA,oBAAAA,oBAAA,wBAAA,IAAA,IAAA,IAAA;AACA,EAAAA,oBAAAA,oBAAA,uBAAA,IAAA,IAAA,IAAA;AACA,EAAAA,oBAAAA,oBAAA,uBAAA,IAAA,IAAA,IAAA;AACA,EAAAA,oBAAAA,oBAAA,sBAAA,IAAA,IAAA,IAAA;AACJ,GAPY,uBAAA,qBAAkB,CAAA,EAAA;AAU9B,IAAY;CAAZ,SAAYC,iBAAc;AACtB,EAAAA,gBAAAA,gBAAA,OAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,KAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,MAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,WAAA,IAAA,IAAA,IAAA;AACA,EAAAA,gBAAAA,gBAAA,iBAAA,IAAA,IAAA,IAAA;AACJ,GANY,mBAAA,iBAAc,CAAA,EAAA;AAS1B,IAAY;CAAZ,SAAYC,eAAY;AACpB,EAAAA,cAAAA,cAAA,OAAA,IAAA,IAAA,IAAA;AACA,EAAAA,cAAAA,cAAA,MAAA,IAAA,IAAA,IAAA;AACA,EAAAA,cAAAA,cAAA,gBAAA,IAAA,IAAA,IAAA;AACJ,GAJY,iBAAA,eAAY,CAAA,EAAA;AAOxB,IAAY;CAAZ,SAAYC,oBAAiB;AACzB,EAAAA,mBAAAA,mBAAA,MAAA,IAAA,CAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,qBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,qBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,qBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,WAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,qBAAA,IAAA,GAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,gBAAA,IAAA,KAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,0BAAA,IAAA,KAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,gBAAA,IAAA,KAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,0BAAA,IAAA,KAAA,IAAA;AACA,EAAAA,mBAAAA,mBAAA,oBAAA,IAAA,GAAA,IAAA;AACJ,GAhBY,sBAAA,oBAAiB,CAAA,EAAA;;;ACrEvB,IAAO,YAAP,MAAO,WAAS;;;;;;;;;EASX,OAAO,UAAU,OAAc,QAAc,WAAoC,aAAqB,gBAAuC;AAChJ,QAAI,MAAwB;AAE5B,QAAI,UAAU,aAAa,SAAS;AAChC,YAAM,OAAO,eAAc;IAC/B,WAAW,UAAU,aAAa,cAAc;AAC5C,YAAM,MAAM,oBAAmB;IACnC,WAAW,UAAU,aAAa,QAAQ;AACtC,YAAM,MAAM,cAAa;IAC7B,WAAW,UAAU,aAAa,6BAA6B;AAC3D,YAAM,OAAO,UAAU,OAAO,eAAc,EAAG,SAAS,MAAM,cAAa,CAAE,EAAE,OAAM,CAAE;IAC3F,WAAW,UAAU,aAAa,aAAa;AAC3C,YAAM,OAAO,eAAc,EAAG,SAAS,MAAM,cAAa,CAAE;IAChE,WAAW,UAAU,aAAa,uBAAuB;AACrD,YAAM,OAAO,eAAc,EAAG,SAAS,MAAM,mBAAkB,CAAE;IACrE,WAAW,UAAU,aAAa,gBAAgB;AAC9C,YAAM,OAAO,eAAc,EAAG,OAAM;IACxC,WAAW,UAAU,aAAa,eAAe;AAC7C,YAAM,MAAM,cAAa,EAAG,OAAM;IACtC,WAAW,UAAU,aAAa,qBAAqB;AACnD,YAAM,MAAM,oBAAmB,EAAG,OAAM;IAC5C,WAAW,UAAU,aAAa,oBAAoB;AAClD,YAAM,OAAO,eAAc,EAAG,SAAS,MAAM,cAAa,CAAE,EAAE,OAAM;IACxE,WAAW,UAAU,aAAa,8BAA8B;AAC5D,YAAM,OAAO,eAAc,EAAG,SAAS,MAAM,mBAAkB,CAAE,EAAE,OAAM;IAC7E,WAAW,UAAU,aAAa,yBAAyB;AACvD,YAAM,OAAO,UAAU,OAAO,eAAc,EAAG,OAAM,CAAE;IAC3D;AAEA,QAAI,KAAK;AACL,cAAQ,UAAU,MAAM;QACpB,KAAK,eAAe;AAChB,yBAAe,aAAa,aAAa,OAAO,eAAe,GAAG,CAAC;AACnE;QACJ,KAAK,eAAe;AAChB,yBAAe,aAAa,aAAa,OAAO,eAAe,GAAG,CAAC;AACnE;QACJ,KAAK,eAAe;AAChB,yBAAe,UAAU,aAAa,GAAG;AACzC;QACJ;AACI;MACR;IACJ;EACJ;;;;;;;;;EAUO,OAAO,WAAW,gBAAyC,SAAiB,OAAY,MAAY;AACvG,YAAQ,MAAM;MACV,KAAK,eAAe;AAChB,uBAAe,SAAS,SAAS,KAAK;AACtC,eAAO;MACX,KAAK,eAAe;AAChB,uBAAe,WAAW,SAAS,QAAQ,UAAU,KAAK,CAAC;AAC3D,eAAO;MACX,KAAK,eAAe;AAChB,uBAAe,WAAW,SAAS,QAAQ,UAAU,KAAK,CAAC;AAC3D,eAAO;MACX,KAAK,eAAe;AAChB,uBAAe,WAAW,SAAS,QAAQ,UAAU,KAAK,CAAC;AAC3D,eAAO;MACX;AACI,eAAO;IACf;EACJ;;;;;;EAOO,OAAO,YAAY,MAAY;AAClC,YAAQ,MAAM;MACV,KAAK,iBAAiB;AAClB,eAAO,QAAQ;MACnB,KAAK,iBAAiB;AAClB,eAAO,QAAQ;MACnB,KAAK,iBAAiB;AAClB,eAAO,QAAQ;MACnB;AACI,eAAO,QAAQ;IACvB;EACJ;;;;;;EAOO,OAAO,sBAAsB,UAAuB;AAEvD,UAAM,OAAO,SAAS;AAEtB,YAAQ,MAAM;MACV,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;MACX;AACI,eAAO;IACf;EACJ;;;;;;EAOO,OAAO,qBAAqB,MAAY;AAC3C,YAAQ,MAAM;MACV,KAAK,mBAAmB;MACxB,KAAK,mBAAmB;MACxB,KAAK,mBAAmB;AACpB,eAAO,QAAQ;MACnB,KAAK,mBAAmB;MACxB,KAAK,mBAAmB;AACpB,eAAO,QAAQ;MACnB;AACI,eAAO,QAAQ;IACvB;EACJ;EAEO,OAAO,wBACV,aACA,YACA,YACA,YACA,eAA6B;AAE7B,iBAAa,WAAW,aAAa;AAErC,UAAM,mBAAmB,YAAY,kBAAkB,WAAW,MAAM;AACxE,QAAI,aAAa,aAAa,iBAAiB,YAAY;AACvD,YAAM,IAAI,MAAM,+BAA+B;IACnD;AAEA,UAAM,SAAS,iBAAiB;AAChC,kBAAc,iBAAiB;AAE/B,YAAQ,eAAe;MACnB,KAAK,eAAe;AAChB,eAAO,IAAI,UAAU,QAAQ,YAAY,UAAU;MACvD,KAAK,eAAe;AAChB,eAAO,IAAI,WAAW,QAAQ,YAAY,UAAU;MACxD,KAAK,eAAe;AAChB,eAAO,IAAI,WAAW,QAAQ,YAAY,UAAU;MACxD,KAAK,eAAe;AAChB,eAAO,IAAI,YAAY,QAAQ,YAAY,UAAU;MACzD;AACI,eAAO,IAAI,aAAa,QAAQ,YAAY,UAAU;IAC9D;EACJ;;;;;;;EAQO,OAAO,sBAAsB,aAA2B,UAAuB;AAClF,UAAM,aAA8B,YAAY,YAAY,SAAS,UAAU;AAC/E,UAAM,aAAa,SAAS,QAAQ,WAAU,sBAAsB,QAAQ;AAC5E,WAAO,WAAU,wBAAwB,aAAa,YAAY,SAAS,YAAY,YAAY,SAAS,aAAa;EAC7H;;;;;;EAOO,OAAO,mBAAmB,MAAqB;AAClD,QAAI,SAAS;AACb,UAAM,SAAS,KAAK;AAEpB,aAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC7B,gBAAU,OAAO,aAAmB,KAAM,CAAC,CAAC;IAChD;AAEA,WAAO;EACX;;;;;;;EAQO,OAAO,mBAAmB,OAAY;AACzC,QAAI,CAAC,WAAU,kBAAkB;AAC7B,aAAO,aAAa,iCAAiC,IAAI;QACrD;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACF,KAAK,IAAI;AAEX,aAAO,aAAa,gCAAgC,IAAI;QACpD;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACF,KAAK,IAAI;AAEX,YAAM,aAAa;QACf,QAAQ;QACR,UAAU;;AAGd,YAAM,UAAU;QACZ,YAAY,CAAC,UAAU;QACvB,UAAU,CAAC,aAAa,cAAc,YAAY;QAClD,UAAU,IAAI,MAAK;QACnB,mBAAmB;;AAGvB,iBAAU,mBAAmB,IAAI,eAAe,uBAAuB,OAAO,YAAY,OAAO;AACjG,iBAAU,iBAAiB,UAAU,cAAc,IAAI,OAAO,KAAK,KAAK,KAAK,CAAG,CAAC;IACrF;AAEA,WAAO,WAAU;EACrB;;AAGe,UAAA,mBAA6C;;;AC3MhE,IAAK;CAAL,SAAKC,aAAU;AACX,EAAAA,YAAAA,YAAA,YAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,YAAAA,YAAA,SAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,cAAA,IAAA,CAAA,IAAA;AACJ,GALK,eAAA,aAAU,CAAA,EAAA;AAOf,IAAM,YAAN,MAAe;EAUX,YAAY,SAAe;AARnB,SAAA,OAAe;AAGhB,SAAA,eAA2B,WAAW;AACtC,SAAA,oBAA4B;AAC5B,SAAA,gBAAwB;AACxB,SAAA,yBAAiC;AAGpC,SAAK,WAAW;AAChB,SAAK,UAAU,QAAQ;EAC3B;EAEO,eAAY;AACf,QAAI,KAAK,MAAK,GAAI;AACd,aAAO,WAAW;IACtB;AAEA,SAAK,gBAAgB,KAAK,KAAI;AAC9B,SAAK,eAAe,WAAW;AAE/B,QAAI,KAAK,kBAAkB,OAAO,KAAK,uBAAuB,KAAK,KAAK,aAAa,GAAG;AACpF,WAAK,eAAe,WAAW;AAC/B,WAAK,oBAAoB,KAAK;AAC9B,aAAO,CAAC,KAAK,MAAK,MAAO,KAAK,uBAAuB,KAAM,KAAK,gBAAgB,KAAK,KAAI,CAAG,KAAK,KAAK,kBAAkB,MAAM;AAC1H,aAAK,qBAAqB,KAAK;AAC/B,aAAK,QAAO;MAChB;IACJ;AAEA,WAAO,KAAK;EAChB;EAEO,OAAI;AACP,WAAO,KAAK,SAAS,KAAK,IAAI;EAClC;EAEO,OAAI;AACP,WAAO,KAAK,SAAS,KAAK,MAAM;EACpC;EAEO,UAAO;AACV,SAAK;EACT;EAEO,QAAK;AACR,WAAO,KAAK,QAAQ,KAAK;EAC7B;;AAOJ,IAAM,iBAAiB,CAAC,SAAS,QAAQ,cAAc,aAAa,uBAAuB,aAAa;AACxG,IAAM,oBAAoB,CAAC,SAAS,QAAQ,cAAc,aAAa,uBAAuB,QAAQ;AAGtG,IAAM,qBAAqB,CAAC,eAAe,YAAY,OAAO;AAC9D,IAAM,wBAAwB,CAAC,YAAY,sBAAsB,SAAS;AAO1E,IAAM,eAAe,CAAC,eAAoB,gBAA6B;AACnE,aAAW,OAAO,eAAe;AAC7B,UAAM,eAAe,cAAc,GAAG;AACtC,gBAAY,QAAQ,GAAG,IAAI;AAC3B,gBAAY;EAChB;AACJ;AAEA,IAAM,eAAe,CAAC,eAAoB,gBAA6B;AACnE,aAAW,OAAO,eAAe;AAC7B,UAAM,eAAe,cAAc,GAAG;AACtC,gBAAY,QAAQ,GAAG,IAAI;AAC3B,gBAAY;EAChB;AACJ;AAEA,IAAM,cAAc,CAAC,eAAoB,iBAAyB,gBAA6B;AAC3F,aAAW,UAAU,eAAe;AAChC,UAAM,eAAe,cAAc,MAAM;AACnC,gBAAa,eAAe,EAAE,MAAM,IAAI;EAClD;AACJ;AAMA,IAAM,eAAe,CAAC,WAAe;AACjC,MAAI,CAAC,QAAQ;AACT;EACJ;AAEA,WAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AACxC,WAAO,IAAI,IAAI,CAAC,IAAI,IAAM,OAAO,IAAI,IAAI,CAAC;EAC9C;AACJ;AAEA,IAAM,eAAe,CAAC,uBAAiE;AACnF,MAAI,mBAAmB,aAAa,UAAU;AAC1C,WAAO;EACX,WAAW,mBAAmB,aAAa,YAAY;AACnD,WAAO;EACX,WAAW,mBAAmB,aAAa,SAAS;AAChD,WAAO;EACX,WAAW,mBAAmB,aAAa,UAAU;AACjD,WAAO;EACX,WAAW,mBAAmB,aAAa,SAAS;AAChD,WAAO;EACX,WAAW,mBAAmB,YAAY,mBAAmB,SAAS,QAAQ,WAAW,MAAM,IAAI;AAC/F,UAAM,UAAU,OAAO,mBAAmB,SAAS,MAAM,GAAG,EAAE,CAAC,CAAC;AAChE,WAAO,QAAQ,YAAY,IAAI,KAAK,UAAU;EAClD;AAEA,SAAO;AACX;AAMA,IAAM,iBAAiB,CAAC,gBAA6B;AACjD,aAAW,QAAQ,YAAY,YAAY;AACvC,UAAM,YAA4B,YAAY,WAAW,IAAI;AAE7D,QAAI,CAAC,UAAU,YAAY,CAAC,UAAU,UAAU;AAC5C;IACJ;AAEA,QAAI,gBAAqC;AAEzC,aAAS,IAAI,GAAG,IAAI,UAAU,SAAS,QAAQ,KAAK;AAEhD,YAAM,UAAU,UAAU,SAAS,CAAC;AACpC,YAAM,UAAiC,UAAU,SAAS,QAAQ,OAAO;AAEzE,UAAI,CAAC,SAAS;AACV;MACJ;AAEA,UAAI,YAA8B;AAClC,UAAI,aAA+B;AAEnC,UAAI,UAAU,YAAY;AACtB,oBAAY,UAAU,WAAW,QAAQ,KAAK;AAC9C,qBAAa,UAAU,WAAW,QAAQ,MAAM;MACpD,OAAO;AACH,oBAAY,QAAQ;AACpB,qBAAa,QAAQ;MACzB;AAEA,YAAM,cAAc,UAAU,sBAAsB,aAAa,YAAY,UAAU,SAAS,CAAC;AACjG,YAAM,eAAe,UAAU,sBAAsB,aAAa,YAAY,UAAU,UAAU,CAAC;AAEnG,YAAM,WAAW,QAAQ,OAAO;AAChC,UAAI,aAAkB,YAAY,MAAM,YAAY,QAAQ;AAE5D,UAAI,eAAe,MAAM;AACrB,qBAAa,YAAY,MAAM,cAAc,QAAQ;MACzD;AAEA,UAAI,eAAe,MAAM;AACrB,cAAM,KAAK,8BAA8B,OAAO,kCAAkC,WAAW,eAAe;AAC5G;MACJ;AAEA,YAAM,SAAS,sBAAsB;AAGrC,UAAI,aAAa,QAAQ,OAAO;AAChC,YAAM,kBAAkB,mBAAmB,QAAQ,UAAU;AAE7D,UAAI,oBAAoB,IAAI;AACxB,qBAAa,sBAAsB,eAAe;MACtD;AAGA,UAAI,gBAAgB,UAAU;AAE9B,UAAI,CAAC,QAAQ;AACT,YAAI,eAAe,sBAAsB;AACrC,0BAAgB,UAAU;AAC1B,qBAAW,qBAAqB,IAAI,WAAU;QAClD,OAAO;AACH,0BAAgB,UAAU;QAC9B;MACJ;AAGA,UAAI,mBAAwC;AAC5C,YAAM,OAAO,CAAA;AACb,UAAI,cAAc;AAClB,UAAI,YAAY;AAEhB,UAAI,UAAU,iBAAiB,cAAc,QAAO,EAAG,WAAW,YAAY,QAAQ;AAClF,2BAAmB;AACnB,oBAAY;MAChB;AAEA,UAAI,CAAC,WAAW;AACZ,oBAAY,MAAM,yBAAyB,CAAC,CAAC,YAAY;AACzD,2BAAmB,IAAI,UAAU,MAAM,SAAS,YAAY,YAAY,GAAG,eAAe,UAAU,uBAAuB;AAC3H,oBAAY,MAAM,yBAAyB;MAC/C;AAGA,eAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACzC,YAAI,QAAa;AAEjB,YAAI,eAAe,sBAAsB;AAErC,kBAAQ,WAAW,UAAU,CAAC,aAAa,WAAW,GAAG,aAAa,cAAc,CAAC,GAAG,aAAa,cAAc,CAAC,GAAG,aAAa,cAAc,CAAC,CAAC,CAAC;AACrJ,yBAAe;QACnB,OAAO;AAEH,kBAAQ,QAAQ,UAAU,CAAC,aAAa,WAAW,GAAG,aAAa,cAAc,CAAC,GAAG,aAAa,cAAc,CAAC,CAAC,CAAC;AACnH,yBAAe;QACnB;AAEA,YAAI,QAAQ;AACR,gBAAM,OAAa;AACnB,cAAI,cAAc,QAAQ,KAAI;AAC9B,cAAI,qBAAqB,IAAI,WAAU;AACvC,cAAI,UAAU,QAAQ,KAAI;AAG1B,cAAI,MAAM,KAAK,cAAa;AAE5B,cAAI,aAAa,eAAe;AAC5B,kBAAM,cAAc,QAAO,EAAG,CAAC,EAAE;UACrC;AAEA,cAAI,UAAU,SAAS,oBAAoB,WAAW;AAEtD,cAAI,eAAe,YAAY;AAC3B,0BAAc;UAClB,WAAW,eAAe,sBAAsB;AAC5C,iCAAqB;UACzB,OAAO;AACH,sBAAU;UACd;AAEA,kBAAQ,OAAO,QAAQ,SAAS,oBAAoB,WAAW;QACnE;AAEA,YAAI,CAAC,WAAW;AACZ,eAAK,KAAK;YACN,OAAO,YAAY,CAAC;YACpB;WACH;QACL,WAAW,eAAe;AACtB,wBAAc,QAAO,EAAG,CAAC,EAAE,QAAQ;QACvC;MACJ;AAGA,UAAI,CAAC,aAAa,kBAAkB;AAChC,yBAAiB,QAAQ,IAAI;AAC7B,mBAAW,WAAW,KAAK,gBAAgB;MAC/C;AAEA,sBAAgB;AAEhB,kBAAY,MAAM,cAAc,UAAU;AAC1C,kBAAY,MAAM,eAAe,YAAY,GAAG,YAAY,YAAY,SAAS,CAAC,GAAG,MAAM,CAAG;IAClG;EACJ;AACJ;AAMA,IAAM,8BAA8B,CAAC,SAA2B;AAC5D,MAAI,MAAwB;AAE5B,MAAI,KAAK,eAAe,KAAK,YAAY,KAAK,OAAO;AACjD,UAAM,QAAQ,QAAQ,UAAU,KAAK,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;AACvD,UAAM,WAAW,WAAW,UAAU,KAAK,YAAY,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;AACnE,UAAM,WAAW,QAAQ,UAAU,KAAK,eAAe,CAAC,GAAG,GAAG,CAAC,CAAC;AAEhE,UAAM,OAAO,QAAQ,OAAO,UAAU,QAAQ;EAClD,OAAO;AACH,UAAM,OAAO,UAAU,KAAK,MAAM;EACtC;AAEA,SAAO;AACX;AAUA,IAAM,gBAAgB,CAAC,aAA2B,OAAmB,WAAmB,gBAAyC;AAE7H,WAAS,IAAI,GAAG,IAAI,YAAY,MAAM,QAAQ,KAAK;AAC/C,QAAI,YAAY,MAAM,CAAC,EAAE,SAAS,WAAW;AACzC,aAAO,YAAY,MAAM,CAAC;IAC9B;EACJ;AAGA,QAAM,QAAQ,YAAY;AAC1B,aAAW,OAAO,OAAO;AACrB,UAAM,OAAkB,MAAM,GAAG;AAEjC,QAAI,CAAC,KAAK,WAAW;AACjB;IACJ;AAEA,UAAM,WAAW,KAAK;AACtB,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,YAAM,QAAmB,YAAY,MAAM,SAAS,CAAC,CAAC;AACtD,UAAI,CAAC,MAAM,WAAW;AAClB;MACJ;AAEA,UAAI,MAAM,cAAc,WAAW;AAC/B,cAAM,MAAM,4BAA4B,IAAI;AAC5C,cAAM,OAAO,IAAI,KAAK,KAAK,QAAQ,IAAI,aAAa,cAAc,aAAa,OAAO,KAAK,WAAW,WAAW,GAAG,GAAG;AACvH,aAAK,KAAK;AACV,eAAO;MACX;IACJ;EACJ;AAEA,SAAO;AACX;AAQA,IAAM,gBAAgB,CAAC,aAA4B,OAA8B;AAC7E,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACzC,UAAM,aAAa,YAAY,CAAC;AAEhC,aAAS,IAAI,GAAG,IAAI,WAAW,KAAK,SAAS,QAAQ,KAAK;AACtD,YAAM,QAAQ,WAAW,KAAK,SAAS,CAAC;AACxC,UAAI,UAAU,IAAI;AACd,eAAO,WAAW;MACtB;IACJ;EACJ;AAEA,SAAO;AACX;AAQA,IAAM,eAAe,CAAC,aAA2B,cAA2C;AACxF,QAAM,QAAQ,YAAY;AAC1B,MAAI,OAAkB,MAAM,SAAS;AACrC,MAAI,MAAM;AACN,WAAO;MACH;MACA,IAAI;;EAEZ;AAEA,aAAW,OAAO,OAAO;AACrB,WAAO,MAAM,GAAG;AAChB,QAAI,KAAK,cAAc,WAAW;AAC9B,aAAO;QACH;QACA,IAAI;;IAEZ;EACJ;AAEA,SAAO;AACX;AAQA,IAAM,iBAAiB,CAAC,OAAmB,OAAuB;AAC9D,WAAS,IAAI,GAAG,IAAI,MAAM,WAAW,QAAQ,KAAK;AAC9C,QAAI,MAAM,WAAW,CAAC,MAAM,IAAI;AAC5B,aAAO;IACX;EACJ;AAEA,SAAO;AACX;AASA,IAAM,iBAAiB,CAAC,aAA2B,aAAuB,OAAmB,gBAA8B;AAEvH,aAAW,OAAO,YAAY,OAAO;AACjC,UAAM,OAAkB,YAAY,MAAM,GAAG;AAC7C,UAAM,KAAK;AAEX,QAAI,CAAC,KAAK,aAAa,eAAe,OAAO,KAAK,SAAS,GAAG;AAC1D;IACJ;AAGA,UAAM,MAAM,4BAA4B,IAAI;AAC5C,UAAM,OAAO,IAAI,KAAK,KAAK,QAAQ,IAAI,aAAa,MAAM,GAAG;AAC7D,SAAK,KAAK;AACV,gBAAY,KAAK,EAAE,MAAY,MAAY,GAAM,CAAE;EACvD;AAGA,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACzC,UAAM,aAAa,YAAY,CAAC;AAChC,UAAM,WAAW,WAAW,KAAK;AAEjC,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,UAAI,QAA+B;AAEnC,eAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACzC,YAAI,YAAY,CAAC,EAAE,OAAO,SAAS,CAAC,GAAG;AACnC,kBAAQ,YAAY,CAAC;AACrB;QACJ;MACJ;AAEA,UAAI,OAAO;AACD,cAAM,KAAM,UAAU,WAAW;AACvC,mBAAW,KAAK,SAAS,KAAK,MAAM,IAAI;MAC5C;IACJ;EACJ;AACJ;AAUA,IAAM,iBAAiB,CAAC,aAA2B,OAAmB,MAAY,gBAA+C;AAC7H,MAAI,CAAC,aAAa;AACd,kBAAc,IAAI,SAAS,MAAM,QAAQ,IAAI,IAAI,YAAY,KAAK;EACtE;AAEA,MAAI,CAAC,MAAM,iBAAiB;AACxB,WAAO;EACX;AAGA,QAAM,cAA6B,CAAA;AACnC,QAAM,mBAA2B,CAAA;AAEjC,iBAAe,aAAa,aAAa,OAAO,WAAW;AAC3D,cAAY,QAAQ,CAAA;AAGpB,WAAS,IAAI,GAAG,IAAI,MAAM,WAAW,QAAQ,KAAK;AAC9C,UAAM,YAAY,aAAa,aAAa,MAAM,WAAW,CAAC,CAAC;AAE/D,QAAI,CAAC,WAAW;AACZ;IACJ;AAEA,UAAM,OAAO,UAAU;AAEvB,QAAI,CAAC,MAAM;AACP,YAAM,KAAK,iBAAiB,MAAM,WAAW,CAAC,IAAI,iBAAiB;AACnE;IACJ;AAEA,UAAM,KAAK,UAAU;AAGrB,UAAM,eAAe,YAAY,MAAM,YAAY,EAAE;AACrD,QAAI,cAAc;AACd,kBAAY,MAAM,KAAK,YAAY;AACnC;IACJ;AAGA,QAAI,YAAY;AAChB,QAAI,aAA6B;AAEjC,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,YAAMC,aAAY,aAAa,aAAa,MAAM,WAAW,CAAC,CAAC;AAE/D,UAAI,CAACA,YAAW;AACZ;MACJ;AAEA,YAAM,QAAmBA,WAAU;AAEnC,UAAI,CAAC,OAAO;AACR,cAAM,KAAK,iBAAiB,MAAM,WAAW,CAAC,IAAI,yCAAyC;AAC3F;MACJ;AAEA,YAAM,WAAW,MAAM;AACvB,UAAI,CAAC,UAAU;AACX;MACJ;AACA,kBAAY;AAEZ,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,YAAI,SAAS,CAAC,MAAM,IAAI;AACpB,uBAAa,cAAc,aAAa,OAAO,MAAM,WAAW,CAAC,GAAG,WAAW;AAC/E,sBAAY;AACZ;QACJ;MACJ;AAEA,UAAI,WAAW;AACX;MACJ;IACJ;AAGA,UAAM,MAAM,4BAA4B,IAAI;AAE5C,QAAI,CAAC,cAAc,YAAY,SAAS,GAAG;AACvC,mBAAa,cAAc,aAAa,EAAE;AAE1C,UAAI,YAAY;AACZ,YAAI,iBAAiB,QAAQ,UAAU,MAAM,IAAI;AAC7C,2BAAiB,KAAK,UAAU;QACpC;MACJ;IACJ;AAEA,UAAM,OAAO,IAAI,KAAK,KAAK,aAAa,IAAI,aAAa,YAAY,GAAG;AACxE,SAAK,KAAK;EACd;AAGA,QAAM,QAAQ,YAAY;AAC1B,cAAY,QAAQ,CAAA;AAEpB,WAAS,IAAI,GAAG,IAAI,MAAM,WAAW,QAAQ,KAAK;AAC9C,UAAM,YAAY,aAAa,aAAa,MAAM,WAAW,CAAC,CAAC;AAE/D,QAAI,CAAC,WAAW;AACZ;IACJ;AAEA,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,UAAI,MAAM,CAAC,EAAE,OAAO,UAAU,IAAI;AAC9B,oBAAY,MAAM,KAAK,MAAM,CAAC,CAAC;AAC/B;MACJ;IACJ;EACJ;AAEA,cAAY,QAAO;AAGnB,WAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAC9C,gBAAY,MAAM,KAAK,iBAAiB,CAAC,CAAC;EAC9C;AAEA,SAAO;AACX;AAWA,IAAM,aAAa,CAAC,aAA2B,MAAiB,QAAkB,IAAY,YAAuB;AACjH,MAAI,CAAC,SAAS;AACV,gBAAY,MAAM,yBAAyB,CAAC,CAAC,YAAY;AACzD,cAAU,IAAI,KAAK,KAAK,QAAQ,IAAI,YAAY,KAAK;AACrD,YAAQ,mBAAmB,YAAY;AACvC,gBAAY,MAAM,yBAAyB;AAC3C,YAAQ,KAAK;EACjB;AAEA,MAAI,CAAC,KAAK,aAAa;AACnB,WAAO;EACX;AAEA,QAAM,eAA2B,CAAA;AAEjC,MAAI,aAAmC;AACvC,QAAM,iBAA2B,CAAA;AACjC,QAAM,iBAA2B,CAAA;AACjC,QAAM,cAAwB,CAAA;AAC9B,QAAM,cAAwB,CAAA;AAE9B,WAAS,YAAY,GAAG,YAAY,OAAO,QAAQ,aAAa;AAC5D,UAAM,SAAS,OAAO,SAAS;AAC/B,UAAM,OAAkB,YAAY,OAAO,MAAM;AAEjD,QAAI,CAAC,MAAM;AACP;IACJ;AAGA,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAE7C,YAAM,iBAAiB,IAAI,WAAU;AAErC,YAAM,YAAY,KAAK,WAAW,CAAC;AACnC,UAAI,UAAU,SAAS,GAAG;MAE1B;AAEA,YAAM,aAAa,UAAU;AAC7B,UAAI,WAAoC;AACxC,UAAI,SAAc;AAGlB,iBAAW,YAAY,YAAY;AAE/B,mBAAW,YAAY,UAAU,WAAW,QAAQ,CAAC;AACrD,iBAAS,UAAU,sBAAsB,aAAa,QAAQ;AAE9D,YAAI,aAAa,UAAU;AACvB,yBAAe,UAAU,IAAI,aAAa,OAAO,MAAM;AACxC,yBAAe,QAAS,IAAI,MAAM;QACrD,WAAW,aAAa,YAAY;AAChC,cAAI,eAAe,wBAAwB;AACvC,2BAAe,YAAY,IAAI,aAAa,OAAO,SAAS,OAAO,SAAS,CAAC;AAE7E,qBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACvC,6BAAe,UAAU,CAAC,IAAI,OAAO,CAAC;AACtC,6BAAe,UAAU,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC;AAC9C,6BAAe,UAAU,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC;YAClD;UACJ,OAAO;AACH,2BAAe,YAAY,IAAI,aAAa,OAAO,MAAM;AAC1C,2BAAe,UAAW,IAAI,MAAM;UACvD;AAEA,yBAAe,KAAK,eAAe,UAAU,MAAM;QACvD,WAAW,SAAS,QAAQ,WAAW,MAAM,IAAI;AAC7C,gBAAM,UAAU,OAAO,SAAS,MAAM,GAAG,EAAE,CAAC,CAAC;AAC7C,gBAAM,SAAS,aAAa,UAAU,YAAY,IAAI,KAAK,UAAU;AACrE,gBAAM,MAAM,IAAI,aAAa,OAAO,MAAM;AAC3B,cAAK,IAAI,MAAM;AAC9B,uBAAa,GAAG;AAChB,yBAAe,IAAI,KAAK,MAAM;QAClC,WAAW,aAAa,SAAS;AAC7B,yBAAe,kBAAkB,IAAI,aAAa,OAAO,MAAM;AAChD,yBAAe,gBAAiB,IAAI,MAAM;QAC7D,WAAW,aAAa,UAAU;AAC9B,yBAAe,kBAAkB,IAAI,aAAa,OAAO,MAAM;AAChD,yBAAe,gBAAiB,IAAI,MAAM;QAC7D,WAAW,aAAa,SAAS;AAC7B,yBAAe,SAAS,IAAI,aAAa,OAAO,MAAM;AACvC,yBAAe,OAAQ,IAAI,MAAM;QACpD;MACJ;AAGA,iBAAW,YAAY,UAAU,UAAU,OAAO;AAClD,UAAI,UAAU;AACV,iBAAS,UAAU,sBAAsB,aAAa,QAAQ;AAE9D,uBAAe,UAAU,IAAI,WAAW,OAAO,MAAM;AACrD,uBAAe,QAAQ,IAAI,MAAM;AACjC,oBAAY,KAAK,eAAe,QAAQ,MAAM;MAClD,OAAO;AAEH,cAAM,UAAoB,CAAA;AAC1B,iBAAS,IAAI,GAAG,IAAiB,eAAe,UAAW,SAAS,GAAG,KAAK;AACxE,kBAAQ,KAAK,CAAC;QAClB;AAEA,uBAAe,UAAU,IAAI,WAAW,OAAO;AAC/C,oBAAY,KAAK,eAAe,QAAQ,MAAM;MAClD;AAEA,UAAI,CAAC,YAAY;AACb,qBAAa;MACjB,OAAO;AACH,mBAAW,MAAM,cAAc;MACnC;AAGA,YAAMC,YAAW,YAAY,MAAM,gBAAgB,UAAU,QAAQ;AAErE,mBAAa,KAAKA,cAAa,OAAO,UAAU,mBAAmB,YAAY,KAAK,IAAIA,SAAQ;AAGhG,qBAAe,KAAK,eAAe,WAAW,IAAI,IAAI,eAAe,eAAe,SAAS,CAAC,IAAI,eAAe,eAAe,SAAS,CAAC,CAAC;AAC3I,kBAAY,KAAK,YAAY,WAAW,IAAI,IAAI,YAAY,YAAY,SAAS,CAAC,IAAI,YAAY,YAAY,SAAS,CAAC,CAAC;IAC7H;EACJ;AACA,MAAI;AACJ,cAAY,MAAM,yBAAyB,CAAC,CAAC,YAAY;AACzD,MAAI,aAAa,SAAS,GAAG;AACzB,eAAW,IAAI,cAAc,aAAa,IAAI,YAAY,KAAK;AAC/D,aAAS,eAAe;EAC5B,OAAO;AACH,eAAW,IAAI,iBAAiB,aAAa,IAAI,YAAY,KAAK;EACtE;AAEA,MAAI,aAAa,WAAW,GAAG;AAC3B,eAAW,aAAa,CAAC;EAC7B;AAEA,WAAS,mBAAmB,YAAY;AAExC,MAAI,CAAC,QAAQ,UAAU;AACnB,YAAQ,WAAW;EACvB;AAGA,MAAI,SAAS,IAAI,YAAY,OAAO,YAAa,OAAO,OAAO;AAC/D,UAAQ,mBAAmB,IAAI;AAE/B,cAAY,MAAM,yBAAyB;AAG3C,UAAQ,YAAY,CAAA;AACpB,MAAI,QAAQ;AACZ,WAAS,YAAY,GAAG,YAAY,OAAO,QAAQ,aAAa;AAC5D,UAAM,SAAS,OAAO,SAAS;AAC/B,UAAM,OAAkB,YAAY,OAAO,MAAM;AAEjD,QAAI,CAAC,MAAM;AACP;IACJ;AAEA,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAC7C,UAAI,KAAK,WAAW,CAAC,EAAE,SAAS,GAAG;MAEnC;AAEA,cAAQ,UAAU,OAAO,eAAe,KAAK,GAAG,eAAe,KAAK,GAAG,YAAY,KAAK,GAAG,YAAY,KAAK,GAAG,SAAS,SAAS,IAAI;AACrI;IACJ;EACJ;AAGA,SAAO;AACX;AASA,IAAM,gBAAgB,CAAC,SAAc,UAAmB,UAAsB,YAAoB;AAC9F,MAAI,QAAQ,UAAU;AAClB,YAAQ,WAAW;EACvB;AAEA,MAAI,QAAQ,sBAAsB,QAAQ,UAAU;AAChD,YAAQ,qBAAqB;EACjC;AAEA,MAAI,QAAQ,SAAS;AACjB,YAAQ,UAAU;EACtB;AACJ;AAOA,IAAM,0BAA0B,CAAC,SAAe,SAAmB;AAC/D,MAAI,KAAK,QAAQ;AACb,UAAM,WAAW,IAAI,QAAQ,GAAG,GAAG,CAAC;AACpC,UAAM,WAAW,IAAI,WAAU;AAC/B,UAAM,UAAU,IAAI,QAAQ,GAAG,GAAG,CAAC;AACnC,UAAM,MAAM,OAAO,UAAU,KAAK,MAAM;AACxC,QAAI,UAAU,SAAS,UAAU,QAAQ;AAEzC,kBAAc,SAAS,UAAU,UAAU,OAAO;EACtD,WAAW,KAAK,eAAe,KAAK,YAAY,KAAK,OAAO;AACxD,kBAAc,SAAS,QAAQ,UAAU,KAAK,WAAW,GAAG,WAAW,UAAU,KAAK,QAAQ,GAAG,QAAQ,UAAU,KAAK,KAAK,CAAC;EAClI;AAEA,UAAQ,mBAAmB,IAAI;AACnC;AASA,IAAM,aAAa,CAAC,aAA2B,MAAiB,OAA8B;AAC1F,MAAI,WAA2B;AAE/B,MAAI,YAAY,qBAAqB,KAAK,QAAQ,KAAK,SAAS;AAC5D,QAAI,YAAY,qBAAqB,YAAY,kBAAkB,SAAS,KAAK,YAAY,kBAAkB,QAAQ,KAAK,QAAQ,EAAE,MAAM,IAAI;AAC5I,aAAO;IACX;EACJ;AAGA,MAAI,KAAK,MAAM;AACX,QAAI,KAAK,QAAQ;AACb,YAAM,OAAmB,YAAY,MAAM,KAAK,IAAI;AAEpD,YAAM,UAAU,WAAW,aAAa,MAAM,KAAK,QAAQ,IAAU,KAAK,WAAW;AACrF,cAAQ,WAAW,YAAY,MAAM,oBAAoB,KAAK,IAAI;AAElE,UAAI,QAAQ,aAAa,MAAM;AAC3B,gBAAQ,WAAW,eAAe,aAAa,MAAM,SAAS,KAAK,eAAe;AAElF,YAAI,CAAC,KAAK,iBAAiB;AACvB,eAAK,kBAAkB,QAAQ;QACnC;MACJ;AAEA,iBAAW;IACf;EACJ,WAAW,KAAK,QAAQ;AAIpB,UAAM,UAAU,WAAW,aAAa,MAAM,KAAK,OAAO,CAAC,KAAK,IAAI,IAAI,KAAK,QAAQ,IAAU,KAAK,WAAW;AAC/G,eAAW;EACf,WAES,KAAK,SAAS,CAAC,KAAK,eAAe,CAAC,YAAY,kBAAkB;AACvE,UAAM,QAAoB,YAAY,OAAO,KAAK,KAAK;AAEvD,QAAI,OAAO;AACP,UAAI,MAAM,SAAS,WAAW;AAC1B,cAAM,cAAsC,MAAO,MAAM,IAAI;AAC7D,cAAM,YAAY,IAAI,iBAAiB,KAAK,OAAO,QAAQ,KAAI,GAAI,YAAY,KAAK;AACpF,kBAAU,OAAO,KAAK,QAAQ;AAE9B,YAAI,YAAY,OAAO;AACnB,oBAAU,UAAU,OAAO,UAAU,YAAY,KAAK;QAC1D;AAEA,mBAAW;MACf,WAAW,MAAM,SAAS,eAAe;AACrC,cAAM,mBAAgD,MAAO,MAAM,IAAI;AACvE,cAAM,WAAW,IAAI,iBAAiB,KAAK,OAAO,QAAQ,KAAI,GAAI,YAAY,KAAK;AACnF,iBAAS,OAAO,KAAK,QAAQ;AAE7B,YAAI,iBAAiB,OAAO;AACxB,mBAAS,UAAU,OAAO,UAAU,iBAAiB,KAAK;QAC9D;AAEA,mBAAW;MACf,WAAW,MAAM,SAAS,SAAS;AAC/B,cAAM,aAAoC,MAAO,MAAM,IAAI;AAC3D,cAAM,UAAU,IAAI,WAAW,KAAK,OAAO,QAAQ,KAAI,GAAI,YAAY,KAAK;AAC5E,gBAAQ,OAAO,KAAK,QAAQ;AAE5B,YAAI,WAAW,OAAO;AAClB,kBAAQ,UAAU,OAAO,UAAU,WAAW,KAAK;QACvD;AAEA,mBAAW;MACf,WAAW,MAAM,SAAS,QAAQ;AAC9B,cAAM,YAAkC,MAAO,MAAM,IAAI;AACzD,cAAM,UAAU,IAAI,UAAU,KAAK,OAAO,QAAQ,KAAI,GAAI,QAAQ,KAAI,GAAI,GAAG,GAAG,YAAY,KAAK;AACjG,gBAAQ,OAAO,KAAK,QAAQ;AAE5B,YAAI,UAAU,OAAO;AACjB,kBAAQ,UAAU,OAAO,UAAU,UAAU,KAAK;QACtD;AAEA,YAAI,UAAU,aAAa;AACvB,kBAAQ,QAAQ,UAAU;QAC9B;AAEA,YAAI,UAAU,iBAAiB;AAC3B,kBAAQ,WAAW,UAAU;QACjC;AAEA,mBAAW;MACf;IACJ;EACJ,WAES,KAAK,UAAU,CAAC,KAAK,eAAe,CAAC,YAAY,kBAAkB;AACxE,UAAM,SAAsB,YAAY,QAAQ,KAAK,MAAM;AAE3D,QAAI,QAAQ;AACR,kBAAY,MAAM,yBAAyB,CAAC,CAAC,YAAY;AACzD,UAAI,OAAO,SAAS,gBAAgB;AAChC,cAAM,cAAc,IAAI,WAAW,KAAK,QAAQ,QAAQ,KAAI,GAAI,YAAY,OAAO,KAAK;AAExF,oBAAY,OAAO,KAAK,QAAQ;AAChC,oBAAY,OAAO,OAAO;AAC1B,oBAAY,cAAa;AAEzB,mBAAW;AAEX,oBAAY,mBAAmB,YAAY;MAC/C,WAAW,OAAO,SAAS,eAAe;AACtC,cAAM,oBAAkD,OAAQ,OAAO,IAAI;AAC3E,cAAM,aAAa,IAAI,WAAW,KAAK,QAAQ,QAAQ,KAAI,GAAI,YAAY,OAAO,KAAK;AAEvF,mBAAW,OAAO,KAAK,QAAQ;AAC/B,mBAAW,cAAa;AAExB,YAAI,CAAC,kBAAkB,aAAa;AAChC,4BAAkB,cAAc,YAAY,MAAM,UAAS,EAAG,eAAc,IAAK,YAAY,MAAM,UAAS,EAAG,gBAAe;QAClI;AAEA,YAAI,kBAAkB,SAAS,kBAAkB,MAAM;AACnD,qBAAW,OAAO,kBAAkB;AACpC,qBAAW,OAAO,kBAAkB;QACxC;AAEA,mBAAW;AACX,mBAAW,mBAAmB,YAAY;MAC9C;AAEA,kBAAY,MAAM,yBAAyB;IAC/C;EACJ;AAGA,MAAI,CAAC,KAAK,WAAW;AACjB,QAAI,KAAK,aAAa;AAClB,aAAO,KAAK;IAChB,WAAW,aAAa,MAAM;AAC1B,kBAAY,MAAM,yBAAyB,CAAC,CAAC,YAAY;AACzD,YAAM,QAAQ,IAAI,KAAK,KAAK,QAAQ,IAAI,YAAY,KAAK;AACzD,YAAM,mBAAmB,YAAY;AACrC,kBAAY,MAAM,yBAAyB;AAC3C,WAAK,cAAc;AACnB,iBAAW;IACf;EACJ;AAEA,MAAI,aAAa,MAAM;AACnB,QAAI,KAAK,UAAU,oBAAoB,MAAM;AACzC,8BAAwB,UAAU,IAAI;IAC1C,OAAO;AACH,YAAM,cAAc,KAAK,eAAe,CAAC,GAAG,GAAG,CAAC;AAChD,YAAM,WAAW,KAAK,YAAY,CAAC,GAAG,GAAG,GAAG,CAAC;AAC7C,YAAM,QAAQ,KAAK,SAAS,CAAC,GAAG,GAAG,CAAC;AACpC,oBAAc,UAAU,QAAQ,UAAU,WAAW,GAAG,WAAW,UAAU,QAAQ,GAAG,QAAQ,UAAU,KAAK,CAAC;IACpH;AAEA,aAAS,YAAY,IAAI;AACzB,SAAK,cAAc;EACvB;AAEA,SAAO;AACX;AASA,IAAM,gBAAgB,CAAC,aAA2B,IAAY,QAAwB,eAAwB,UAAS;AACnH,QAAM,OAAkB,YAAY,MAAM,EAAE;AAC5C,MAAI,UAA0B;AAE9B,MAAI,YAAY,oBAAoB,CAAC,gBAAgB,YAAY,mBAAmB;AAChF,QAAI,YAAY,kBAAkB,QAAQ,KAAK,QAAQ,EAAE,MAAM,MAAM,YAAY,kBAAkB,WAAW,GAAG;AAC7G,qBAAe;IACnB,OAAO;AACH,qBAAe;IACnB;EACJ,OAAO;AACH,mBAAe;EACnB;AAEA,MAAI,CAAC,KAAK,aAAa,cAAc;AACjC,cAAU,WAAW,aAAa,MAAM,EAAE;AAE1C,QAAI,YAAY,MAAM;AAClB,cAAQ,KAAK;AACb,cAAQ,SAAS;IACrB;EACJ;AAEA,MAAI,KAAK,UAAU;AACf,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC3C,oBAAc,aAAa,KAAK,SAAS,CAAC,GAAG,SAAS,YAAY;IACtE;EACJ;AACJ;AAMA,IAAM,WAAW,CAAC,gBAA6B;AAE3C,MAAI,eAAuC,YAAY;AAEvD,MAAI,cAAc;AACd,aAAS,IAAI,GAAG,IAAI,aAAa,MAAM,QAAQ,KAAK;AAChD,oBAAc,aAAa,aAAa,MAAM,CAAC,GAAG,IAAI;IAC1D;EACJ,OAAO;AACH,eAAW,SAAS,YAAY,QAAQ;AACpC,qBAAe,YAAY,OAAO,KAAK;AAEvC,eAAS,IAAI,GAAG,IAAI,aAAa,MAAM,QAAQ,KAAK;AAChD,sBAAc,aAAa,aAAa,MAAM,CAAC,GAAG,IAAI;MAC1D;IACJ;EACJ;AAGA,iBAAe,WAAW;AAE1B,WAAS,IAAI,GAAG,IAAI,YAAY,MAAM,UAAU,QAAQ,KAAK;AACzD,UAAM,WAAW,YAAY,MAAM,UAAU,CAAC;AAC9C,gBAAY,MAAM,eAAe,UAAU,GAAG,OAAO,WAAW,MAAM,CAAG;EAC7E;AACJ;AAYA,IAAM,uBAAuB,CACzB,MACA,aACA,mBACA,gBACA,WACA,UACA,cACA;AACA,QAAM,iBAAiB,SAAS,UAAU,UAAU;AAEpD,aAAW,QAAQ,mBAAmB;AAClC,UAAM,UAAmC,kBAAkB,IAAI;AAC/D,UAAM,OAAO,QAAQ;AAErB,QAAI,SAAS,eAAe,cAAc,SAAS,eAAe,cAAc,SAAS,eAAe,YAAY;AAChH,UAAI,QAAQ,YAAY,CAAC,QAAQ,UAAU,CAAC,QAAQ,MAAM;AACtD,kBAAU,UAAU,YAAY,OAAO,MAAM,SAAS,MAAM,eAAe,UAAS,CAAE;MAC1F,WAAW,QAAQ,aAAa,QAAQ,UAAU,QAAQ,OAAO;AAC7D,YAAI,SAAS,YAAY,MAAM,cAAc,QAAQ,UAAU,QAAQ,QAAQ,EAAE;AACjF,YAAI,WAAW,MAAM;AACjB,mBAAS,YAAY,MAAM,YAAY,QAAQ,UAAU,QAAQ,QAAQ,EAAE;QAC/E;AACA,YAAI,WAAW,MAAM;AACjB;QACJ;AAEA,kBAAU,UAAU,YAAY,OAAO,QAAQ,SAAS,MAAM,eAAe,UAAS,CAAE;MAC5F;IACJ,OAAO;AACH,YAAM,QAAc,eAAgB,UAAU,SAAS,IAAI,CAAC;AAC5D,UAAI,CAAC,OAAO;AACR;MACJ;AAEA,UAAI,SAAS,eAAe,YAAY;AACpC,cAAM,UAAU,YAAY,SAAS,SAAS,SAAS,QAAQ,QAAQ,KAAK,EAAE;AAE9E,YAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C;QACJ;AAEA,uBAAe,UAAS,EAAG,WAAW,MAAM,OAAO;MACvD,OAAO;AACH,kBAAU,WAAW,eAAe,UAAS,GAAI,MAAM,OAAO,IAAI;MACtE;IACJ;EACJ;AAEA,YAAU,cAAc;AAC5B;AAUA,IAAM,gCAAgC,CAClC,aACA,gBACA,WACA,UACA,sBACA;AACA,QAAM,iBAAiB,SAAS,UAAU,UAAU;AACpD,QAAM,oBAAoB,UAAU;AAKpC,aAAW,QAAQ,mBAAmB;AAClC,UAAM,UAAmC,kBAAkB,IAAI;AAC/D,UAAM,OAAO,QAAQ;AACrB,QAAI,QAAc,eAAgB,kBAAkB,IAAI,CAAC;AAEzD,QAAI,UAAU,QAAW;AAErB,cAAa,QAAQ;IACzB;AAEA,QAAI,CAAC,OAAO;AACR;IACJ;AAEA,UAAM,gBAAgB,CAAC,gBAAiC;AACpD,aAAO,CAAC,YAAoB;AACxB,YAAI,QAAQ,SAAS,aAAa;AAE9B,yBAAe,WAAW,aAAa,OAAO;AAC9C,iBAAO,kBAAkB,WAAW;QACxC;MACJ;IACJ;AAGA,QAAI,SAAS,eAAe,YAAY;AACpC,0BAAoB,iBAAiB,aAAa,SAAS,SAAS,QAAQ,QAAQ,OAAO,cAAc,IAAI,GAAG,MAAM,cAAc,IAAI,CAAC;IAC7I,OAEK;AACD,UAAI,QAAQ,SAAS,UAAU,WAAW,gBAAgB,MAAM,SAAS,SAAS,QAAQ,QAAQ,OAAO,IAAI,GAAG;AAE5G,eAAO,kBAAkB,IAAI;MACjC;IACJ;EACJ;AACJ;AASA,IAAM,uBAAuB,CAAC,SAAuB,gBAAgC,YAAsC;AACvH,SAAO,CAAC,QAAgB,UAAiB;AACrC,mBAAe,QAAQ,IAAI;AAC3B,YAAQ,kCAAkC,QAAQ,OAAO,cAAc,QAAQ,oCAAoC;EACvH;AACJ;AAYA,IAAM,yBAAyB,CAC3B,aACA,gBACA,WACA,UACA,mBACA,cACA;AACA,SAAO,CAAC,MAAa;AACjB,kCAA8B,aAAa,gBAAgB,WAAW,UAAU,iBAAiB;AAEjG,mBAAe,SAAS,CAAC,SAAsB;AAC3C,2BAAqB,MAAM,aAAa,mBAAmB,gBAAgB,WAAW,UAAU,SAAS;IAC7G;EACJ;AACJ;AASA,IAAM,sBAAsB,CAAC,WAAsB,WAA2B,sBAAyE;AACnJ,aAAW,QAAQ,UAAU,UAAU;AACnC,UAAM,UAAU,UAAU,SAAS,IAAI;AACvC,UAAM,mBAA4C,UAAU,WAAW,OAAO;AAE9E,QAAI,UAAU,sBAAsB,MAAM;AACtC,UAAI,iBAAiB,YAAY,CAAC,iBAAiB,UAAU,CAAC,iBAAiB,MAAM;AACjF,cAAM,iBAAiB,eAAe,QAAQ,iBAAiB,QAAQ;AAEvE,YAAI,mBAAmB,IAAI;AACvB,iBAAO,kBAAkB,IAAI;AAC7B,iBAAO,kBAAkB,cAAc;QAC3C;MACJ;IACJ;EACJ;AAEA,SAAO,UAAU;AACrB;AAMA,IAAM,kBAAkB,CAAC,gBAA6B;AAElD,aAAW,OAAO,YAAY,WAAW;AACrC,wBAAoB,kBAChB,aACA,KACA,MAAK;IAAE,GACP,MAAK;IAAE,CAAC;EAEhB;AACJ;AAMM,IAAO,iBAAP,MAAqB;EAChB,OAAO,cAAc,YAAiB,OAAc,SAAe;AACtE,UAAM,cAA4B;MAC9B,YAAY,CAAA;MACZ,WAAW,CAAA;MACX,SAAS,CAAA;MACT,aAAa,CAAA;MACb,QAAQ,CAAA;MACR,QAAQ,CAAA;MACR,SAAS,CAAA;MACT,OAAO,CAAA;MACP,QAAQ,CAAA;MACR,UAAU,CAAA;MACV,SAAS,CAAA;MACT,UAAU,CAAA;MACV,UAAU,CAAA;MACV,YAAY,CAAA;MACZ,WAAW,CAAA;MACX,YAAY,CAAA;MACZ,OAAO,CAAA;MACP,gBAAgB,CAAA;MAEhB,QAAQ,CAAA;MAER,cAAc;MACd,cAAc;MAEd;MACA;MAEA,mBAAmB;MACnB,mBAAmB,CAAA;MAEnB,mBAAmB;MAEnB,kBAAkB;MAElB,YAAY,CAAA;MAEZ,gBAAgB;;AAIpB,QAAI,WAAW,YAAY;AACvB,kBAAY,WAAW,YAAY,cAAc,WAAW;IAChE;AAEA,QAAI,WAAW,gBAAgB;AAC3B,kBAAY,WAAW,gBAAgB,kBAAkB,WAAW;IACxE;AAEA,QAAI,WAAW,SAAS;AACpB,mBAAa,WAAW,SAAS,WAAW;IAChD;AAEA,QAAI,WAAW,aAAa;AACxB,kBAAY,WAAW,aAAa,eAAe,WAAW;IAClE;AAEA,QAAI,WAAW,WAAW;AACtB,kBAAY,WAAW,WAAW,aAAa,WAAW;IAC9D;AAEA,QAAI,WAAW,QAAQ;AACnB,kBAAY,WAAW,QAAQ,UAAU,WAAW;IACxD;AAEA,QAAI,WAAW,QAAQ;AACnB,kBAAY,WAAW,QAAQ,UAAU,WAAW;IACxD;AAEA,QAAI,WAAW,SAAS;AACpB,kBAAY,WAAW,SAAS,WAAW,WAAW;IAC1D;AAEA,QAAI,WAAW,OAAO;AAClB,kBAAY,WAAW,OAAO,SAAS,WAAW;IACtD;AAEA,QAAI,WAAW,QAAQ;AACnB,kBAAY,WAAW,QAAQ,UAAU,WAAW;IACxD;AAEA,QAAI,WAAW,UAAU;AACrB,kBAAY,WAAW,UAAU,YAAY,WAAW;IAC5D;AAEA,QAAI,WAAW,SAAS;AACpB,mBAAa,WAAW,SAAS,WAAW;IAChD;AAEA,QAAI,WAAW,UAAU;AACrB,kBAAY,WAAW,UAAU,YAAY,WAAW;IAC5D;AAEA,QAAI,WAAW,UAAU;AACrB,kBAAY,WAAW,UAAU,YAAY,WAAW;IAC5D;AAEA,QAAI,WAAW,YAAY;AACvB,kBAAY,WAAW,YAAY,cAAc,WAAW;IAChE;AAEA,QAAI,WAAW,WAAW;AACtB,kBAAY,WAAW,WAAW,aAAa,WAAW;IAC9D;AAEA,QAAI,WAAW,YAAY;AACvB,kBAAY,WAAW,YAAY,cAAc,WAAW;IAChE;AAEA,QAAI,WAAW,OAAO;AAClB,kBAAY,WAAW,OAAO,SAAS,WAAW;IACtD;AAEA,QAAI,WAAW,QAAQ;AACnB,kBAAY,SAAS,WAAW;IACpC;AAEA,QAAI,WAAW,SAAS,WAAW,QAAQ;AACvC,kBAAY,eAAe,WAAW,OAAO,WAAW,KAAK;IACjE;AAEA,WAAO;EACX;;EAGO,OAAO,gBACV,aACA,IACA,WACA,SACA,YAAuB;AAEvB,UAAM,SAAsB,YAAY,QAAQ,EAAE;AAElD,QAAI,MAAM,SAAS,OAAO,GAAG,GAAG;AAC5B,iBAAW,MAAM,UAAU,IAAI,WAAW,MAAM,aAAa,OAAO,GAAG,CAAC,CAAC,CAAC;IAC9E,OAAO;AACH,YAAM,SACF,YAAY,UAAU,OAAO,KAC7B,CAAC,SAAS,UAAU,IAAI,WAAW,IAAmB,CAAC,GACvD,YACA,QACA,MACA,CAAC,YAAW;AACR,YAAI,SAAS;AACT,kBAAQ,QAAQ,SAAS,MAAM,QAAQ,UAAU;QACrD;MACJ,CAAC;IAET;EACJ;;EAGO,OAAO,uBAAuB,aAA2B,IAAY,WAAwD,SAAkC;AAClK,UAAM,UAAwB,YAAY,SAAS,EAAE;AAErD,QAAI,CAAC,WAAW,CAAC,QAAQ,QAAQ;AAC7B,cAAQ,EAAE;AACV;IACJ;AAEA,QAAI,QAAQ,gBAAgB;AACxB,gBAAU,IAAI;AACd;IACJ;AAEA,UAAM,SAAqB,YAAY,OAAO,QAAQ,MAAM;AAE5D,QAAI,MAAM,SAAS,OAAO,GAAG,GAAG;AAC5B,iBAAW,MAAM,UAAU,IAAI,WAAW,MAAM,aAAa,OAAO,GAAG,CAAC,CAAC,CAAC;IAC9E,OAAO;AACH,YAAM,SACF,YAAY,UAAU,OAAO,KAC7B,CAAC,SAAS,UAAU,IAAI,WAAW,IAAmB,CAAC,GACvD,QACA,QACA,MACA,CAAC,YAAW;AACR,YAAI,SAAS;AACT,kBAAQ,QAAQ,SAAS,MAAM,QAAQ,UAAU;QACrD;MACJ,CAAC;IAET;EACJ;;EAGO,OAAO,mBAAmB,aAA2B,IAAY,QAAmC,WAAqC;AAC5I,UAAM,UAAwB,YAAY,SAAS,EAAE;AAErD,QAAI,QAAQ,gBAAgB;AACxB,gBAAU,QAAQ,cAAc;AAChC;IACJ;AAEA,UAAM,UAAwB,YAAY,SAAS,QAAQ,OAAO;AAElE,UAAM,gBACF,QAAQ,cAAc,mBAAmB,0BACzC,QAAQ,cAAc,mBAAmB,yBACzC,QAAQ,cAAc,mBAAmB,yBACzC,QAAQ,cAAc,mBAAmB;AAE7C,UAAM,eAAe,QAAQ;AAE7B,UAAM,OAAO,UAAU,OAAO,IAAI,KAAI,IAAK,IAAI,KAAK,CAAC,MAAM,CAAC;AAC5D,UAAM,UAAU,IAAI,gBAAgB,IAAI;AACxC,UAAM,gBAAgB,MAAM,IAAI,gBAAgB,OAAO;AACvD,UAAM,aAAa,IAAI,QAAQ,SAAS,YAAY,OAAO,CAAC,eAAe,MAAM,cAAc,eAAe,aAAa;AAC3H,QAAI,QAAQ,UAAU,QAAW;AAC7B,iBAAW,QAAQ,UAAU,YAAY,QAAQ,KAAK;IAC1D;AACA,QAAI,QAAQ,UAAU,QAAW;AAC7B,iBAAW,QAAQ,UAAU,YAAY,QAAQ,KAAK;IAC1D;AACA,eAAW,OAAO;AAElB,YAAQ,iBAAiB;AACzB,cAAU,UAAU;EACxB;;EAGO,OAAO,sBAAsB,aAA2B,IAAY,WAAyD,SAAmC;AACnK,UAAM,SAAsB,YAAY,QAAQ,EAAE;AAElD,QAAI,MAAM,SAAS,OAAO,GAAG,GAAG;AAC5B,YAAM,eAAe,KAAK,OAAO,IAAI,MAAM,GAAG,EAAE,CAAC,CAAC;AAClD,UAAI,WAAW;AACX,kBAAU,YAAY;MAC1B;IACJ,OAAO;AACH,YAAM,SAAS,YAAY,UAAU,OAAO,KAAK,WAAW,QAAW,QAAW,OAAO,CAAC,YAAW;AACjG,YAAI,WAAW,SAAS;AACpB,kBAAQ,QAAQ,SAAS,MAAM,QAAQ,UAAU;QACrD;MACJ,CAAC;IACL;EACJ;;EAGO,OAAO,kBAAkB,aAA2B,IAAY,WAAyC,SAAkC;AAC9I,UAAM,WAA0B,YAAY,UAAU,EAAE;AACxD,QAAI,CAAC,SAAS,WAAW;AACrB,UAAI,SAAS;AACT,gBAAQ,qBAAqB;MACjC;AACA;IACJ;AAEA,UAAM,YAA4B,YAAY,WAAW,SAAS,SAAS;AAC3E,QAAI,CAAC,WAAW;AACZ,kBAAY,MAAM,yBAAyB,CAAC,CAAC,YAAY;AACzD,YAAM,kBAAkB,IAAI,iBAAiB,IAAI,YAAY,KAAK;AAClE,sBAAgB,mBAAmB,YAAY;AAC/C,kBAAY,MAAM,yBAAyB;AAC3C,sBAAgB,eAAe,IAAI,OAAO,KAAK,KAAK,GAAG;AACvD,sBAAgB,kBAAkB,SAAS;AAC3C,gBAAU,eAAe;AACzB;IACJ;AAEA,UAAM,UAAwB,YAAY,SAAS,UAAU,OAAO;AACpE,UAAM,SAA+B,UAAU;AAE/C,UAAM,eAAuB,OAAO,aAAa,QAAQ,eAAe,cAAc;AACtF,UAAM,cAAsB,OAAO,aAAa,QAAQ,iBAAiB,aAAa;AACtF,QAAI,kBAAkB;AACtB,QAAI,iBAAiB;AAErB,UAAM,kBAAkB,IAAI,UAAU,YAAY;AAClD,UAAM,iBAAiB,IAAI,UAAU,WAAW;AAEhD,UAAM,oBAAgE,CAAA;AACtE,UAAM,WAAqB,CAAA;AAC3B,UAAM,aAAuB,CAAA;AAC7B,UAAM,WAAqB,CAAA;AAG3B,eAAW,QAAQ,UAAU,UAAU;AACnC,YAAM,UAAU,UAAU,SAAS,IAAI;AACvC,YAAM,mBAA4C,UAAU,WAAW,OAAO;AAE9E,wBAAkB,IAAI,IAAI;AAE1B,UAAI,iBAAiB,YAAY,CAAC,iBAAiB,QAAQ,CAAC,iBAAiB,QAAQ;AACjF,cAAM,iBAAiB,eAAe,QAAQ,iBAAiB,QAAQ;AACvE,YAAI,mBAAmB,IAAI;AACvB,mBAAS,KAAK,kBAAkB,cAAc,CAAC;AAC/C,iBAAO,kBAAkB,IAAI;QACjC,OAAO;AACH,mBAAS,KAAK,IAAI;QACtB;MACJ,WAAW,iBAAiB,SAAS,eAAe,YAAY;AAC5D,iBAAS,KAAK,IAAI;MACtB,OAAO;AACH,iBAAS,KAAK,IAAI;MACtB;IACJ;AAEA,eAAW,QAAQ,UAAU,YAAY;AACrC,YAAM,YAAY,UAAU,WAAW,IAAI;AAC3C,YAAM,qBAA8C,UAAU,WAAW,SAAS;AAElF,UAAI,mBAAmB,UAAU;AAC7B,cAAM,OAAO,aAAa,kBAAkB;AAC5C,YAAI,MAAM;AACN,qBAAW,KAAK,IAAI;QACxB;MACJ;IACJ;AAGA,WAAO,CAAC,gBAAgB,MAAK,KAAM,gBAAgB,aAAY,GAAI;AAC/D,YAAM,YAAY,gBAAgB;AAElC,UAAI,cAAc,WAAW,YAAY;AACrC,2BAAmB,gBAAgB;AACnC;MACJ;AAEA,UAAI,iBAAiB;AAErB,iBAAW,QAAQ,UAAU,YAAY;AACrC,cAAM,YAAY,UAAU,WAAW,IAAI;AAC3C,cAAM,qBAA8C,UAAU,WAAW,SAAS;AAElF,YAAI,gBAAgB,sBAAsB,QAAQ,mBAAmB,UAAU;AAC3E,6BAAmB,aAAa,kBAAkB;AAClD,2BAAiB;AACjB;QACJ;MACJ;AAEA,UAAI,gBAAgB;AAChB;MACJ;AAEA,yBAAmB,oBAAoB,iBAAiB,WAAW,iBAAiB;IACxF;AAGA,WAAO,CAAC,eAAe,MAAK,KAAM,eAAe,aAAY,GAAI;AAC7D,YAAM,YAAY,eAAe;AAEjC,UAAI,cAAc,WAAW,YAAY;AACrC,0BAAkB,eAAe;AACjC;MACJ;AAEA,wBAAkB,oBAAoB,gBAAgB,WAAW,iBAAiB;IACtF;AAGA,UAAM,aAAa;MACf,QAAQ,QAAQ,eAAe;MAC/B,UAAU,QAAQ,iBAAiB;;AAGvC,UAAM,UAAU;MACZ;MACA;MACA;MACA,mBAAmB,UAAU,OAAO,UAAU,OAAO,OAAO,QAAQ,IAAI,MAAM;;AAGlF,WAAO,aAAa,QAAQ,eAAe,KAAK,cAAc,IAAI;AAClE,WAAO,aAAa,QAAQ,iBAAiB,KAAK,aAAa,IAAI;AAEnE,UAAM,iBAAiB,IAAI,eAAe,IAAI,YAAY,OAAO,YAAY,OAAO;AACpF,mBAAe,UAAU,qBAAqB,SAAS,gBAAgB,OAAO;AAC9E,mBAAe,aAAa,uBAAuB,aAAa,gBAAgB,WAAW,UAAU,mBAAmB,SAAS;AACjI,mBAAe,kBAAkB,SAAS;AAE1C,QAAI,UAAU,OAAO,WAAW;AAC5B,YAAM,YAAY,OAAO;AACzB,UAAI,UAAU,YAAY,UAAU,SAAS,CAAC,MAAM,aAAa,MAAM;AACnE,uBAAe,kBAAkB;MACrC;AAEA,YAAM,YAAY,UAAU;AAC5B,UAAI,WAAW;AACX,YACI,UAAU,CAAC,MAAM,kBAAkB,aACnC,UAAU,CAAC,MAAM,kBAAkB,uBACnC,UAAU,CAAC,MAAM,kBAAkB,OACnC,UAAU,CAAC,MAAM,kBAAkB,KACrC;AACE,yBAAe,YAAY,UAAU;QACzC,WACI,UAAU,CAAC,MAAM,kBAAkB,OACnC,UAAU,CAAC,MAAM,kBAAkB,OACnC,UAAU,CAAC,MAAM,kBAAkB,QACnC,UAAU,CAAC,MAAM,kBAAkB,KACrC;AACE,yBAAe,YAAY,UAAU;QACzC,WACI,UAAU,CAAC,MAAM,kBAAkB,aACnC,UAAU,CAAC,MAAM,kBAAkB,OACnC,UAAU,CAAC,MAAM,kBAAkB,QACnC,UAAU,CAAC,MAAM,kBAAkB,KACrC;AACE,yBAAe,YAAY,UAAU;QACzC,WACI,UAAU,CAAC,MAAM,kBAAkB,QACnC,UAAU,CAAC,MAAM,kBAAkB,uBACnC,UAAU,CAAC,MAAM,kBAAkB,OACnC,UAAU,CAAC,MAAM,kBAAkB,KACrC;AACE,yBAAe,YAAY,UAAU;QACzC,WACI,UAAU,CAAC,MAAM,kBAAkB,aACnC,UAAU,CAAC,MAAM,kBAAkB,QACnC,UAAU,CAAC,MAAM,kBAAkB,OACnC,UAAU,CAAC,MAAM,kBAAkB,KACrC;AACE,yBAAe,YAAY,UAAU;QACzC,WACI,UAAU,CAAC,MAAM,kBAAkB,aACnC,UAAU,CAAC,MAAM,kBAAkB,uBACnC,UAAU,CAAC,MAAM,kBAAkB,OACnC,UAAU,CAAC,MAAM,kBAAkB,KACrC;AACE,yBAAe,YAAY,UAAU;QACzC;MACJ;IACJ;EACJ;;AAQE,IAAOC,cAAP,MAAO,YAAU;EAGZ,OAAO,kBAAkB,WAA8B;AAC1D,QAAI,YAAW,WAAW,UAAU,IAAI,GAAG;AACvC,YAAM,MAAM,8BAA8B,UAAU,OAAO,kBAAkB;AAC7E;IACJ;AAEA,gBAAW,WAAW,UAAU,IAAI,IAAI;EAC5C;EAEO,UAAO;EAEd;;EAGQ,iBACJ,aACA,OACA,MACA,SACA,gBACA,WACA,YACA,SAAmC;AAEnC,UAAM,uBAAuB;AAE7B,wBAAoB,iBAChB,OACA,MACA,SACA,CAAC,gBAAe;AACZ,kBAAY,iBAAiB;AAC7B,kBAAY,mBAAmB;AAE/B,UAAI,gBAAgB,IAAI;AACpB,oBAAY,oBAAoB,CAAA;MACpC,WAAW,OAAO,gBAAgB,UAAU;AACxC,oBAAY,oBAAoB,CAAC,WAAW;MAChD,WAAW,eAAe,EAAE,uBAAuB,QAAQ;AACvD,oBAAY,oBAAoB,CAAC,WAAW;MAChD,OAAO;AACH,oBAAY,oBAAoB,CAAA;AAChC,cAAM,KAAK,yDAAyD;MACxE;AAGA,WAAK,aAAa,WAAW;AAE7B,YAAM,SAAyB,CAAA;AAC/B,YAAM,YAAwB,CAAA;AAG9B,iBAAW,OAAO,YAAY,OAAO;AACjC,cAAM,OAAkB,YAAY,MAAM,GAAG;AAE7C,YAAI,KAAK,uBAAuB,cAAc;AAC1C,iBAAO,KAAK,KAAK,WAAW;QAChC;MACJ;AAEA,iBAAW,OAAO,YAAY,OAAO;AACjC,cAAM,OAAmB,YAAY,MAAM,GAAG;AAE9C,YAAI,KAAK,2BAA2B,UAAU;AAC1C,oBAAU,KAAK,KAAK,eAAe;QACvC;MACJ;AAGA,WAAK,kBAAkB,aAAa,MAAK;AACrC,aAAK,kBAAkB,aAAa,MAAK;AACrC,0BAAgB,WAAW;AAC3B,mBAAS,WAAW;AAEpB,cAAI,CAAC,eAAe,sBAAsB,WAAW;AACjD,sBAAU,QAAQ,SAAS;UAC/B;QACJ,CAAC;MACL,CAAC;AAED,UAAI,eAAe,sBAAsB,WAAW;AAChD,kBAAU,QAAQ,SAAS;MAC/B;IACJ,GACA,OAAO;AAGX,WAAO;EACX;;;;;;;;;;;;EAaO,gBACH,aACA,OACA,gBACA,MACA,SACA,YAAuD;AAEvD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,WAAK,iBACD,aACA,OACA,MACA,SACA,gBACA,CAAC,QAAQ,cAAa;AAClB,gBAAQ;UACJ;UACA,iBAAiB,CAAA;UACjB;UACA,iBAAiB,CAAA;UACjB,QAAQ,CAAA;UACR,gBAAgB,CAAA;UAChB,YAAY,CAAA;UACZ,gBAAgB,CAAA;SACnB;MACL,GACA,YACA,CAAC,YAAW;AACR,eAAO,IAAI,MAAM,OAAO,CAAC;MAC7B,CAAC;IAET,CAAC;EACL;;EAGQ,WACJ,OACA,MACA,SACA,WACA,YACA,SAAmC;AAEnC,UAAM,uBAAuB;AAE7B,wBAAoB,iBAChB,OACA,MACA,SACA,CAAC,gBAAe;AAEZ,0BAAoB,2BAChB,aACA,MAAK;AAED,aAAK,aAAa,WAAW;AAG7B,aAAK,kBAAkB,aAAa,MAAK;AACrC,eAAK,kBAAkB,aAAa,MAAK;AACrC,4BAAgB,WAAW;AAC3B,qBAAS,WAAW;AAEpB,gBAAI,CAAC,eAAe,oBAAoB;AACpC,wBAAS;YACb;UACJ,CAAC;QACL,CAAC;AAED,YAAI,eAAe,oBAAoB;AACnC,oBAAS;QACb;MACJ,GACA,OAAO;IAEf,GACA,OAAO;EAEf;;;;;;;;;EAUO,MAAM,UAAU,OAAc,MAAuB,SAAiB,YAAuD;AAChI,WAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAU;AACzC,WAAK,WACD,OACA,MACA,SACA,MAAK;AACD,gBAAO;MACX,GACA,YACA,CAAC,YAAW;AACR,eAAO,IAAI,MAAM,OAAO,CAAC;MAC7B,CAAC;IAET,CAAC;EACL;;EAGQ,kBAAkB,aAA2B,QAAkB;AACnE,QAAI,aAAa;AAEjB,UAAM,gBAAgB,CAAC,KAAa,WAAuB;AACvD,0BAAoB,sBAChB,aACA,KACA,CAAC,iBAAgB;AACb,YAAI,wBAAwB,aAAa;AACrC;QACJ;AAEA,oBAAY;AAEZ,YAAI,cAAc;AACd,iBAAO,aAAa,OAAO,OAAO,SAAS,YAAY,SAAS,iBAAiB,cAAc,IAAI;QACvG;AAEA,YAAI,YAAY,sBAAsB,YAAY,cAAc;AAC5D,iBAAM;QACV;MACJ,GACA,MAAK;AACD,cAAM,MAAM,6CAA6C,MAAM,iBAAiB,OAAO,GAAG;MAC9F,CAAC;IAET;AAEA,eAAW,OAAO,YAAY,SAAS;AACnC,mBAAa;AAEb,YAAM,SAAsB,YAAY,QAAQ,GAAG;AACnD,UAAI,QAAQ;AACR,sBAAc,KAAK,MAAM,KAAK,MAAM,EAAC;MACzC,OAAO;AACH,cAAM,MAAM,sBAAsB,GAAG;MACzC;IACJ;AAEA,QAAI,CAAC,YAAY;AACb,aAAM;IACV;EACJ;;EAGQ,kBAAkB,aAA2B,QAAkB;AACnE,QAAI,aAAa;AAEjB,UAAM,gBAAgB,CAAC,KAAa,WAAuB;AACvD,0BAAoB,gBAChB,aACA,KACA,CAAC,eAAc;AACX,oBAAY;AAEZ,YAAI,YAAY;AACZ,cAAI,WAAW,cAAc,YAAY,QAAQ,GAAG,EAAE,YAAY;AAC9D,kBAAM,MAAM,kBAAkB,MAAM,gBAAgB,WAAW,aAAa,iBAAiB,OAAO,UAAU;UAClH;AAEA,sBAAY,kBAAkB,GAAG,IAAI;QACzC;AAEA,YAAI,YAAY,sBAAsB,YAAY,cAAc;AAC5D,iBAAM;QACV;MACJ,GACA,MAAK;AACD,cAAM,MAAM,qCAAqC,MAAM,iBAAiB,OAAO,GAAG;MACtF,CAAC;IAET;AAEA,eAAW,OAAO,YAAY,SAAS;AACnC,mBAAa;AAEb,YAAM,SAAsB,YAAY,QAAQ,GAAG;AACnD,UAAI,QAAQ;AACR,sBAAc,KAAK,MAAM,KAAK,MAAM,EAAC;MACzC,OAAO;AACH,cAAM,MAAM,sBAAsB,GAAG;MACzC;IACJ;AAEA,QAAI,CAAC,YAAY;AACb,aAAM;IACV;EACJ;EAEQ,aAAa,aAAyB;AAC1C,QAAI,eAA2B,YAAY;AAE3C,QAAI,cAAc;AAEd,eAAS,IAAI,GAAG,IAAI,aAAa,MAAM,QAAQ,KAAK;AAChD,sBAAc,aAAa,aAAa,MAAM,CAAC,GAAG,IAAI;MAC1D;IACJ,OAAO;AAEH,iBAAW,SAAS,YAAY,QAAQ;AACpC,uBAAe,YAAY,OAAO,KAAK;AAEvC,iBAAS,IAAI,GAAG,IAAI,aAAa,MAAM,QAAQ,KAAK;AAChD,wBAAc,aAAa,aAAa,MAAM,CAAC,GAAG,IAAI;QAC1D;MACJ;IACJ;EACJ;;AA7TcA,YAAA,aAAsD,CAAA;AAiUlE,IAAgB,sBAAhB,MAAgB,qBAAmB;EAGrC,YAAmB,MAAY;AAC3B,SAAK,QAAQ;EACjB;EAEA,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;;;;;;;;;;;;EAaO,iBAAiB,OAAc,MAAuB,SAAiB,WAAiD,SAAmC;AAC9J,WAAO;EACX;;;;;;;;;;EAWO,2BAA2B,aAA2B,WAAuB,SAAmC;AACnH,WAAO;EACX;;;;;;;;;;;;;EAcO,gBACH,aACA,IACA,WACA,SACA,YAAuB;AAEvB,WAAO;EACX;;;;;;;;;;;EAYO,uBAAuB,aAA2B,IAAY,WAA8C,SAAkC;AACjJ,WAAO;EACX;;;;;;;;;;;;EAaO,mBAAmB,aAA2B,IAAY,QAAyB,WAAuC,SAAkC;AAC/J,WAAO;EACX;;;;;;;;;;;EAYO,sBAAsB,aAA2B,IAAY,WAA2C,SAAkC;AAC7I,WAAO;EACX;;;;;;;;;;;EAYO,kBAAkB,aAA2B,IAAY,WAAyC,SAAkC;AACvI,WAAO;EACX;;;;;EAOO,OAAO,iBACV,OACA,MACA,SACA,WACA,SAAmC;AAEnC,yBAAoB,iBAChB,CAAC,oBAAmB;AAChB,aAAO,gBAAgB,iBAAiB,OAAO,MAAM,SAAS,WAAW,OAAO;IACpF,GACA,MAAK;AACD,iBAAW,MAAK;AACZ,YAAI,CAAC,WAAW;AACZ;QACJ;AACA,kBAAU,eAAe,cAAc,KAAK,MAAM,OAAO,OAAO,CAAC;MACrE,CAAC;IACL,CAAC;EAET;;EAGO,OAAO,2BAA2B,aAA2B,WAAuB,SAAmC;AAC1H,yBAAoB,iBAChB,CAAC,oBAAmB;AAChB,aAAO,gBAAgB,2BAA2B,aAAa,WAAW,OAAO;IACrF,GACA,MAAK;AACD,iBAAW,MAAK;AACZ,kBAAS;MACb,CAAC;IACL,CAAC;EAET;;EAGO,OAAO,gBACV,aACA,IACA,WACA,SACA,YAAuB;AAEvB,yBAAoB,iBAChB,CAAC,oBAAmB;AAChB,aAAO,gBAAgB,gBAAgB,aAAa,IAAI,WAAW,SAAS,UAAU;IAC1F,GACA,MAAK;AACD,qBAAe,gBAAgB,aAAa,IAAI,WAAW,SAAS,UAAU;IAClF,CAAC;EAET;;EAGO,OAAO,iBAAiB,aAA2B,IAAY,WAAuC,SAAkC;AAC3I,yBAAoB,wBAChB,aACA,IACA,CAAC,WAAU;AACP,UAAI,QAAQ;AACR,6BAAoB,oBAAoB,aAAa,IAAI,QAAQ,WAAW,OAAO;MACvF;IACJ,GACA,OAAO;EAEf;;EAGO,OAAO,sBAAsB,aAA2B,IAAY,WAAuD,SAAkC;AAChK,yBAAoB,iBAChB,CAAC,oBAAmB;AAChB,aAAO,gBAAgB,sBAAsB,aAAa,IAAI,WAAW,OAAO;IACpF,GACA,MAAK;AACD,qBAAe,sBAAsB,aAAa,IAAI,WAAW,OAAO;IAC5E,CAAC;EAET;;EAGO,OAAO,kBAAkB,aAA2B,IAAY,WAAyC,SAAkC;AAC9I,yBAAoB,iBAChB,CAAC,oBAAmB;AAChB,aAAO,gBAAgB,kBAAkB,aAAa,IAAI,WAAW,OAAO;IAChF,GACA,MAAK;AACD,qBAAe,kBAAkB,aAAa,IAAI,WAAW,OAAO;IACxE,CAAC;EAET;;EAGQ,OAAO,wBACX,aACA,IACA,WACA,SAAkC;AAElC,yBAAoB,iBAChB,CAAC,oBAAmB;AAChB,aAAO,gBAAgB,uBAAuB,aAAa,IAAI,WAAW,OAAO;IACrF,GACA,MAAK;AACD,qBAAe,uBAAuB,aAAa,IAAI,WAAW,OAAO;IAC7E,CAAC;EAET;;EAGQ,OAAO,oBACX,aACA,IACA,QACA,WACA,SAAkC;AAElC,yBAAoB,iBAChB,CAAC,oBAAmB;AAChB,aAAO,gBAAgB,mBAAmB,aAAa,IAAI,QAAQ,WAAW,OAAO;IACzF,GACA,MAAK;AACD,qBAAe,mBAAmB,aAAa,IAAI,QAAQ,SAAS;IACxE,CAAC;EAET;EAEQ,OAAO,iBAAiB,MAAyD,aAAuB;AAC5G,eAAW,iBAAiBA,YAAW,YAAY;AAC/C,YAAM,kBAAkBA,YAAW,WAAW,aAAa;AAC3D,UAAI,KAAK,eAAe,GAAG;AACvB;MACJ;IACJ;AAEA,gBAAW;EACf;;AAGJ,eAAe,qBAAqB,MAAM,IAAIA,YAAU;;;ACryExD,IAAM,4BAA4B;AAiB5B,IAAO,sBAAP,cAAmC,oBAAmB;EAGxD,cAAA;AACI,UAAM,iBAAiB;EAC3B;;EAGgB,iBAAiB,OAAc,MAAuB,SAAiB,WAA8C;AACjI,UAAM,iBAAuB,KAAK,KAAM;AACxC,QAAI,CAAC,kBAAkB,eAAe,QAAQ,KAAK,IAAI,MAAM,MAAM,CAAC,KAAK,KAAK;AAC1E,aAAO;IACX;AAEA,SAAK,OAAO,KAAK;AACjB,cAAU,eAAe,cAAc,KAAK,MAAM,OAAO,OAAO,CAAC;AACjE,WAAO;EACX;;EAGgB,gBAAgB,aAA2B,IAAY,WAA8C,SAAkC;AACnJ,QAAI,YAAY,eAAe,QAAQ,KAAK,IAAI,MAAM,IAAI;AACtD,aAAO;IACX;AAEA,QAAI,OAAO,2BAA2B;AAClC,aAAO;IACX;AAGA,SAAK,KAAK,UAAU,GAAG,KAAK,KAAK,UAAU,EAAE,KAAK,WAAW,CAAC,UAAU,QAAQ,MAAM,OAAO,CAAC;AAC9F,WAAO;EACX;;EAGgB,uBAAuB,aAA2B,IAAY,WAA4C;AACtH,UAAM,UAAwB,YAAY,SAAS,EAAE;AACrD,UAAM,SAAqB,YAAY,OAAO,QAAQ,MAAM;AAC5D,QAAI,CAAC,OAAO,cAAc,EAAE,KAAK,QAAQ,OAAO,aAAa;AACzD,aAAO;IACX;AAEA,UAAM,YAAuC,OAAO,WAAW,KAAK,IAAI;AACxE,UAAM,aAA8B,YAAY,YAAY,UAAU,UAAU;AAChF,UAAM,SAAS,UAAU,wBAAwB,aAAa,YAAY,GAAG,WAAW,YAAY,eAAe,aAAa;AAChI,cAAU,MAAM;AAChB,WAAO;EACX;;EAGgB,sBAAsB,aAA2B,IAAY,WAAyC;AAClH,UAAM,SAAsB,YAAY,QAAQ,EAAE;AAClD,QAAI,CAAC,OAAO,cAAc,EAAE,KAAK,QAAQ,OAAO,aAAa;AACzD,aAAO;IACX;AAEA,UAAM,wBAAoD,OAAO,WAAW,KAAK,IAAI;AACrF,UAAM,aAA8B,YAAY,YAAY,sBAAsB,UAAU;AAC5F,UAAM,cAAc,UAAU,wBAAwB,aAAa,YAAY,GAAG,WAAW,YAAY,eAAe,aAAa;AAErI,eAAW,MAAK;AACZ,YAAM,eAAe,UAAU,mBAAmB,WAAW;AAC7D,gBAAU,YAAY;IAC1B,CAAC;AAED,WAAO;EACX;;AAGJC,YAAW,kBAAkB,IAAI,oBAAmB,CAAE;;;ACvBhD,IAAO,+BAAP,cAA4C,oBAAmB;EACjE,cAAA;AACI,UAAM,sBAAsB;EAChC;;EAGgB,2BAA2B,aAAyB;AAChE,QAAI,CAAC,YAAY,YAAY;AACzB,aAAO;IACX;AAEA,UAAM,YAAyC,YAAY,WAAW,KAAK,IAAI;AAC/E,QAAI,CAAC,WAAW;AACZ,aAAO;IACX;AAGA,UAAM,SAAS,UAAU;AACzB,QAAI,QAAQ;AACR,iBAAW,SAAS,QAAQ;AACxB,cAAM,QAAmC,OAAO,KAAK;AAErD,gBAAQ,MAAM,MAAM;UAChB,KAAK,WAAW;AACZ,kBAAM,eAAe,IAAI,iBAAiB,MAAM,MAAM,IAAI,QAAQ,GAAG,GAAG,CAAC,GAAG,YAAY,KAAK;AAC7F,kBAAM,UAAU,MAAM;AACtB,gBAAI,SAAS;AACT,2BAAa,UAAU,OAAO,UAAU,QAAQ,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;YACtE;AACA;UACJ;UACA,KAAK,SAAS;AACV,kBAAM,aAAa,IAAI,WAAW,MAAM,MAAM,IAAI,QAAQ,IAAI,IAAI,EAAE,GAAG,YAAY,KAAK;AACxF,kBAAM,QAAQ,MAAM;AACpB,gBAAI,OAAO;AACP,yBAAW,UAAU,OAAO,UAAU,MAAM,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;YAClE;AACA;UACJ;UACA,KAAK,eAAe;AAChB,kBAAM,WAAW,IAAI,iBAAiB,MAAM,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,YAAY,KAAK;AAC1F,kBAAM,cAAc,MAAM;AAC1B,gBAAI,aAAa;AACb,uBAAS,UAAU,OAAO,UAAU,YAAY,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;YACtE;AACA;UACJ;UACA,KAAK,QAAQ;AACT,kBAAM,OAAO,MAAM;AACnB,gBAAI,MAAM;AACN,oBAAM,YAAY,IAAI,UAClB,MAAM,MACN,IAAI,QAAQ,GAAG,IAAI,CAAC,GACpB,IAAI,QAAQ,GAAG,IAAI,CAAC,GACpB,KAAK,gBAAgB,KAAK,IAC1B,KAAK,mBAAmB,GACxB,YAAY,KAAK;AAErB,wBAAU,UAAU,OAAO,UAAU,KAAK,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;YAChE;AACA;UACJ;UACA;AACI,kBAAM,KAAK,iDAAiD,MAAM,OAAO,iBAAiB;AAC1F;QACR;MACJ;IACJ;AAEA,WAAO;EACX;;EAGgB,kBAAkB,aAA2B,IAAY,WAAyC,SAAkC;AAChJ,UAAM,WAA0B,YAAY,UAAU,EAAE;AACxD,QAAI,CAAC,YAAY,CAAC,SAAS,YAAY;AACnC,aAAO;IACX;AAEA,UAAM,YAA2C,SAAS,WAAW,KAAK,IAAI;AAC9E,QAAI,CAAC,WAAW;AACZ,aAAO;IACX;AAEA,UAAM,mBAAmB,IAAI,iBAAiB,IAAI,YAAY,KAAK;AACnE,qBAAiB,kBAAkB,SAAS;AAE5C,QAAI,UAAU,cAAc,YAAY;AACpC,uBAAiB,kBAAkB;IACvC;AAEA,qBAAiB,kBAAkB,UAAU,gBAAgB,SAAY,QAAQ,CAAC,UAAU;AAC5F,qBAAiB,QAAQ,UAAU,OAAO,iBAAiB,SAAY,IAAM,UAAU,OAAO;AAC9F,qBAAiB,gBAAgB,UAAU,OAAO,cAAc,SAAY,IAAM,UAAU,OAAO;AAGnG,QAAI,OAAO,UAAU,OAAO,YAAY,UAAU;AAC9C,WAAK,aAAa,aAAa,UAAU,OAAO,SAAS,kBAAkB,kBAAkB,OAAO;IACxG,OAAO;AACH,uBAAiB,eAAe,OAAO,UAAU,UAAU,OAAO,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC;IAC1F;AAGA,QAAI,OAAO,UAAU,OAAO,YAAY,UAAU;AAC9C,WAAK,aAAa,aAAa,UAAU,OAAO,SAAS,kBAAkB,kBAAkB,OAAO;IACxG,OAAO;AACH,uBAAiB,eAAe,OAAO,UAAU,UAAU,OAAO,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC;IAC1F;AAGA,QAAI,OAAO,UAAU,OAAO,aAAa,UAAU;AAC/C,WAAK,aAAa,aAAa,UAAU,OAAO,UAAU,kBAAkB,mBAAmB,OAAO;IAC1G,OAAO;AACH,uBAAiB,gBAAgB,OAAO,UAAU,UAAU,OAAO,YAAY,CAAC,GAAG,GAAG,CAAC,CAAC;IAC5F;AAGA,QAAI,OAAO,UAAU,OAAO,aAAa,UAAU;AAC/C,WAAK,aAAa,aAAa,UAAU,OAAO,UAAU,kBAAkB,mBAAmB,OAAO;IAC1G,OAAO;AACH,uBAAiB,gBAAgB,OAAO,UAAU,UAAU,OAAO,YAAY,CAAC,GAAG,GAAG,CAAC,CAAC;IAC5F;AAEA,WAAO;EACX;EAEQ,aAAa,aAA2B,IAAY,UAA4B,cAAsB,SAAkC;AAE5I,mBAAe,uBACX,aACA,IACA,CAAC,WAAU;AAEP,qBAAe,mBAAmB,aAAa,IAAI,QAAQ,CAAC,YAAmB,SAAU,YAAY,IAAI,OAAQ;IACrH,GACA,OAAO;EAEf;;AAGJC,YAAW,kBAAkB,IAAI,6BAA4B,CAAE;;;ACpN/D,IAAAC,aAAA;SAAAA,YAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",
  "names": ["GLTFLoader", "EComponentType", "EShaderType", "EParameterType", "ETextureWrapMode", "ETextureFilterType", "ETextureFormat", "ECullingType", "EBlendingFunction", "ETokenType", "jointNode", "material", "GLTFLoader", "GLTFLoader", "GLTFLoader", "__exports"]
}
