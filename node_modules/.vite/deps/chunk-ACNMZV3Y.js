import {
  FlowGraphGLTFDataProvider
} from "./chunk-7WZW4BDD.js";
import {
  InteractivityGraphToFlowGraphParser,
  KHR_interactivity,
  _AddInteractivityObjectModel,
  gltfTypeToBabylonType
} from "./chunk-T34EMOEK.js";
import {
  KHR_node_visibility
} from "./chunk-ZBLQW6OX.js";
import {
  KHR_node_selectability
} from "./chunk-KSWMQMFW.js";
import {
  KHR_node_hoverability
} from "./chunk-ICPMYOL6.js";
import {
  addNewInteractivityFlowGraphMapping,
  getAllSupportedNativeNodeTypes,
  getMappingForDeclaration,
  getMappingForFullOperationName
} from "./chunk-D65QHHOE.js";
import {
  ExtrasAsMetadata
} from "./chunk-UFL3H72O.js";
import {
  KHR_texture_basisu
} from "./chunk-J534XXS6.js";
import {
  KHR_texture_transform
} from "./chunk-QGHCMI2O.js";
import {
  KHR_xmp_json_ld
} from "./chunk-HAKSP4W6.js";
import {
  KHR_animation_pointer
} from "./chunk-XC6W6GHB.js";
import {
  MSFT_audio_emitter
} from "./chunk-WN6AWTL5.js";
import {
  MSFT_lod
} from "./chunk-2AHLN7TU.js";
import {
  MSFT_minecraftMesh
} from "./chunk-6ATNFHR6.js";
import {
  MSFT_sRGBFactors
} from "./chunk-GTBRASJP.js";
import {
  KHR_materials_ior
} from "./chunk-C2EK5CKO.js";
import {
  KHR_materials_variants
} from "./chunk-3LCVER22.js";
import {
  KHR_materials_transmission
} from "./chunk-EBMHJ3UZ.js";
import {
  KHR_materials_diffuse_transmission
} from "./chunk-F6QVSOSR.js";
import {
  KHR_materials_volume
} from "./chunk-FJ3CV3XD.js";
import {
  KHR_materials_dispersion
} from "./chunk-FYNXIJRL.js";
import {
  EXT_materials_diffuse_roughness
} from "./chunk-XENN6XHR.js";
import {
  KHR_mesh_quantization
} from "./chunk-6USWYQ4L.js";
import {
  KHR_materials_pbrSpecularGlossiness
} from "./chunk-LVJDNZJF.js";
import {
  KHR_materials_unlit
} from "./chunk-KNBO34EH.js";
import {
  KHR_materials_clearcoat
} from "./chunk-S524O25J.js";
import {
  KHR_materials_iridescence
} from "./chunk-6WZXTIZ5.js";
import {
  KHR_materials_anisotropy
} from "./chunk-Z7VKSDRX.js";
import {
  KHR_materials_emissive_strength
} from "./chunk-WBBQLSBQ.js";
import {
  KHR_materials_sheen
} from "./chunk-FPGLD7CX.js";
import {
  KHR_materials_specular
} from "./chunk-ANK3Z56J.js";
import {
  EXT_lights_image_based
} from "./chunk-TEE7L2WW.js";
import {
  EXT_mesh_gpu_instancing
} from "./chunk-IM7MG4XN.js";
import {
  EXT_meshopt_compression
} from "./chunk-HEW7OSUO.js";
import {
  EXT_texture_webp
} from "./chunk-O2AOKORR.js";
import {
  EXT_texture_avif
} from "./chunk-PVTLGRTE.js";
import {
  EXT_lights_ies
} from "./chunk-MRETWB37.js";
import {
  KHR_draco_mesh_compression
} from "./chunk-SWROYH7Y.js";
import {
  KHR_lights
} from "./chunk-T3ZANODH.js";
import {
  AnimationPropertyInfo,
  TransformNodeAnimationPropertyInfo,
  WeightAnimationPropertyInfo,
  getQuaternion,
  getVector3,
  getWeights
} from "./chunk-J53RLHNC.js";
import {
  ArrayItem,
  GLTFFileLoader,
  GLTFLoader,
  LoadBoundingInfoFromPositionAccessor
} from "./chunk-GDQVZCNY.js";
import {
  AddObjectAccessorToKey,
  GetMappingForKey,
  GetPathToObjectConverter,
  SetInterpolationForKey
} from "./chunk-FEEXIZU7.js";
import {
  registerGLTFExtension,
  registeredGLTFExtensions,
  unregisterGLTFExtension
} from "./chunk-QGBHPVKU.js";
import {
  HemisphericLight
} from "./chunk-AOW5YPRD.js";
import {
  DirectionalLight,
  PointLight
} from "./chunk-6JAS7EJE.js";
import {
  FreeCamera
} from "./chunk-CU2JCES3.js";
import {
  Skeleton
} from "./chunk-CW5HQPXY.js";
import {
  SpotLight
} from "./chunk-3FWXDCVB.js";
import {
  Bone
} from "./chunk-EJZYJTZQ.js";
import {
  ShaderMaterial
} from "./chunk-2VDLYGHE.js";
import {
  Constants
} from "./chunk-BJLSHJRF.js";
import {
  Animation
} from "./chunk-OXA6IQE7.js";
import {
  AbstractMesh,
  Camera,
  Geometry,
  Mesh,
  MultiMaterial,
  VertexData
} from "./chunk-D5TD3MFB.js";
import {
  StandardMaterial
} from "./chunk-FKEVOXJZ.js";
import {
  Material,
  SubMesh
} from "./chunk-JPUTYCJI.js";
import {
  Texture
} from "./chunk-WI5SXUON.js";
import {
  Color3,
  Color4
} from "./chunk-ZUPBS36P.js";
import {
  VertexBuffer
} from "./chunk-6JFLQ55T.js";
import {
  Tools
} from "./chunk-NWYBHPBZ.js";
import {
  Effect
} from "./chunk-2P6TTFAX.js";
import {
  Matrix,
  Quaternion,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-5BUGPWC4.js";
import {
  __export
} from "./chunk-6TJCVOLN.js";

// node_modules/@babylonjs/loaders/glTF/1.0/index.js
var __exports = {};
__export(__exports, {
  EBlendingFunction: () => EBlendingFunction,
  EComponentType: () => EComponentType,
  ECullingType: () => ECullingType,
  EParameterType: () => EParameterType,
  EShaderType: () => EShaderType,
  ETextureFilterType: () => ETextureFilterType,
  ETextureFormat: () => ETextureFormat,
  ETextureWrapMode: () => ETextureWrapMode,
  GLTFBinaryExtension: () => GLTFBinaryExtension,
  GLTFLoader: () => GLTFLoader2,
  GLTFLoaderBase: () => GLTFLoaderBase,
  GLTFLoaderExtension: () => GLTFLoaderExtension,
  GLTFMaterialsCommonExtension: () => GLTFMaterialsCommonExtension,
  GLTFUtils: () => GLTFUtils
});

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderInterfaces.js
var EComponentType;
(function(EComponentType2) {
  EComponentType2[EComponentType2["BYTE"] = 5120] = "BYTE";
  EComponentType2[EComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EComponentType2[EComponentType2["SHORT"] = 5122] = "SHORT";
  EComponentType2[EComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EComponentType2[EComponentType2["FLOAT"] = 5126] = "FLOAT";
})(EComponentType || (EComponentType = {}));
var EShaderType;
(function(EShaderType2) {
  EShaderType2[EShaderType2["FRAGMENT"] = 35632] = "FRAGMENT";
  EShaderType2[EShaderType2["VERTEX"] = 35633] = "VERTEX";
})(EShaderType || (EShaderType = {}));
var EParameterType;
(function(EParameterType2) {
  EParameterType2[EParameterType2["BYTE"] = 5120] = "BYTE";
  EParameterType2[EParameterType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EParameterType2[EParameterType2["SHORT"] = 5122] = "SHORT";
  EParameterType2[EParameterType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EParameterType2[EParameterType2["INT"] = 5124] = "INT";
  EParameterType2[EParameterType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  EParameterType2[EParameterType2["FLOAT"] = 5126] = "FLOAT";
  EParameterType2[EParameterType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  EParameterType2[EParameterType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  EParameterType2[EParameterType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  EParameterType2[EParameterType2["INT_VEC2"] = 35667] = "INT_VEC2";
  EParameterType2[EParameterType2["INT_VEC3"] = 35668] = "INT_VEC3";
  EParameterType2[EParameterType2["INT_VEC4"] = 35669] = "INT_VEC4";
  EParameterType2[EParameterType2["BOOL"] = 35670] = "BOOL";
  EParameterType2[EParameterType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  EParameterType2[EParameterType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  EParameterType2[EParameterType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  EParameterType2[EParameterType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  EParameterType2[EParameterType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  EParameterType2[EParameterType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  EParameterType2[EParameterType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
})(EParameterType || (EParameterType = {}));
var ETextureWrapMode;
(function(ETextureWrapMode2) {
  ETextureWrapMode2[ETextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  ETextureWrapMode2[ETextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  ETextureWrapMode2[ETextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
})(ETextureWrapMode || (ETextureWrapMode = {}));
var ETextureFilterType;
(function(ETextureFilterType2) {
  ETextureFilterType2[ETextureFilterType2["NEAREST"] = 9728] = "NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR"] = 9728] = "LINEAR";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilterType || (ETextureFilterType = {}));
var ETextureFormat;
(function(ETextureFormat2) {
  ETextureFormat2[ETextureFormat2["ALPHA"] = 6406] = "ALPHA";
  ETextureFormat2[ETextureFormat2["RGB"] = 6407] = "RGB";
  ETextureFormat2[ETextureFormat2["RGBA"] = 6408] = "RGBA";
  ETextureFormat2[ETextureFormat2["LUMINANCE"] = 6409] = "LUMINANCE";
  ETextureFormat2[ETextureFormat2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
})(ETextureFormat || (ETextureFormat = {}));
var ECullingType;
(function(ECullingType2) {
  ECullingType2[ECullingType2["FRONT"] = 1028] = "FRONT";
  ECullingType2[ECullingType2["BACK"] = 1029] = "BACK";
  ECullingType2[ECullingType2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(ECullingType || (ECullingType = {}));
var EBlendingFunction;
(function(EBlendingFunction2) {
  EBlendingFunction2[EBlendingFunction2["ZERO"] = 0] = "ZERO";
  EBlendingFunction2[EBlendingFunction2["ONE"] = 1] = "ONE";
  EBlendingFunction2[EBlendingFunction2["SRC_COLOR"] = 768] = "SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["DST_COLOR"] = 774] = "DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["DST_ALPHA"] = 772] = "DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(EBlendingFunction || (EBlendingFunction = {}));

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderUtils.js
var GLTFUtils = class _GLTFUtils {
  /**
   * Sets the given "parameter" matrix
   * @param scene the Scene object
   * @param source the source node where to pick the matrix
   * @param parameter the GLTF technique parameter
   * @param uniformName the name of the shader's uniform
   * @param shaderMaterial the shader material
   */
  static SetMatrix(scene, source, parameter, uniformName, shaderMaterial) {
    let mat = null;
    if (parameter.semantic === "MODEL") {
      mat = source.getWorldMatrix();
    } else if (parameter.semantic === "PROJECTION") {
      mat = scene.getProjectionMatrix();
    } else if (parameter.semantic === "VIEW") {
      mat = scene.getViewMatrix();
    } else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
    } else if (parameter.semantic === "MODELVIEW") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
    } else if (parameter.semantic === "MODELVIEWPROJECTION") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
    } else if (parameter.semantic === "MODELINVERSE") {
      mat = source.getWorldMatrix().invert();
    } else if (parameter.semantic === "VIEWINVERSE") {
      mat = scene.getViewMatrix().invert();
    } else if (parameter.semantic === "PROJECTIONINVERSE") {
      mat = scene.getProjectionMatrix().invert();
    } else if (parameter.semantic === "MODELVIEWINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
    } else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
    } else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().invert());
    }
    if (mat) {
      switch (parameter.type) {
        case EParameterType.FLOAT_MAT2:
          shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));
          break;
        case EParameterType.FLOAT_MAT3:
          shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));
          break;
        case EParameterType.FLOAT_MAT4:
          shaderMaterial.setMatrix(uniformName, mat);
          break;
        default:
          break;
      }
    }
  }
  /**
   * Sets the given "parameter" matrix
   * @param shaderMaterial the shader material
   * @param uniform the name of the shader's uniform
   * @param value the value of the uniform
   * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)
   * @returns true if set, else false
   */
  static SetUniform(shaderMaterial, uniform, value, type) {
    switch (type) {
      case EParameterType.FLOAT:
        shaderMaterial.setFloat(uniform, value);
        return true;
      case EParameterType.FLOAT_VEC2:
        shaderMaterial.setVector2(uniform, Vector2.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC3:
        shaderMaterial.setVector3(uniform, Vector3.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC4:
        shaderMaterial.setVector4(uniform, Vector4.FromArray(value));
        return true;
      default:
        return false;
    }
  }
  /**
   * Returns the wrap mode of the texture
   * @param mode the mode value
   * @returns the wrap mode (TEXTURE_WRAP_ADDRESSMODE, MIRROR_ADDRESSMODE or CLAMP_ADDRESSMODE)
   */
  static GetWrapMode(mode) {
    switch (mode) {
      case ETextureWrapMode.CLAMP_TO_EDGE:
        return Texture.CLAMP_ADDRESSMODE;
      case ETextureWrapMode.MIRRORED_REPEAT:
        return Texture.MIRROR_ADDRESSMODE;
      case ETextureWrapMode.REPEAT:
        return Texture.WRAP_ADDRESSMODE;
      default:
        return Texture.WRAP_ADDRESSMODE;
    }
  }
  /**
   * Returns the byte stride giving an accessor
   * @param accessor the GLTF accessor objet
   * @returns the byte stride
   */
  static GetByteStrideFromType(accessor) {
    const type = accessor.type;
    switch (type) {
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
      default:
        return 1;
    }
  }
  /**
   * Returns the texture filter mode giving a mode value
   * @param mode the filter mode value
   * @returns the filter mode (TODO - needs to be a type?)
   */
  static GetTextureFilterMode(mode) {
    switch (mode) {
      case ETextureFilterType.LINEAR:
      case ETextureFilterType.LINEAR_MIPMAP_NEAREST:
      case ETextureFilterType.LINEAR_MIPMAP_LINEAR:
        return Texture.TRILINEAR_SAMPLINGMODE;
      case ETextureFilterType.NEAREST:
      case ETextureFilterType.NEAREST_MIPMAP_NEAREST:
        return Texture.NEAREST_SAMPLINGMODE;
      default:
        return Texture.BILINEAR_SAMPLINGMODE;
    }
  }
  static GetBufferFromBufferView(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
    byteOffset = bufferView.byteOffset + byteOffset;
    const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
    if (byteOffset + byteLength > loadedBufferView.byteLength) {
      throw new Error("Buffer access is out of range");
    }
    const buffer = loadedBufferView.buffer;
    byteOffset += loadedBufferView.byteOffset;
    switch (componentType) {
      case EComponentType.BYTE:
        return new Int8Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_BYTE:
        return new Uint8Array(buffer, byteOffset, byteLength);
      case EComponentType.SHORT:
        return new Int16Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_SHORT:
        return new Uint16Array(buffer, byteOffset, byteLength);
      default:
        return new Float32Array(buffer, byteOffset, byteLength);
    }
  }
  /**
   * Returns a buffer from its accessor
   * @param gltfRuntime the GLTF runtime
   * @param accessor the GLTF accessor
   * @returns an array buffer view
   */
  static GetBufferFromAccessor(gltfRuntime, accessor) {
    const bufferView = gltfRuntime.bufferViews[accessor.bufferView];
    const byteLength = accessor.count * _GLTFUtils.GetByteStrideFromType(accessor);
    return _GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
  }
  /**
   * Decodes a buffer view into a string
   * @param view the buffer view
   * @returns a string
   */
  static DecodeBufferToText(view) {
    let result = "";
    const length = view.byteLength;
    for (let i = 0; i < length; ++i) {
      result += String.fromCharCode(view[i]);
    }
    return result;
  }
  /**
   * Returns the default material of gltf. Related to
   * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material
   * @param scene the Babylon.js scene
   * @returns the default Babylon material
   */
  static GetDefaultMaterial(scene) {
    if (!_GLTFUtils._DefaultMaterial) {
      Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
        "precision highp float;",
        "",
        "uniform mat4 worldView;",
        "uniform mat4 projection;",
        "",
        "attribute vec3 position;",
        "",
        "void main(void)",
        "{",
        "    gl_Position = projection * worldView * vec4(position, 1.0);",
        "}"
      ].join("\n");
      Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
        "precision highp float;",
        "",
        "uniform vec4 u_emission;",
        "",
        "void main(void)",
        "{",
        "    gl_FragColor = u_emission;",
        "}"
      ].join("\n");
      const shaderPath = {
        vertex: "GLTFDefaultMaterial",
        fragment: "GLTFDefaultMaterial"
      };
      const options = {
        attributes: ["position"],
        uniforms: ["worldView", "projection", "u_emission"],
        samplers: new Array(),
        needAlphaBlending: false
      };
      _GLTFUtils._DefaultMaterial = new ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
      _GLTFUtils._DefaultMaterial.setColor4("u_emission", new Color4(0.5, 0.5, 0.5, 1));
    }
    return _GLTFUtils._DefaultMaterial;
  }
};
GLTFUtils._DefaultMaterial = null;

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoader.js
var ETokenType;
(function(ETokenType2) {
  ETokenType2[ETokenType2["IDENTIFIER"] = 1] = "IDENTIFIER";
  ETokenType2[ETokenType2["UNKNOWN"] = 2] = "UNKNOWN";
  ETokenType2[ETokenType2["END_OF_INPUT"] = 3] = "END_OF_INPUT";
})(ETokenType || (ETokenType = {}));
var Tokenizer = class {
  constructor(toParse) {
    this._pos = 0;
    this.currentToken = ETokenType.UNKNOWN;
    this.currentIdentifier = "";
    this.currentString = "";
    this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
    this._toParse = toParse;
    this._maxPos = toParse.length;
  }
  getNextToken() {
    if (this.isEnd()) {
      return ETokenType.END_OF_INPUT;
    }
    this.currentString = this.read();
    this.currentToken = ETokenType.UNKNOWN;
    if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
      this.currentToken = ETokenType.IDENTIFIER;
      this.currentIdentifier = this.currentString;
      while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_")) {
        this.currentIdentifier += this.currentString;
        this.forward();
      }
    }
    return this.currentToken;
  }
  peek() {
    return this._toParse[this._pos];
  }
  read() {
    return this._toParse[this._pos++];
  }
  forward() {
    this._pos++;
  }
  isEnd() {
    return this._pos >= this._maxPos;
  }
};
var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
var BabylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
var glTFAnimationPaths = ["translation", "rotation", "scale"];
var BabylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
var ParseBuffers = (parsedBuffers, gltfRuntime) => {
  for (const buf in parsedBuffers) {
    const parsedBuffer = parsedBuffers[buf];
    gltfRuntime.buffers[buf] = parsedBuffer;
    gltfRuntime.buffersCount++;
  }
};
var ParseShaders = (parsedShaders, gltfRuntime) => {
  for (const sha in parsedShaders) {
    const parsedShader = parsedShaders[sha];
    gltfRuntime.shaders[sha] = parsedShader;
    gltfRuntime.shaderscount++;
  }
};
var ParseObject = (parsedObjects, runtimeProperty, gltfRuntime) => {
  for (const object in parsedObjects) {
    const parsedObject = parsedObjects[object];
    gltfRuntime[runtimeProperty][object] = parsedObject;
  }
};
var NormalizeUVs = (buffer) => {
  if (!buffer) {
    return;
  }
  for (let i = 0; i < buffer.length / 2; i++) {
    buffer[i * 2 + 1] = 1 - buffer[i * 2 + 1];
  }
};
var GetAttribute = (attributeParameter) => {
  if (attributeParameter.semantic === "NORMAL") {
    return "normal";
  } else if (attributeParameter.semantic === "POSITION") {
    return "position";
  } else if (attributeParameter.semantic === "JOINT") {
    return "matricesIndices";
  } else if (attributeParameter.semantic === "WEIGHT") {
    return "matricesWeights";
  } else if (attributeParameter.semantic === "COLOR") {
    return "color";
  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
    const channel = Number(attributeParameter.semantic.split("_")[1]);
    return "uv" + (channel === 0 ? "" : channel + 1);
  }
  return null;
};
var LoadAnimations = (gltfRuntime) => {
  for (const anim in gltfRuntime.animations) {
    const animation = gltfRuntime.animations[anim];
    if (!animation.channels || !animation.samplers) {
      continue;
    }
    let lastAnimation = null;
    for (let i = 0; i < animation.channels.length; i++) {
      const channel = animation.channels[i];
      const sampler = animation.samplers[channel.sampler];
      if (!sampler) {
        continue;
      }
      let inputData = null;
      let outputData = null;
      if (animation.parameters) {
        inputData = animation.parameters[sampler.input];
        outputData = animation.parameters[sampler.output];
      } else {
        inputData = sampler.input;
        outputData = sampler.output;
      }
      const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
      const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
      const targetId = channel.target.id;
      let targetNode = gltfRuntime.scene.getNodeById(targetId);
      if (targetNode === null) {
        targetNode = gltfRuntime.scene.getNodeByName(targetId);
      }
      if (targetNode === null) {
        Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetId + " to attach to");
        continue;
      }
      const isBone = targetNode instanceof Bone;
      let targetPath = channel.target.path;
      const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
      if (targetPathIndex !== -1) {
        targetPath = BabylonAnimationPaths[targetPathIndex];
      }
      let animationType = Animation.ANIMATIONTYPE_MATRIX;
      if (!isBone) {
        if (targetPath === "rotationQuaternion") {
          animationType = Animation.ANIMATIONTYPE_QUATERNION;
          targetNode.rotationQuaternion = new Quaternion();
        } else {
          animationType = Animation.ANIMATIONTYPE_VECTOR3;
        }
      }
      let babylonAnimation = null;
      const keys = [];
      let arrayOffset = 0;
      let modifyKey = false;
      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
        babylonAnimation = lastAnimation;
        modifyKey = true;
      }
      if (!modifyKey) {
        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
        babylonAnimation = new Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);
        gltfRuntime.scene._blockEntityCollection = false;
      }
      for (let j = 0; j < bufferInput.length; j++) {
        let value = null;
        if (targetPath === "rotationQuaternion") {
          value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
          arrayOffset += 4;
        } else {
          value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
          arrayOffset += 3;
        }
        if (isBone) {
          const bone = targetNode;
          let translation = Vector3.Zero();
          let rotationQuaternion = new Quaternion();
          let scaling = Vector3.Zero();
          let mat = bone.getBaseMatrix();
          if (modifyKey && lastAnimation) {
            mat = lastAnimation.getKeys()[j].value;
          }
          mat.decompose(scaling, rotationQuaternion, translation);
          if (targetPath === "position") {
            translation = value;
          } else if (targetPath === "rotationQuaternion") {
            rotationQuaternion = value;
          } else {
            scaling = value;
          }
          value = Matrix.Compose(scaling, rotationQuaternion, translation);
        }
        if (!modifyKey) {
          keys.push({
            frame: bufferInput[j],
            value
          });
        } else if (lastAnimation) {
          lastAnimation.getKeys()[j].value = value;
        }
      }
      if (!modifyKey && babylonAnimation) {
        babylonAnimation.setKeys(keys);
        targetNode.animations.push(babylonAnimation);
      }
      lastAnimation = babylonAnimation;
      gltfRuntime.scene.stopAnimation(targetNode);
      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1);
    }
  }
};
var ConfigureBoneTransformation = (node) => {
  let mat = null;
  if (node.translation || node.rotation || node.scale) {
    const scale = Vector3.FromArray(node.scale || [1, 1, 1]);
    const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
    const position = Vector3.FromArray(node.translation || [0, 0, 0]);
    mat = Matrix.Compose(scale, rotation, position);
  } else {
    mat = Matrix.FromArray(node.matrix);
  }
  return mat;
};
var GetParentBone = (gltfRuntime, skins, jointName, newSkeleton) => {
  for (let i = 0; i < newSkeleton.bones.length; i++) {
    if (newSkeleton.bones[i].name === jointName) {
      return newSkeleton.bones[i];
    }
  }
  const nodes = gltfRuntime.nodes;
  for (const nde in nodes) {
    const node = nodes[nde];
    if (!node.jointName) {
      continue;
    }
    const children = node.children;
    for (let i = 0; i < children.length; i++) {
      const child = gltfRuntime.nodes[children[i]];
      if (!child.jointName) {
        continue;
      }
      if (child.jointName === jointName) {
        const mat = ConfigureBoneTransformation(node);
        const bone = new Bone(node.name || "", newSkeleton, GetParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
        bone.id = nde;
        return bone;
      }
    }
  }
  return null;
};
var GetNodeToRoot = (nodesToRoot, id) => {
  for (let i = 0; i < nodesToRoot.length; i++) {
    const nodeToRoot = nodesToRoot[i];
    for (let j = 0; j < nodeToRoot.node.children.length; j++) {
      const child = nodeToRoot.node.children[j];
      if (child === id) {
        return nodeToRoot.bone;
      }
    }
  }
  return null;
};
var GetJointNode = (gltfRuntime, jointName) => {
  const nodes = gltfRuntime.nodes;
  let node = nodes[jointName];
  if (node) {
    return {
      node,
      id: jointName
    };
  }
  for (const nde in nodes) {
    node = nodes[nde];
    if (node.jointName === jointName) {
      return {
        node,
        id: nde
      };
    }
  }
  return null;
};
var NodeIsInJoints = (skins, id) => {
  for (let i = 0; i < skins.jointNames.length; i++) {
    if (skins.jointNames[i] === id) {
      return true;
    }
  }
  return false;
};
var GetNodesToRoot = (gltfRuntime, newSkeleton, skins, nodesToRoot) => {
  for (const nde in gltfRuntime.nodes) {
    const node = gltfRuntime.nodes[nde];
    const id = nde;
    if (!node.jointName || NodeIsInJoints(skins, node.jointName)) {
      continue;
    }
    const mat = ConfigureBoneTransformation(node);
    const bone = new Bone(node.name || "", newSkeleton, null, mat);
    bone.id = id;
    nodesToRoot.push({ bone, node, id });
  }
  for (let i = 0; i < nodesToRoot.length; i++) {
    const nodeToRoot = nodesToRoot[i];
    const children = nodeToRoot.node.children;
    for (let j = 0; j < children.length; j++) {
      let child = null;
      for (let k = 0; k < nodesToRoot.length; k++) {
        if (nodesToRoot[k].id === children[j]) {
          child = nodesToRoot[k];
          break;
        }
      }
      if (child) {
        child.bone._parent = nodeToRoot.bone;
        nodeToRoot.bone.children.push(child.bone);
      }
    }
  }
};
var ImportSkeleton = (gltfRuntime, skins, mesh, newSkeleton) => {
  if (!newSkeleton) {
    newSkeleton = new Skeleton(skins.name || "", "", gltfRuntime.scene);
  }
  if (!skins.babylonSkeleton) {
    return newSkeleton;
  }
  const nodesToRoot = [];
  const nodesToRootToAdd = [];
  GetNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
  newSkeleton.bones = [];
  for (let i = 0; i < skins.jointNames.length; i++) {
    const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    const node = jointNode.node;
    if (!node) {
      Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
      continue;
    }
    const id = jointNode.id;
    const existingBone = gltfRuntime.scene.getBoneById(id);
    if (existingBone) {
      newSkeleton.bones.push(existingBone);
      continue;
    }
    let foundBone = false;
    let parentBone = null;
    for (let j = 0; j < i; j++) {
      const jointNode2 = GetJointNode(gltfRuntime, skins.jointNames[j]);
      if (!jointNode2) {
        continue;
      }
      const joint = jointNode2.node;
      if (!joint) {
        Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
        continue;
      }
      const children = joint.children;
      if (!children) {
        continue;
      }
      foundBone = false;
      for (let k = 0; k < children.length; k++) {
        if (children[k] === id) {
          parentBone = GetParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
          foundBone = true;
          break;
        }
      }
      if (foundBone) {
        break;
      }
    }
    const mat = ConfigureBoneTransformation(node);
    if (!parentBone && nodesToRoot.length > 0) {
      parentBone = GetNodeToRoot(nodesToRoot, id);
      if (parentBone) {
        if (nodesToRootToAdd.indexOf(parentBone) === -1) {
          nodesToRootToAdd.push(parentBone);
        }
      }
    }
    const bone = new Bone(node.jointName || "", newSkeleton, parentBone, mat);
    bone.id = id;
  }
  const bones = newSkeleton.bones;
  newSkeleton.bones = [];
  for (let i = 0; i < skins.jointNames.length; i++) {
    const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    for (let j = 0; j < bones.length; j++) {
      if (bones[j].id === jointNode.id) {
        newSkeleton.bones.push(bones[j]);
        break;
      }
    }
  }
  newSkeleton.prepare();
  for (let i = 0; i < nodesToRootToAdd.length; i++) {
    newSkeleton.bones.push(nodesToRootToAdd[i]);
  }
  return newSkeleton;
};
var ImportMesh = (gltfRuntime, node, meshes, id, newMesh) => {
  if (!newMesh) {
    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
    newMesh = new Mesh(node.name || "", gltfRuntime.scene);
    newMesh._parentContainer = gltfRuntime.assetContainer;
    gltfRuntime.scene._blockEntityCollection = false;
    newMesh.id = id;
  }
  if (!node.babylonNode) {
    return newMesh;
  }
  const subMaterials = [];
  let vertexData = null;
  const verticesStarts = [];
  const verticesCounts = [];
  const indexStarts = [];
  const indexCounts = [];
  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    const meshId = meshes[meshIndex];
    const mesh = gltfRuntime.meshes[meshId];
    if (!mesh) {
      continue;
    }
    for (let i = 0; i < mesh.primitives.length; i++) {
      const tempVertexData = new VertexData();
      const primitive = mesh.primitives[i];
      if (primitive.mode !== 4) {
      }
      const attributes = primitive.attributes;
      let accessor = null;
      let buffer = null;
      for (const semantic in attributes) {
        accessor = gltfRuntime.accessors[attributes[semantic]];
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        if (semantic === "NORMAL") {
          tempVertexData.normals = new Float32Array(buffer.length);
          tempVertexData.normals.set(buffer);
        } else if (semantic === "POSITION") {
          if (GLTFFileLoader.HomogeneousCoordinates) {
            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
            for (let j = 0; j < buffer.length; j += 4) {
              tempVertexData.positions[j] = buffer[j];
              tempVertexData.positions[j + 1] = buffer[j + 1];
              tempVertexData.positions[j + 2] = buffer[j + 2];
            }
          } else {
            tempVertexData.positions = new Float32Array(buffer.length);
            tempVertexData.positions.set(buffer);
          }
          verticesCounts.push(tempVertexData.positions.length);
        } else if (semantic.indexOf("TEXCOORD_") !== -1) {
          const channel = Number(semantic.split("_")[1]);
          const uvKind = VertexBuffer.UVKind + (channel === 0 ? "" : channel + 1);
          const uvs = new Float32Array(buffer.length);
          uvs.set(buffer);
          NormalizeUVs(uvs);
          tempVertexData.set(uvs, uvKind);
        } else if (semantic === "JOINT") {
          tempVertexData.matricesIndices = new Float32Array(buffer.length);
          tempVertexData.matricesIndices.set(buffer);
        } else if (semantic === "WEIGHT") {
          tempVertexData.matricesWeights = new Float32Array(buffer.length);
          tempVertexData.matricesWeights.set(buffer);
        } else if (semantic === "COLOR") {
          tempVertexData.colors = new Float32Array(buffer.length);
          tempVertexData.colors.set(buffer);
        }
      }
      accessor = gltfRuntime.accessors[primitive.indices];
      if (accessor) {
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        tempVertexData.indices = new Int32Array(buffer.length);
        tempVertexData.indices.set(buffer);
        indexCounts.push(tempVertexData.indices.length);
      } else {
        const indices = [];
        for (let j = 0; j < tempVertexData.positions.length / 3; j++) {
          indices.push(j);
        }
        tempVertexData.indices = new Int32Array(indices);
        indexCounts.push(tempVertexData.indices.length);
      }
      if (!vertexData) {
        vertexData = tempVertexData;
      } else {
        vertexData.merge(tempVertexData);
      }
      const material2 = gltfRuntime.scene.getMaterialById(primitive.material);
      subMaterials.push(material2 === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material2);
      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
    }
  }
  let material;
  gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
  if (subMaterials.length > 1) {
    material = new MultiMaterial("multimat" + id, gltfRuntime.scene);
    material.subMaterials = subMaterials;
  } else {
    material = new StandardMaterial("multimat" + id, gltfRuntime.scene);
  }
  if (subMaterials.length === 1) {
    material = subMaterials[0];
  }
  material._parentContainer = gltfRuntime.assetContainer;
  if (!newMesh.material) {
    newMesh.material = material;
  }
  new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
  newMesh.computeWorldMatrix(true);
  gltfRuntime.scene._blockEntityCollection = false;
  newMesh.subMeshes = [];
  let index = 0;
  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    const meshId = meshes[meshIndex];
    const mesh = gltfRuntime.meshes[meshId];
    if (!mesh) {
      continue;
    }
    for (let i = 0; i < mesh.primitives.length; i++) {
      if (mesh.primitives[i].mode !== 4) {
      }
      SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
      index++;
    }
  }
  return newMesh;
};
var ConfigureNode = (newNode, position, rotation, scaling) => {
  if (newNode.position) {
    newNode.position = position;
  }
  if (newNode.rotationQuaternion || newNode.rotation) {
    newNode.rotationQuaternion = rotation;
  }
  if (newNode.scaling) {
    newNode.scaling = scaling;
  }
};
var ConfigureNodeFromMatrix = (newNode, node) => {
  if (node.matrix) {
    const position = new Vector3(0, 0, 0);
    const rotation = new Quaternion();
    const scaling = new Vector3(0, 0, 0);
    const mat = Matrix.FromArray(node.matrix);
    mat.decompose(scaling, rotation, position);
    ConfigureNode(newNode, position, rotation, scaling);
  } else if (node.translation && node.rotation && node.scale) {
    ConfigureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));
  }
  newNode.computeWorldMatrix(true);
};
var ImportNode = (gltfRuntime, node, id) => {
  let lastNode = null;
  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
      return null;
    }
  }
  if (node.skin) {
    if (node.meshes) {
      const skin = gltfRuntime.skins[node.skin];
      const newMesh = ImportMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);
      if (newMesh.skeleton === null) {
        newMesh.skeleton = ImportSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);
        if (!skin.babylonSkeleton) {
          skin.babylonSkeleton = newMesh.skeleton;
        }
      }
      lastNode = newMesh;
    }
  } else if (node.meshes) {
    const newMesh = ImportMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
    lastNode = newMesh;
  } else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    const light = gltfRuntime.lights[node.light];
    if (light) {
      if (light.type === "ambient") {
        const ambienLight = light[light.type];
        const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        hemiLight.name = node.name || "";
        if (ambienLight.color) {
          hemiLight.diffuse = Color3.FromArray(ambienLight.color);
        }
        lastNode = hemiLight;
      } else if (light.type === "directional") {
        const directionalLight = light[light.type];
        const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        dirLight.name = node.name || "";
        if (directionalLight.color) {
          dirLight.diffuse = Color3.FromArray(directionalLight.color);
        }
        lastNode = dirLight;
      } else if (light.type === "point") {
        const pointLight = light[light.type];
        const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        ptLight.name = node.name || "";
        if (pointLight.color) {
          ptLight.diffuse = Color3.FromArray(pointLight.color);
        }
        lastNode = ptLight;
      } else if (light.type === "spot") {
        const spotLight = light[light.type];
        const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);
        spLight.name = node.name || "";
        if (spotLight.color) {
          spLight.diffuse = Color3.FromArray(spotLight.color);
        }
        if (spotLight.fallOfAngle) {
          spLight.angle = spotLight.fallOfAngle;
        }
        if (spotLight.fallOffExponent) {
          spLight.exponent = spotLight.fallOffExponent;
        }
        lastNode = spLight;
      }
    }
  } else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    const camera = gltfRuntime.cameras[node.camera];
    if (camera) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      if (camera.type === "orthographic") {
        const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        orthoCamera.name = node.name || "";
        orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        orthoCamera.attachControl();
        lastNode = orthoCamera;
        orthoCamera._parentContainer = gltfRuntime.assetContainer;
      } else if (camera.type === "perspective") {
        const perspectiveCamera = camera[camera.type];
        const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        persCamera.name = node.name || "";
        persCamera.attachControl();
        if (!perspectiveCamera.aspectRatio) {
          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
        }
        if (perspectiveCamera.znear && perspectiveCamera.zfar) {
          persCamera.maxZ = perspectiveCamera.zfar;
          persCamera.minZ = perspectiveCamera.znear;
        }
        lastNode = persCamera;
        persCamera._parentContainer = gltfRuntime.assetContainer;
      }
      gltfRuntime.scene._blockEntityCollection = false;
    }
  }
  if (!node.jointName) {
    if (node.babylonNode) {
      return node.babylonNode;
    } else if (lastNode === null) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      const dummy = new Mesh(node.name || "", gltfRuntime.scene);
      dummy._parentContainer = gltfRuntime.assetContainer;
      gltfRuntime.scene._blockEntityCollection = false;
      node.babylonNode = dummy;
      lastNode = dummy;
    }
  }
  if (lastNode !== null) {
    if (node.matrix && lastNode instanceof Mesh) {
      ConfigureNodeFromMatrix(lastNode, node);
    } else {
      const translation = node.translation || [0, 0, 0];
      const rotation = node.rotation || [0, 0, 0, 1];
      const scale = node.scale || [1, 1, 1];
      ConfigureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));
    }
    lastNode.updateCache(true);
    node.babylonNode = lastNode;
  }
  return lastNode;
};
var TraverseNodes = (gltfRuntime, id, parent, meshIncluded = false) => {
  const node = gltfRuntime.nodes[id];
  let newNode = null;
  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
    if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
      meshIncluded = true;
    } else {
      meshIncluded = false;
    }
  } else {
    meshIncluded = true;
  }
  if (!node.jointName && meshIncluded) {
    newNode = ImportNode(gltfRuntime, node, id);
    if (newNode !== null) {
      newNode.id = id;
      newNode.parent = parent;
    }
  }
  if (node.children) {
    for (let i = 0; i < node.children.length; i++) {
      TraverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
    }
  }
};
var PostLoad = (gltfRuntime) => {
  let currentScene = gltfRuntime.currentScene;
  if (currentScene) {
    for (let i = 0; i < currentScene.nodes.length; i++) {
      TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
    }
  } else {
    for (const thing in gltfRuntime.scenes) {
      currentScene = gltfRuntime.scenes[thing];
      for (let i = 0; i < currentScene.nodes.length; i++) {
        TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    }
  }
  LoadAnimations(gltfRuntime);
  for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
    const skeleton = gltfRuntime.scene.skeletons[i];
    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1);
  }
};
var OnBindShaderMaterial = (mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) => {
  const materialValues = material.values || technique.parameters;
  for (const unif in unTreatedUniforms) {
    const uniform = unTreatedUniforms[unif];
    const type = uniform.type;
    if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {
      if (uniform.semantic && !uniform.source && !uniform.node) {
        GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
      } else if (uniform.semantic && (uniform.source || uniform.node)) {
        let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
        if (source === null) {
          source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || "");
        }
        if (source === null) {
          continue;
        }
        GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
      }
    } else {
      const value = materialValues[technique.uniforms[unif]];
      if (!value) {
        continue;
      }
      if (type === EParameterType.SAMPLER_2D) {
        const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
        if (texture === null || texture === void 0) {
          continue;
        }
        shaderMaterial.getEffect().setTexture(unif, texture);
      } else {
        GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);
      }
    }
  }
  onSuccess(shaderMaterial);
};
var PrepareShaderMaterialUniforms = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) => {
  const materialValues = material.values || technique.parameters;
  const techniqueUniforms = technique.uniforms;
  for (const unif in unTreatedUniforms) {
    const uniform = unTreatedUniforms[unif];
    const type = uniform.type;
    let value = materialValues[techniqueUniforms[unif]];
    if (value === void 0) {
      value = uniform.value;
    }
    if (!value) {
      continue;
    }
    const onLoadTexture = (uniformName) => {
      return (texture) => {
        if (uniform.value && uniformName) {
          shaderMaterial.setTexture(uniformName, texture);
          delete unTreatedUniforms[uniformName];
        }
      };
    };
    if (type === EParameterType.SAMPLER_2D) {
      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));
    } else {
      if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {
        delete unTreatedUniforms[unif];
      }
    }
  }
};
var OnShaderCompileError = (program, shaderMaterial, onError) => {
  return (effect, error) => {
    shaderMaterial.dispose(true);
    onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
  };
};
var OnShaderCompileSuccess = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) => {
  return (_) => {
    PrepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
    shaderMaterial.onBind = (mesh) => {
      OnBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
    };
  };
};
var ParseShaderUniforms = (tokenizer, technique, unTreatedUniforms) => {
  for (const unif in technique.uniforms) {
    const uniform = technique.uniforms[unif];
    const uniformParameter = technique.parameters[uniform];
    if (tokenizer.currentIdentifier === unif) {
      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          delete unTreatedUniforms[unif];
          return BabylonTransforms[transformIndex];
        }
      }
    }
  }
  return tokenizer.currentIdentifier;
};
var ImportMaterials = (gltfRuntime) => {
  for (const mat in gltfRuntime.materials) {
    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, () => {
    }, () => {
    });
  }
};
var GLTFLoaderBase = class {
  static CreateRuntime(parsedData, scene, rootUrl) {
    const gltfRuntime = {
      extensions: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      meshes: {},
      lights: {},
      cameras: {},
      nodes: {},
      images: {},
      textures: {},
      shaders: {},
      programs: {},
      samplers: {},
      techniques: {},
      materials: {},
      animations: {},
      skins: {},
      extensionsUsed: [],
      scenes: {},
      buffersCount: 0,
      shaderscount: 0,
      scene,
      rootUrl,
      loadedBufferCount: 0,
      loadedBufferViews: {},
      loadedShaderCount: 0,
      importOnlyMeshes: false,
      dummyNodes: [],
      assetContainer: null
    };
    if (parsedData.extensions) {
      ParseObject(parsedData.extensions, "extensions", gltfRuntime);
    }
    if (parsedData.extensionsUsed) {
      ParseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
    }
    if (parsedData.buffers) {
      ParseBuffers(parsedData.buffers, gltfRuntime);
    }
    if (parsedData.bufferViews) {
      ParseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
    }
    if (parsedData.accessors) {
      ParseObject(parsedData.accessors, "accessors", gltfRuntime);
    }
    if (parsedData.meshes) {
      ParseObject(parsedData.meshes, "meshes", gltfRuntime);
    }
    if (parsedData.lights) {
      ParseObject(parsedData.lights, "lights", gltfRuntime);
    }
    if (parsedData.cameras) {
      ParseObject(parsedData.cameras, "cameras", gltfRuntime);
    }
    if (parsedData.nodes) {
      ParseObject(parsedData.nodes, "nodes", gltfRuntime);
    }
    if (parsedData.images) {
      ParseObject(parsedData.images, "images", gltfRuntime);
    }
    if (parsedData.textures) {
      ParseObject(parsedData.textures, "textures", gltfRuntime);
    }
    if (parsedData.shaders) {
      ParseShaders(parsedData.shaders, gltfRuntime);
    }
    if (parsedData.programs) {
      ParseObject(parsedData.programs, "programs", gltfRuntime);
    }
    if (parsedData.samplers) {
      ParseObject(parsedData.samplers, "samplers", gltfRuntime);
    }
    if (parsedData.techniques) {
      ParseObject(parsedData.techniques, "techniques", gltfRuntime);
    }
    if (parsedData.materials) {
      ParseObject(parsedData.materials, "materials", gltfRuntime);
    }
    if (parsedData.animations) {
      ParseObject(parsedData.animations, "animations", gltfRuntime);
    }
    if (parsedData.skins) {
      ParseObject(parsedData.skins, "skins", gltfRuntime);
    }
    if (parsedData.scenes) {
      gltfRuntime.scenes = parsedData.scenes;
    }
    if (parsedData.scene && parsedData.scenes) {
      gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
    }
    return gltfRuntime;
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    const buffer = gltfRuntime.buffers[id];
    if (Tools.IsBase64(buffer.uri)) {
      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data)), onProgress, void 0, true, (request) => {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    const texture = gltfRuntime.textures[id];
    if (!texture || !texture.source) {
      onError("");
      return;
    }
    if (texture.babylonTexture) {
      onSuccess(null);
      return;
    }
    const source = gltfRuntime.images[texture.source];
    if (Tools.IsBase64(source.uri)) {
      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data)), void 0, void 0, true, (request) => {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  static CreateTextureAsync(gltfRuntime, id, buffer, onSuccess) {
    const texture = gltfRuntime.textures[id];
    if (texture.babylonTexture) {
      onSuccess(texture.babylonTexture);
      return;
    }
    const sampler = gltfRuntime.samplers[texture.sampler];
    const createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;
    const samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    const blob = buffer == null ? new Blob() : new Blob([buffer]);
    const blobURL = URL.createObjectURL(blob);
    const revokeBlobURL = () => URL.revokeObjectURL(blobURL);
    const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
    if (sampler.wrapS !== void 0) {
      newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);
    }
    if (sampler.wrapT !== void 0) {
      newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);
    }
    newTexture.name = id;
    texture.babylonTexture = newTexture;
    onSuccess(newTexture);
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    const shader = gltfRuntime.shaders[id];
    if (Tools.IsBase64(shader.uri)) {
      const shaderString = atob(shader.uri.split(",")[1]);
      if (onSuccess) {
        onSuccess(shaderString);
      }
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, void 0, void 0, false, (request) => {
        if (request && onError) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    const material = gltfRuntime.materials[id];
    if (!material.technique) {
      if (onError) {
        onError("No technique found.");
      }
      return;
    }
    const technique = gltfRuntime.techniques[material.technique];
    if (!technique) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);
      defaultMaterial._parentContainer = gltfRuntime.assetContainer;
      gltfRuntime.scene._blockEntityCollection = false;
      defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);
      defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
      onSuccess(defaultMaterial);
      return;
    }
    const program = gltfRuntime.programs[technique.program];
    const states = technique.states;
    const vertexShader = Effect.ShadersStore[program.vertexShader + "VertexShader"];
    const pixelShader = Effect.ShadersStore[program.fragmentShader + "PixelShader"];
    let newVertexShader = "";
    let newPixelShader = "";
    const vertexTokenizer = new Tokenizer(vertexShader);
    const pixelTokenizer = new Tokenizer(pixelShader);
    const unTreatedUniforms = {};
    const uniforms = [];
    const attributes = [];
    const samplers = [];
    for (const unif in technique.uniforms) {
      const uniform = technique.uniforms[unif];
      const uniformParameter = technique.parameters[uniform];
      unTreatedUniforms[unif] = uniformParameter;
      if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          uniforms.push(BabylonTransforms[transformIndex]);
          delete unTreatedUniforms[unif];
        } else {
          uniforms.push(unif);
        }
      } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {
        samplers.push(unif);
      } else {
        uniforms.push(unif);
      }
    }
    for (const attr in technique.attributes) {
      const attribute = technique.attributes[attr];
      const attributeParameter = technique.parameters[attribute];
      if (attributeParameter.semantic) {
        const name = GetAttribute(attributeParameter);
        if (name) {
          attributes.push(name);
        }
      }
    }
    while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
      const tokenType = vertexTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newVertexShader += vertexTokenizer.currentString;
        continue;
      }
      let foundAttribute = false;
      for (const attr in technique.attributes) {
        const attribute = technique.attributes[attr];
        const attributeParameter = technique.parameters[attribute];
        if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
          newVertexShader += GetAttribute(attributeParameter);
          foundAttribute = true;
          break;
        }
      }
      if (foundAttribute) {
        continue;
      }
      newVertexShader += ParseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
    }
    while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
      const tokenType = pixelTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newPixelShader += pixelTokenizer.currentString;
        continue;
      }
      newPixelShader += ParseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
    }
    const shaderPath = {
      vertex: program.vertexShader + id,
      fragment: program.fragmentShader + id
    };
    const options = {
      attributes,
      uniforms,
      samplers,
      needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1
    };
    Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
    Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
    const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
    shaderMaterial.onError = OnShaderCompileError(program, shaderMaterial, onError);
    shaderMaterial.onCompiled = OnShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
    shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (states && states.functions) {
      const functions = states.functions;
      if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {
        shaderMaterial.backFaceCulling = false;
      }
      const blendFunc = functions.blendFuncSeparate;
      if (blendFunc) {
        if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;
        } else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ADD;
        } else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;
        } else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;
        }
      }
    }
  }
};
var GLTFLoader2 = class _GLTFLoader {
  static RegisterExtension(extension) {
    if (_GLTFLoader.Extensions[extension.name]) {
      Tools.Error('Tool with the same name "' + extension.name + '" already exists');
      return;
    }
    _GLTFLoader.Extensions[extension.name] = extension;
  }
  dispose() {
  }
  // eslint-disable-next-line no-restricted-syntax
  _importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {
      gltfRuntime.assetContainer = assetContainer;
      gltfRuntime.importOnlyMeshes = true;
      if (meshesNames === "") {
        gltfRuntime.importMeshesNames = [];
      } else if (typeof meshesNames === "string") {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else if (meshesNames && !(meshesNames instanceof Array)) {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else {
        gltfRuntime.importMeshesNames = [];
        Tools.Warn("Argument meshesNames must be of type string or string[]");
      }
      this._createNodes(gltfRuntime);
      const meshes = [];
      const skeletons = [];
      for (const nde in gltfRuntime.nodes) {
        const node = gltfRuntime.nodes[nde];
        if (node.babylonNode instanceof AbstractMesh) {
          meshes.push(node.babylonNode);
        }
      }
      for (const skl in gltfRuntime.skins) {
        const skin = gltfRuntime.skins[skl];
        if (skin.babylonSkeleton instanceof Skeleton) {
          skeletons.push(skin.babylonSkeleton);
        }
      }
      this._loadBuffersAsync(gltfRuntime, () => {
        this._loadShadersAsync(gltfRuntime, () => {
          ImportMaterials(gltfRuntime);
          PostLoad(gltfRuntime);
          if (!GLTFFileLoader.IncrementalLoading && onSuccess) {
            onSuccess(meshes, skeletons);
          }
        });
      });
      if (GLTFFileLoader.IncrementalLoading && onSuccess) {
        onSuccess(meshes, skeletons);
      }
    }, onError);
    return true;
  }
  /**
   * Imports one or more meshes from a loaded gltf file and adds them to the scene
   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
   * @param scene the scene the meshes should be added to
   * @param assetContainer defines the asset container to use (can be null)
   * @param data gltf data containing information of the meshes in a loaded file
   * @param rootUrl root url to load from
   * @param onProgress event that fires when loading progress has occured
   * @returns a promise containg the loaded meshes, particles, skeletons and animations
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  importMeshAsync(meshesNames, scene, assetContainer, data, rootUrl, onProgress) {
    return new Promise((resolve, reject) => {
      this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, (meshes, skeletons) => {
        resolve({
          meshes,
          particleSystems: [],
          skeletons,
          animationGroups: [],
          lights: [],
          transformNodes: [],
          geometries: [],
          spriteManagers: []
        });
      }, onProgress, (message) => {
        reject(new Error(message));
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  _loadAsync(scene, data, rootUrl, onSuccess, onProgress, onError) {
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {
      GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {
        this._createNodes(gltfRuntime);
        this._loadBuffersAsync(gltfRuntime, () => {
          this._loadShadersAsync(gltfRuntime, () => {
            ImportMaterials(gltfRuntime);
            PostLoad(gltfRuntime);
            if (!GLTFFileLoader.IncrementalLoading) {
              onSuccess();
            }
          });
        });
        if (GLTFFileLoader.IncrementalLoading) {
          onSuccess();
        }
      }, onError);
    }, onError);
  }
  /**
   * Imports all objects from a loaded gltf file and adds them to the scene
   * @param scene the scene the objects should be added to
   * @param data gltf data containing information of the meshes in a loaded file
   * @param rootUrl root url to load from
   * @param onProgress event that fires when loading progress has occured
   * @returns a promise which completes when objects have been loaded to the scene
   */
  async loadAsync(scene, data, rootUrl, onProgress) {
    return await new Promise((resolve, reject) => {
      this._loadAsync(scene, data, rootUrl, () => {
        resolve();
      }, onProgress, (message) => {
        reject(new Error(message));
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  _loadShadersAsync(gltfRuntime, onload) {
    let hasShaders = false;
    const processShader = (sha, shader) => {
      GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {
        if (shaderString instanceof ArrayBuffer) {
          return;
        }
        gltfRuntime.loadedShaderCount++;
        if (shaderString) {
          Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
        }
        if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
          onload();
        }
      }, () => {
        Tools.Error("Error when loading shader program named " + sha + " located at " + shader.uri);
      });
    };
    for (const sha in gltfRuntime.shaders) {
      hasShaders = true;
      const shader = gltfRuntime.shaders[sha];
      if (shader) {
        processShader.bind(this, sha, shader)();
      } else {
        Tools.Error("No shader named: " + sha);
      }
    }
    if (!hasShaders) {
      onload();
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  _loadBuffersAsync(gltfRuntime, onLoad) {
    let hasBuffers = false;
    const processBuffer = (buf, buffer) => {
      GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {
        gltfRuntime.loadedBufferCount++;
        if (bufferView) {
          if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {
            Tools.Error("Buffer named " + buf + " is length " + bufferView.byteLength + ". Expected: " + buffer.byteLength);
          }
          gltfRuntime.loadedBufferViews[buf] = bufferView;
        }
        if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
          onLoad();
        }
      }, () => {
        Tools.Error("Error when loading buffer named " + buf + " located at " + buffer.uri);
      });
    };
    for (const buf in gltfRuntime.buffers) {
      hasBuffers = true;
      const buffer = gltfRuntime.buffers[buf];
      if (buffer) {
        processBuffer.bind(this, buf, buffer)();
      } else {
        Tools.Error("No buffer named: " + buf);
      }
    }
    if (!hasBuffers) {
      onLoad();
    }
  }
  _createNodes(gltfRuntime) {
    let currentScene = gltfRuntime.currentScene;
    if (currentScene) {
      for (let i = 0; i < currentScene.nodes.length; i++) {
        TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    } else {
      for (const thing in gltfRuntime.scenes) {
        currentScene = gltfRuntime.scenes[thing];
        for (let i = 0; i < currentScene.nodes.length; i++) {
          TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
        }
      }
    }
  }
};
GLTFLoader2.Extensions = {};
var GLTFLoaderExtension = class _GLTFLoaderExtension {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  /**
   * Defines an override for loading the runtime
   * Return true to stop further extensions from loading the runtime
   * @param scene
   * @param data
   * @param rootUrl
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading the runtime
   */
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an onverride for creating gltf runtime
   * Return true to stop further extensions from creating the runtime
   * @param gltfRuntime
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from creating the runtime
   */
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for loading buffers
   * Return true to stop further extensions from loading this buffer
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @param onProgress
   * @returns true to stop further extensions from loading this buffer
   */
  // eslint-disable-next-line no-restricted-syntax
  // eslint-disable-next-line no-restricted-syntax
  loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    return false;
  }
  /**
   * Defines an override for loading texture buffers
   * Return true to stop further extensions from loading this texture data
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this texture data
   */
  // eslint-disable-next-line no-restricted-syntax
  loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for creating textures
   * Return true to stop further extensions from loading this texture
   * @param gltfRuntime
   * @param id
   * @param buffer
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this texture
   */
  // eslint-disable-next-line no-restricted-syntax
  createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for loading shader strings
   * Return true to stop further extensions from loading this shader data
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this shader data
   */
  // eslint-disable-next-line no-restricted-syntax
  loadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for loading materials
   * Return true to stop further extensions from loading this material
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this material
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  // ---------
  // Utilities
  // ---------
  // eslint-disable-next-line no-restricted-syntax
  static LoadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
    }, () => {
      setTimeout(() => {
        if (!onSuccess) {
          return;
        }
        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
    }, () => {
      setTimeout(() => {
        onSuccess();
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    }, () => {
      GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadTextureAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {
      if (buffer) {
        _GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
      }
    }, onError);
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static _LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static _CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);
    });
  }
  static _ApplyExtensions(func, defaultFunc) {
    for (const extensionName in GLTFLoader2.Extensions) {
      const loaderExtension = GLTFLoader2.Extensions[extensionName];
      if (func(loaderExtension)) {
        return;
      }
    }
    defaultFunc();
  }
};
GLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader2();

// node_modules/@babylonjs/loaders/glTF/1.0/glTFBinaryExtension.js
var BinaryExtensionBufferName = "binary_glTF";
var GLTFBinaryExtension = class extends GLTFLoaderExtension {
  constructor() {
    super("KHR_binary_glTF");
  }
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeAsync(scene, data, rootUrl, onSuccess) {
    const extensionsUsed = data.json.extensionsUsed;
    if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
      return false;
    }
    this._bin = data.bin;
    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
    return true;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadBufferAsync(gltfRuntime, id, onSuccess, onError) {
    if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
      return false;
    }
    if (id !== BinaryExtensionBufferName) {
      return false;
    }
    this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));
    return true;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadTextureBufferAsync(gltfRuntime, id, onSuccess) {
    const texture = gltfRuntime.textures[id];
    const source = gltfRuntime.images[texture.source];
    if (!source.extensions || !(this.name in source.extensions)) {
      return false;
    }
    const sourceExt = source.extensions[this.name];
    const bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
    const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    onSuccess(buffer);
    return true;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadShaderStringAsync(gltfRuntime, id, onSuccess) {
    const shader = gltfRuntime.shaders[id];
    if (!shader.extensions || !(this.name in shader.extensions)) {
      return false;
    }
    const binaryExtensionShader = shader.extensions[this.name];
    const bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
    const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    setTimeout(() => {
      const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);
      onSuccess(shaderString);
    });
    return true;
  }
};
GLTFLoader2.RegisterExtension(new GLTFBinaryExtension());

// node_modules/@babylonjs/loaders/glTF/1.0/glTFMaterialsCommonExtension.js
var GLTFMaterialsCommonExtension = class extends GLTFLoaderExtension {
  constructor() {
    super("KHR_materials_common");
  }
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeExtensionsAsync(gltfRuntime) {
    if (!gltfRuntime.extensions) {
      return false;
    }
    const extension = gltfRuntime.extensions[this.name];
    if (!extension) {
      return false;
    }
    const lights = extension.lights;
    if (lights) {
      for (const thing in lights) {
        const light = lights[thing];
        switch (light.type) {
          case "ambient": {
            const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);
            const ambient = light.ambient;
            if (ambient) {
              ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);
            }
            break;
          }
          case "point": {
            const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);
            const point = light.point;
            if (point) {
              pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);
            }
            break;
          }
          case "directional": {
            const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);
            const directional = light.directional;
            if (directional) {
              dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);
            }
            break;
          }
          case "spot": {
            const spot = light.spot;
            if (spot) {
              const spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0, gltfRuntime.scene);
              spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);
            }
            break;
          }
          default:
            Tools.Warn('GLTF Material Common extension: light type "' + light.type + " not supported");
            break;
        }
      }
    }
    return false;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    const material = gltfRuntime.materials[id];
    if (!material || !material.extensions) {
      return false;
    }
    const extension = material.extensions[this.name];
    if (!extension) {
      return false;
    }
    const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);
    standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (extension.technique === "CONSTANT") {
      standardMaterial.disableLighting = true;
    }
    standardMaterial.backFaceCulling = extension.doubleSided === void 0 ? false : !extension.doubleSided;
    standardMaterial.alpha = extension.values.transparency === void 0 ? 1 : extension.values.transparency;
    standardMaterial.specularPower = extension.values.shininess === void 0 ? 0 : extension.values.shininess;
    if (typeof extension.values.ambient === "string") {
      this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
    } else {
      standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);
    }
    if (typeof extension.values.diffuse === "string") {
      this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
    } else {
      standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
    }
    if (typeof extension.values.emission === "string") {
      this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
    } else {
      standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);
    }
    if (typeof extension.values.specular === "string") {
      this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
    } else {
      standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);
    }
    return true;
  }
  _loadTexture(gltfRuntime, id, material, propertyPath, onError) {
    GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => material[propertyPath] = texture);
    }, onError);
  }
};
GLTFLoader2.RegisterExtension(new GLTFMaterialsCommonExtension());

// node_modules/@babylonjs/loaders/glTF/2.0/index.js
var __exports2 = {};
__export(__exports2, {
  AddObjectAccessorToKey: () => AddObjectAccessorToKey,
  AnimationPropertyInfo: () => AnimationPropertyInfo,
  ArrayItem: () => ArrayItem,
  EXT_lights_ies: () => EXT_lights_ies,
  EXT_lights_image_based: () => EXT_lights_image_based,
  EXT_materials_diffuse_roughness: () => EXT_materials_diffuse_roughness,
  EXT_mesh_gpu_instancing: () => EXT_mesh_gpu_instancing,
  EXT_meshopt_compression: () => EXT_meshopt_compression,
  EXT_texture_avif: () => EXT_texture_avif,
  EXT_texture_webp: () => EXT_texture_webp,
  ExtrasAsMetadata: () => ExtrasAsMetadata,
  FlowGraphGLTFDataProvider: () => FlowGraphGLTFDataProvider,
  GLTFFileLoader: () => GLTFFileLoader,
  GLTFLoader: () => GLTFLoader,
  GetMappingForKey: () => GetMappingForKey,
  GetPathToObjectConverter: () => GetPathToObjectConverter,
  InteractivityGraphToFlowGraphParser: () => InteractivityGraphToFlowGraphParser,
  KHR_animation_pointer: () => KHR_animation_pointer,
  KHR_draco_mesh_compression: () => KHR_draco_mesh_compression,
  KHR_interactivity: () => KHR_interactivity,
  KHR_lights: () => KHR_lights,
  KHR_materials_anisotropy: () => KHR_materials_anisotropy,
  KHR_materials_clearcoat: () => KHR_materials_clearcoat,
  KHR_materials_diffuse_transmission: () => KHR_materials_diffuse_transmission,
  KHR_materials_dispersion: () => KHR_materials_dispersion,
  KHR_materials_emissive_strength: () => KHR_materials_emissive_strength,
  KHR_materials_ior: () => KHR_materials_ior,
  KHR_materials_iridescence: () => KHR_materials_iridescence,
  KHR_materials_pbrSpecularGlossiness: () => KHR_materials_pbrSpecularGlossiness,
  KHR_materials_sheen: () => KHR_materials_sheen,
  KHR_materials_specular: () => KHR_materials_specular,
  KHR_materials_transmission: () => KHR_materials_transmission,
  KHR_materials_unlit: () => KHR_materials_unlit,
  KHR_materials_variants: () => KHR_materials_variants,
  KHR_materials_volume: () => KHR_materials_volume,
  KHR_mesh_quantization: () => KHR_mesh_quantization,
  KHR_node_hoverability: () => KHR_node_hoverability,
  KHR_node_selectability: () => KHR_node_selectability,
  KHR_node_visibility: () => KHR_node_visibility,
  KHR_texture_basisu: () => KHR_texture_basisu,
  KHR_texture_transform: () => KHR_texture_transform,
  KHR_xmp_json_ld: () => KHR_xmp_json_ld,
  LoadBoundingInfoFromPositionAccessor: () => LoadBoundingInfoFromPositionAccessor,
  MSFT_audio_emitter: () => MSFT_audio_emitter,
  MSFT_lod: () => MSFT_lod,
  MSFT_minecraftMesh: () => MSFT_minecraftMesh,
  MSFT_sRGBFactors: () => MSFT_sRGBFactors,
  SetInterpolationForKey: () => SetInterpolationForKey,
  TransformNodeAnimationPropertyInfo: () => TransformNodeAnimationPropertyInfo,
  WeightAnimationPropertyInfo: () => WeightAnimationPropertyInfo,
  _AddInteractivityObjectModel: () => _AddInteractivityObjectModel,
  addNewInteractivityFlowGraphMapping: () => addNewInteractivityFlowGraphMapping,
  getAllSupportedNativeNodeTypes: () => getAllSupportedNativeNodeTypes,
  getMappingForDeclaration: () => getMappingForDeclaration,
  getMappingForFullOperationName: () => getMappingForFullOperationName,
  getQuaternion: () => getQuaternion,
  getVector3: () => getVector3,
  getWeights: () => getWeights,
  gltfTypeToBabylonType: () => gltfTypeToBabylonType,
  registerGLTFExtension: () => registerGLTFExtension,
  registeredGLTFExtensions: () => registeredGLTFExtensions,
  unregisterGLTFExtension: () => unregisterGLTFExtension
});

export {
  __exports,
  __exports2
};
//# sourceMappingURL=chunk-ACNMZV3Y.js.map
