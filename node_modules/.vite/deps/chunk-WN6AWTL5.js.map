{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts"],
  "sourcesContent": ["import type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Sound } from \"core/Audio/sound\";\r\nimport { WeightedSound } from \"core/Audio/weightedsound\";\r\n\r\nimport type { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IMSFTAudioEmitter_Clip, IMSFTAudioEmitter_Emitter, IMSFTAudioEmitter_EmittersReference, IMSFTAudioEmitter_AnimationEvent } from \"babylonjs-gltf2interface\";\r\nimport { IMSFTAudioEmitter_AnimationEventAction } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nimport \"core/Audio/audioSceneComponent\";\r\n\r\nconst NAME = \"MSFT_audio_emitter\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_audio_emitter extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_audio_emitter\"]: {};\r\n    }\r\n}\r\n\r\ninterface ILoaderClip extends IMSFTAudioEmitter_Clip, IArrayItem {\r\n    _objectURL?: Promise<string>;\r\n}\r\n\r\ninterface ILoaderEmitter extends IMSFTAudioEmitter_Emitter, IArrayItem {\r\n    _babylonData?: {\r\n        sound?: WeightedSound;\r\n        loaded: Promise<void>;\r\n    };\r\n    _babylonSounds: Sound[];\r\n}\r\n\r\ninterface IMSFTAudioEmitter {\r\n    clips: ILoaderClip[];\r\n    emitters: ILoaderEmitter[];\r\n}\r\n\r\ninterface ILoaderAnimationEvent extends IMSFTAudioEmitter_AnimationEvent, IArrayItem {}\r\n\r\ninterface ILoaderAnimationEvents {\r\n    events: ILoaderAnimationEvent[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _clips: Array<ILoaderClip>;\r\n    private _emitters: Array<ILoaderEmitter>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        (this._clips as any) = null;\r\n        (this._emitters as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\r\n\r\n            this._clips = extension.clips;\r\n            this._emitters = extension.emitters;\r\n\r\n            ArrayItem.Assign(this._clips);\r\n            ArrayItem.Assign(this._emitters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference>(context, scene, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            for (const emitterIndex of extension.emitters) {\r\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                if (\r\n                    emitter.refDistance != undefined ||\r\n                    emitter.maxDistance != undefined ||\r\n                    emitter.rolloffFactor != undefined ||\r\n                    emitter.distanceModel != undefined ||\r\n                    emitter.innerAngle != undefined ||\r\n                    emitter.outerAngle != undefined\r\n                ) {\r\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\r\n                }\r\n\r\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\r\n            }\r\n\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            const babylonMesh = await this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\r\n                for (const emitterIndex of extension.emitters) {\r\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                    promises.push(\r\n                        // eslint-disable-next-line github/no-then\r\n                        this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\r\n                            for (const sound of emitter._babylonSounds) {\r\n                                sound.attachToMesh(babylonMesh);\r\n                                if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\r\n                                    sound.setLocalDirectionToMesh(Vector3.Forward());\r\n                                    sound.setDirectionalCone(\r\n                                        2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\r\n                                        2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\r\n                                        0\r\n                                    );\r\n                                }\r\n                            }\r\n                        })\r\n                    );\r\n                }\r\n\r\n                assign(babylonMesh);\r\n            });\r\n            await Promise.all(promises);\r\n            return babylonMesh;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, async (extensionContext, extension) => {\r\n            const babylonAnimationGroup = await this._loader.loadAnimationAsync(context, animation);\r\n            const promises = new Array<Promise<any>>();\r\n            ArrayItem.Assign(extension.events);\r\n            for (const event of extension.events) {\r\n                promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\r\n            }\r\n            await Promise.all(promises);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\r\n        if (clip._objectURL) {\r\n            return clip._objectURL;\r\n        }\r\n\r\n        let promise: Promise<ArrayBufferView>;\r\n        if (clip.uri) {\r\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\r\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        clip._objectURL = promise.then((data) => {\r\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\r\n        });\r\n\r\n        return clip._objectURL;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\r\n        emitter._babylonSounds = emitter._babylonSounds || [];\r\n        if (!emitter._babylonData) {\r\n            const clipPromises = new Array<Promise<any>>();\r\n            const name = emitter.name || `emitter${emitter.index}`;\r\n            const options = {\r\n                loop: false,\r\n                autoplay: false,\r\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\r\n            };\r\n\r\n            for (let i = 0; i < emitter.clips.length; i++) {\r\n                const clipContext = `/extensions/${this.name}/clips`;\r\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\r\n                clipPromises.push(\r\n                    // eslint-disable-next-line github/no-then\r\n                    this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\r\n                        const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\r\n                        sound.refDistance = emitter.refDistance || 1;\r\n                        sound.maxDistance = emitter.maxDistance || 256;\r\n                        sound.rolloffFactor = emitter.rolloffFactor || 1;\r\n                        sound.distanceModel = emitter.distanceModel || \"exponential\";\r\n                    })\r\n                );\r\n            }\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            const promise = Promise.all(clipPromises).then(() => {\r\n                const weights = emitter.clips.map((clip) => {\r\n                    return clip.weight || 1;\r\n                });\r\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\r\n                if (emitter.innerAngle) {\r\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\r\n                }\r\n                if (emitter.outerAngle) {\r\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\r\n                }\r\n                if (emitter.volume) {\r\n                    weightedSound.volume = emitter.volume;\r\n                }\r\n                emitter._babylonData!.sound = weightedSound;\r\n            });\r\n\r\n            emitter._babylonData = {\r\n                loaded: promise,\r\n            };\r\n        }\r\n\r\n        return emitter._babylonData.loaded;\r\n    }\r\n\r\n    private _getEventAction(\r\n        context: string,\r\n        sound: WeightedSound,\r\n        action: IMSFTAudioEmitter_AnimationEventAction,\r\n        time: number,\r\n        startOffset?: number\r\n    ): (currentFrame: number) => void {\r\n        switch (action) {\r\n            case IMSFTAudioEmitter_AnimationEventAction.play: {\r\n                return (currentFrame: number) => {\r\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\r\n                    sound.play(frameOffset);\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.stop: {\r\n                return () => {\r\n                    sound.stop();\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.pause: {\r\n                return () => {\r\n                    sound.pause();\r\n                };\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Unsupported action ${action}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadAnimationEventAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        event: ILoaderAnimationEvent,\r\n        babylonAnimationGroup: AnimationGroup\r\n    ): Promise<void> {\r\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\r\n            return Promise.resolve();\r\n        }\r\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\r\n        const emitterIndex = event.emitter;\r\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\r\n        // eslint-disable-next-line github/no-then\r\n        return this._loadEmitterAsync(context, emitter).then(() => {\r\n            const sound = emitter._babylonData!.sound;\r\n            if (sound) {\r\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\r\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\r\n                // Make sure all started audio stops when this animation is terminated.\r\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\r\n                    sound.stop();\r\n                });\r\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\r\n                    sound.pause();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_audio_emitter(loader));\r\n"],
  "mappings": "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",
  "names": ["babylonMesh"]
}
