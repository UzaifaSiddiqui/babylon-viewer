{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts"],
  "sourcesContent": ["import type { IKHRInteractivity_Graph, IKHRInteractivity_Node, IKHRInteractivity_OutputSocketReference, IKHRInteractivity_Variable } from \"babylonjs-gltf2interface\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport type { IGLTFToFlowGraphMapping } from \"./declarationMapper\";\nimport { getMappingForDeclaration, getMappingForFullOperationName } from \"./declarationMapper\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphConnection, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport { RandomGUID } from \"core/Misc/guid\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { FlowGraphConnectionType } from \"core/FlowGraph/flowGraphConnection\";\nimport { FlowGraphTypes } from \"core/FlowGraph/flowGraphRichTypes\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface InteractivityEvent {\n    eventId: string;\n    eventData?: {\n        eventData: boolean;\n        id: string;\n        type: string;\n        value?: any;\n    }[];\n}\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const gltfTypeToBabylonType: {\n    [key: string]: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" };\n} = {\n    float: { length: 1, flowGraphType: FlowGraphTypes.Number, elementType: \"number\" },\n    bool: { length: 1, flowGraphType: FlowGraphTypes.Boolean, elementType: \"boolean\" },\n    float2: { length: 2, flowGraphType: FlowGraphTypes.Vector2, elementType: \"number\" },\n    float3: { length: 3, flowGraphType: FlowGraphTypes.Vector3, elementType: \"number\" },\n    float4: { length: 4, flowGraphType: FlowGraphTypes.Vector4, elementType: \"number\" },\n    float4x4: { length: 16, flowGraphType: FlowGraphTypes.Matrix, elementType: \"number\" },\n    float2x2: { length: 4, flowGraphType: FlowGraphTypes.Matrix2D, elementType: \"number\" },\n    float3x3: { length: 9, flowGraphType: FlowGraphTypes.Matrix3D, elementType: \"number\" },\n    int: { length: 1, flowGraphType: FlowGraphTypes.Integer, elementType: \"number\" },\n};\n\nexport class InteractivityGraphToFlowGraphParser {\n    /**\n     * Note - the graph should be rejected if the same type is defined twice.\n     * We currently don't validate that.\n     */\n    private _types: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" }[] = [];\n    private _mappings: { flowGraphMapping: IGLTFToFlowGraphMapping; fullOperationName: string }[] = [];\n    private _staticVariables: { type: FlowGraphTypes; value: any[] }[] = [];\n    private _events: InteractivityEvent[] = [];\n    private _internalEventsCounter: number = 0;\n    private _nodes: { blocks: ISerializedFlowGraphBlock[]; fullOperationName: string }[] = [];\n\n    constructor(\n        private _interactivityGraph: IKHRInteractivity_Graph,\n        private _gltf: IGLTF,\n        public _animationTargetFps: number = 60\n    ) {\n        // start with types\n        this._parseTypes();\n        // continue with declarations\n        this._parseDeclarations();\n        this._parseVariables();\n        this._parseEvents();\n        this._parseNodes();\n    }\n\n    public get arrays() {\n        return {\n            types: this._types,\n            mappings: this._mappings,\n            staticVariables: this._staticVariables,\n            events: this._events,\n            nodes: this._nodes,\n        };\n    }\n\n    private _parseTypes() {\n        if (!this._interactivityGraph.types) {\n            return;\n        }\n        for (const type of this._interactivityGraph.types) {\n            this._types.push(gltfTypeToBabylonType[type.signature]);\n        }\n    }\n\n    private _parseDeclarations() {\n        if (!this._interactivityGraph.declarations) {\n            return;\n        }\n        for (const declaration of this._interactivityGraph.declarations) {\n            // make sure we have the mapping for this operation\n            const mapping = getMappingForDeclaration(declaration);\n            // mapping is defined, because we generate an empty mapping if it's not found\n            if (!mapping) {\n                Logger.Error([\"No mapping found for declaration\", declaration]);\n                throw new Error(\"Error parsing declarations\");\n            }\n            this._mappings.push({\n                flowGraphMapping: mapping,\n                fullOperationName: declaration.extension ? declaration.op + \":\" + declaration.extension : declaration.op,\n            });\n        }\n    }\n\n    private _parseVariables() {\n        if (!this._interactivityGraph.variables) {\n            return;\n        }\n        for (const variable of this._interactivityGraph.variables) {\n            const parsed = this._parseVariable(variable);\n            // set the default values here\n            this._staticVariables.push(parsed);\n        }\n    }\n\n    private _parseVariable(variable: IKHRInteractivity_Variable, dataTransform?: (value: any, parser: InteractivityGraphToFlowGraphParser) => any) {\n        const type = this._types[variable.type];\n        if (!type) {\n            Logger.Error([\"No type found for variable\", variable]);\n            throw new Error(\"Error parsing variables\");\n        }\n        if (variable.value) {\n            if (variable.value.length !== type.length) {\n                Logger.Error([\"Invalid value length for variable\", variable, type]);\n                throw new Error(\"Error parsing variables\");\n            }\n        }\n        const value = variable.value || [];\n        if (!value.length) {\n            switch (type.flowGraphType) {\n                case FlowGraphTypes.Boolean:\n                    value.push(false);\n                    break;\n                case FlowGraphTypes.Integer:\n                    value.push(0);\n                    break;\n                case FlowGraphTypes.Number:\n                    value.push(NaN);\n                    break;\n                case FlowGraphTypes.Vector2:\n                    value.push(NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector3:\n                    value.push(NaN, NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector4:\n                case FlowGraphTypes.Matrix2D:\n                case FlowGraphTypes.Quaternion:\n                    value.fill(NaN, 0, 4);\n                    break;\n                case FlowGraphTypes.Matrix:\n                    value.fill(NaN, 0, 16);\n                    break;\n                case FlowGraphTypes.Matrix3D:\n                    value.fill(NaN, 0, 9);\n                    break;\n                default:\n                    break;\n            }\n        }\n        // in case of NaN, Infinity, we need to parse the string to the object itself\n        if (type.elementType === \"number\" && typeof value[0] === \"string\") {\n            value[0] = parseFloat(value[0]);\n        }\n        return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };\n    }\n\n    private _parseEvents() {\n        if (!this._interactivityGraph.events) {\n            return;\n        }\n        for (const event of this._interactivityGraph.events) {\n            const converted: InteractivityEvent = {\n                eventId: event.id || \"internalEvent_\" + this._internalEventsCounter++,\n            };\n            if (event.values) {\n                converted.eventData = Object.keys(event.values).map((key) => {\n                    const eventValue = event.values?.[key];\n                    if (!eventValue) {\n                        Logger.Error([\"No value found for event key\", key]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const type = this._types[eventValue.type];\n                    if (!type) {\n                        Logger.Error([\"No type found for event value\", eventValue]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const value = typeof eventValue.value !== \"undefined\" ? this._parseVariable(eventValue) : undefined;\n                    return {\n                        id: key,\n                        type: type.flowGraphType,\n                        eventData: true,\n                        value,\n                    };\n                });\n            }\n            this._events.push(converted);\n        }\n    }\n\n    private _parseNodes() {\n        if (!this._interactivityGraph.nodes) {\n            return;\n        }\n        for (const node of this._interactivityGraph.nodes) {\n            // some validation\n            if (typeof node.declaration !== \"number\") {\n                Logger.Error([\"No declaration found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            const mapping = this._mappings[node.declaration];\n            if (!mapping) {\n                Logger.Error([\"No mapping found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            if (mapping.flowGraphMapping.validation) {\n                const validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);\n                if (!validationResult.valid) {\n                    throw new Error(`Error validating interactivity node ${this._interactivityGraph.declarations?.[node.declaration].op} - ${validationResult.error}`);\n                }\n            }\n            const blocks: ISerializedFlowGraphBlock[] = [];\n            // create block(s) for this node using the mapping\n            for (const blockType of mapping.flowGraphMapping.blocks) {\n                const block = this._getEmptyBlock(blockType, mapping.fullOperationName);\n                this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);\n                blocks.push(block);\n            }\n            this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });\n        }\n    }\n\n    private _getEmptyBlock(className: string, type: string): ISerializedFlowGraphBlock {\n        const uniqueId = RandomGUID();\n        const dataInputs: ISerializedFlowGraphConnection[] = [];\n        const dataOutputs: ISerializedFlowGraphConnection[] = [];\n        const signalInputs: ISerializedFlowGraphConnection[] = [];\n        const signalOutputs: ISerializedFlowGraphConnection[] = [];\n        const config: IFlowGraphBlockConfiguration = {};\n        const metadata = {};\n        return {\n            uniqueId,\n            className,\n            dataInputs,\n            dataOutputs,\n            signalInputs,\n            signalOutputs,\n            config,\n            type,\n            metadata,\n        };\n    }\n\n    private _parseNodeConfiguration(node: IKHRInteractivity_Node, block: ISerializedFlowGraphBlock, nodeMapping: IGLTFToFlowGraphMapping, blockType: FlowGraphBlockNames | string) {\n        const configuration = block.config;\n        if (node.configuration) {\n            const keys = Object.keys(node.configuration);\n            for (const key of keys) {\n                const value = node.configuration?.[key];\n                // value is always an array, never a number or string\n                if (!value) {\n                    Logger.Error([\"No value found for node configuration\", key]);\n                    throw new Error(\"Error parsing node configuration\");\n                }\n                const configMapping = nodeMapping.configuration?.[key];\n                const belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;\n                if (belongsToBlock) {\n                    // get the right name for the configuration key\n                    const configKey = configMapping?.name || key;\n                    if ((!value || typeof value.value === \"undefined\") && typeof configMapping?.defaultValue !== \"undefined\") {\n                        configuration[configKey] = {\n                            value: configMapping.defaultValue,\n                        };\n                    } else if (value.value.length >= 0) {\n                        // supporting int[] and int/boolean/string\n                        configuration[configKey] = {\n                            value: value.value.length === 1 ? value.value[0] : value.value,\n                        };\n                    } else {\n                        Logger.Warn([\"Invalid value for node configuration\", value]);\n                    }\n                    // make sure we transform the data if needed\n                    if (configMapping && configMapping.dataTransformer) {\n                        configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];\n                    }\n                }\n            }\n        }\n    }\n\n    private _parseNodeConnections(context: ISerializedFlowGraphContext) {\n        for (let i = 0; i < this._nodes.length; i++) {\n            // get the corresponding gltf node\n            const gltfNode = this._interactivityGraph.nodes?.[i];\n            if (!gltfNode) {\n                // should never happen but let's still check\n                Logger.Error([\"No node found for interactivity node\", this._nodes[i]]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowGraphBlocks = this._nodes[i];\n            const outputMapper = this._mappings[gltfNode.declaration];\n            // validate\n            if (!outputMapper) {\n                Logger.Error([\"No mapping found for node\", gltfNode]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowsFromGLTF = gltfNode.flows || {};\n            const flowsKeys = Object.keys(flowsFromGLTF).sort(); // sorting as some operations require sorted keys\n            // connect the flows\n            for (const flowKey of flowsKeys) {\n                const flow = flowsFromGLTF[flowKey];\n                const flowMapping = outputMapper.flowGraphMapping.outputs?.flows?.[flowKey];\n                const socketOutName = flowMapping?.name || flowKey;\n                // create a serialized socket\n                const socketOut = this._createNewSocketConnection(socketOutName, true);\n                const block = (flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.signalOutputs.push(socketOut);\n                // get the input node of this block\n                const inputNodeId = flow.node;\n                const nodeIn = this._nodes[inputNodeId];\n                if (!nodeIn) {\n                    Logger.Error([\"No node found for input node id\", inputNodeId]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                // get the mapper for the input node - in case it mapped to multiple blocks\n                const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);\n                if (!inputMapper) {\n                    Logger.Error([\"No mapping found for input node\", nodeIn]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                let flowInMapping = inputMapper.inputs?.flows?.[flow.socket || \"in\"];\n                let arrayMapping = false;\n                if (!flowInMapping) {\n                    for (const key in inputMapper.inputs?.flows) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            flowInMapping = inputMapper.inputs?.flows?.[key];\n                        }\n                    }\n                }\n                const nodeInSocketName = flowInMapping ? (arrayMapping ? flowInMapping.name.replace(\"$1\", flow.socket || \"\") : flowInMapping.name) : flow.socket || \"in\";\n                const inputBlock = (flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock)) || nodeIn.blocks[0];\n                // in all of the flow graph input connections, find the one with the same name as the socket\n                let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);\n                // if the socket doesn't exist, create the input socket for the connection\n                if (!socketIn) {\n                    socketIn = this._createNewSocketConnection(nodeInSocketName);\n                    inputBlock.signalInputs.push(socketIn);\n                }\n                // connect the sockets\n                socketIn.connectedPointIds.push(socketOut.uniqueId);\n                socketOut.connectedPointIds.push(socketIn.uniqueId);\n            }\n            // connect the values\n            const valuesFromGLTF = gltfNode.values || {};\n            const valuesKeys = Object.keys(valuesFromGLTF);\n            for (const valueKey of valuesKeys) {\n                const value = valuesFromGLTF[valueKey];\n                let valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[valueKey];\n                let arrayMapping = false;\n                if (!valueMapping) {\n                    for (const key in outputMapper.flowGraphMapping.inputs?.values) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[key];\n                        }\n                    }\n                }\n                const socketInName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", valueKey) : valueMapping.name) : valueKey;\n                // create a serialized socket\n                const socketIn = this._createNewSocketConnection(socketInName);\n                const block = (valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.dataInputs.push(socketIn);\n                if ((value as IKHRInteractivity_Variable).value !== undefined) {\n                    const convertedValue = this._parseVariable(value as IKHRInteractivity_Variable, valueMapping && valueMapping.dataTransformer);\n                    context._connectionValues[socketIn.uniqueId] = convertedValue;\n                } else if (typeof (value as IKHRInteractivity_OutputSocketReference).node !== \"undefined\") {\n                    const nodeOutId = (value as IKHRInteractivity_OutputSocketReference).node;\n                    const nodeOutSocketName = (value as IKHRInteractivity_OutputSocketReference).socket || \"value\";\n                    const nodeOut = this._nodes[nodeOutId];\n                    if (!nodeOut) {\n                        Logger.Error([\"No node found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    const outputMapper = getMappingForFullOperationName(nodeOut.fullOperationName);\n                    if (!outputMapper) {\n                        Logger.Error([\"No mapping found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    let valueMapping = outputMapper.outputs?.values?.[nodeOutSocketName];\n                    let arrayMapping = false;\n                    // check if there is an array mapping defined\n                    if (!valueMapping) {\n                        // search for a value mapping that has an array mapping\n                        for (const key in outputMapper.outputs?.values) {\n                            if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                                arrayMapping = true;\n                                valueMapping = outputMapper.outputs?.values?.[key];\n                            }\n                        }\n                    }\n                    const socketOutName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", nodeOutSocketName) : valueMapping?.name) : nodeOutSocketName;\n                    const outBlock = (valueMapping && valueMapping.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping.toBlock)) || nodeOut.blocks[0];\n                    let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);\n                    // if the socket doesn't exist, create it\n                    if (!socketOut) {\n                        socketOut = this._createNewSocketConnection(socketOutName, true);\n                        outBlock.dataOutputs.push(socketOut);\n                    }\n                    // connect the sockets\n                    socketIn.connectedPointIds.push(socketOut.uniqueId);\n                    socketOut.connectedPointIds.push(socketIn.uniqueId);\n                } else {\n                    Logger.Error([\"Invalid value for value connection\", value]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n            }\n\n            // inter block connections\n            if (outputMapper.flowGraphMapping.interBlockConnectors) {\n                for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {\n                    const input = connector.input;\n                    const output = connector.output;\n                    const isVariable = connector.isVariable;\n                    this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);\n                }\n            }\n\n            if (outputMapper.flowGraphMapping.extraProcessor) {\n                const declaration = this._interactivityGraph.declarations?.[gltfNode.declaration];\n                if (!declaration) {\n                    Logger.Error([\"No declaration found for extra processor\", gltfNode]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(\n                    gltfNode,\n                    declaration,\n                    outputMapper.flowGraphMapping,\n                    this,\n                    flowGraphBlocks.blocks,\n                    context,\n                    this._gltf\n                );\n            }\n        }\n    }\n\n    private _createNewSocketConnection(name: string, isOutput?: boolean): ISerializedFlowGraphConnection {\n        return {\n            uniqueId: RandomGUID(),\n            name,\n            _connectionType: isOutput ? FlowGraphConnectionType.Output : FlowGraphConnectionType.Input,\n            connectedPointIds: [],\n        };\n    }\n\n    private _connectFlowGraphNodes(input: string, output: string, serializedInput: ISerializedFlowGraphBlock, serializedOutput: ISerializedFlowGraphBlock, isVariable?: boolean) {\n        const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;\n        const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;\n        const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);\n        const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);\n        // of not found add it to the array\n        if (!inputArray.find((s) => s.name === input)) {\n            inputArray.push(inputConnection);\n        }\n        if (!outputArray.find((s) => s.name === output)) {\n            outputArray.push(outputConnection);\n        }\n        // connect the sockets\n        inputConnection.connectedPointIds.push(outputConnection.uniqueId);\n        outputConnection.connectedPointIds.push(inputConnection.uniqueId);\n    }\n\n    public getVariableName(index: number) {\n        return \"staticVariable_\" + index;\n    }\n\n    public serializeToFlowGraph(): ISerializedFlowGraph {\n        const context: ISerializedFlowGraphContext = {\n            uniqueId: RandomGUID(),\n            _userVariables: {},\n            _connectionValues: {},\n        };\n        this._parseNodeConnections(context);\n        for (let i = 0; i < this._staticVariables.length; i++) {\n            const variable = this._staticVariables[i];\n            context._userVariables[this.getVariableName(i)] = variable;\n        }\n\n        const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), [] as ISerializedFlowGraphBlock[]);\n\n        return {\n            rightHanded: true,\n            allBlocks,\n            executionContexts: [context],\n        };\n    }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { IKHRInteractivity } from \"babylonjs-gltf2interface\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\nimport { ParseFlowGraphAsync } from \"core/FlowGraph/flowGraphParser\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\r\nimport { AddObjectAccessorToKey, GetPathToObjectConverter } from \"./objectModelMapping\";\r\nimport { InteractivityGraphToFlowGraphParser } from \"./KHR_interactivity/interactivityGraphParser\";\r\nimport { addToBlockFactory } from \"core/FlowGraph/Blocks/flowGraphBlockFactory\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IAnimation } from \"../glTFLoaderInterfaces\";\r\n\r\nconst NAME = \"KHR_interactivity\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_interactivity extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_interactivity\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * Loader extension for KHR_interactivity\r\n */\r\nexport class KHR_interactivity implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _pathConverter?: GLTFPathToObjectConverter<any, any, any>;\r\n\r\n    /**\r\n     * @internal\r\n     * @param _loader\r\n     */\r\n    constructor(private _loader: GLTFLoader) {\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        this._pathConverter = GetPathToObjectConverter(this._loader.gltf);\r\n        // avoid starting animations automatically.\r\n        _loader._skipStartAnimationStep = true;\r\n\r\n        // Update object model with new pointers\r\n\r\n        const scene = _loader.babylonScene;\r\n        if (scene) {\r\n            _AddInteractivityObjectModel(scene);\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._pathConverter;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises\r\n    public async onReady(): Promise<void> {\r\n        if (!this._loader.babylonScene || !this._pathConverter) {\r\n            return;\r\n        }\r\n        const scene = this._loader.babylonScene;\r\n        const interactivityDefinition = this._loader.gltf.extensions?.KHR_interactivity as IKHRInteractivity;\r\n        if (!interactivityDefinition) {\r\n            // This can technically throw, but it's not a critical error\r\n            return;\r\n        }\r\n\r\n        const coordinator = new FlowGraphCoordinator({ scene });\r\n        coordinator.dispatchEventsSynchronously = false; // glTF interactivity dispatches events asynchronously\r\n        const graphs = interactivityDefinition.graphs.map((graph) => {\r\n            const parser = new InteractivityGraphToFlowGraphParser(graph, this._loader.gltf, this._loader.parent.targetFps);\r\n            return parser.serializeToFlowGraph();\r\n        });\r\n        // parse each graph async\r\n        await Promise.all(graphs.map(async (graph) => await ParseFlowGraphAsync(graph, { coordinator, pathConverter: this._pathConverter })));\r\n\r\n        coordinator.start();\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * populates the object model with the interactivity extension\r\n */\r\nexport function _AddInteractivityObjectModel(scene: Scene) {\r\n    // Note - all of those are read-only, as per the specs!\r\n\r\n    // active camera rotation\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/rotation\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Quaternion(NaN, NaN, NaN, NaN);\r\n            }\r\n            const quat = Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();\r\n            if (!scene.useRightHandedSystem) {\r\n                quat.w *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n                quat.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return quat;\r\n        },\r\n        type: \"Quaternion\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n    // activeCamera position\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/position\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Vector3(NaN, NaN, NaN);\r\n            }\r\n            const pos = scene.activeCamera.getWorldMatrix().getTranslation(); // not global position\r\n            if (!scene.useRightHandedSystem) {\r\n                pos.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return pos;\r\n        },\r\n        type: \"Vector3\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n\r\n    // /animations/{} pointers:\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/isPlaying\", {\r\n        get: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup?.isPlaying ?? false;\r\n        },\r\n        type: \"boolean\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/minTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.from ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/maxTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.to ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    // playhead\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/playhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    //virtualPlayhead - TODO, do we support this property in our animations? getCurrentFrame  is the only method we have for this.\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/virtualPlayhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n}\r\n\r\n// Register flow graph blocks. Do it here so they are available when the extension is enabled.\r\naddToBlockFactory(NAME, \"FlowGraphGLTFDataProvider\", async () => {\r\n    return (await import(\"./KHR_interactivity/flowGraphGLTFDataProvider\")).FlowGraphGLTFDataProvider;\r\n});\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_interactivity(loader));\r\n"],
  "mappings": "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",
  "names": ["outputMapper", "valueMapping", "arrayMapping"]
}
