import {
  StandardMaterial
} from "./chunk-FKEVOXJZ.js";
import {
  Texture
} from "./chunk-WI5SXUON.js";
import {
  Color3
} from "./chunk-ZUPBS36P.js";

// node_modules/@babylonjs/loaders/OBJ/mtlFileLoader.js
var MTLFileLoader = class _MTLFileLoader {
  constructor() {
    this.materials = [];
  }
  /**
   * This function will read the mtl file and create each material described inside
   * This function could be improve by adding :
   * -some component missing (Ni, Tf...)
   * -including the specific options available
   *
   * @param scene defines the scene the material will be created in
   * @param data defines the mtl data to parse
   * @param rootUrl defines the rooturl to use in order to load relative dependencies
   * @param assetContainer defines the asset container to store the material in (can be null)
   */
  parseMTL(scene, data, rootUrl, assetContainer) {
    if (data instanceof ArrayBuffer) {
      return;
    }
    const lines = data.split("\n");
    const delimiterPattern = /\s+/;
    let color;
    let material = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      }
      const pos = line.indexOf(" ");
      let key = pos >= 0 ? line.substring(0, pos) : line;
      key = key.toLowerCase();
      const value = pos >= 0 ? line.substring(pos + 1).trim() : "";
      if (key === "newmtl") {
        if (material) {
          this.materials.push(material);
        }
        scene._blockEntityCollection = !!assetContainer;
        material = new StandardMaterial(value, scene);
        material._parentContainer = assetContainer;
        scene._blockEntityCollection = false;
      } else if (key === "kd" && material) {
        color = value.split(delimiterPattern, 3).map(parseFloat);
        material.diffuseColor = Color3.FromArray(color);
      } else if (key === "ka" && material) {
        color = value.split(delimiterPattern, 3).map(parseFloat);
        material.ambientColor = Color3.FromArray(color);
      } else if (key === "ks" && material) {
        color = value.split(delimiterPattern, 3).map(parseFloat);
        material.specularColor = Color3.FromArray(color);
      } else if (key === "ke" && material) {
        color = value.split(delimiterPattern, 3).map(parseFloat);
        material.emissiveColor = Color3.FromArray(color);
      } else if (key === "ns" && material) {
        material.specularPower = parseFloat(value);
      } else if (key === "d" && material) {
        material.alpha = parseFloat(value);
      } else if (key === "map_ka" && material) {
        material.ambientTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "map_kd" && material) {
        material.diffuseTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "map_ks" && material) {
        material.specularTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "map_ns") {
      } else if (key === "map_bump" && material) {
        const values = value.split(delimiterPattern);
        const bumpMultiplierIndex = values.indexOf("-bm");
        let bumpMultiplier = null;
        if (bumpMultiplierIndex >= 0) {
          bumpMultiplier = values[bumpMultiplierIndex + 1];
          values.splice(bumpMultiplierIndex, 2);
        }
        material.bumpTexture = _MTLFileLoader._GetTexture(rootUrl, values.join(" "), scene);
        if (material.bumpTexture && bumpMultiplier !== null) {
          material.bumpTexture.level = parseFloat(bumpMultiplier);
        }
      } else if (key === "map_d" && material) {
        material.opacityTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "illum") {
        if (value === "0") {
        } else if (value === "1") {
        } else if (value === "2") {
        } else if (value === "3") {
        } else if (value === "4") {
        } else if (value === "5") {
        } else if (value === "6") {
        } else if (value === "7") {
        } else if (value === "8") {
        } else if (value === "9") {
        } else if (value === "10") {
        }
      } else {
      }
    }
    if (material) {
      this.materials.push(material);
    }
  }
  /**
   * Gets the texture for the material.
   *
   * If the material is imported from input file,
   * We sanitize the url to ensure it takes the texture from aside the material.
   *
   * @param rootUrl The root url to load from
   * @param value The value stored in the mtl
   * @param scene
   * @returns The Texture
   */
  static _GetTexture(rootUrl, value, scene) {
    if (!value) {
      return null;
    }
    let url = rootUrl;
    if (rootUrl === "file:") {
      let lastDelimiter = value.lastIndexOf("\\");
      if (lastDelimiter === -1) {
        lastDelimiter = value.lastIndexOf("/");
      }
      if (lastDelimiter > -1) {
        url += value.substring(lastDelimiter + 1);
      } else {
        url += value;
      }
    } else {
      url += value;
    }
    return new Texture(url, scene, false, _MTLFileLoader.INVERT_TEXTURE_Y);
  }
};
MTLFileLoader.INVERT_TEXTURE_Y = true;

export {
  MTLFileLoader
};
//# sourceMappingURL=chunk-W6FIJBEV.js.map
