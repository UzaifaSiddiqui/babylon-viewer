import {
  FlowGraphCoordinator
} from "./chunk-3FBTZ75P.js";
import {
  FlowGraphEventBlock
} from "./chunk-HKARB7RB.js";
import {
  FlowGraphExecutionBlock
} from "./chunk-T7DWCINE.js";
import {
  defaultValueParseFunction,
  needsPathConverter
} from "./chunk-KJPKAW6K.js";
import {
  RichType,
  getRichTypeByFlowGraphType
} from "./chunk-EGZAI6OC.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/flowGraphBlockFactory.js
var CustomBlocks = {};
function addToBlockFactory(module, blockName, factory) {
  CustomBlocks[`${module}/${blockName}`] = factory;
}
function blockFactory(blockName) {
  switch (blockName) {
    case "FlowGraphPlayAnimationBlock":
      return async () => (await import("./flowGraphPlayAnimationBlock-Y3XRJPFL.js")).FlowGraphPlayAnimationBlock;
    case "FlowGraphStopAnimationBlock":
      return async () => (await import("./flowGraphStopAnimationBlock-JNDBQ7J3.js")).FlowGraphStopAnimationBlock;
    case "FlowGraphPauseAnimationBlock":
      return async () => (await import("./flowGraphPauseAnimationBlock-BUONTQNE.js")).FlowGraphPauseAnimationBlock;
    case "FlowGraphInterpolationBlock":
      return async () => (await import("./flowGraphInterpolationBlock-EPQZ364G.js")).FlowGraphInterpolationBlock;
    case "FlowGraphSceneReadyEventBlock":
      return async () => (await import("./flowGraphSceneReadyEventBlock-OFJNQPIR.js")).FlowGraphSceneReadyEventBlock;
    case "FlowGraphSceneTickEventBlock":
      return async () => (await import("./flowGraphSceneTickEventBlock-NLHAJBZR.js")).FlowGraphSceneTickEventBlock;
    case "FlowGraphSendCustomEventBlock":
      return async () => (await import("./flowGraphSendCustomEventBlock-XO4GZN4E.js")).FlowGraphSendCustomEventBlock;
    case "FlowGraphReceiveCustomEventBlock":
      return async () => (await import("./flowGraphReceiveCustomEventBlock-32LYWREG.js")).FlowGraphReceiveCustomEventBlock;
    case "FlowGraphMeshPickEventBlock":
      return async () => (await import("./flowGraphMeshPickEventBlock-3CNM7CNX.js")).FlowGraphMeshPickEventBlock;
    case "FlowGraphEBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphEBlock;
    case "FlowGraphPIBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphPiBlock;
    case "FlowGraphInfBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphInfBlock;
    case "FlowGraphNaNBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphNaNBlock;
    case "FlowGraphRandomBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphRandomBlock;
    case "FlowGraphAddBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAddBlock;
    case "FlowGraphSubtractBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphSubtractBlock;
    case "FlowGraphMultiplyBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphMultiplyBlock;
    case "FlowGraphDivideBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphDivideBlock;
    case "FlowGraphAbsBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAbsBlock;
    case "FlowGraphSignBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphSignBlock;
    case "FlowGraphTruncBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphTruncBlock;
    case "FlowGraphFloorBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphFloorBlock;
    case "FlowGraphCeilBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphCeilBlock;
    case "FlowGraphRoundBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphRoundBlock;
    case "FlowGraphFractBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphFractionBlock;
    case "FlowGraphNegationBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphNegationBlock;
    case "FlowGraphModuloBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphModuloBlock;
    case "FlowGraphMinBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphMinBlock;
    case "FlowGraphMaxBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphMaxBlock;
    case "FlowGraphClampBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphClampBlock;
    case "FlowGraphSaturateBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphSaturateBlock;
    case "FlowGraphMathInterpolationBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphMathInterpolationBlock;
    case "FlowGraphEqualityBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphEqualityBlock;
    case "FlowGraphLessThanBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphLessThanBlock;
    case "FlowGraphLessThanOrEqualBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphLessThanOrEqualBlock;
    case "FlowGraphGreaterThanBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphGreaterThanBlock;
    case "FlowGraphGreaterThanOrEqualBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphGreaterThanOrEqualBlock;
    case "FlowGraphIsNaNBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphIsNanBlock;
    case "FlowGraphIsInfBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphIsInfinityBlock;
    case "FlowGraphDegToRadBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphDegToRadBlock;
    case "FlowGraphRadToDegBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphRadToDegBlock;
    case "FlowGraphSinBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphSinBlock;
    case "FlowGraphCosBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphCosBlock;
    case "FlowGraphTanBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphTanBlock;
    case "FlowGraphASinBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAsinBlock;
    case "FlowGraphACosBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAcosBlock;
    case "FlowGraphATanBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAtanBlock;
    case "FlowGraphATan2Block":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAtan2Block;
    case "FlowGraphSinhBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphSinhBlock;
    case "FlowGraphCoshBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphCoshBlock;
    case "FlowGraphTanhBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphTanhBlock;
    case "FlowGraphASinhBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAsinhBlock;
    case "FlowGraphACoshBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAcoshBlock;
    case "FlowGraphATanhBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphAtanhBlock;
    case "FlowGraphExponentialBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphExpBlock;
    case "FlowGraphLogBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphLogBlock;
    case "FlowGraphLog2Block":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphLog2Block;
    case "FlowGraphLog10Block":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphLog10Block;
    case "FlowGraphSquareRootBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphSquareRootBlock;
    case "FlowGraphPowerBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphPowerBlock;
    case "FlowGraphCubeRootBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphCubeRootBlock;
    case "FlowGraphBitwiseAndBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphBitwiseAndBlock;
    case "FlowGraphBitwiseOrBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphBitwiseOrBlock;
    case "FlowGraphBitwiseNotBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphBitwiseNotBlock;
    case "FlowGraphBitwiseXorBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphBitwiseXorBlock;
    case "FlowGraphBitwiseLeftShiftBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphBitwiseLeftShiftBlock;
    case "FlowGraphBitwiseRightShiftBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphBitwiseRightShiftBlock;
    case "FlowGraphLengthBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphLengthBlock;
    case "FlowGraphNormalizeBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphNormalizeBlock;
    case "FlowGraphDotBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphDotBlock;
    case "FlowGraphCrossBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphCrossBlock;
    case "FlowGraphRotate2DBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphRotate2DBlock;
    case "FlowGraphRotate3DBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphRotate3DBlock;
    case "FlowGraphTransposeBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-TCZTT2BH.js")).FlowGraphTransposeBlock;
    case "FlowGraphDeterminantBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-TCZTT2BH.js")).FlowGraphDeterminantBlock;
    case "FlowGraphInvertMatrixBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-TCZTT2BH.js")).FlowGraphInvertMatrixBlock;
    case "FlowGraphMatrixMultiplicationBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-TCZTT2BH.js")).FlowGraphMatrixMultiplicationBlock;
    case "FlowGraphBranchBlock":
      return async () => (await import("./flowGraphBranchBlock-CI37F5M5.js")).FlowGraphBranchBlock;
    case "FlowGraphSetDelayBlock":
      return async () => (await import("./flowGraphSetDelayBlock-VE4WK4O6.js")).FlowGraphSetDelayBlock;
    case "FlowGraphCancelDelayBlock":
      return async () => (await import("./flowGraphCancelDelayBlock-IXMCL5K6.js")).FlowGraphCancelDelayBlock;
    case "FlowGraphCallCounterBlock":
      return async () => (await import("./flowGraphCounterBlock-VKZCDL3I.js")).FlowGraphCallCounterBlock;
    case "FlowGraphDebounceBlock":
      return async () => (await import("./flowGraphDebounceBlock-X6KG7QIX.js")).FlowGraphDebounceBlock;
    case "FlowGraphThrottleBlock":
      return async () => (await import("./flowGraphThrottleBlock-QFUIIMPD.js")).FlowGraphThrottleBlock;
    case "FlowGraphDoNBlock":
      return async () => (await import("./flowGraphDoNBlock-QCWKYWCT.js")).FlowGraphDoNBlock;
    case "FlowGraphFlipFlopBlock":
      return async () => (await import("./flowGraphFlipFlopBlock-JHILIHY4.js")).FlowGraphFlipFlopBlock;
    case "FlowGraphForLoopBlock":
      return async () => (await import("./flowGraphForLoopBlock-N2TK6444.js")).FlowGraphForLoopBlock;
    case "FlowGraphMultiGateBlock":
      return async () => (await import("./flowGraphMultiGateBlock-MGNXH5LL.js")).FlowGraphMultiGateBlock;
    case "FlowGraphSequenceBlock":
      return async () => (await import("./flowGraphSequenceBlock-JXS64XOZ.js")).FlowGraphSequenceBlock;
    case "FlowGraphSwitchBlock":
      return async () => (await import("./flowGraphSwitchBlock-NLLGPAEI.js")).FlowGraphSwitchBlock;
    case "FlowGraphWaitAllBlock":
      return async () => (await import("./flowGraphWaitAllBlock-C4GJCN2F.js")).FlowGraphWaitAllBlock;
    case "FlowGraphWhileLoopBlock":
      return async () => (await import("./flowGraphWhileLoopBlock-UEUJ3FJS.js")).FlowGraphWhileLoopBlock;
    case "FlowGraphConsoleLogBlock":
      return async () => (await import("./flowGraphConsoleLogBlock-TTEQO6LB.js")).FlowGraphConsoleLogBlock;
    case "FlowGraphConditionalBlock":
      return async () => (await import("./flowGraphConditionalDataBlock-FNTCNZLE.js")).FlowGraphConditionalDataBlock;
    case "FlowGraphConstantBlock":
      return async () => (await import("./flowGraphConstantBlock-Z5AILMFK.js")).FlowGraphConstantBlock;
    case "FlowGraphTransformCoordinatesSystemBlock":
      return async () => (await import("./flowGraphTransformCoordinatesSystemBlock-XQE4RKPA.js")).FlowGraphTransformCoordinatesSystemBlock;
    case "FlowGraphGetAssetBlock":
      return async () => (await import("./flowGraphGetAssetBlock-VAAOJT2R.js")).FlowGraphGetAssetBlock;
    case "FlowGraphGetPropertyBlock":
      return async () => (await import("./flowGraphGetPropertyBlock-DJP3A4EZ.js")).FlowGraphGetPropertyBlock;
    case "FlowGraphSetPropertyBlock":
      return async () => (await import("./flowGraphSetPropertyBlock-YYTXCCK4.js")).FlowGraphSetPropertyBlock;
    case "FlowGraphGetVariableBlock":
      return async () => (await import("./flowGraphGetVariableBlock-6IKXMDME.js")).FlowGraphGetVariableBlock;
    case "FlowGraphSetVariableBlock":
      return async () => (await import("./flowGraphSetVariableBlock-T4NNLHPD.js")).FlowGraphSetVariableBlock;
    case "FlowGraphJsonPointerParserBlock":
      return async () => (await import("./flowGraphJsonPointerParserBlock-6JZKVI6D.js")).FlowGraphJsonPointerParserBlock;
    case "FlowGraphLeadingZerosBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphLeadingZerosBlock;
    case "FlowGraphTrailingZerosBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphTrailingZerosBlock;
    case "FlowGraphOneBitsCounterBlock":
      return async () => (await import("./flowGraphMathBlocks-GBJ5I4SK.js")).FlowGraphOneBitsCounterBlock;
    case "FlowGraphCombineVector2Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphCombineVector2Block;
    case "FlowGraphCombineVector3Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphCombineVector3Block;
    case "FlowGraphCombineVector4Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphCombineVector4Block;
    case "FlowGraphCombineMatrixBlock":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphCombineMatrixBlock;
    case "FlowGraphExtractVector2Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphExtractVector2Block;
    case "FlowGraphExtractVector3Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphExtractVector3Block;
    case "FlowGraphExtractVector4Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphExtractVector4Block;
    case "FlowGraphExtractMatrixBlock":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-MYO5VEPD.js")).FlowGraphExtractMatrixBlock;
    case "FlowGraphTransformVectorBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphTransformBlock;
    case "FlowGraphTransformCoordinatesBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphTransformCoordinatesBlock;
    case "FlowGraphConjugateBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphConjugateBlock;
    case "FlowGraphAngleBetweenBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphAngleBetweenBlock;
    case "FlowGraphQuaternionFromAxisAngleBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphQuaternionFromAxisAngleBlock;
    case "FlowGraphAxisAngleFromQuaternionBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphAxisAngleFromQuaternionBlock;
    case "FlowGraphQuaternionFromDirectionsBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-NLSF5CHY.js")).FlowGraphQuaternionFromDirectionsBlock;
    case "FlowGraphMatrixDecompose":
      return async () => (await import("./flowGraphMatrixMathBlocks-TCZTT2BH.js")).FlowGraphMatrixDecomposeBlock;
    case "FlowGraphMatrixCompose":
      return async () => (await import("./flowGraphMatrixMathBlocks-TCZTT2BH.js")).FlowGraphMatrixComposeBlock;
    case "FlowGraphBooleanToFloat":
      return async () => (await import("./flowGraphTypeToTypeBlocks-P6GVZJKF.js")).FlowGraphBooleanToFloat;
    case "FlowGraphBooleanToInt":
      return async () => (await import("./flowGraphTypeToTypeBlocks-P6GVZJKF.js")).FlowGraphBooleanToInt;
    case "FlowGraphFloatToBoolean":
      return async () => (await import("./flowGraphTypeToTypeBlocks-P6GVZJKF.js")).FlowGraphFloatToBoolean;
    case "FlowGraphIntToBoolean":
      return async () => (await import("./flowGraphTypeToTypeBlocks-P6GVZJKF.js")).FlowGraphIntToBoolean;
    case "FlowGraphIntToFloat":
      return async () => (await import("./flowGraphTypeToTypeBlocks-P6GVZJKF.js")).FlowGraphIntToFloat;
    case "FlowGraphFloatToInt":
      return async () => (await import("./flowGraphTypeToTypeBlocks-P6GVZJKF.js")).FlowGraphFloatToInt;
    case "FlowGraphEasingBlock":
      return async () => (await import("./flowGraphEasingBlock-D45XBF25.js")).FlowGraphEasingBlock;
    case "FlowGraphBezierCurveEasing":
      return async () => (await import("./flowGraphBezierCurveEasingBlock-MWJRJ3ER.js")).FlowGraphBezierCurveEasingBlock;
    case "FlowGraphPointerOverEventBlock":
      return async () => (await import("./flowGraphPointerOverEventBlock-ECIOCPX7.js")).FlowGraphPointerOverEventBlock;
    case "FlowGraphPointerOutEventBlock":
      return async () => (await import("./flowGraphPointerOutEventBlock-SW4JREDO.js")).FlowGraphPointerOutEventBlock;
    case "FlowGraphContextBlock":
      return async () => (await import("./flowGraphContextBlock-R2NSDLJT.js")).FlowGraphContextBlock;
    case "FlowGraphArrayIndexBlock":
      return async () => (await import("./flowGraphArrayIndexBlock-GVPZ2ZD7.js")).FlowGraphArrayIndexBlock;
    case "FlowGraphCodeExecutionBlock":
      return async () => (await import("./flowGraphCodeExecutionBlock-RLMZKJOG.js")).FlowGraphCodeExecutionBlock;
    case "FlowGraphIndexOfBlock":
      return async () => (await import("./flowGraphIndexOfBlock-EZKHPVZW.js")).FlowGraphIndexOfBlock;
    case "FlowGraphFunctionReference":
      return async () => (await import("./flowGraphFunctionReferenceBlock-2O4LLQLJ.js")).FlowGraphFunctionReferenceBlock;
    case "FlowGraphDataSwitchBlock":
      return async () => (await import("./flowGraphDataSwitchBlock-Z6R7WK5R.js")).FlowGraphDataSwitchBlock;
    default:
      if (CustomBlocks[blockName]) {
        return CustomBlocks[blockName];
      }
      throw new Error(`Unknown block name ${blockName}`);
  }
}

// node_modules/@babylonjs/core/FlowGraph/flowGraphParser.js
function GetDataOutConnectionByUniqueId(blocks, uniqueId) {
  for (const block of blocks) {
    for (const dataOut of block.dataOutputs) {
      if (dataOut.uniqueId === uniqueId) {
        return dataOut;
      }
    }
  }
  throw new Error("Could not find data out connection with unique id " + uniqueId);
}
function GetSignalInConnectionByUniqueId(blocks, uniqueId) {
  for (const block of blocks) {
    if (block instanceof FlowGraphExecutionBlock) {
      for (const signalIn of block.signalInputs) {
        if (signalIn.uniqueId === uniqueId) {
          return signalIn;
        }
      }
    }
  }
  throw new Error("Could not find signal in connection with unique id " + uniqueId);
}
async function ParseCoordinatorAsync(serializedObject, options) {
  var _a;
  const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
  const coordinator = new FlowGraphCoordinator({ scene: options.scene });
  if (serializedObject.dispatchEventsSynchronously) {
    coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;
  }
  await options.scene.whenReadyAsync();
  if (serializedObject._defaultValues) {
    for (const key in serializedObject._defaultValues) {
      const value = serializedObject._defaultValues[key];
      getRichTypeByFlowGraphType(key).defaultValue = value;
    }
  }
  await Promise.all((_a = serializedObject._flowGraphs) == null ? void 0 : _a.map(async (serializedGraph) => await ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter })));
  return coordinator;
}
async function ParseFlowGraphAsync(serializationObject, options) {
  const resolvedClasses = await Promise.all(serializationObject.allBlocks.map(async (serializedBlock) => {
    const classFactory = blockFactory(serializedBlock.className);
    return await classFactory();
  }));
  return ParseFlowGraph(serializationObject, options, resolvedClasses);
}
function ParseFlowGraph(serializationObject, options, resolvedClasses) {
  const graph = options.coordinator.createGraph();
  const blocks = [];
  const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
  for (let i = 0; i < serializationObject.allBlocks.length; i++) {
    const serializedBlock = serializationObject.allBlocks[i];
    const block = ParseFlowGraphBlockWithClassType(serializedBlock, { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction }, resolvedClasses[i]);
    blocks.push(block);
    if (block instanceof FlowGraphEventBlock) {
      graph.addEventBlock(block);
    }
  }
  for (const block of blocks) {
    for (const dataIn of block.dataInputs) {
      for (const serializedConnection of dataIn.connectedPointIds) {
        const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);
        dataIn.connectTo(connection);
      }
    }
    if (block instanceof FlowGraphExecutionBlock) {
      for (const signalOut of block.signalOutputs) {
        for (const serializedConnection of signalOut.connectedPointIds) {
          const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);
          signalOut.connectTo(connection);
        }
      }
    }
  }
  for (const serializedContext of serializationObject.executionContexts) {
    ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);
  }
  return graph;
}
function ParseFlowGraphContext(serializationObject, options, rightHanded) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const result = options.graph.createContext();
  if (serializationObject.enableLogging) {
    result.enableLogging = true;
  }
  result.treatDataAsRightHanded = rightHanded || false;
  const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
  result.uniqueId = serializationObject.uniqueId;
  const scene = result.getScene();
  if (serializationObject._assetsContext) {
    const ac = serializationObject._assetsContext;
    const assetsContext = {
      meshes: (_a = ac.meshes) == null ? void 0 : _a.map((m) => scene.getMeshById(m)),
      lights: (_b = ac.lights) == null ? void 0 : _b.map((l) => scene.getLightByName(l)),
      cameras: (_c = ac.cameras) == null ? void 0 : _c.map((c) => scene.getCameraByName(c)),
      materials: (_d = ac.materials) == null ? void 0 : _d.map((m) => scene.getMaterialById(m)),
      textures: (_e = ac.textures) == null ? void 0 : _e.map((t) => scene.getTextureByName(t)),
      animations: (_f = ac.animations) == null ? void 0 : _f.map((a) => scene.animations.find((anim) => anim.name === a)),
      skeletons: (_g = ac.skeletons) == null ? void 0 : _g.map((s) => scene.getSkeletonByName(s)),
      particleSystems: (_h = ac.particleSystems) == null ? void 0 : _h.map((ps) => scene.getParticleSystemById(ps)),
      animationGroups: (_i = ac.animationGroups) == null ? void 0 : _i.map((ag) => scene.getAnimationGroupByName(ag)),
      transformNodes: (_j = ac.transformNodes) == null ? void 0 : _j.map((tn) => scene.getTransformNodeById(tn)),
      rootNodes: [],
      multiMaterials: [],
      morphTargetManagers: [],
      geometries: [],
      actionManagers: [],
      environmentTexture: null,
      postProcesses: [],
      sounds: null,
      effectLayers: [],
      layers: [],
      reflectionProbes: [],
      lensFlareSystems: [],
      proceduralTextures: [],
      getNodes: function() {
        throw new Error("Function not implemented.");
      }
    };
    result.assetsContext = assetsContext;
  }
  for (const key in serializationObject._userVariables) {
    const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);
    result.userVariables[key] = value;
  }
  for (const key in serializationObject._connectionValues) {
    const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);
    result._setConnectionValueByKey(key, value);
  }
  return result;
}
async function ParseBlockAsync(serializationObject, parseOptions) {
  const classFactory = blockFactory(serializationObject.className);
  const classType = await classFactory();
  return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);
}
function ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType) {
  const parsedConfig = {};
  const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;
  if (serializationObject.config) {
    for (const key in serializationObject.config) {
      parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);
    }
  }
  if (needsPathConverter(serializationObject.className)) {
    if (!parseOptions.pathConverter) {
      throw new Error("Path converter is required for this block");
    }
    parsedConfig.pathConverter = parseOptions.pathConverter;
  }
  const obj = new classType(parsedConfig);
  obj.uniqueId = serializationObject.uniqueId;
  for (let i = 0; i < serializationObject.dataInputs.length; i++) {
    const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);
    if (dataInput) {
      dataInput.deserialize(serializationObject.dataInputs[i]);
    } else {
      throw new Error("Could not find data input with name " + serializationObject.dataInputs[i].name + " in block " + serializationObject.className);
    }
  }
  for (let i = 0; i < serializationObject.dataOutputs.length; i++) {
    const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);
    if (dataOutput) {
      dataOutput.deserialize(serializationObject.dataOutputs[i]);
    } else {
      throw new Error("Could not find data output with name " + serializationObject.dataOutputs[i].name + " in block " + serializationObject.className);
    }
  }
  obj.metadata = serializationObject.metadata;
  obj.deserialize && obj.deserialize(serializationObject);
  return obj;
}
function ParseGraphConnectionWithClassType(serializationObject = {}, ownerBlock, classType) {
  const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);
  connection.deserialize(serializationObject);
  return connection;
}
function ParseGraphDataConnection(serializationObject, ownerBlock, classType) {
  const richType = ParseRichType(serializationObject.richType);
  const defaultValue = serializationObject.defaultValue;
  const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);
  connection.deserialize(serializationObject);
  return connection;
}
function ParseRichType(serializationObject) {
  return new RichType(serializationObject.typeName, serializationObject.defaultValue);
}

export {
  addToBlockFactory,
  blockFactory,
  GetDataOutConnectionByUniqueId,
  GetSignalInConnectionByUniqueId,
  ParseCoordinatorAsync,
  ParseFlowGraphAsync,
  ParseFlowGraph,
  ParseFlowGraphContext,
  ParseBlockAsync,
  ParseFlowGraphBlockWithClassType,
  ParseGraphConnectionWithClassType,
  ParseGraphDataConnection
};
//# sourceMappingURL=chunk-TQEMBGSN.js.map
