{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"],
  "sourcesContent": ["import { Animation } from \"core/Animations/animation\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { INode } from \"./glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { SetInterpolationForKey } from \"./Extensions/objectModelMapping\";\r\n\r\n/** @internal */\r\nexport type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getVector3(_target: any, source: Float32Array, offset: number, scale: number): Vector3 {\r\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): Quaternion {\r\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number> {\r\n    const value = new Array<number>(target._numMorphTargets!);\r\n    for (let i = 0; i < value.length; i++) {\r\n        value[i] = source[offset++] * scale;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class AnimationPropertyInfo {\r\n    /** @internal */\r\n    public constructor(\r\n        public readonly type: number,\r\n        public readonly name: string,\r\n        public readonly getValue: GetValueFn,\r\n        public readonly getStride: (target: any) => number\r\n    ) {}\r\n\r\n    protected _buildAnimation(name: string, fps: number, keys: any[]): Animation {\r\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\r\n        babylonAnimation.setKeys(keys);\r\n        return babylonAnimation;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract buildAnimations(target: any, name: string, fps: number, keys: any[]): { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[];\r\n}\r\n\r\n/** @internal */\r\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        babylonAnimations.push({ babylonAnimatable: target._babylonTransformNode!, babylonAnimation: this._buildAnimation(name, fps, keys) });\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        if (target._numMorphTargets) {\r\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\r\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\r\n                babylonAnimation.setKeys(\r\n                    keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        interpolation: key.interpolation,\r\n                    }))\r\n                );\r\n\r\n                if (target._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\r\n                        if (babylonMesh.morphTargetManager) {\r\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\r\n                            const babylonAnimationClone = babylonAnimation.clone();\r\n                            morphTarget.animations.push(babylonAnimationClone);\r\n                            babylonAnimations.push({ babylonAnimatable: morphTarget, babylonAnimation: babylonAnimationClone });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\nSetInterpolationForKey(\"/nodes/{}/translation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/rotation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)]);\r\nSetInterpolationForKey(\"/nodes/{}/scale\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/weights\", [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets!)]);\r\n"],
  "mappings": ";;;;;;;;;;;;AAWM,SAAU,WAAW,SAAc,QAAsB,QAAgB,OAAa;AACxF,SAAO,QAAQ,UAAU,QAAQ,MAAM,EAAE,aAAa,KAAK;AAC/D;AAIM,SAAU,cAAc,SAAc,QAAsB,QAAgB,OAAa;AAC3F,SAAO,WAAW,UAAU,QAAQ,MAAM,EAAE,aAAa,KAAK;AAClE;AAIM,SAAU,WAAW,QAAe,QAAsB,QAAgB,OAAa;AACzF,QAAM,QAAQ,IAAI,MAAc,OAAO,gBAAiB;AACxD,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,UAAM,CAAC,IAAI,OAAO,QAAQ,IAAI;EAClC;AAEA,SAAO;AACX;AAGM,IAAgB,wBAAhB,MAAqC;;EAEvC,YACoB,MACA,MACA,UACA,WAAkC;AAHlC,SAAA,OAAA;AACA,SAAA,OAAA;AACA,SAAA,WAAA;AACA,SAAA,YAAA;EACjB;EAEO,gBAAgB,MAAc,KAAa,MAAW;AAC5D,UAAM,mBAAmB,IAAI,UAAU,MAAM,KAAK,MAAM,KAAK,KAAK,IAAI;AACtE,qBAAiB,QAAQ,IAAI;AAC7B,WAAO;EACX;;AAOE,IAAO,qCAAP,cAAkD,sBAAqB;;EAElE,gBAAgB,QAAe,MAAc,KAAa,MAAW;AACxE,UAAM,oBAAuF,CAAA;AAC7F,sBAAkB,KAAK,EAAE,mBAAmB,OAAO,uBAAwB,kBAAkB,KAAK,gBAAgB,MAAM,KAAK,IAAI,EAAC,CAAE;AACpI,WAAO;EACX;;AAIE,IAAO,8BAAP,cAA2C,sBAAqB;EAC3D,gBAAgB,QAAe,MAAc,KAAa,MAAW;AACxE,UAAM,oBAAuF,CAAA;AAC7F,QAAI,OAAO,kBAAkB;AACzB,eAAS,cAAc,GAAG,cAAc,OAAO,kBAAkB,eAAe;AAC5E,cAAM,mBAAmB,IAAI,UAAU,GAAG,IAAI,IAAI,WAAW,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI;AAC1F,yBAAiB,QACb,KAAK,IAAI,CAAC,SAAS;UACf,OAAO,IAAI;UACX,WAAW,IAAI,YAAY,IAAI,UAAU,WAAW,IAAI;UACxD,OAAO,IAAI,MAAM,WAAW;UAC5B,YAAY,IAAI,aAAa,IAAI,WAAW,WAAW,IAAI;UAC3D,eAAe,IAAI;UACrB,CAAC;AAGP,YAAI,OAAO,yBAAyB;AAChC,qBAAW,eAAe,OAAO,yBAAyB;AACtD,gBAAI,YAAY,oBAAoB;AAChC,oBAAM,cAAc,YAAY,mBAAmB,UAAU,WAAW;AACxE,oBAAM,wBAAwB,iBAAiB,MAAK;AACpD,0BAAY,WAAW,KAAK,qBAAqB;AACjD,gCAAkB,KAAK,EAAE,mBAAmB,aAAa,kBAAkB,sBAAqB,CAAE;YACtG;UACJ;QACJ;MACJ;IACJ;AACA,WAAO;EACX;;AAGJ,uBAAuB,yBAAyB,CAAC,IAAI,mCAAmC,UAAU,uBAAuB,YAAY,YAAY,MAAM,CAAC,CAAC,CAAC;AAC1J,uBAAuB,sBAAsB,CAAC,IAAI,mCAAmC,UAAU,0BAA0B,sBAAsB,eAAe,MAAM,CAAC,CAAC,CAAC;AACvK,uBAAuB,mBAAmB,CAAC,IAAI,mCAAmC,UAAU,uBAAuB,WAAW,YAAY,MAAM,CAAC,CAAC,CAAC;AACnJ,uBAAuB,qBAAqB,CAAC,IAAI,4BAA4B,UAAU,qBAAqB,aAAa,YAAY,CAAC,WAAW,OAAO,gBAAiB,CAAC,CAAC;",
  "names": []
}
