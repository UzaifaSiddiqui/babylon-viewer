import {
  SpotLight
} from "./chunk-3FWXDCVB.js";
import {
  Constants
} from "./chunk-BJLSHJRF.js";
import {
  Color4
} from "./chunk-ZUPBS36P.js";
import {
  Matrix,
  Quaternion,
  Vector2
} from "./chunk-5BUGPWC4.js";

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/gltfPathToObjectConverter.js
var OptionalPathExceptionsList = [
  {
    // get the node as object when reading an extension
    regex: new RegExp(`^/nodes/\\d+/extensions/`)
  }
];
var GLTFPathToObjectConverter = class {
  constructor(_gltf, _infoTree) {
    this._gltf = _gltf;
    this._infoTree = _infoTree;
  }
  /**
   * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).
   * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers
   * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>
   * <rootNode> := "nodes" | "materials" | "meshes" | "cameras" | "extensions"
   * <assetIndex> := <digit> | <name>
   * <propertyPath> := <extensionPath> | <standardPath>
   * <extensionPath> := "extensions"/<name>/<standardPath>
   * <standardPath> := <name> | <name>/<standardPath>
   * <name> := W+
   * <digit> := D+
   *
   * Examples:
   *  - "/nodes/0/rotation"
   * - "/nodes.length"
   *  - "/materials/2/emissiveFactor"
   *  - "/materials/2/pbrMetallicRoughness/baseColorFactor"
   *  - "/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength"
   *
   * @param path The path to convert
   * @returns The object and info associated with the path
   */
  convert(path) {
    let objectTree = this._gltf;
    let infoTree = this._infoTree;
    let target = void 0;
    if (!path.startsWith("/")) {
      throw new Error("Path must start with a /");
    }
    const parts = path.split("/");
    parts.shift();
    if (parts[parts.length - 1].includes(".length")) {
      const lastPart = parts[parts.length - 1];
      const split = lastPart.split(".");
      parts.pop();
      parts.push(...split);
    }
    let ignoreObjectTree = false;
    for (const part of parts) {
      const isLength = part === "length";
      if (isLength && !infoTree.__array__) {
        throw new Error(`Path ${path} is invalid`);
      }
      if (infoTree.__ignoreObjectTree__) {
        ignoreObjectTree = true;
      }
      if (infoTree.__array__ && !isLength) {
        infoTree = infoTree.__array__;
      } else {
        infoTree = infoTree[part];
        if (!infoTree) {
          throw new Error(`Path ${path} is invalid`);
        }
      }
      if (!ignoreObjectTree) {
        if (objectTree === void 0) {
          const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));
          if (!exception) {
            throw new Error(`Path ${path} is invalid`);
          }
        } else if (!isLength) {
          objectTree = objectTree == null ? void 0 : objectTree[part];
        }
      }
      if (infoTree.__target__ || isLength) {
        target = objectTree;
      }
    }
    return {
      object: target,
      info: infoTree
    };
  }
};

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/objectModelMapping.js
var nodesTree = {
  length: {
    type: "number",
    get: (nodes) => nodes.length,
    getTarget: (nodes) => nodes.map((node) => node._babylonTransformNode),
    getPropertyName: [() => "length"]
  },
  __array__: {
    __target__: true,
    translation: {
      type: "Vector3",
      get: (node) => {
        var _a;
        return (_a = node._babylonTransformNode) == null ? void 0 : _a.position;
      },
      set: (value, node) => {
        var _a;
        return (_a = node._babylonTransformNode) == null ? void 0 : _a.position.copyFrom(value);
      },
      getTarget: (node) => node._babylonTransformNode,
      getPropertyName: [() => "position"]
    },
    rotation: {
      type: "Quaternion",
      get: (node) => {
        var _a;
        return (_a = node._babylonTransformNode) == null ? void 0 : _a.rotationQuaternion;
      },
      set: (value, node) => {
        var _a, _b;
        return (_b = (_a = node._babylonTransformNode) == null ? void 0 : _a.rotationQuaternion) == null ? void 0 : _b.copyFrom(value);
      },
      getTarget: (node) => node._babylonTransformNode,
      getPropertyName: [() => "rotationQuaternion"]
    },
    scale: {
      type: "Vector3",
      get: (node) => {
        var _a;
        return (_a = node._babylonTransformNode) == null ? void 0 : _a.scaling;
      },
      set: (value, node) => {
        var _a;
        return (_a = node._babylonTransformNode) == null ? void 0 : _a.scaling.copyFrom(value);
      },
      getTarget: (node) => node._babylonTransformNode,
      getPropertyName: [() => "scaling"]
    },
    weights: {
      length: {
        type: "number",
        get: (node) => node._numMorphTargets,
        getTarget: (node) => node._babylonTransformNode,
        getPropertyName: [() => "influence"]
      },
      __array__: {
        __target__: true,
        type: "number",
        get: (node, index) => {
          var _a, _b;
          return index !== void 0 ? (_b = (_a = node._primitiveBabylonMeshes) == null ? void 0 : _a[0].morphTargetManager) == null ? void 0 : _b.getTarget(index).influence : void 0;
        },
        // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),
        getTarget: (node) => node._babylonTransformNode,
        getPropertyName: [() => "influence"]
      },
      type: "number[]",
      get: (node, index) => [0],
      // TODO: get the weights correctly
      // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),
      getTarget: (node) => node._babylonTransformNode,
      getPropertyName: [() => "influence"]
    },
    // readonly!
    matrix: {
      type: "Matrix",
      get: (node) => {
        var _a, _b, _c;
        return Matrix.Compose((_a = node._babylonTransformNode) == null ? void 0 : _a.scaling, (_b = node._babylonTransformNode) == null ? void 0 : _b.rotationQuaternion, (_c = node._babylonTransformNode) == null ? void 0 : _c.position);
      },
      getTarget: (node) => node._babylonTransformNode,
      isReadOnly: true
    },
    globalMatrix: {
      type: "Matrix",
      get: (node) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const matrix = Matrix.Identity();
        let rootNode = node.parent;
        while (rootNode && rootNode.parent) {
          rootNode = rootNode.parent;
        }
        const forceUpdate = ((_a = node._babylonTransformNode) == null ? void 0 : _a.position._isDirty) || ((_c = (_b = node._babylonTransformNode) == null ? void 0 : _b.rotationQuaternion) == null ? void 0 : _c._isDirty) || ((_d = node._babylonTransformNode) == null ? void 0 : _d.scaling._isDirty);
        if (rootNode) {
          const rootMatrix = (_e = rootNode._babylonTransformNode) == null ? void 0 : _e.computeWorldMatrix(true).invert();
          if (rootMatrix) {
            (_g = (_f = node._babylonTransformNode) == null ? void 0 : _f.computeWorldMatrix(forceUpdate)) == null ? void 0 : _g.multiplyToRef(rootMatrix, matrix);
          }
        } else if (node._babylonTransformNode) {
          matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));
        }
        return matrix;
      },
      getTarget: (node) => node._babylonTransformNode,
      isReadOnly: true
    },
    extensions: {
      EXT_lights_ies: {
        multiplier: {
          type: "number",
          get: (node) => {
            var _a, _b;
            return (_b = (_a = node._babylonTransformNode) == null ? void 0 : _a.getChildren((child) => child instanceof SpotLight, true)[0]) == null ? void 0 : _b.intensity;
          },
          getTarget: (node) => {
            var _a;
            return (_a = node._babylonTransformNode) == null ? void 0 : _a.getChildren((child) => child instanceof SpotLight, true)[0];
          },
          set: (value, node) => {
            if (node._babylonTransformNode) {
              const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];
              if (light) {
                light.intensity = value;
              }
            }
          }
        },
        color: {
          type: "Color3",
          get: (node) => {
            var _a, _b;
            return (_b = (_a = node._babylonTransformNode) == null ? void 0 : _a.getChildren((child) => child instanceof SpotLight, true)[0]) == null ? void 0 : _b.diffuse;
          },
          getTarget: (node) => {
            var _a;
            return (_a = node._babylonTransformNode) == null ? void 0 : _a.getChildren((child) => child instanceof SpotLight, true)[0];
          },
          set: (value, node) => {
            if (node._babylonTransformNode) {
              const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];
              if (light) {
                light.diffuse = value;
              }
            }
          }
        }
      }
    }
  }
};
var animationsTree = {
  length: {
    type: "number",
    get: (animations) => animations.length,
    getTarget: (animations) => animations.map((animation) => animation._babylonAnimationGroup),
    getPropertyName: [() => "length"]
  },
  __array__: {}
};
var meshesTree = {
  length: {
    type: "number",
    get: (meshes) => meshes.length,
    getTarget: (meshes) => meshes.map((mesh) => {
      var _a;
      return (_a = mesh.primitives[0]._instanceData) == null ? void 0 : _a.babylonSourceMesh;
    }),
    getPropertyName: [() => "length"]
  },
  __array__: {}
};
var camerasTree = {
  __array__: {
    __target__: true,
    orthographic: {
      xmag: {
        componentsCount: 2,
        type: "Vector2",
        get: (camera) => {
          var _a, _b;
          return new Vector2(((_a = camera._babylonCamera) == null ? void 0 : _a.orthoLeft) ?? 0, ((_b = camera._babylonCamera) == null ? void 0 : _b.orthoRight) ?? 0);
        },
        set: (value, camera) => {
          if (camera._babylonCamera) {
            camera._babylonCamera.orthoLeft = value.x;
            camera._babylonCamera.orthoRight = value.y;
          }
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "orthoLeft", () => "orthoRight"]
      },
      ymag: {
        componentsCount: 2,
        type: "Vector2",
        get: (camera) => {
          var _a, _b;
          return new Vector2(((_a = camera._babylonCamera) == null ? void 0 : _a.orthoBottom) ?? 0, ((_b = camera._babylonCamera) == null ? void 0 : _b.orthoTop) ?? 0);
        },
        set: (value, camera) => {
          if (camera._babylonCamera) {
            camera._babylonCamera.orthoBottom = value.x;
            camera._babylonCamera.orthoTop = value.y;
          }
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "orthoBottom", () => "orthoTop"]
      },
      zfar: {
        type: "number",
        get: (camera) => {
          var _a;
          return (_a = camera._babylonCamera) == null ? void 0 : _a.maxZ;
        },
        set: (value, camera) => {
          if (camera._babylonCamera) {
            camera._babylonCamera.maxZ = value;
          }
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "maxZ"]
      },
      znear: {
        type: "number",
        get: (camera) => {
          var _a;
          return (_a = camera._babylonCamera) == null ? void 0 : _a.minZ;
        },
        set: (value, camera) => {
          if (camera._babylonCamera) {
            camera._babylonCamera.minZ = value;
          }
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "minZ"]
      }
    },
    perspective: {
      aspectRatio: {
        type: "number",
        get: (camera) => {
          var _a;
          return (_a = camera._babylonCamera) == null ? void 0 : _a.getEngine().getAspectRatio(camera._babylonCamera);
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "aspectRatio"],
        isReadOnly: true
        // might not be the case for glTF?
      },
      yfov: {
        type: "number",
        get: (camera) => {
          var _a;
          return (_a = camera._babylonCamera) == null ? void 0 : _a.fov;
        },
        set: (value, camera) => {
          if (camera._babylonCamera) {
            camera._babylonCamera.fov = value;
          }
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "fov"]
      },
      zfar: {
        type: "number",
        get: (camera) => {
          var _a;
          return (_a = camera._babylonCamera) == null ? void 0 : _a.maxZ;
        },
        set: (value, camera) => {
          if (camera._babylonCamera) {
            camera._babylonCamera.maxZ = value;
          }
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "maxZ"]
      },
      znear: {
        type: "number",
        get: (camera) => {
          var _a;
          return (_a = camera._babylonCamera) == null ? void 0 : _a.minZ;
        },
        set: (value, camera) => {
          if (camera._babylonCamera) {
            camera._babylonCamera.minZ = value;
          }
        },
        getTarget: (camera) => camera,
        getPropertyName: [() => "minZ"]
      }
    }
  }
};
var materialsTree = {
  __array__: {
    __target__: true,
    emissiveFactor: {
      type: "Color3",
      get: (material, index, payload) => GetMaterial(material, index, payload).emissiveColor,
      set: (value, material, index, payload) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),
      getTarget: (material, index, payload) => GetMaterial(material, index, payload),
      getPropertyName: [() => "emissiveColor"]
    },
    emissiveTexture: {
      extensions: {
        KHR_texture_transform: GenerateTextureMap("emissiveTexture")
      }
    },
    normalTexture: {
      scale: {
        type: "number",
        get: (material, index, payload) => {
          var _a;
          return (_a = GetTexture(material, payload, "bumpTexture")) == null ? void 0 : _a.level;
        },
        set: (value, material, index, payload) => {
          const texture = GetTexture(material, payload, "bumpTexture");
          if (texture) {
            texture.level = value;
          }
        },
        getTarget: (material, index, payload) => GetMaterial(material, index, payload),
        getPropertyName: [() => "level"]
      },
      extensions: {
        KHR_texture_transform: GenerateTextureMap("bumpTexture")
      }
    },
    occlusionTexture: {
      strength: {
        type: "number",
        get: (material, index, payload) => GetMaterial(material, index, payload).ambientTextureStrength,
        set: (value, material, index, payload) => {
          const mat = GetMaterial(material, index, payload);
          if (mat) {
            mat.ambientTextureStrength = value;
          }
        },
        getTarget: (material, index, payload) => GetMaterial(material, index, payload),
        getPropertyName: [() => "ambientTextureStrength"]
      },
      extensions: {
        KHR_texture_transform: GenerateTextureMap("ambientTexture")
      }
    },
    pbrMetallicRoughness: {
      baseColorFactor: {
        type: "Color4",
        get: (material, index, payload) => {
          const mat = GetMaterial(material, index, payload);
          return Color4.FromColor3(mat.albedoColor, mat.alpha);
        },
        set: (value, material, index, payload) => {
          const mat = GetMaterial(material, index, payload);
          mat.albedoColor.set(value.r, value.g, value.b);
          mat.alpha = value.a;
        },
        getTarget: (material, index, payload) => GetMaterial(material, index, payload),
        // This is correct on the animation level, but incorrect as a single property of a type Color4
        getPropertyName: [() => "albedoColor", () => "alpha"]
      },
      baseColorTexture: {
        extensions: {
          KHR_texture_transform: GenerateTextureMap("albedoTexture")
        }
      },
      metallicFactor: {
        type: "number",
        get: (material, index, payload) => GetMaterial(material, index, payload).metallic,
        set: (value, material, index, payload) => {
          const mat = GetMaterial(material, index, payload);
          if (mat) {
            mat.metallic = value;
          }
        },
        getTarget: (material, index, payload) => GetMaterial(material, index, payload),
        getPropertyName: [() => "metallic"]
      },
      roughnessFactor: {
        type: "number",
        get: (material, index, payload) => GetMaterial(material, index, payload).roughness,
        set: (value, material, index, payload) => {
          const mat = GetMaterial(material, index, payload);
          if (mat) {
            mat.roughness = value;
          }
        },
        getTarget: (material, index, payload) => GetMaterial(material, index, payload),
        getPropertyName: [() => "roughness"]
      },
      metallicRoughnessTexture: {
        extensions: {
          KHR_texture_transform: GenerateTextureMap("metallicTexture")
        }
      }
    },
    extensions: {
      KHR_materials_anisotropy: {
        anisotropyStrength: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.intensity,
          set: (value, material, index, payload) => {
            GetMaterial(material, index, payload).anisotropy.intensity = value;
          },
          getTarget: (material, index, payload) => GetMaterial(material, index, payload),
          getPropertyName: [() => "anisotropy.intensity"]
        },
        anisotropyRotation: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.angle,
          set: (value, material, index, payload) => {
            GetMaterial(material, index, payload).anisotropy.angle = value;
          },
          getTarget: (material, index, payload) => GetMaterial(material, index, payload),
          getPropertyName: [() => "anisotropy.angle"]
        },
        anisotropyTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("anisotropy", "texture")
          }
        }
      },
      KHR_materials_clearcoat: {
        clearcoatFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.intensity,
          set: (value, material, index, payload) => {
            GetMaterial(material, index, payload).clearCoat.intensity = value;
          },
          getTarget: (material, index, payload) => GetMaterial(material, index, payload),
          getPropertyName: [() => "clearCoat.intensity"]
        },
        clearcoatRoughnessFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.roughness,
          set: (value, material, index, payload) => {
            GetMaterial(material, index, payload).clearCoat.roughness = value;
          },
          getTarget: (material, index, payload) => GetMaterial(material, index, payload),
          getPropertyName: [() => "clearCoat.roughness"]
        },
        clearcoatTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("clearCoat", "texture")
          }
        },
        clearcoatNormalTexture: {
          scale: {
            type: "number",
            get: (material, index, payload) => {
              var _a;
              return (_a = GetMaterial(material, index, payload).clearCoat.bumpTexture) == null ? void 0 : _a.level;
            },
            getTarget: GetMaterial,
            set: (value, material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture.level = value
          },
          extensions: {
            KHR_texture_transform: GenerateTextureMap("clearCoat", "bumpTexture")
          }
        },
        clearcoatRoughnessTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("clearCoat", "textureRoughness")
          }
        }
      },
      KHR_materials_dispersion: {
        dispersion: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion = value
        }
      },
      KHR_materials_emissive_strength: {
        emissiveStrength: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity = value
        }
      },
      KHR_materials_ior: {
        ior: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction = value
        }
      },
      KHR_materials_iridescence: {
        iridescenceFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity = value
        },
        iridescenceIor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction = value
        },
        iridescenceTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("iridescence", "texture")
          }
        },
        iridescenceThicknessMaximum: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness = value
        },
        iridescenceThicknessMinimum: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness = value
        },
        iridescenceThicknessTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("iridescence", "thicknessTexture")
          }
        }
      },
      KHR_materials_sheen: {
        sheenColorFactor: {
          type: "Color3",
          get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value)
        },
        sheenColorTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("sheen", "texture")
          }
        },
        sheenRoughnessFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.intensity = value
        },
        sheenRoughnessTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("sheen", "thicknessTexture")
          }
        }
      },
      KHR_materials_specular: {
        specularFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor = value,
          getPropertyName: [() => "metallicF0Factor"]
        },
        specularColorFactor: {
          type: "Color3",
          get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),
          getPropertyName: [() => "metallicReflectanceColor"]
        },
        specularTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("metallicReflectanceTexture")
          }
        },
        specularColorTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("reflectanceTexture")
          }
        }
      },
      KHR_materials_transmission: {
        transmissionFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity = value,
          getPropertyName: [() => "subSurface.refractionIntensity"]
        },
        transmissionTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("subSurface", "refractionIntensityTexture")
          }
        }
      },
      KHR_materials_diffuse_transmission: {
        diffuseTransmissionFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity = value
        },
        diffuseTransmissionTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("subSurface", "translucencyIntensityTexture")
          }
        },
        diffuseTransmissionColorFactor: {
          type: "Color3",
          get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => {
            var _a;
            return value && ((_a = GetMaterial(material, index, payload).subSurface.translucencyColor) == null ? void 0 : _a.copyFrom(value));
          }
        },
        diffuseTransmissionColorTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("subSurface", "translucencyColorTexture")
          }
        }
      },
      KHR_materials_volume: {
        attenuationColor: {
          type: "Color3",
          get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value)
        },
        attenuationDistance: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value
        },
        thicknessFactor: {
          type: "number",
          get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,
          getTarget: GetMaterial,
          set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness = value
        },
        thicknessTexture: {
          extensions: {
            KHR_texture_transform: GenerateTextureMap("subSurface", "thicknessTexture")
          }
        }
      }
    }
  }
};
var extensionsTree = {
  KHR_lights_punctual: {
    lights: {
      length: {
        type: "number",
        get: (lights) => lights.length,
        getTarget: (lights) => lights.map((light) => light._babylonLight),
        getPropertyName: [(_lights) => "length"]
      },
      __array__: {
        __target__: true,
        color: {
          type: "Color3",
          get: (light) => {
            var _a;
            return (_a = light._babylonLight) == null ? void 0 : _a.diffuse;
          },
          set: (value, light) => {
            var _a;
            return (_a = light._babylonLight) == null ? void 0 : _a.diffuse.copyFrom(value);
          },
          getTarget: (light) => light._babylonLight,
          getPropertyName: [(_light) => "diffuse"]
        },
        intensity: {
          type: "number",
          get: (light) => {
            var _a;
            return (_a = light._babylonLight) == null ? void 0 : _a.intensity;
          },
          set: (value, light) => light._babylonLight ? light._babylonLight.intensity = value : void 0,
          getTarget: (light) => light._babylonLight,
          getPropertyName: [(_light) => "intensity"]
        },
        range: {
          type: "number",
          get: (light) => {
            var _a;
            return (_a = light._babylonLight) == null ? void 0 : _a.range;
          },
          set: (value, light) => light._babylonLight ? light._babylonLight.range = value : void 0,
          getTarget: (light) => light._babylonLight,
          getPropertyName: [(_light) => "range"]
        },
        spot: {
          innerConeAngle: {
            type: "number",
            get: (light) => {
              var _a;
              return (_a = light._babylonLight) == null ? void 0 : _a.innerAngle;
            },
            set: (value, light) => light._babylonLight ? light._babylonLight.innerAngle = value : void 0,
            getTarget: (light) => light._babylonLight,
            getPropertyName: [(_light) => "innerConeAngle"]
          },
          outerConeAngle: {
            type: "number",
            get: (light) => {
              var _a;
              return (_a = light._babylonLight) == null ? void 0 : _a.angle;
            },
            set: (value, light) => light._babylonLight ? light._babylonLight.angle = value : void 0,
            getTarget: (light) => light._babylonLight,
            getPropertyName: [(_light) => "outerConeAngle"]
          }
        }
      }
    }
  },
  EXT_lights_ies: {
    lights: {
      length: {
        type: "number",
        get: (lights) => lights.length,
        getTarget: (lights) => lights.map((light) => light._babylonLight),
        getPropertyName: [(_lights) => "length"]
      }
    }
  },
  EXT_lights_image_based: {
    lights: {
      length: {
        type: "number",
        get: (lights) => lights.length,
        getTarget: (lights) => lights.map((light) => light._babylonTexture),
        getPropertyName: [(_lights) => "length"]
      },
      __array__: {
        __target__: true,
        intensity: {
          type: "number",
          get: (light) => {
            var _a;
            return (_a = light._babylonTexture) == null ? void 0 : _a.level;
          },
          set: (value, light) => {
            if (light._babylonTexture) {
              light._babylonTexture.level = value;
            }
          },
          getTarget: (light) => light._babylonTexture
        },
        rotation: {
          type: "Quaternion",
          get: (light) => {
            var _a;
            return light._babylonTexture && Quaternion.FromRotationMatrix((_a = light._babylonTexture) == null ? void 0 : _a.getReflectionTextureMatrix());
          },
          set: (value, light) => {
            var _a;
            if (!light._babylonTexture) {
              return;
            }
            if (!((_a = light._babylonTexture.getScene()) == null ? void 0 : _a.useRightHandedSystem)) {
              value = Quaternion.Inverse(value);
            }
            Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());
          },
          getTarget: (light) => light._babylonTexture
        }
      }
    }
  }
};
function GetTexture(material, payload, textureType, textureInObject) {
  const babylonMaterial = GetMaterial(material, payload);
  return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];
}
function GetMaterial(material, _index, payload) {
  var _a, _b;
  return (_b = (_a = material._data) == null ? void 0 : _a[(payload == null ? void 0 : payload.fillMode) ?? Constants.MATERIAL_TriangleFillMode]) == null ? void 0 : _b.babylonMaterial;
}
function GenerateTextureMap(textureType, textureInObject) {
  return {
    offset: {
      componentsCount: 2,
      // assuming two independent values for u and v, and NOT a Vector2
      type: "Vector2",
      get: (material, _index, payload) => {
        const texture = GetTexture(material, payload, textureType, textureInObject);
        return new Vector2(texture == null ? void 0 : texture.uOffset, texture == null ? void 0 : texture.vOffset);
      },
      getTarget: GetMaterial,
      set: (value, material, _index, payload) => {
        const texture = GetTexture(material, payload, textureType, textureInObject);
        texture.uOffset = value.x, texture.vOffset = value.y;
      },
      getPropertyName: [
        () => `${textureType}${textureInObject ? "." + textureInObject : ""}.uOffset`,
        () => `${textureType}${textureInObject ? "." + textureInObject : ""}.vOffset`
      ]
    },
    rotation: {
      type: "number",
      get: (material, _index, payload) => {
        var _a;
        return (_a = GetTexture(material, payload, textureType, textureInObject)) == null ? void 0 : _a.wAng;
      },
      getTarget: GetMaterial,
      set: (value, material, _index, payload) => GetTexture(material, payload, textureType, textureInObject).wAng = value,
      getPropertyName: [() => `${textureType}${textureInObject ? "." + textureInObject : ""}.wAng`]
    },
    scale: {
      componentsCount: 2,
      type: "Vector2",
      get: (material, _index, payload) => {
        const texture = GetTexture(material, payload, textureType, textureInObject);
        return new Vector2(texture == null ? void 0 : texture.uScale, texture == null ? void 0 : texture.vScale);
      },
      getTarget: GetMaterial,
      set: (value, material, index, payload) => {
        const texture = GetTexture(material, payload, textureType, textureInObject);
        texture.uScale = value.x, texture.vScale = value.y;
      },
      getPropertyName: [
        () => `${textureType}${textureInObject ? "." + textureInObject : ""}.uScale`,
        () => `${textureType}${textureInObject ? "." + textureInObject : ""}.vScale`
      ]
    }
  };
}
var objectModelMapping = {
  cameras: camerasTree,
  nodes: nodesTree,
  materials: materialsTree,
  extensions: extensionsTree,
  animations: animationsTree,
  meshes: meshesTree
};
function GetPathToObjectConverter(gltf) {
  return new GLTFPathToObjectConverter(gltf, objectModelMapping);
}
function GetMappingForKey(key) {
  const keyParts = key.split("/").map((part) => part.replace(/{}/g, "__array__"));
  let current = objectModelMapping;
  for (const part of keyParts) {
    if (!part) {
      continue;
    }
    current = current[part];
  }
  if (current && current.type && current.get) {
    return current;
  }
  return void 0;
}
function SetInterpolationForKey(key, interpolation) {
  const keyParts = key.split("/").map((part) => part.replace(/{}/g, "__array__"));
  let current = objectModelMapping;
  for (const part of keyParts) {
    if (!part) {
      continue;
    }
    current = current[part];
  }
  if (current && current.type && current.get) {
    current.interpolation = interpolation;
  }
}
function AddObjectAccessorToKey(key, accessor) {
  const keyParts = key.split("/").map((part) => part.replace(/{}/g, "__array__"));
  let current = objectModelMapping;
  for (const part of keyParts) {
    if (!part) {
      continue;
    }
    if (!current[part]) {
      if (part === "?") {
        current.__ignoreObjectTree__ = true;
        continue;
      }
      current[part] = {};
      if (part === "__array__") {
        current[part].__target__ = true;
      }
    }
    current = current[part];
  }
  Object.assign(current, accessor);
}

export {
  GetPathToObjectConverter,
  GetMappingForKey,
  SetInterpolationForKey,
  AddObjectAccessorToKey
};
//# sourceMappingURL=chunk-FEEXIZU7.js.map
