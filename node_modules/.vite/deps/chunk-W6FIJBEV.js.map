{
  "version": 3,
  "sources": ["../../../dev/loaders/src/OBJ/mtlFileLoader.ts"],
  "sourcesContent": ["import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        const lines = data.split(\"\\n\");\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        const delimiterPattern = /\\s+/;\r\n        //Array with RGB colors\r\n        let color: number[];\r\n        //New material\r\n        let material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            const pos = line.indexOf(\" \");\r\n            let key = pos >= 0 ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            const value: string = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiterPattern);\r\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the texture from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @param scene\r\n     * @returns The Texture\r\n     */\r\n    private static _GetTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        let url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substring(lastDelimiter + 1);\r\n            } else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
