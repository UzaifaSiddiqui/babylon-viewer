import "./chunk-6TJCVOLN.js";

// node_modules/tga-js/dist/esm/tga.js
var e = 0;
var t = 1;
var a = 3;
var r = 9;
var o = 10;
var i = 11;
var s = 0;
var h = 2;
var n = 3;
var g = 4;
var l = 48;
var tga_default = class {
  _checkHeader() {
    const t2 = this.header;
    if (t2.imageType === e)
      throw Error("No data");
    if (t2.hasColorMap) {
      if (t2.colorMapLength > 256 || 24 !== t2.colorMapDepth || 1 !== t2.colorMapType)
        throw Error("Invalid colormap for indexed type");
    } else if (t2.colorMapType)
      throw Error("Why does the image contain a palette ?");
    if (!t2.width || !t2.height)
      throw Error("Invalid image size");
    if (8 !== t2.pixelDepth && 16 !== t2.pixelDepth && 24 !== t2.pixelDepth && 32 !== t2.pixelDepth)
      throw Error('Invalid pixel size "' + t2.pixelDepth + '"');
  }
  _decodeRLE(e2, t2, a2, r2) {
    const o2 = new Uint8Array(r2), i2 = new Uint8Array(a2);
    let s2 = 0;
    for (; s2 < r2; ) {
      const r3 = e2[t2++];
      let h2 = 1 + (127 & r3);
      if (128 & r3) {
        for (let r4 = 0; r4 < a2; ++r4)
          i2[r4] = e2[t2 + r4];
        t2 += a2;
        for (let e3 = 0; e3 < h2; ++e3)
          o2.set(i2, s2), s2 += a2;
      } else {
        h2 *= a2;
        for (let a3 = 0; a3 < h2; ++a3)
          o2[s2 + a3] = e2[t2 + a3];
        s2 += h2, t2 += h2;
      }
    }
    return o2;
  }
  _getImageData8bits(e2, t2, a2, r2, o2, i2, s2, h2, n2, g2) {
    for (let l2 = 0, p = o2; p !== s2; p += i2)
      for (let o3 = h2; o3 !== g2; o3 += n2, l2++) {
        const i3 = t2[l2];
        e2[4 * (o3 + r2 * p) + 3] = 255, e2[4 * (o3 + r2 * p) + 2] = a2[3 * i3 + 0], e2[4 * (o3 + r2 * p) + 1] = a2[3 * i3 + 1], e2[4 * (o3 + r2 * p) + 0] = a2[3 * i3 + 2];
      }
    return e2;
  }
  _getImageData16bits(e2, t2, a2, r2, o2, i2, s2, h2, n2, g2) {
    for (let a3 = 0, l2 = o2; l2 !== s2; l2 += i2)
      for (let o3 = h2; o3 !== g2; o3 += n2, a3 += 2) {
        const i3 = t2[a3 + 0] | t2[a3 + 1] << 8;
        e2[4 * (o3 + r2 * l2) + 0] = (31744 & i3) >> 7, e2[4 * (o3 + r2 * l2) + 1] = (992 & i3) >> 2, e2[4 * (o3 + r2 * l2) + 2] = (31 & i3) >> 3, e2[4 * (o3 + r2 * l2) + 3] = 32768 & i3 ? 0 : 255;
      }
    return e2;
  }
  _getImageData24bits(e2, t2, a2, r2, o2, i2, s2, h2, n2, g2) {
    for (let a3 = 0, l2 = o2; l2 !== s2; l2 += i2)
      for (let o3 = h2; o3 !== g2; o3 += n2, a3 += 3)
        e2[4 * (o3 + r2 * l2) + 3] = 255, e2[4 * (o3 + r2 * l2) + 2] = t2[a3 + 0], e2[4 * (o3 + r2 * l2) + 1] = t2[a3 + 1], e2[4 * (o3 + r2 * l2) + 0] = t2[a3 + 2];
    return e2;
  }
  _getImageData32bits(e2, t2, a2, r2, o2, i2, s2, h2, n2, g2) {
    for (let a3 = 0, l2 = o2; l2 !== s2; l2 += i2)
      for (let o3 = h2; o3 !== g2; o3 += n2, a3 += 4)
        e2[4 * (o3 + r2 * l2) + 2] = t2[a3 + 0], e2[4 * (o3 + r2 * l2) + 1] = t2[a3 + 1], e2[4 * (o3 + r2 * l2) + 0] = t2[a3 + 2], e2[4 * (o3 + r2 * l2) + 3] = t2[a3 + 3];
    return e2;
  }
  _getImageDataGrey8bits(e2, t2, a2, r2, o2, i2, s2, h2, n2, g2) {
    for (let a3 = 0, l2 = o2; l2 !== s2; l2 += i2)
      for (let o3 = h2; o3 !== g2; o3 += n2, a3++) {
        const i3 = t2[a3];
        e2[4 * (o3 + r2 * l2) + 0] = i3, e2[4 * (o3 + r2 * l2) + 1] = i3, e2[4 * (o3 + r2 * l2) + 2] = i3, e2[4 * (o3 + r2 * l2) + 3] = 255;
      }
    return e2;
  }
  _getImageDataGrey16bits(e2, t2, a2, r2, o2, i2, s2, h2, n2, g2) {
    for (let a3 = 0, l2 = o2; l2 !== s2; l2 += i2)
      for (let o3 = h2; o3 !== g2; o3 += n2, a3 += 2)
        e2[4 * (o3 + r2 * l2) + 0] = t2[a3 + 0], e2[4 * (o3 + r2 * l2) + 1] = t2[a3 + 0], e2[4 * (o3 + r2 * l2) + 2] = t2[a3 + 0], e2[4 * (o3 + r2 * l2) + 3] = t2[a3 + 1];
    return e2;
  }
  open(e2, t2) {
    const a2 = new XMLHttpRequest();
    a2.responseType = "arraybuffer", a2.open("GET", e2, true), a2.onload = () => {
      200 === a2.status && (this.load(new Uint8Array(a2.response)), t2 && t2());
    }, a2.send(null);
  }
  load(e2) {
    let s2 = 0;
    if (e2.length < 18)
      throw Error("Not enough data to contain header");
    const h2 = { idLength: e2[s2++], colorMapType: e2[s2++], imageType: e2[s2++], colorMapIndex: e2[s2++] | e2[s2++] << 8, colorMapLength: e2[s2++] | e2[s2++] << 8, colorMapDepth: e2[s2++], offsetX: e2[s2++] | e2[s2++] << 8, offsetY: e2[s2++] | e2[s2++] << 8, width: e2[s2++] | e2[s2++] << 8, height: e2[s2++] | e2[s2++] << 8, pixelDepth: e2[s2++], flags: e2[s2++] };
    if (h2.hasEncoding = h2.imageType === r || h2.imageType === o || h2.imageType === i, h2.hasColorMap = h2.imageType === r || h2.imageType === t, h2.isGreyColor = h2.imageType === i || h2.imageType === a, this.header = h2, this._checkHeader(), (s2 += h2.idLength) >= e2.length)
      throw Error("No data");
    if (h2.hasColorMap) {
      const t2 = h2.colorMapLength * (h2.colorMapDepth >> 3);
      this.palette = e2.subarray(s2, s2 + t2), s2 += t2;
    }
    const n2 = h2.pixelDepth >> 3, g2 = h2.width * h2.height, l2 = g2 * n2;
    h2.hasEncoding ? this.imageData = this._decodeRLE(e2, s2, n2, l2) : this.imageData = e2.subarray(s2, s2 + (h2.hasColorMap ? g2 : l2));
  }
  getImageData(e2) {
    const { width: t2, height: a2, flags: r2, pixelDepth: o2, isGreyColor: i2 } = this.header, p = (r2 & l) >> g;
    let c, d, m, f, D, y, u;
    switch (e2 || (e2 = document ? document.createElement("canvas").getContext("2d").createImageData(t2, a2) : { width: t2, height: a2, data: new Uint8ClampedArray(t2 * a2 * 4) }), p === h || p === n ? (f = 0, D = 1, y = a2) : (f = a2 - 1, D = -1, y = -1), p === h || p === s ? (c = 0, d = 1, m = t2) : (c = t2 - 1, d = -1, m = -1), o2) {
      case 8:
        u = i2 ? this._getImageDataGrey8bits : this._getImageData8bits;
        break;
      case 16:
        u = i2 ? this._getImageDataGrey16bits : this._getImageData16bits;
        break;
      case 24:
        u = this._getImageData24bits;
        break;
      case 32:
        u = this._getImageData32bits;
    }
    return u.call(this, e2.data, this.imageData, this.palette, t2, f, D, y, c, d, m), e2;
  }
  getCanvas() {
    const { width: e2, height: t2 } = this.header, a2 = document.createElement("canvas"), r2 = a2.getContext("2d"), o2 = r2.createImageData(e2, t2);
    return a2.width = e2, a2.height = t2, r2.putImageData(this.getImageData(o2), 0, 0), a2;
  }
  getDataURL(e2) {
    return this.getCanvas().toDataURL(e2 || "image/png");
  }
};
export {
  tga_default as default
};
/*! Bundled license information:

tga-js/dist/esm/tga.js:
  (**
   * @license tga-js 1.1.1
   * Copyright (c) 2013-2020 Vincent Thibault, Inc.
   * License: MIT
   *)
*/
//# sourceMappingURL=tga-js.js.map
