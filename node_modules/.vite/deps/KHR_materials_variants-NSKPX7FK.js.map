{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts"],
  "sourcesContent": ["import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Node } from \"core/node\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { INode, IMeshPrimitive, IMesh } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRMaterialVariants_Mapping, IKHRMaterialVariants_Variant, IKHRMaterialVariants_Variants } from \"babylonjs-gltf2interface\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { MaterialVariantsController } from \"../../glTFFileLoader\";\r\n\r\nconst NAME = \"KHR_materials_variants\";\r\n\r\nexport { MaterialVariantsController };\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // Define options related types here so they can be referenced in the options,\r\n    // but export the types at the module level. This ensures the types are in the\r\n    // correct namespace for UMD.\r\n    type MaterialVariantsController = {\r\n        /**\r\n         * The list of available variant names for this asset.\r\n         */\r\n        readonly variants: readonly string[];\r\n\r\n        /**\r\n         * Gets or sets the selected variant.\r\n         */\r\n        selectedVariant: string;\r\n    };\r\n\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_variants extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_variants\"]: Partial<{\r\n            /**\r\n             * Specifies the name of the variant that should be selected by default.\r\n             */\r\n            defaultVariant: string;\r\n\r\n            /**\r\n             * Defines a callback that will be called if material variants are loaded.\r\n             * @experimental\r\n             */\r\n            onLoaded: (controller: MaterialVariantsController) => void;\r\n        }>;\r\n    }\r\n}\r\n\r\ninterface IVariantsMap {\r\n    [key: string]: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n}\r\n\r\ninterface IExtensionMetadata {\r\n    lastSelected: Nullable<string | Array<string>>;\r\n    original: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n    variants: IVariantsMap;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_variants implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _variants?: Array<IKHRMaterialVariants_Variant>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public static GetAvailableVariants(rootNode: TransformNode): string[] {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            return [];\r\n        }\r\n\r\n        return Object.keys(extensionMetadata.variants);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public getAvailableVariants(rootNode: TransformNode): string[] {\r\n        return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public static SelectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        const select = (variantName: string): void => {\r\n            const entries = extensionMetadata.variants[variantName];\r\n            if (entries) {\r\n                for (const entry of entries) {\r\n                    entry.mesh.material = entry.material;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (variantName instanceof Array) {\r\n            for (const name of variantName) {\r\n                select(name);\r\n            }\r\n        } else {\r\n            select(variantName);\r\n        }\r\n\r\n        extensionMetadata.lastSelected = variantName;\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public selectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public static Reset(rootNode: TransformNode): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        for (const entry of extensionMetadata.original) {\r\n            entry.mesh.material = entry.material;\r\n        }\r\n\r\n        extensionMetadata.lastSelected = null;\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public reset(rootNode: TransformNode): void {\r\n        KHR_materials_variants.Reset(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public static GetLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        return extensionMetadata.lastSelected;\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public getLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        return KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n    }\r\n\r\n    private static _GetExtensionMetadata(rootNode: Nullable<TransformNode>): Nullable<IExtensionMetadata> {\r\n        return rootNode?._internalMetadata?.gltf?.[NAME] || null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRMaterialVariants_Variants;\r\n            this._variants = extension.variants;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        const rootNode = this._loader.rootBabylonMesh;\r\n        if (rootNode) {\r\n            const options = this._loader.parent.extensionOptions[NAME];\r\n            if (options?.defaultVariant) {\r\n                KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);\r\n            }\r\n\r\n            options?.onLoaded?.({\r\n                get variants() {\r\n                    return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n                },\r\n                get selectedVariant(): string {\r\n                    const lastSelectedVariant = KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n                    if (!lastSelectedVariant) {\r\n                        return KHR_materials_variants.GetAvailableVariants(rootNode)[0];\r\n                    }\r\n                    if (Array.isArray(lastSelectedVariant)) {\r\n                        return lastSelectedVariant[0];\r\n                    }\r\n                    return lastSelectedVariant;\r\n                },\r\n                set selectedVariant(variantName) {\r\n                    KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialVariants_Mapping, AbstractMesh>(context, primitive, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(\r\n                this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\r\n                    assign(babylonMesh);\r\n\r\n                    if (babylonMesh instanceof Mesh) {\r\n                        const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n\r\n                        const root = this._loader.rootBabylonMesh;\r\n                        const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\r\n                        const gltf = (metadata.gltf = metadata.gltf || {});\r\n                        const extensionMetadata: IExtensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\r\n\r\n                        // Store the original material.\r\n                        extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\r\n\r\n                        // For each mapping, look at the variants and make a new entry for them.\r\n                        for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\r\n                            const mapping = extension.mappings[mappingIndex];\r\n                            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\r\n                            promises.push(\r\n                                this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                                    for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\r\n                                        const variantIndex = mapping.variants[mappingVariantIndex];\r\n                                        const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\r\n                                        extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\r\n                                        extensionMetadata.variants[variant.name].push({\r\n                                            mesh: babylonMesh,\r\n                                            material: babylonMaterial,\r\n                                        });\r\n\r\n                                        // Replace the target when original mesh is cloned\r\n                                        babylonMesh.onClonedObservable.add((newOne: Node) => {\r\n                                            const newMesh = newOne as Mesh;\r\n                                            let metadata: Nullable<IExtensionMetadata> = null;\r\n                                            let newRoot: Nullable<Node> = newMesh;\r\n\r\n                                            // Find root to get medata\r\n                                            do {\r\n                                                newRoot = newRoot.parent;\r\n                                                if (!newRoot) {\r\n                                                    return;\r\n                                                }\r\n                                                metadata = KHR_materials_variants._GetExtensionMetadata(newRoot as Mesh);\r\n                                            } while (metadata === null);\r\n\r\n                                            // Need to clone the metadata on the root (first time only)\r\n                                            if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\r\n                                                // Copy main metadata\r\n                                                newRoot._internalMetadata = {};\r\n                                                for (const key in root._internalMetadata) {\r\n                                                    newRoot._internalMetadata[key] = root._internalMetadata[key];\r\n                                                }\r\n\r\n                                                // Copy the gltf metadata\r\n                                                newRoot._internalMetadata.gltf = [];\r\n                                                for (const key in root._internalMetadata.gltf) {\r\n                                                    newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\r\n                                                }\r\n\r\n                                                // Duplicate the extension specific metadata\r\n                                                newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\r\n                                                for (const original of metadata.original) {\r\n                                                    newRoot._internalMetadata.gltf[NAME].original.push({\r\n                                                        mesh: original.mesh,\r\n                                                        material: original.material,\r\n                                                    });\r\n                                                }\r\n                                                for (const key in metadata.variants) {\r\n                                                    if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\r\n                                                        newRoot._internalMetadata.gltf[NAME].variants[key] = [];\r\n                                                        for (const variantEntry of metadata.variants[key]) {\r\n                                                            newRoot._internalMetadata.gltf[NAME].variants[key].push({\r\n                                                                mesh: variantEntry.mesh,\r\n                                                                material: variantEntry.material,\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                metadata = newRoot._internalMetadata.gltf[NAME];\r\n                                            }\r\n\r\n                                            // Relocate\r\n                                            for (const target of metadata!.original) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                            for (const target of metadata!.variants[variant.name]) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n            );\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(([babylonMesh]) => {\r\n                return babylonMesh;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_variants(loader));\r\n"],
  "mappings": "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",
  "names": ["variantName", "metadata"]
}
