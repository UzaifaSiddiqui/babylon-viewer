{"version":3,"file":"mesh.vertexData.functions-D7sV26vR.esm.js","sources":["../../../../../dev/core/dist/Misc/bitArray.js","../../../../../dev/core/dist/Meshes/mesh.vertexData.functions.js"],"sourcesContent":["function GetByteIndex(bitIndex) {\n    return Math.floor(bitIndex / 8);\n}\nfunction GetBitMask(bitIndex) {\n    return 1 << bitIndex % 8;\n}\n/**\n * An fixed size array that effectively stores boolean values where each value is a single bit of backing data.\n * @remarks\n * All bits are initialized to false.\n */\nexport class BitArray {\n    /**\n     * Creates a new bit array with a fixed size.\n     * @param size The number of bits to store.\n     */\n    constructor(size) {\n        this.size = size;\n        this._byteArray = new Uint8Array(Math.ceil(this.size / 8));\n    }\n    /**\n     * Gets the current value at the specified index.\n     * @param bitIndex The index to get the value from.\n     * @returns The value at the specified index.\n     */\n    get(bitIndex) {\n        if (bitIndex >= this.size) {\n            throw new RangeError(\"Bit index out of range\");\n        }\n        const byteIndex = GetByteIndex(bitIndex);\n        const bitMask = GetBitMask(bitIndex);\n        return (this._byteArray[byteIndex] & bitMask) !== 0;\n    }\n    /**\n     * Sets the value at the specified index.\n     * @param bitIndex The index to set the value at.\n     * @param value The value to set.\n     */\n    set(bitIndex, value) {\n        if (bitIndex >= this.size) {\n            throw new RangeError(\"Bit index out of range\");\n        }\n        const byteIndex = GetByteIndex(bitIndex);\n        const bitMask = GetBitMask(bitIndex);\n        if (value) {\n            this._byteArray[byteIndex] |= bitMask;\n        }\n        else {\n            this._byteArray[byteIndex] &= ~bitMask;\n        }\n    }\n}\n//# sourceMappingURL=bitArray.js.map","import { BitArray } from \"core/Misc/bitArray\";\n/**\n * Sort (in place) the index array so that faces with common indices are close\n * @param indices the array of indices to sort\n */\nexport function OptimizeIndices(indices) {\n    const faces = [];\n    const faceCount = indices.length / 3;\n    // Step 1: Break the indices array into faces\n    for (let i = 0; i < faceCount; i++) {\n        faces.push([indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]]);\n    }\n    // Step 2: Build a graph connecting faces sharing a vertex\n    const vertexToFaceMap = new Map();\n    for (let faceIndex = 0; faceIndex < faces.length; faceIndex++) {\n        const face = faces[faceIndex];\n        for (const vertex of face) {\n            let face = vertexToFaceMap.get(vertex);\n            if (!face) {\n                vertexToFaceMap.set(vertex, (face = []));\n            }\n            face.push(faceIndex);\n        }\n    }\n    // Step 3: Traverse faces using DFS to ensure connected faces are close\n    const visited = new BitArray(faceCount);\n    const sortedFaces = [];\n    // Using a stack and not a recursive version to avoid call stack overflow\n    const deepFirstSearchStack = (startFaceIndex) => {\n        const stack = [startFaceIndex];\n        while (stack.length > 0) {\n            const currentFaceIndex = stack.pop();\n            if (visited.get(currentFaceIndex)) {\n                continue;\n            }\n            visited.set(currentFaceIndex, true);\n            sortedFaces.push(faces[currentFaceIndex]);\n            // Push unvisited neighbors (faces sharing a vertex) onto the stack\n            for (const vertex of faces[currentFaceIndex]) {\n                const neighbors = vertexToFaceMap.get(vertex);\n                if (!neighbors) {\n                    return;\n                }\n                for (const neighborFaceIndex of neighbors) {\n                    if (!visited.get(neighborFaceIndex)) {\n                        stack.push(neighborFaceIndex);\n                    }\n                }\n            }\n        }\n    };\n    // Start DFS from the first face\n    for (let i = 0; i < faceCount; i++) {\n        if (!visited.get(i)) {\n            deepFirstSearchStack(i);\n        }\n    }\n    // Step 4: Flatten the sorted faces back into an array\n    let index = 0;\n    for (const face of sortedFaces) {\n        indices[index++] = face[0];\n        indices[index++] = face[1];\n        indices[index++] = face[2];\n    }\n}\n//# sourceMappingURL=mesh.vertexData.functions.js.map"],"names":[],"mappings":"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"}