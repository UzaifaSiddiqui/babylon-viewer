{"version":3,"file":"EXT_lights_image_based-CPO2yX8f.esm.min.js","sources":["../../../../../dev/core/dist/Materials/Textures/rawCubeTexture.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/EXT_lights_image_based.js"],"sourcesContent":["import { SerializationHelper } from \"../../Misc/decorators.serialization\";\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools\";\nimport { CubeTexture } from \"./cubeTexture\";\nimport { Constants } from \"../../Engines/constants\";\n/**\n * Raw cube texture where the raw buffers are passed in\n */\nexport class RawCubeTexture extends CubeTexture {\n    /**\n     * Creates a cube texture where the raw buffers are passed in.\n     * @param scene defines the scene the texture is attached to\n     * @param data defines the array of data to use to create each face\n     * @param size defines the size of the textures\n     * @param format defines the format of the data\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\n     * @param generateMipMaps  defines if the engine should generate the mip levels\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\n     * @param compression defines the compression used (null by default)\n     */\n    constructor(scene, data, size, format = Constants.TEXTUREFORMAT_RGBA, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, generateMipMaps = false, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, compression = null) {\n        super(\"\", scene);\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n    }\n    /**\n     * Updates the raw cube texture.\n     * @param data defines the data to store\n     * @param format defines the data format\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param compression defines the compression used (null by default)\n     */\n    update(data, format, type, invertY, compression = null) {\n        this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n    }\n    /**\n     * Updates a raw cube texture with RGBD encoded data.\n     * @param data defines the array of data [mipmap][face] to use to create each face\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n     * @returns a promise that resolves when the operation is complete\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {\n        // eslint-disable-next-line github/no-then\n        return UpdateRGBDAsyncEnvTools(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => { });\n    }\n    /**\n     * Clones the raw cube texture.\n     * @returns a new cube texture\n     */\n    clone() {\n        return SerializationHelper.Clone(() => {\n            const scene = this.getScene();\n            const internalTexture = this._texture;\n            const texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n            if (internalTexture.source === 13 /* InternalTextureSource.CubeRawRGBD */) {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n            }\n            return texture;\n        }, this);\n    }\n}\n//# sourceMappingURL=rawCubeTexture.js.map","import { SphericalHarmonics, SphericalPolynomial } from \"core/Maths/sphericalPolynomial\";\nimport { Quaternion, Matrix } from \"core/Maths/math.vector\";\nimport { RawCubeTexture } from \"core/Materials/Textures/rawCubeTexture\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"EXT_lights_image_based\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_lights_image_based {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadSceneAsync(context, scene) {\n        return GLTFLoader.LoadExtensionAsync(context, scene, this.name, async (extensionContext, extension) => {\n            this._loader._allMaterialsDirtyRequired = true;\n            const promises = new Array();\n            promises.push(this._loader.loadSceneAsync(context, scene));\n            this._loader.logOpen(`${extensionContext}`);\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\n            promises.push(\n            // eslint-disable-next-line github/no-then\n            this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\n                this._loader.babylonScene.environmentTexture = texture;\n            }));\n            this._loader.logClose();\n            // eslint-disable-next-line github/no-then\n            return await Promise.all(promises).then(() => { });\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadLightAsync(context, light) {\n        if (!light._loaded) {\n            const promises = new Array();\n            this._loader.logOpen(`${context}`);\n            const imageData = new Array(light.specularImages.length);\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\n                const faces = light.specularImages[mipmap];\n                imageData[mipmap] = new Array(faces.length);\n                for (let face = 0; face < faces.length; face++) {\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\n                    this._loader.logOpen(`${specularImageContext}`);\n                    const index = faces[face];\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\n                    promises.push(\n                    // eslint-disable-next-line github/no-then\n                    this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {\n                        imageData[mipmap][face] = data;\n                    }));\n                    this._loader.logClose();\n                }\n            }\n            this._loader.logClose();\n            // eslint-disable-next-line github/no-then\n            light._loaded = Promise.all(promises).then(async () => {\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\n                babylonTexture.name = light.name || \"environment\";\n                light._babylonTexture = babylonTexture;\n                if (light.intensity != undefined) {\n                    babylonTexture.level = light.intensity;\n                }\n                if (light.rotation) {\n                    let rotation = Quaternion.FromArray(light.rotation);\n                    // Invert the rotation so that positive rotation is counter-clockwise.\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\n                        rotation = Quaternion.Inverse(rotation);\n                    }\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\n                }\n                if (!light.irradianceCoefficients) {\n                    throw new Error(`${context}: Irradiance coefficients are missing`);\n                }\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\n                sphericalHarmonics.scaleInPlace(light.intensity);\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n                // Compute the lod generation scale to fit exactly to the number of levels available.\n                const lodGenerationScale = (imageData.length - 1) / Math.log2(light.specularImageSize);\n                return await babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\n            });\n        }\n        // eslint-disable-next-line github/no-then\n        return light._loaded.then(() => {\n            return light._babylonTexture;\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_image_based(loader));\n//# sourceMappingURL=EXT_lights_image_based.js.map"],"names":["RawCubeTexture","CubeTexture","constructor","scene","data","size","format","Constants","TEXTUREFORMAT_RGBA","type","TEXTURETYPE_UNSIGNED_BYTE","generateMipMaps","invertY","samplingMode","TEXTURE_TRILINEAR_SAMPLINGMODE","compression","super","this","_texture","getEngine","createRawCubeTexture","update","updateRawCubeTexture","updateRGBDAsync","sphericalPolynomial","lodScale","lodOffset","UpdateRGBDAsyncEnvTools","then","clone","SerializationHelper","Clone","getScene","internalTexture","texture","_bufferViewArray","width","_compression","source","_bufferViewArrayArray","_sphericalPolynomial","_lodGenerationScale","_lodGenerationOffset","NAME","EXT_lights_image_based","loader","name","_loader","enabled","isExtensionUsed","dispose","_lights","onLoading","extensions","gltf","extension","lights","loadSceneAsync","context","GLTFLoader","LoadExtensionAsync","async","extensionContext","_allMaterialsDirtyRequired","promises","Array","push","logOpen","light","ArrayItem","Get","_loadLightAsync","babylonScene","environmentTexture","logClose","Promise","all","_loaded","imageData","specularImages","length","mipmap","faces","face","specularImageContext","index","image","images","loadImageAsync","babylonTexture","specularImageSize","_babylonTexture","undefined","intensity","level","rotation","Quaternion","FromArray","useRightHandedSystem","Inverse","Matrix","FromQuaternionToRef","getReflectionTextureMatrix","irradianceCoefficients","Error","sphericalHarmonics","SphericalHarmonics","scaleInPlace","convertIrradianceToLambertianRadiance","SphericalPolynomial","FromHarmonics","lodGenerationScale","Math","log2","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}