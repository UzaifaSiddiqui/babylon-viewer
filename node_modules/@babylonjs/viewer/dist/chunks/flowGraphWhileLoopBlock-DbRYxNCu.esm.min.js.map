{"version":3,"file":"flowGraphWhileLoopBlock-DbRYxNCu.esm.min.js","sources":["../../../../../dev/core/dist/FlowGraph/Blocks/Execution/ControlFlow/flowGraphWhileLoopBlock.js"],"sourcesContent":["import { RichTypeBoolean } from \"../../../flowGraphRichTypes\";\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\nimport { Logger } from \"core/Misc/logger\";\n/**\n * A block that executes a branch while a condition is true.\n */\nexport class FlowGraphWhileLoopBlock extends FlowGraphExecutionBlockWithOutSignal {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(config);\n        this.config = config;\n        this.condition = this.registerDataInput(\"condition\", RichTypeBoolean);\n        this.executionFlow = this._registerSignalOutput(\"executionFlow\");\n        this.completed = this._registerSignalOutput(\"completed\");\n        // unregister \"out\" signal\n        this._unregisterSignalOutput(\"out\");\n    }\n    _execute(context, _callingSignal) {\n        let conditionValue = this.condition.getValue(context);\n        if (this.config?.doWhile && !conditionValue) {\n            this.executionFlow._activateSignal(context);\n        }\n        let i = 0;\n        while (conditionValue) {\n            this.executionFlow._activateSignal(context);\n            ++i;\n            if (i >= FlowGraphWhileLoopBlock.MaxLoopCount) {\n                Logger.Warn(\"FlowGraphWhileLoopBlock: Max loop count reached. Breaking.\");\n                break;\n            }\n            conditionValue = this.condition.getValue(context);\n        }\n        // out is not triggered - completed is triggered\n        this.completed._activateSignal(context);\n    }\n    getClassName() {\n        return \"FlowGraphWhileLoopBlock\" /* FlowGraphBlockNames.WhileLoop */;\n    }\n}\n/**\n * The maximum number of iterations allowed in a loop.\n * This can be set to avoid an infinite loop.\n */\nFlowGraphWhileLoopBlock.MaxLoopCount = 1000;\nRegisterClass(\"FlowGraphWhileLoopBlock\" /* FlowGraphBlockNames.WhileLoop */, FlowGraphWhileLoopBlock);\n//# sourceMappingURL=flowGraphWhileLoopBlock.js.map"],"names":["FlowGraphWhileLoopBlock","FlowGraphExecutionBlockWithOutSignal","constructor","config","super","this","condition","registerDataInput","RichTypeBoolean","executionFlow","_registerSignalOutput","completed","_unregisterSignalOutput","_execute","context","_callingSignal","conditionValue","getValue","doWhile","_activateSignal","i","MaxLoopCount","Logger","Warn","getClassName","RegisterClass"],"mappings":"gOAOO,MAAMA,UAAgCC,EACzC,WAAAC,CAIAC,GACIC,MAAMD,GACNE,KAAKF,OAASA,EACdE,KAAKC,UAAYD,KAAKE,kBAAkB,YAAaC,GACrDH,KAAKI,cAAgBJ,KAAKK,sBAAsB,iBAChDL,KAAKM,UAAYN,KAAKK,sBAAsB,aAE5CL,KAAKO,wBAAwB,MACrC,CACI,QAAAC,CAASC,EAASC,GACd,IAAIC,EAAiBX,KAAKC,UAAUW,SAASH,GACzCT,KAAKF,QAAQe,UAAYF,GACzBX,KAAKI,cAAcU,gBAAgBL,GAEvC,IAAIM,EAAI,EACR,KAAOJ,GAAgB,CAGnB,GAFAX,KAAKI,cAAcU,gBAAgBL,KACjCM,EACEA,GAAKpB,EAAwBqB,aAAc,CAC3CC,EAAOC,KAAK,8DACZ,KAChB,CACYP,EAAiBX,KAAKC,UAAUW,SAASH,EACrD,CAEQT,KAAKM,UAAUQ,gBAAgBL,EACvC,CACI,YAAAU,GACI,MAAO,yBACf,EAMAxB,EAAwBqB,aAAe,IACvCI,EAAc,0BAA+DzB"}