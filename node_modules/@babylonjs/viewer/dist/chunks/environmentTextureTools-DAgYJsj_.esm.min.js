import{L as e,aC as r,V as t,C as n,a0 as a,B as o,b as i,I as s,P as l}from"./index-VvGulz6u.esm.min.js";import"./dumpTools-pAyGUYsv.esm.min.js";const u="image/png",c=[134,22,135,150,246,214,150,54];function T(r){const t=new DataView(r.buffer,r.byteOffset,r.byteLength);let n=0;for(let r=0;r<c.length;r++)if(t.getUint8(n++)!==c[r])return e.Error("Not a babylon environment map"),null;let a="",o=0;for(;o=t.getUint8(n++);)a+=String.fromCharCode(o);let i=JSON.parse(a);return i=d(i),i.binaryDataPosition=n,i.specular&&(i.specular.lodGenerationScale=i.specular.lodGenerationScale||.8),i}function d(e){if(e.version>2)throw new Error(`Unsupported babylon environment map version "${e.version}". Latest supported version is "2".`);return 2===e.version?e:e={...e,version:2,imageType:u}}function p(e,r,i){const s=(i=d(i)).specular;if(!s)return Promise.resolve([]);e._lodGenerationScale=s.lodGenerationScale;const l=[],c=function(e,r){const t=(r=d(r)).specular;let n=Math.log2(r.width);if(n=Math.round(n)+1,t.mipmaps.length!==6*n)throw new Error(`Unsupported specular mipmaps number "${t.mipmaps.length}"`);const a=new Array(n);for(let o=0;o<n;o++){a[o]=new Array(6);for(let n=0;n<6;n++){const i=t.mipmaps[6*o+n];a[o][n]=new Uint8Array(e.buffer,e.byteOffset+r.binaryDataPosition+i.position,i.length)}}return a}(r,i);l.push(m(e,c,i.imageType));const T=i.irradiance?.irradianceTexture;if(T){const s=function(e,r){r=d(r);const t=new Array(6),n=r.irradiance?.irradianceTexture;if(n){if(6!==n.faces.length)throw new Error(`Incorrect irradiance texture faces number "${n.faces.length}"`);for(let a=0;a<6;a++){const o=n.faces[a];t[a]=new Uint8Array(e.buffer,e.byteOffset+r.binaryDataPosition+o.position,o.length)}}return t}(r,i);let c=null;i.irradiance?.irradianceTexture?.dominantDirection&&(c=t.FromArray(i.irradiance.irradianceTexture.dominantDirection)),l.push(async function(e,r,t,i=u,s=null){const l=e.getEngine(),c=new a(l,5),T=new o(l,c);e._irradianceTexture=T,T._dominantDirection=s,c.isCube=!0,c.format=n.TEXTUREFORMAT_RGBA,c.type=n.TEXTURETYPE_UNSIGNED_BYTE,c.generateMipMaps=!0,c._cachedAnisotropicFilteringLevel=null,c.generateMipMaps=!0,c.width=t,c.height=t,l.updateTextureSamplingMode(n.TEXTURE_TRILINEAR_SAMPLINGMODE,c),await _(c,[r],!1,i),l.generateMipMapsForCubemap(c),c.isReady=!0}(e,s,T.size,i.imageType,c))}return Promise.all(l)}async function f(e,r,t,a,o,i,s,l,u,c,T){return await new Promise(((d,p)=>{if(t){const t=r.createTexture(null,!0,!0,null,n.TEXTURE_NEAREST_SAMPLINGMODE,null,(e=>{p(e)}),e);a?.onEffectCreatedObservable.addOnce((n=>{n.executeWhenCompiled((()=>{a.externalTextureSamplerBinding=!0,a.onApply=n=>{n._bindTexture("textureSampler",t),n.setFloat2("scale",1,r._features.needsInvertingBitmap&&e instanceof ImageBitmap?-1:1)},r.scenes.length&&(r.scenes[0].postProcessManager.directRender([a],c,!0,i,s),r.restoreDefaultFramebuffer(),t.dispose(),URL.revokeObjectURL(o),d())}))}))}else{if(r._uploadImageToTexture(T,e,i,s),l){const t=u[s];t&&r._uploadImageToTexture(t._texture,e,i,0)}d()}}))}async function m(e,r,t=u){const a=e.getEngine();e.format=n.TEXTUREFORMAT_RGBA,e.type=n.TEXTURETYPE_UNSIGNED_BYTE,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,a.updateTextureSamplingMode(n.TEXTURE_TRILINEAR_SAMPLINGMODE,e),await _(e,r,!0,t),e.isReady=!0}async function _(e,r,t,c=u){if(!i.IsExponentOfTwo(e.width))throw new Error("Texture size must be a power of two");const T=s(e.width)+1,d=e.getEngine();let p=!1,m=!1,_=null,y=null,g=null;const E=d.getCaps();E.textureLOD?d._features.supportRenderAndCopyToLodForFloatTextures?E.textureHalfFloatRender&&E.textureHalfFloatLinearFiltering?(p=!0,e.type=n.TEXTURETYPE_HALF_FLOAT):E.textureFloatRender&&E.textureFloatLinearFiltering&&(p=!0,e.type=n.TEXTURETYPE_FLOAT):p=!1:(p=!1,m=t);let x=0;if(p)d.isWebGPU?(x=1,await import("./rgbdDecode.fragment-0PXM7WjS.esm.min.js")):await import("./rgbdDecode.fragment-BSs49ztt.esm.min.js"),_=new l("rgbdDecode","rgbdDecode",null,null,1,null,n.TEXTURE_TRILINEAR_SAMPLINGMODE,d,!1,void 0,e.type,void 0,null,!1,void 0,x),e._isRGBD=!1,e.invertY=!1,y=d.createRenderTargetCubeTexture(e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:n.TEXTURE_TRILINEAR_SAMPLINGMODE,type:e.type,format:n.TEXTUREFORMAT_RGBA});else if(e._isRGBD=!0,e.invertY=!0,m){const r=3;g={};const t=e._lodGenerationScale,i=e._lodGenerationOffset;for(let s=0;s<r;s++){const l=(T-1)*t+i,u=i+(l-i)*(1-s/(r-1)),c=Math.round(Math.min(Math.max(u,0),l)),p=new a(d,2);p.isCube=!0,p.invertY=!0,p.generateMipMaps=!1,d.updateTextureSamplingMode(n.TEXTURE_LINEAR_LINEAR,p);const f=new o(null);switch(f._isCube=!0,f._texture=p,g[c]=f,s){case 0:e._lodTextureLow=f;break;case 1:e._lodTextureMid=f;break;case 2:e._lodTextureHigh=f}}}const R=[];for(let t=0;t<r.length;t++)for(let n=0;n<6;n++){const a=r[t][n],o=new Blob([a],{type:c}),i=URL.createObjectURL(o);let s;if(d._features.forceBitmapOverHTMLImageElement)s=d.createImageBitmap(o,{premultiplyAlpha:"none"}).then((async r=>await f(r,d,p,_,i,n,t,m,g,y,e)));else{const r=new Image;r.src=i,s=new Promise(((a,o)=>{r.onload=()=>{f(r,d,p,_,i,n,t,m,g,y,e).then((()=>a())).catch((e=>{o(e)}))},r.onerror=e=>{o(e)}}))}R.push(s)}if(await Promise.all(R),r.length<T){let t;const a=Math.pow(2,T-1-r.length),o=a*a*4;switch(e.type){case n.TEXTURETYPE_UNSIGNED_BYTE:t=new Uint8Array(o);break;case n.TEXTURETYPE_HALF_FLOAT:t=new Uint16Array(o);break;case n.TEXTURETYPE_FLOAT:t=new Float32Array(o)}for(let n=r.length;n<T;n++)for(let r=0;r<6;r++)d._uploadArrayBufferViewToTexture(y?.texture||e,t,r,n)}if(y){const r=e._irradianceTexture;e._irradianceTexture=null,d._releaseTexture(e),y._swapAndDie(e),e._irradianceTexture=r}_&&_.dispose(),m&&(e._lodTextureHigh&&e._lodTextureHigh._texture&&(e._lodTextureHigh._texture.isReady=!0),e._lodTextureMid&&e._lodTextureMid._texture&&(e._lodTextureMid._texture.isReady=!0),e._lodTextureLow&&e._lodTextureLow._texture&&(e._lodTextureLow._texture.isReady=!0))}function y(e,n){const a=(n=d(n)).irradiance;if(!a)return;const o=new r;t.FromArrayToRef(a.x,0,o.x),t.FromArrayToRef(a.y,0,o.y),t.FromArrayToRef(a.z,0,o.z),t.FromArrayToRef(a.xx,0,o.xx),t.FromArrayToRef(a.yy,0,o.yy),t.FromArrayToRef(a.zz,0,o.zz),t.FromArrayToRef(a.yz,0,o.yz),t.FromArrayToRef(a.zx,0,o.zx),t.FromArrayToRef(a.xy,0,o.xy),e._sphericalPolynomial=o}function g(e,r,t,n,a){const o=m(e.getEngine().createRawCubeTexture(null,e.width,e.format,e.type,e.generateMipMaps,e.invertY,e.samplingMode,e._compression),r).then((()=>e));return e.onRebuildCallback=e=>({proxy:o,isReady:!0,isAsync:!0}),e._source=13,e._bufferViewArrayArray=r,e._lodGenerationScale=n,e._lodGenerationOffset=a,e._sphericalPolynomial=t,m(e,r).then((()=>(e.isReady=!0,e)))}export{T as G,y as U,g as _,p as a};
//# sourceMappingURL=environmentTextureTools-DAgYJsj_.esm.min.js.map
