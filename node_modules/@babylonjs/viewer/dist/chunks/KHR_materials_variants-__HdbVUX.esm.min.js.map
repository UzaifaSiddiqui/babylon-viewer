{"version":3,"file":"KHR_materials_variants-__HdbVUX.esm.min.js","sources":["../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_materials_variants.js"],"sourcesContent":["import { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"KHR_materials_variants\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_variants {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * Gets the list of available variant names for this asset.\n     * @param rootNode The glTF root node\n     * @returns the list of all the variant names for this model\n     */\n    static GetAvailableVariants(rootNode) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            return [];\n        }\n        return Object.keys(extensionMetadata.variants);\n    }\n    /**\n     * Gets the list of available variant names for this asset.\n     * @param rootNode The glTF root node\n     * @returns the list of all the variant names for this model\n     */\n    getAvailableVariants(rootNode) {\n        return KHR_materials_variants.GetAvailableVariants(rootNode);\n    }\n    /**\n     * Select a variant given a variant name or a list of variant names.\n     * @param rootNode The glTF root node\n     * @param variantName The variant name(s) to select.\n     */\n    static SelectVariant(rootNode, variantName) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        const select = (variantName) => {\n            const entries = extensionMetadata.variants[variantName];\n            if (entries) {\n                for (const entry of entries) {\n                    entry.mesh.material = entry.material;\n                }\n            }\n        };\n        if (variantName instanceof Array) {\n            for (const name of variantName) {\n                select(name);\n            }\n        }\n        else {\n            select(variantName);\n        }\n        extensionMetadata.lastSelected = variantName;\n    }\n    /**\n     * Select a variant given a variant name or a list of variant names.\n     * @param rootNode The glTF root node\n     * @param variantName The variant name(s) to select.\n     */\n    selectVariant(rootNode, variantName) {\n        KHR_materials_variants.SelectVariant(rootNode, variantName);\n    }\n    /**\n     * Reset back to the original before selecting a variant.\n     * @param rootNode The glTF root node\n     */\n    static Reset(rootNode) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        for (const entry of extensionMetadata.original) {\n            entry.mesh.material = entry.material;\n        }\n        extensionMetadata.lastSelected = null;\n    }\n    /**\n     * Reset back to the original before selecting a variant.\n     * @param rootNode The glTF root node\n     */\n    reset(rootNode) {\n        KHR_materials_variants.Reset(rootNode);\n    }\n    /**\n     * Gets the last selected variant name(s) or null if original.\n     * @param rootNode The glTF root node\n     * @returns The selected variant name(s).\n     */\n    static GetLastSelectedVariant(rootNode) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        return extensionMetadata.lastSelected;\n    }\n    /**\n     * Gets the last selected variant name(s) or null if original.\n     * @param rootNode The glTF root node\n     * @returns The selected variant name(s).\n     */\n    getLastSelectedVariant(rootNode) {\n        return KHR_materials_variants.GetLastSelectedVariant(rootNode);\n    }\n    static _GetExtensionMetadata(rootNode) {\n        return rootNode?._internalMetadata?.gltf?.[NAME] || null;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._variants = extension.variants;\n        }\n    }\n    /** @internal */\n    onReady() {\n        const rootNode = this._loader.rootBabylonMesh;\n        if (rootNode) {\n            const options = this._loader.parent.extensionOptions[NAME];\n            if (options?.defaultVariant) {\n                KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);\n            }\n            options?.onLoaded?.({\n                get variants() {\n                    return KHR_materials_variants.GetAvailableVariants(rootNode);\n                },\n                get selectedVariant() {\n                    const lastSelectedVariant = KHR_materials_variants.GetLastSelectedVariant(rootNode);\n                    if (!lastSelectedVariant) {\n                        return KHR_materials_variants.GetAvailableVariants(rootNode)[0];\n                    }\n                    if (Array.isArray(lastSelectedVariant)) {\n                        return lastSelectedVariant[0];\n                    }\n                    return lastSelectedVariant;\n                },\n                set selectedVariant(variantName) {\n                    KHR_materials_variants.SelectVariant(rootNode, variantName);\n                },\n            });\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, async (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\n                assign(babylonMesh);\n                if (babylonMesh instanceof Mesh) {\n                    const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n                    const root = this._loader.rootBabylonMesh;\n                    const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\n                    const gltf = (metadata.gltf = metadata.gltf || {});\n                    const extensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\n                    // Store the original material.\n                    extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\n                    // For each mapping, look at the variants and make a new entry for them.\n                    for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\n                        const mapping = extension.mappings[mappingIndex];\n                        const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\n                        promises.push(this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                            for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\n                                const variantIndex = mapping.variants[mappingVariantIndex];\n                                const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\n                                extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\n                                extensionMetadata.variants[variant.name].push({\n                                    mesh: babylonMesh,\n                                    material: babylonMaterial,\n                                });\n                                // Replace the target when original mesh is cloned\n                                babylonMesh.onClonedObservable.add((newOne) => {\n                                    const newMesh = newOne;\n                                    let metadata = null;\n                                    let newRoot = newMesh;\n                                    // Find root to get medata\n                                    do {\n                                        newRoot = newRoot.parent;\n                                        if (!newRoot) {\n                                            return;\n                                        }\n                                        metadata = KHR_materials_variants._GetExtensionMetadata(newRoot);\n                                    } while (metadata === null);\n                                    // Need to clone the metadata on the root (first time only)\n                                    if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\n                                        // Copy main metadata\n                                        newRoot._internalMetadata = {};\n                                        for (const key in root._internalMetadata) {\n                                            newRoot._internalMetadata[key] = root._internalMetadata[key];\n                                        }\n                                        // Copy the gltf metadata\n                                        newRoot._internalMetadata.gltf = [];\n                                        for (const key in root._internalMetadata.gltf) {\n                                            newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\n                                        }\n                                        // Duplicate the extension specific metadata\n                                        newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\n                                        for (const original of metadata.original) {\n                                            newRoot._internalMetadata.gltf[NAME].original.push({\n                                                mesh: original.mesh,\n                                                material: original.material,\n                                            });\n                                        }\n                                        for (const key in metadata.variants) {\n                                            if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\n                                                newRoot._internalMetadata.gltf[NAME].variants[key] = [];\n                                                for (const variantEntry of metadata.variants[key]) {\n                                                    newRoot._internalMetadata.gltf[NAME].variants[key].push({\n                                                        mesh: variantEntry.mesh,\n                                                        material: variantEntry.material,\n                                                    });\n                                                }\n                                            }\n                                        }\n                                        metadata = newRoot._internalMetadata.gltf[NAME];\n                                    }\n                                    // Relocate\n                                    for (const target of metadata.original) {\n                                        if (target.mesh === babylonMesh) {\n                                            target.mesh = newMesh;\n                                        }\n                                    }\n                                    for (const target of metadata.variants[variant.name]) {\n                                        if (target.mesh === babylonMesh) {\n                                            target.mesh = newMesh;\n                                        }\n                                    }\n                                });\n                            }\n                        }));\n                    }\n                }\n            }));\n            // eslint-disable-next-line github/no-then\n            return await Promise.all(promises).then(([babylonMesh]) => {\n                return babylonMesh;\n            });\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_variants(loader));\n//# sourceMappingURL=KHR_materials_variants.js.map"],"names":["NAME","KHR_materials_variants","constructor","loader","this","name","_loader","enabled","isExtensionUsed","dispose","GetAvailableVariants","rootNode","extensionMetadata","_GetExtensionMetadata","Object","keys","variants","getAvailableVariants","SelectVariant","variantName","Error","select","entries","entry","mesh","material","Array","lastSelected","selectVariant","Reset","original","reset","GetLastSelectedVariant","getLastSelectedVariant","_internalMetadata","gltf","onLoading","extensions","extension","_variants","onReady","rootBabylonMesh","options","parent","extensionOptions","defaultVariant","onLoaded","selectedVariant","lastSelectedVariant","isArray","_loadMeshPrimitiveAsync","context","node","primitive","assign","GLTFLoader","LoadExtensionAsync","async","extensionContext","promises","push","babylonMesh","Mesh","babylonDrawMode","_GetDrawMode","mode","root","metadata","mappingIndex","mappings","length","mapping","ArrayItem","Get","materials","_loadMaterialAsync","babylonMaterial","mappingVariantIndex","variantIndex","variant","onClonedObservable","add","newOne","newMesh","newRoot","key","prototype","hasOwnProperty","call","variantEntry","target","Promise","all","then","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}