import{b as e,aH as t,m as r,L as o,bJ as s,bI as a}from"./index-VvGulz6u.esm.min.js";import{A as n}from"./workerPool-BWHiDmEZ.esm.min.js";import{GLTFLoader as i,ArrayItem as d,LoadBoundingInfoFromPositionAccessor as l}from"./glTFLoader-X6ZTOkAw.esm.min.js";import"./bone-DPw1oOFK.esm.min.js";import"./skeleton-BDCw4yVL.esm.min.js";import"./rawTexture-B-F8SA5B.esm.min.js";import"./assetContainer-Da0Xx6Do.esm.min.js";import"./objectModelMapping-CghNRpa4.esm.min.js";function c(e,t,r,o,s){const a=e;let n=null,i=null,d=null;try{let e;n=new a.Decoder,i=new a.DecoderBuffer,i.Init(t,t.byteLength);const l=n.GetEncodedGeometryType(i);switch(l){case a.TRIANGULAR_MESH:{const t=new a.Mesh;if(e=n.DecodeBufferToMesh(i,t),!e.ok()||0===t.ptr)throw new Error(e.error_msg());const r=3*t.num_faces(),s=4*r,l=a._malloc(s);try{n.GetTrianglesUInt32Array(t,s,l);const e=new Uint32Array(r);e.set(new Uint32Array(a.HEAPF32.buffer,l,r)),o(e)}finally{a._free(l)}d=t;break}case a.POINT_CLOUD:{const t=new a.PointCloud;if(e=n.DecodeBufferToPointCloud(i,t),!e.ok()||!t.ptr)throw new Error(e.error_msg());d=t;break}default:throw new Error(`Invalid geometry type ${l}`)}const c=d.num_points(),m=(e,t,r,o)=>{const n=o.data_type(),i=o.num_components(),d=o.normalized(),l=o.byte_stride(),m=o.byte_offset(),u={[a.DT_FLOAT32]:{typedArrayConstructor:Float32Array,heap:a.HEAPF32},[a.DT_INT8]:{typedArrayConstructor:Int8Array,heap:a.HEAP8},[a.DT_INT16]:{typedArrayConstructor:Int16Array,heap:a.HEAP16},[a.DT_INT32]:{typedArrayConstructor:Int32Array,heap:a.HEAP32},[a.DT_UINT8]:{typedArrayConstructor:Uint8Array,heap:a.HEAPU8},[a.DT_UINT16]:{typedArrayConstructor:Uint16Array,heap:a.HEAPU16},[a.DT_UINT32]:{typedArrayConstructor:Uint32Array,heap:a.HEAPU32}}[n];if(!u)throw new Error(`Invalid data type ${n}`);const y=c*i,f=y*u.typedArrayConstructor.BYTES_PER_ELEMENT,w=a._malloc(f);try{e.GetAttributeDataArrayForAllPoints(t,o,n,f,w);const a=new u.typedArrayConstructor(u.heap.buffer,w,y);s(r,a.slice(),i,m,l,d)}finally{a._free(w)}};if(r)for(const e in r){const t=r[e],o=n.GetAttributeByUniqueId(d,t);m(n,d,e,o)}else{const e={position:a.POSITION,normal:a.NORMAL,color:a.COLOR,uv:a.TEX_COORD};for(const t in e){const r=n.GetAttributeId(d,e[t]);if(-1!==r){const e=n.GetAttribute(d,r);m(n,d,t,e)}}}return c}finally{d&&a.destroy(d),i&&a.destroy(i),n&&a.destroy(n)}}function m(){let e;onmessage=t=>{const r=t.data;switch(r.id){case"init":{r.url&&importScripts(r.url);const t=r.wasmBinary?{wasmBinary:r.wasmBinary}:{};e=DracoDecoderModule(t),postMessage({id:"initDone"});break}case"decodeMesh":if(!e)throw new Error("Draco decoder module is not available");e.then((e=>{const t=c(e,r.dataView,r.attributes,(e=>{postMessage({id:"indices",data:e},[e.buffer])}),((e,t,r,o,s,a)=>{postMessage({id:"attribute",kind:e,data:t,size:r,byteOffset:o,byteStride:s,normalized:a},[t.buffer])}));postMessage({id:"decodeMeshDone",totalVertices:t})}))}}}class u{constructor(t){if(t.workerPool)return void(this._workerPoolPromise=Promise.resolve(t.workerPool));const r=t.wasmBinary,o=t.numWorkers??("object"==typeof navigator&&navigator.hardwareConcurrency?Math.min(Math.floor(.5*navigator.hardwareConcurrency),4):1),s=o&&"function"==typeof Worker&&"function"==typeof URL,a=s||!t.jsModule,i=t.wasmUrl&&t.wasmBinaryUrl&&"object"==typeof WebAssembly?{url:a?e.GetBabylonScriptURL(t.wasmUrl,!0):"",wasmBinaryPromise:r?Promise.resolve(r):e.LoadFileAsync(e.GetBabylonScriptURL(t.wasmBinaryUrl,!0))}:{url:a?e.GetBabylonScriptURL(t.fallbackUrl):"",wasmBinaryPromise:Promise.resolve(void 0)};s?this._workerPoolPromise=i.wasmBinaryPromise.then((e=>{const t=this._getWorkerContent(),r=URL.createObjectURL(new Blob([t],{type:"application/javascript"}));return new n(o,(()=>async function(e,t,r){return await new Promise(((o,s)=>{const a=t=>{e.removeEventListener("error",a),e.removeEventListener("message",n),s(t)},n=t=>{"initDone"===t.data.id&&(e.removeEventListener("error",a),e.removeEventListener("message",n),o(e))};if(e.addEventListener("error",a),e.addEventListener("message",n),t){const o=t.slice(0);e.postMessage({id:"init",url:r,wasmBinary:o},[o])}else e.postMessage({id:"init",url:r})}))}(new Worker(r),e,i.url)))})):this._modulePromise=i.wasmBinaryPromise.then((async r=>{if(!this._isModuleAvailable()&&!t.jsModule){if(!i.url)throw new Error("Draco codec module is not available");await e.LoadBabylonScriptAsync(i.url)}return await this._createModuleAsync(r,t.jsModule)}))}async whenReadyAsync(){this._workerPoolPromise?await this._workerPoolPromise:this._modulePromise&&await this._modulePromise}dispose(){this._workerPoolPromise&&this._workerPoolPromise.then((e=>{e.dispose()})),delete this._workerPoolPromise,delete this._modulePromise}}class y extends u{static get DefaultAvailable(){return!!((e=y.DefaultConfiguration).wasmUrl&&(e.wasmBinary||e.wasmBinaryUrl)&&"object"==typeof WebAssembly||e.fallbackUrl);var e}static get Default(){return y._Default??=new y,y._Default}static ResetDefault(e){y._Default&&(e||y._Default.dispose(),y._Default=null)}_isModuleAvailable(){return"undefined"!=typeof DracoDecoderModule}async _createModuleAsync(e,t){return{module:await(t||DracoDecoderModule)({wasmBinary:e})}}_getWorkerContent(){return`${c}(${m})()`}constructor(e=y.DefaultConfiguration){super(e)}decodeMeshToMeshDataAsync(e,t,r){const s=e instanceof ArrayBuffer?new Int8Array(e):new Int8Array(e.buffer,e.byteOffset,e.byteLength);if(this._workerPoolPromise)return this._workerPoolPromise.then((async e=>await new Promise(((a,n)=>{e.push(((e,i)=>{let d=null;const l=[],c=t=>{e.removeEventListener("error",c),e.removeEventListener("message",m),n(t),i()},m=t=>{const s=t.data;switch(s.id){case"indices":d=s.data;break;case"attribute":l.push({kind:s.kind,data:s.data,size:s.size,byteOffset:s.byteOffset,byteStride:s.byteStride,normalized:(n=s.kind,u=s.normalized,r&&void 0!==r[n]?(u!==r[n]&&o.Warn(`Normalized flag from Draco data (${u}) does not match normalized flag from glTF accessor (${r[n]}). Using flag from glTF accessor.`),r[n]):u)});break;case"decodeMeshDone":e.removeEventListener("error",c),e.removeEventListener("message",m),a({indices:d,attributes:l,totalVertices:s.totalVertices}),i()}var n,u};e.addEventListener("error",c),e.addEventListener("message",m);const u=s.slice();e.postMessage({id:"decodeMesh",dataView:u,attributes:t},[u.buffer])}))}))));if(this._modulePromise)return this._modulePromise.then((e=>{let r=null;const o=[],a=c(e.module,s,t,(e=>{r=e}),((e,t,r,s,a,n)=>{o.push({kind:e,data:t,size:r,byteOffset:s,byteStride:a,normalized:n})}));return{indices:r,attributes:o,totalVertices:a}}));throw new Error("Draco decoder module is not available")}async decodeMeshToGeometryAsync(e,o,s,a){const n=await this.decodeMeshToMeshDataAsync(s,a),i=new t(e,o);n.indices&&i.setIndices(n.indices);for(const e of n.attributes)i.setVerticesBuffer(new r(o.getEngine(),e.data,e.kind,!1,void 0,e.byteStride,void 0,e.byteOffset,e.size,void 0,e.normalized,!0),n.totalVertices);return i}async _decodeMeshToGeometryForGltfAsync(e,o,s,a,n,i){const d=await this.decodeMeshToMeshDataAsync(s,a,n),l=new t(e,o);i&&(l._boundingInfo=i,l.useBoundingInfoFromGeometry=!0),d.indices&&l.setIndices(d.indices);for(const e of d.attributes)l.setVerticesBuffer(new r(o.getEngine(),e.data,e.kind,!1,void 0,e.byteStride,void 0,e.byteOffset,e.size,void 0,e.normalized,!0),d.totalVertices);return l}}y.DefaultConfiguration={wasmUrl:`${e._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,wasmBinaryUrl:`${e._DefaultCdnUrl}/draco_decoder_gltf.wasm`,fallbackUrl:`${e._DefaultCdnUrl}/draco_decoder_gltf.js`},y._Default=null;const f="KHR_draco_mesh_compression";class w{constructor(e){this.name=f,this.useNormalizedFlagFromAccessor=!0,this._loader=e,this.enabled=y.DefaultAvailable&&this._loader.isExtensionUsed(f)}dispose(){delete this.dracoDecoder,this._loader=null}_loadVertexDataAsync(e,t,o){return i.LoadExtensionAsync(e,t,this.name,(async(s,a)=>{if(null!=t.mode&&4!==t.mode&&5!==t.mode)throw new Error(`${e}: Unsupported mode ${t.mode}`);const n={},i={},c=(e,r)=>{const s=a.attributes[e];if(null!=s&&(o._delayInfo=o._delayInfo||[],-1===o._delayInfo.indexOf(r)&&o._delayInfo.push(r),n[r]=s,this.useNormalizedFlagFromAccessor)){const o=d.TryGet(this._loader.gltf.accessors,t.attributes[e]);o&&(i[r]=o.normalized||!1)}};c("POSITION",r.PositionKind),c("NORMAL",r.NormalKind),c("TANGENT",r.TangentKind),c("TEXCOORD_0",r.UVKind),c("TEXCOORD_1",r.UV2Kind),c("TEXCOORD_2",r.UV3Kind),c("TEXCOORD_3",r.UV4Kind),c("TEXCOORD_4",r.UV5Kind),c("TEXCOORD_5",r.UV6Kind),c("JOINTS_0",r.MatricesIndicesKind),c("WEIGHTS_0",r.MatricesWeightsKind),c("COLOR_0",r.ColorKind);const m=d.Get(s,this._loader.gltf.bufferViews,a.bufferView);return m._dracoBabylonGeometry||(m._dracoBabylonGeometry=this._loader.loadBufferViewAsync(`/bufferViews/${m.index}`,m).then((async r=>{const s=this.dracoDecoder||y.Default,a=d.TryGet(this._loader.gltf.accessors,t.attributes.POSITION),c=this._loader.parent.alwaysComputeBoundingBox||o.skeleton||!a?null:l(a);return await s._decodeMeshToGeometryForGltfAsync(o.name,this._loader.babylonScene,r,n,i,c).catch((t=>{throw new Error(`${e}: ${t.message}`)}))}))),await m._dracoBabylonGeometry}))}}s(f),a(f,!0,(e=>new w(e)));export{w as KHR_draco_mesh_compression};
//# sourceMappingURL=KHR_draco_mesh_compression-17u_gMs4.esm.min.js.map
