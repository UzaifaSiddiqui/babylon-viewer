{"version":3,"file":"flowGraphGetPropertyBlock-xlg0hghx.esm.min.js","sources":["../../../../../dev/core/dist/FlowGraph/Blocks/Data/flowGraphGetPropertyBlock.js"],"sourcesContent":["import { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphCachedOperationBlock } from \"./flowGraphCachedOperationBlock\";\n/**\n * This block will deliver a property of an asset, based on the property name and an input asset.\n * The property name can include dots (\".\"), which will be interpreted as a path to the property.\n *\n * For example, with an input of a mesh asset, the property name \"position.x\" will deliver the x component of the position of the mesh.\n *\n * Note that it is recommended to input the object on which you are working on (i.e. a material) rather than providing a mesh as object and then getting the material from it.\n */\nexport class FlowGraphGetPropertyBlock extends FlowGraphCachedOperationBlock {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(RichTypeAny, config);\n        this.config = config;\n        this.object = this.registerDataInput(\"object\", RichTypeAny, config.object);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config.propertyName);\n        this.customGetFunction = this.registerDataInput(\"customGetFunction\", RichTypeAny);\n    }\n    _doOperation(context) {\n        const getter = this.customGetFunction.getValue(context);\n        let value;\n        if (getter) {\n            value = getter(this.object.getValue(context), this.propertyName.getValue(context), context);\n        }\n        else {\n            const target = this.object.getValue(context);\n            const propertyName = this.propertyName.getValue(context);\n            value = target && propertyName ? this._getPropertyValue(target, propertyName) : undefined;\n        }\n        return value;\n    }\n    _getPropertyValue(target, propertyName) {\n        const path = propertyName.split(\".\");\n        let value = target;\n        for (const prop of path) {\n            value = value[prop];\n            if (value === undefined) {\n                return;\n            }\n        }\n        return value;\n    }\n    getClassName() {\n        return \"FlowGraphGetPropertyBlock\" /* FlowGraphBlockNames.GetProperty */;\n    }\n}\nRegisterClass(\"FlowGraphGetPropertyBlock\" /* FlowGraphBlockNames.GetProperty */, FlowGraphGetPropertyBlock);\n//# sourceMappingURL=flowGraphGetPropertyBlock.js.map"],"names":["FlowGraphGetPropertyBlock","FlowGraphCachedOperationBlock","constructor","config","super","RichTypeAny","this","object","registerDataInput","propertyName","customGetFunction","_doOperation","context","getter","getValue","value","target","_getPropertyValue","undefined","path","split","prop","getClassName","RegisterClass"],"mappings":"qRAWO,MAAMA,UAAkCC,EAC3C,WAAAC,CAIAC,GACIC,MAAMC,EAAaF,GACnBG,KAAKH,OAASA,EACdG,KAAKC,OAASD,KAAKE,kBAAkB,SAAUH,EAAaF,EAAOI,QACnED,KAAKG,aAAeH,KAAKE,kBAAkB,eAAgBH,EAAaF,EAAOM,cAC/EH,KAAKI,kBAAoBJ,KAAKE,kBAAkB,oBAAqBH,EAC7E,CACI,YAAAM,CAAaC,GACT,MAAMC,EAASP,KAAKI,kBAAkBI,SAASF,GAC/C,IAAIG,EACJ,GAAIF,EACAE,EAAQF,EAAOP,KAAKC,OAAOO,SAASF,GAAUN,KAAKG,aAAaK,SAASF,GAAUA,OAElF,CACD,MAAMI,EAASV,KAAKC,OAAOO,SAASF,GAC9BH,EAAeH,KAAKG,aAAaK,SAASF,GAChDG,EAAQC,GAAUP,EAAeH,KAAKW,kBAAkBD,EAAQP,QAAgBS,CAC5F,CACQ,OAAOH,CACf,CACI,iBAAAE,CAAkBD,EAAQP,GACtB,MAAMU,EAAOV,EAAaW,MAAM,KAChC,IAAIL,EAAQC,EACZ,IAAK,MAAMK,KAAQF,EAEf,GADAJ,EAAQA,EAAMM,QACAH,IAAVH,EACA,OAGR,OAAOA,CACf,CACI,YAAAO,GACI,MAAO,2BACf,EAEAC,EAAc,4BAAmEvB"}