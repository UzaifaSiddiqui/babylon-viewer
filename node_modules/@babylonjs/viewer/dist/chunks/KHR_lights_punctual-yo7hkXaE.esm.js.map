{"version":3,"file":"KHR_lights_punctual-yo7hkXaE.esm.js","sources":["../../../../../dev/core/dist/Lights/directionalLight.js","../../../../../dev/core/dist/Lights/pointLight.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_lights_punctual.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport { ShadowLight } from \"./shadowLight\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nimport { Constants } from \"core/Engines/constants\";\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\n});\n/**\n * A directional light is defined by a direction (what a surprise!).\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class DirectionalLight extends ShadowLight {\n    /**\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\n     */\n    get shadowFrustumSize() {\n        return this._shadowFrustumSize;\n    }\n    /**\n     * Specifies a fix frustum size for the shadow generation.\n     */\n    set shadowFrustumSize(value) {\n        this._shadowFrustumSize = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    get shadowOrthoScale() {\n        return this._shadowOrthoScale;\n    }\n    /**\n     * Sets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    set shadowOrthoScale(value) {\n        this._shadowOrthoScale = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets or sets the orthoLeft property used to build the light frustum\n     */\n    get orthoLeft() {\n        return this._orthoLeft;\n    }\n    set orthoLeft(left) {\n        this._orthoLeft = left;\n    }\n    /**\n     * Gets or sets the orthoRight property used to build the light frustum\n     */\n    get orthoRight() {\n        return this._orthoRight;\n    }\n    set orthoRight(right) {\n        this._orthoRight = right;\n    }\n    /**\n     * Gets or sets the orthoTop property used to build the light frustum\n     */\n    get orthoTop() {\n        return this._orthoTop;\n    }\n    set orthoTop(top) {\n        this._orthoTop = top;\n    }\n    /**\n     * Gets or sets the orthoBottom property used to build the light frustum\n     */\n    get orthoBottom() {\n        return this._orthoBottom;\n    }\n    set orthoBottom(bottom) {\n        this._orthoBottom = bottom;\n    }\n    /**\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\n     * The directional light is emitted from everywhere in the given direction.\n     * It can cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param direction The direction of the light\n     * @param scene The scene the light belongs to\n     */\n    constructor(name, direction, scene) {\n        super(name, scene);\n        this._shadowFrustumSize = 0;\n        this._shadowOrthoScale = 0.1;\n        /**\n         * Automatically compute the projection matrix to best fit (including all the casters)\n         * on each frame.\n         */\n        this.autoUpdateExtends = true;\n        /**\n         * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\n         * on each frame. autoUpdateExtends must be set to true for this to work\n         */\n        this.autoCalcShadowZBounds = false;\n        // Cache\n        this._orthoLeft = Number.MAX_VALUE;\n        this._orthoRight = Number.MIN_VALUE;\n        this._orthoTop = Number.MIN_VALUE;\n        this._orthoBottom = Number.MAX_VALUE;\n        this.position = direction.scale(-1.0);\n        this.direction = direction;\n    }\n    /**\n     * Returns the string \"DirectionalLight\".\n     * @returns The class name\n     */\n    getClassName() {\n        return \"DirectionalLight\";\n    }\n    /**\n     * Returns the integer 1.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    getTypeID() {\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        if (this.shadowFrustumSize > 0) {\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n        }\n        else {\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n        }\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     */\n    _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        // Check extends\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n            const tempVector3 = Vector3.Zero();\n            this._orthoLeft = Number.MAX_VALUE;\n            this._orthoRight = -Number.MAX_VALUE;\n            this._orthoTop = -Number.MAX_VALUE;\n            this._orthoBottom = Number.MAX_VALUE;\n            let shadowMinZ = Number.MAX_VALUE;\n            let shadowMaxZ = -Number.MAX_VALUE;\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n                const mesh = renderList[meshIndex];\n                if (!mesh) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo();\n                const boundingBox = boundingInfo.boundingBox;\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n                    if (tempVector3.x < this._orthoLeft) {\n                        this._orthoLeft = tempVector3.x;\n                    }\n                    if (tempVector3.y < this._orthoBottom) {\n                        this._orthoBottom = tempVector3.y;\n                    }\n                    if (tempVector3.x > this._orthoRight) {\n                        this._orthoRight = tempVector3.x;\n                    }\n                    if (tempVector3.y > this._orthoTop) {\n                        this._orthoTop = tempVector3.y;\n                    }\n                    if (this.autoCalcShadowZBounds) {\n                        if (tempVector3.z < shadowMinZ) {\n                            shadowMinZ = tempVector3.z;\n                        }\n                        if (tempVector3.z > shadowMaxZ) {\n                            shadowMaxZ = tempVector3.z;\n                        }\n                    }\n                }\n            }\n            if (this.autoCalcShadowZBounds) {\n                this._shadowMinZ = shadowMinZ;\n                this._shadowMaxZ = shadowMaxZ;\n            }\n        }\n        const xOffset = this._orthoRight - this._orthoLeft;\n        const yOffset = this._orthoTop - this._orthoBottom;\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera?.minZ || Constants.ShadowMinZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera?.maxZ || Constants.ShadowMaxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The directional light\n     */\n    transferToEffect(effect, lightIndex) {\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n            return this;\n        }\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        if (this.computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n            return this;\n        }\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n        return this;\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     *\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n     * (when not using reverse depth buffer / NDC half Z range)\n     * @param _activeCamera The camera we are returning the min for (not used)\n     * @returns the depth min z\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getDepthMinZ(_activeCamera) {\n        const engine = this._scene.getEngine();\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     *\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n     * (when not using reverse depth buffer / NDC half Z range)\n     * @param _activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getDepthMaxZ(_activeCamera) {\n        const engine = this._scene.getEngine();\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"DIRLIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n__decorate([\n    serialize(\"orthoLeft\")\n], DirectionalLight.prototype, \"_orthoLeft\", void 0);\n__decorate([\n    serialize(\"orthoRight\")\n], DirectionalLight.prototype, \"_orthoRight\", void 0);\n__decorate([\n    serialize(\"orthoTop\")\n], DirectionalLight.prototype, \"_orthoTop\", void 0);\n__decorate([\n    serialize(\"orthoBottom\")\n], DirectionalLight.prototype, \"_orthoBottom\", void 0);\n// Register Class Name\nRegisterClass(\"BABYLON.DirectionalLight\", DirectionalLight);\n//# sourceMappingURL=directionalLight.js.map","import { __decorate } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport { ShadowLight } from \"./shadowLight\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\n    return () => new PointLight(name, Vector3.Zero(), scene);\n});\n/**\n * A point light is a light defined by an unique point in world space.\n * The light is emitted in every direction from this point.\n * A good example of a point light is a standard light bulb.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class PointLight extends ShadowLight {\n    /**\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    get shadowAngle() {\n        return this._shadowAngle;\n    }\n    /**\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    set shadowAngle(value) {\n        this._shadowAngle = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets the direction if it has been set.\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    set direction(value) {\n        const previousNeedCube = this.needCube();\n        this._direction = value;\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\n            const iterator = this._shadowGenerators.values();\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                const shadowGenerator = key.value;\n                shadowGenerator.recreateShadowMap();\n            }\n        }\n    }\n    /**\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\n     * A PointLight emits the light in every direction.\n     * It can cast shadows.\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\n     * ```javascript\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\n     * ```\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The light friendly name\n     * @param position The position of the point light in the scene\n     * @param scene The scene the lights belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, scene);\n        this._shadowAngle = Math.PI / 2;\n        this.position = position;\n    }\n    /**\n     * Returns the string \"PointLight\"\n     * @returns the class name\n     */\n    getClassName() {\n        return \"PointLight\";\n    }\n    /**\n     * Returns the integer 0.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    getTypeID() {\n        return Light.LIGHTTYPEID_POINTLIGHT;\n    }\n    /**\n     * Specifies whether or not the shadowmap should be a cube texture.\n     * @returns true if the shadowmap needs to be a cube texture.\n     */\n    needCube() {\n        return !this.direction;\n    }\n    /**\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\n     */\n    getShadowDirection(faceIndex) {\n        if (this.direction) {\n            return super.getShadowDirection(faceIndex);\n        }\n        else {\n            switch (faceIndex) {\n                case 0:\n                    return new Vector3(1.0, 0.0, 0.0);\n                case 1:\n                    return new Vector3(-1.0, 0.0, 0.0);\n                case 2:\n                    return new Vector3(0.0, -1.0, 0.0);\n                case 3:\n                    return new Vector3(0.0, 1.0, 0.0);\n                case 4:\n                    return new Vector3(0.0, 0.0, 1.0);\n                case 5:\n                    return new Vector3(0.0, 0.0, -1.0);\n            }\n        }\n        return Vector3.Zero();\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\n     * - fov = PI / 2\n     * - aspect ratio : 1.0\n     * - z-near and far equal to the active camera minZ and maxZ.\n     * Returns the PointLight.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1.0, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, undefined, useReverseDepthBuffer);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The point light\n     */\n    transferToEffect(effect, lightIndex) {\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0.0, lightIndex);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, 0, lightIndex);\n        }\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        if (this.computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);\n        }\n        return this;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"POINTLIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serialize()\n], PointLight.prototype, \"shadowAngle\", null);\n// Register Class Name\nRegisterClass(\"BABYLON.PointLight\", PointLight);\n//# sourceMappingURL=pointLight.js.map","import { Vector3 } from \"core/Maths/math.vector\";\nimport { Color3 } from \"core/Maths/math.color\";\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\nimport { PointLight } from \"core/Lights/pointLight\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport { Light } from \"core/Lights/light\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"KHR_lights_punctual\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_lights {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n            ArrayItem.Assign(this._lights);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            this._loader._allMaterialsDirtyRequired = true;\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\n                let babylonLight;\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n                const name = light.name || babylonMesh.name;\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\n                switch (light.type) {\n                    case \"directional\" /* KHRLightsPunctual_LightType.DIRECTIONAL */: {\n                        const babylonDirectionalLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\n                        babylonDirectionalLight.position.setAll(0);\n                        babylonLight = babylonDirectionalLight;\n                        break;\n                    }\n                    case \"point\" /* KHRLightsPunctual_LightType.POINT */: {\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\n                        break;\n                    }\n                    case \"spot\" /* KHRLightsPunctual_LightType.SPOT */: {\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\n                        babylonLight = babylonSpotLight;\n                        break;\n                    }\n                    default: {\n                        this._loader.babylonScene._blockEntityCollection = false;\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\n                    }\n                }\n                babylonLight._parentContainer = this._loader._assetContainer;\n                this._loader.babylonScene._blockEntityCollection = false;\n                light._babylonLight = babylonLight;\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n                babylonLight.parent = babylonMesh;\n                this._loader._babylonLights.push(babylonLight);\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n                assign(babylonMesh);\n            });\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_lights(loader));\n//# sourceMappingURL=KHR_lights_punctual.js.map"],"names":[],"mappings":"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"}