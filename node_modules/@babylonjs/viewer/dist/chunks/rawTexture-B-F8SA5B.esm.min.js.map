{"version":3,"file":"rawTexture-B-F8SA5B.esm.min.js","sources":["../../../../../dev/core/dist/Materials/Textures/rawTexture.js"],"sourcesContent":["import { Texture } from \"./texture\";\nimport { Constants } from \"../../Engines/constants\";\n/**\n * Raw texture can help creating a texture directly from an array of data.\n * This can be super useful if you either get the data from an uncompressed source or\n * if you wish to create your texture pixel by pixel.\n */\nexport class RawTexture extends Texture {\n    /**\n     * Instantiates a new RawTexture.\n     * Raw texture can help creating a texture directly from an array of data.\n     * This can be super useful if you either get the data from an uncompressed source or\n     * if you wish to create your texture pixel by pixel.\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\n     * @param width define the width of the texture\n     * @param height define the height of the texture\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps define whether mip maps should be generated or not\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.\n     */\n    constructor(data, width, height, \n    /**\n     * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n     */\n    format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags, useSRGBBuffer, waitDataToBeReady) {\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\n        this.format = format;\n        if (!this._engine) {\n            return;\n        }\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._waitingForData = !!waitDataToBeReady && !data;\n    }\n    /**\n     * Updates the texture underlying data.\n     * @param data Define the new data of the texture\n     */\n    update(data) {\n        this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);\n        this._waitingForData = false;\n    }\n    /**\n     * Clones the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        if (!this._texture) {\n            return super.clone();\n        }\n        const rawTexture = new RawTexture(null, this.getSize().width, this.getSize().height, this.format, this.getScene(), this._texture.generateMipMaps, this._invertY, this.samplingMode, this._texture.type, this._texture._creationFlags, this._useSRGBBuffer);\n        rawTexture._texture = this._texture;\n        this._texture.incrementReferences();\n        return rawTexture;\n    }\n    isReady() {\n        return super.isReady() && !this._waitingForData;\n    }\n    /**\n     * Creates a luminance texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the luminance texture\n     */\n    static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates a luminance alpha texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the luminance alpha texture\n     */\n    static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates an alpha texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the alpha texture\n     */\n    static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates a RGB texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the RGB alpha texture\n     */\n    static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags = 0, useSRGBBuffer = false) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n    }\n    /**\n     * Creates a RGBA texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.\n     * @returns the RGBA texture\n     */\n    static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags = 0, useSRGBBuffer = false, waitDataToBeReady = false) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer, waitDataToBeReady);\n    }\n    /**\n     * Creates a RGBA storage texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the RGBA texture\n     */\n    static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, useSRGBBuffer = false) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE, useSRGBBuffer);\n    }\n    /**\n     * Creates a R texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @returns the R texture\n     */\n    static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_FLOAT) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n    }\n    /**\n     * Creates a R storage texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @returns the R texture\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_FLOAT) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\n    }\n}\n//# sourceMappingURL=rawTexture.js.map"],"names":["RawTexture","Texture","constructor","data","width","height","format","sceneOrEngine","generateMipMaps","invertY","samplingMode","Constants","TEXTURE_TRILINEAR_SAMPLINGMODE","type","TEXTURETYPE_UNSIGNED_BYTE","creationFlags","useSRGBBuffer","waitDataToBeReady","super","undefined","this","_engine","_caps","textureFloatLinearFiltering","TEXTURETYPE_FLOAT","TEXTURE_NEAREST_SAMPLINGMODE","textureHalfFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","_texture","createRawTexture","wrapU","CLAMP_ADDRESSMODE","wrapV","_waitingForData","update","_getEngine","updateRawTexture","_useSRGBBuffer","clone","rawTexture","getSize","getScene","_invertY","_creationFlags","incrementReferences","isReady","CreateLuminanceTexture","TEXTUREFORMAT_LUMINANCE","CreateLuminanceAlphaTexture","TEXTUREFORMAT_LUMINANCE_ALPHA","CreateAlphaTexture","TEXTUREFORMAT_ALPHA","CreateRGBTexture","TEXTUREFORMAT_RGB","CreateRGBATexture","TEXTUREFORMAT_RGBA","CreateRGBAStorageTexture","TEXTURE_CREATIONFLAG_STORAGE","CreateRTexture","TRILINEAR_SAMPLINGMODE","TEXTUREFORMAT_R","CreateRStorageTexture"],"mappings":"uDAOO,MAAMA,UAAmBC,EAmB5B,WAAAC,CAAYC,EAAMC,EAAOC,EAIzBC,EAAQC,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeC,EAAUC,+BAAgCC,EAAOF,EAAUG,0BAA2BC,EAAeC,EAAeC,GAC/LC,MAAM,KAAMX,GAAgBC,EAAiBC,OAASU,OAAWA,OAAWA,OAAWA,OAAWA,OAAWA,OAAWA,OAAWA,EAAWJ,GAC9IK,KAAKd,OAASA,EACTc,KAAKC,UAGLD,KAAKC,QAAQC,MAAMC,6BAA+BV,IAASF,EAAUa,oBACtEd,EAAeC,EAAUc,8BAExBL,KAAKC,QAAQC,MAAMI,iCAAmCb,IAASF,EAAUgB,yBAC1EjB,EAAeC,EAAUc,8BAE7BL,KAAKQ,SAAWR,KAAKC,QAAQQ,iBAAiB1B,EAAMC,EAAOC,EAAQC,EAAQE,EAAiBC,EAASC,EAAc,KAAMG,EAAME,GAAiB,EAAGC,IAAiB,GACpKI,KAAKU,MAAQ7B,EAAQ8B,kBACrBX,KAAKY,MAAQ/B,EAAQ8B,kBACrBX,KAAKa,kBAAoBhB,IAAsBd,EACvD,CAKI,MAAA+B,CAAO/B,GACHiB,KAAKe,aAAaC,iBAAiBhB,KAAKQ,SAAUzB,EAAMiB,KAAKQ,SAAStB,OAAQc,KAAKQ,SAASnB,QAAS,KAAMW,KAAKQ,SAASf,KAAMO,KAAKQ,SAASS,gBAC7IjB,KAAKa,iBAAkB,CAC/B,CAKI,KAAAK,GACI,IAAKlB,KAAKQ,SACN,OAAOV,MAAMoB,QAEjB,MAAMC,EAAa,IAAIvC,EAAW,KAAMoB,KAAKoB,UAAUpC,MAAOgB,KAAKoB,UAAUnC,OAAQe,KAAKd,OAAQc,KAAKqB,WAAYrB,KAAKQ,SAASpB,gBAAiBY,KAAKsB,SAAUtB,KAAKV,aAAcU,KAAKQ,SAASf,KAAMO,KAAKQ,SAASe,eAAgBvB,KAAKiB,gBAG3O,OAFAE,EAAWX,SAAWR,KAAKQ,SAC3BR,KAAKQ,SAASgB,sBACPL,CACf,CACI,OAAAM,GACI,OAAO3B,MAAM2B,YAAczB,KAAKa,eACxC,CAYI,6BAAOa,CAAuB3C,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeC,EAAUC,gCAChI,OAAO,IAAIZ,EAAWG,EAAMC,EAAOC,EAAQM,EAAUoC,wBAAyBxC,EAAeC,EAAiBC,EAASC,EAC/H,CAYI,kCAAOsC,CAA4B7C,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeC,EAAUC,gCACrI,OAAO,IAAIZ,EAAWG,EAAMC,EAAOC,EAAQM,EAAUsC,8BAA+B1C,EAAeC,EAAiBC,EAASC,EACrI,CAYI,yBAAOwC,CAAmB/C,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeC,EAAUC,gCAC5H,OAAO,IAAIZ,EAAWG,EAAMC,EAAOC,EAAQM,EAAUwC,oBAAqB5C,EAAeC,EAAiBC,EAASC,EAC3H,CAeI,uBAAO0C,CAAiBjD,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeC,EAAUC,+BAAgCC,EAAOF,EAAUG,0BAA2BC,EAAgB,EAAGC,GAAgB,GACzO,OAAO,IAAIhB,EAAWG,EAAMC,EAAOC,EAAQM,EAAU0C,kBAAmB9C,EAAeC,EAAiBC,EAASC,EAAcG,EAAME,EAAeC,EAC5J,CAgBI,wBAAOsC,CAAkBnD,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeC,EAAUC,+BAAgCC,EAAOF,EAAUG,0BAA2BC,EAAgB,EAAGC,GAAgB,EAAOC,GAAoB,GACrQ,OAAO,IAAIjB,EAAWG,EAAMC,EAAOC,EAAQM,EAAU4C,mBAAoBhD,EAAeC,EAAiBC,EAASC,EAAcG,EAAME,EAAeC,EAAeC,EAC5K,CAcI,+BAAOuC,CAAyBrD,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeC,EAAUC,+BAAgCC,EAAOF,EAAUG,0BAA2BE,GAAgB,GAC9N,OAAO,IAAIhB,EAAWG,EAAMC,EAAOC,EAAQM,EAAU4C,mBAAoBhD,EAAeC,EAAiBC,EAASC,EAAcG,EAAMF,EAAU8C,6BAA8BzC,EACtL,CAaI,qBAAO0C,CAAevD,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeT,EAAQ0D,uBAAwB9C,EAAOF,EAAUa,mBAC/J,OAAO,IAAIxB,EAAWG,EAAMC,EAAOC,EAAQM,EAAUiD,gBAAiBrD,EAAeC,EAAiBC,EAASC,EAAcG,EACrI,CAcI,4BAAOgD,CAAsB1D,EAAMC,EAAOC,EAAQE,EAAeC,GAAkB,EAAMC,GAAU,EAAOC,EAAeT,EAAQ0D,uBAAwB9C,EAAOF,EAAUa,mBACtK,OAAO,IAAIxB,EAAWG,EAAMC,EAAOC,EAAQM,EAAUiD,gBAAiBrD,EAAeC,EAAiBC,EAASC,EAAcG,EAAMF,EAAU8C,6BACrJ"}