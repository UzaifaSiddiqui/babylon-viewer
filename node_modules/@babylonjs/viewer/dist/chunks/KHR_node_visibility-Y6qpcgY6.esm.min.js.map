{"version":3,"file":"KHR_node_visibility-Y6qpcgY6.esm.min.js","sources":["../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_node_visibility.js"],"sourcesContent":["import { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\nconst NAME = \"KHR_node_visibility\";\n// object model extension for visibility\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_visibility/visible\", {\n    get: (node) => {\n        const tn = node._babylonTransformNode;\n        if (tn && tn.isVisible !== undefined) {\n            return tn.isVisible;\n        }\n        return true;\n    },\n    set: (value, node) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.inheritVisibility = true;\n        });\n        if (node._babylonTransformNode) {\n            node._babylonTransformNode.isVisible = value;\n        }\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.isVisible = value;\n        });\n    },\n    getTarget: (node) => node._babylonTransformNode,\n    getPropertyName: [() => \"isVisible\"],\n    type: \"boolean\",\n});\n/**\n * Loader extension for KHR_node_visibility\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_visibility {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises\n    async onReady() {\n        this._loader.gltf.nodes?.forEach((node) => {\n            node._primitiveBabylonMeshes?.forEach((mesh) => {\n                mesh.inheritVisibility = true;\n            });\n            // When the JSON Pointer is used we need to change both the transform node and the primitive meshes to the new value.\n            if (node.extensions?.KHR_node_visibility) {\n                if (node.extensions?.KHR_node_visibility.visible === false) {\n                    if (node._babylonTransformNode) {\n                        node._babylonTransformNode.isVisible = false;\n                    }\n                    node._primitiveBabylonMeshes?.forEach((mesh) => {\n                        mesh.isVisible = false;\n                    });\n                }\n            }\n        });\n    }\n    dispose() {\n        this._loader = null;\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_visibility(loader));\n//# sourceMappingURL=KHR_node_visibility.js.map"],"names":["NAME","AddObjectAccessorToKey","get","node","tn","_babylonTransformNode","undefined","isVisible","set","value","_primitiveBabylonMeshes","forEach","mesh","inheritVisibility","getTarget","getPropertyName","type","KHR_node_visibility","constructor","loader","this","name","_loader","enabled","isExtensionUsed","onReady","gltf","nodes","extensions","visible","dispose","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"sHAEA,MAAMA,EAAO,sBAEbC,EAAuB,mDAAoD,CACvEC,IAAMC,IACF,MAAMC,EAAKD,EAAKE,sBAChB,OAAID,QAAuBE,IAAjBF,EAAGG,WACFH,EAAGG,WAIlBC,IAAK,CAACC,EAAON,KACTA,EAAKO,yBAAyBC,SAASC,IACnCA,EAAKC,mBAAoB,KAEzBV,EAAKE,wBACLF,EAAKE,sBAAsBE,UAAYE,GAE3CN,EAAKO,yBAAyBC,SAASC,IACnCA,EAAKL,UAAYE,MAGzBK,UAAYX,GAASA,EAAKE,sBAC1BU,gBAAiB,CAAC,IAAM,aACxBC,KAAM,YAMH,MAAMC,EAIT,WAAAC,CAAYC,GAIRC,KAAKC,KAAOrB,EACZoB,KAAKE,QAAUH,EACfC,KAAKG,QAAUJ,EAAOK,gBAAgBxB,EAC9C,CAEI,aAAMyB,GACFL,KAAKE,QAAQI,KAAKC,OAAOhB,SAASR,IAC9BA,EAAKO,yBAAyBC,SAASC,IACnCA,EAAKC,mBAAoB,KAGzBV,EAAKyB,YAAYX,sBACoC,IAAjDd,EAAKyB,YAAYX,oBAAoBY,UACjC1B,EAAKE,wBACLF,EAAKE,sBAAsBE,WAAY,GAE3CJ,EAAKO,yBAAyBC,SAASC,IACnCA,EAAKL,WAAY,QAKzC,CACI,OAAAuB,GACIV,KAAKE,QAAU,IACvB,EAEAS,EAAwB/B,GACxBgC,EAAsBhC,GAAM,GAAOmB,GAAW,IAAIF,EAAoBE"}