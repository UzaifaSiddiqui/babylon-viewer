import{S as e}from"./index-VvGulz6u.esm.min.js";import"./bonesVertex-rvwWfLSL.esm.min.js";import"./bakedVertexAnimation-B2PGfSXG.esm.min.js";import"./instancesDeclaration-BfCYcH_7.esm.min.js";import"./morphTargetsVertex-CXh_w3qU.esm.min.js";const t="iblVoxelGridVertexShader",n="attribute position: vec3f;varying vNormalizedPosition: vec3f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\nuniform invWorldScale: mat4x4f;uniform viewMatrix: mat4x4f;@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated=vertexInputs.position;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nlet worldPos=finalWorld*vec4f(positionUpdated,1.0);vertexOutputs.position=uniforms.viewMatrix*uniforms.invWorldScale*worldPos;vertexOutputs.vNormalizedPosition=vertexOutputs.position.xyz*0.5+0.5;\n#ifdef IS_NDC_HALF_ZRANGE\nvertexOutputs.position=vec4f(vertexOutputs.position.x,vertexOutputs.position.y,vertexOutputs.position.z*0.5+0.5,vertexOutputs.position.w);\n#endif\n}\n";e.ShadersStoreWGSL[t]||(e.ShadersStoreWGSL[t]=n);const i={name:t,shader:n};export{i as iblVoxelGridVertexShaderWGSL};
//# sourceMappingURL=iblVoxelGrid.vertex-CmwgZL3y.esm.min.js.map
