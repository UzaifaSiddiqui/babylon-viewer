{"version":3,"file":"objFileLoader-DtLciUID.esm.min.js","sources":["../../../../../dev/loaders/dist/OBJ/mtlFileLoader.js","../../../../../dev/loaders/dist/OBJ/solidParser.js","../../../../../dev/loaders/dist/OBJ/objFileLoader.js"],"sourcesContent":["import { Color3 } from \"core/Maths/math.color\";\nimport { Texture } from \"core/Materials/Textures/texture\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n    constructor() {\n        /**\n         * All material loaded from the mtl will be set here\n         */\n        this.materials = [];\n    }\n    /**\n     * This function will read the mtl file and create each material described inside\n     * This function could be improve by adding :\n     * -some component missing (Ni, Tf...)\n     * -including the specific options available\n     *\n     * @param scene defines the scene the material will be created in\n     * @param data defines the mtl data to parse\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\n     * @param assetContainer defines the asset container to store the material in (can be null)\n     */\n    parseMTL(scene, data, rootUrl, assetContainer) {\n        if (data instanceof ArrayBuffer) {\n            return;\n        }\n        //Split the lines from the file\n        const lines = data.split(\"\\n\");\n        // whitespace char ie: [ \\t\\r\\n\\f]\n        const delimiterPattern = /\\s+/;\n        //Array with RGB colors\n        let color;\n        //New material\n        let material = null;\n        //Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim();\n            // Blank line or comment\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            //Get the first parameter (keyword)\n            const pos = line.indexOf(\" \");\n            let key = pos >= 0 ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n            //Get the data following the key\n            const value = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\n            //This mtl keyword will create the new material\n            if (key === \"newmtl\") {\n                //Check if it is the first material.\n                // Materials specifications are described after this keyword.\n                if (material) {\n                    //Add the previous material in the material array.\n                    this.materials.push(material);\n                }\n                //Create a new material.\n                // value is the name of the material read in the mtl file\n                scene._blockEntityCollection = !!assetContainer;\n                material = new StandardMaterial(value, scene);\n                material._parentContainer = assetContainer;\n                scene._blockEntityCollection = false;\n            }\n            else if (key === \"kd\" && material) {\n                // Diffuse color (color under white light) using RGB values\n                //value  = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.diffuseColor = Color3.FromArray(color);\n            }\n            else if (key === \"ka\" && material) {\n                // Ambient color (color under shadow) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.ambientColor = Color3.FromArray(color);\n            }\n            else if (key === \"ks\" && material) {\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set the color into the material\n                material.specularColor = Color3.FromArray(color);\n            }\n            else if (key === \"ke\" && material) {\n                // Emissive color using RGB values\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                material.emissiveColor = Color3.FromArray(color);\n            }\n            else if (key === \"ns\" && material) {\n                //value = \"Integer\"\n                material.specularPower = parseFloat(value);\n            }\n            else if (key === \"d\" && material) {\n                //d is dissolve for current material. It mean alpha for BABYLON\n                material.alpha = parseFloat(value);\n                //Texture\n                //This part can be improved by adding the possible options of texture\n            }\n            else if (key === \"map_ka\" && material) {\n                // ambient texture map with a loaded image\n                //We must first get the folder of the image\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_kd\" && material) {\n                // Diffuse texture map with a loaded image\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ks\" && material) {\n                // Specular texture map with a loaded image\n                //We must first get the folder of the image\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ns\") {\n                //Specular\n                //Specular highlight component\n                //We must first get the folder of the image\n                //\n                //Not supported by BABYLON\n                //\n                //    continue;\n            }\n            else if (key === \"map_bump\" && material) {\n                //The bump texture\n                const values = value.split(delimiterPattern);\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\n                let bumpMultiplier = null;\n                if (bumpMultiplierIndex >= 0) {\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\n                    values.splice(bumpMultiplierIndex, 2); // remove\n                }\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\n                if (material.bumpTexture && bumpMultiplier !== null) {\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\n                }\n            }\n            else if (key === \"map_d\" && material) {\n                // The dissolve of the material\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n                //Options for illumination\n            }\n            else if (key === \"illum\") {\n                //Illumination\n                if (value === \"0\") {\n                    //That mean Kd == Kd\n                }\n                else if (value === \"1\") {\n                    //Color on and Ambient on\n                }\n                else if (value === \"2\") {\n                    //Highlight on\n                }\n                else if (value === \"3\") {\n                    //Reflection on and Ray trace on\n                }\n                else if (value === \"4\") {\n                    //Transparency: Glass on, Reflection: Ray trace on\n                }\n                else if (value === \"5\") {\n                    //Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"6\") {\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                }\n                else if (value === \"7\") {\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"8\") {\n                    //Reflection on and Ray trace off\n                }\n                else if (value === \"9\") {\n                    //Transparency: Glass on, Reflection: Ray trace off\n                }\n                else if (value === \"10\") {\n                    //Casts shadows onto invisible surfaces\n                }\n            }\n            else {\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n            }\n        }\n        //At the end of the file, add the last material\n        if (material) {\n            this.materials.push(material);\n        }\n    }\n    /**\n     * Gets the texture for the material.\n     *\n     * If the material is imported from input file,\n     * We sanitize the url to ensure it takes the texture from aside the material.\n     *\n     * @param rootUrl The root url to load from\n     * @param value The value stored in the mtl\n     * @param scene\n     * @returns The Texture\n     */\n    static _GetTexture(rootUrl, value, scene) {\n        if (!value) {\n            return null;\n        }\n        let url = rootUrl;\n        // Load from input file.\n        if (rootUrl === \"file:\") {\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\n            if (lastDelimiter === -1) {\n                lastDelimiter = value.lastIndexOf(\"/\");\n            }\n            if (lastDelimiter > -1) {\n                url += value.substring(lastDelimiter + 1);\n            }\n            else {\n                url += value;\n            }\n        }\n        // Not from input file.\n        else {\n            url += value;\n        }\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\n    }\n}\n/**\n * Invert Y-Axis of referenced textures on load\n */\nMTLFileLoader.INVERT_TEXTURE_Y = true;\n//# sourceMappingURL=mtlFileLoader.js.map","import { VertexBuffer } from \"core/Buffers/buffer\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\nimport { Color3, Color4 } from \"core/Maths/math.color\";\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\nimport { Geometry } from \"core/Meshes/geometry\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\nimport { Logger } from \"core/Misc/logger\";\n/**\n * Class used to load mesh data from OBJ content\n */\nexport class SolidParser {\n    /**\n     * Creates a new SolidParser\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\n     * @param loadingOptions defines the loading options to use\n     */\n    constructor(materialToUse, babylonMeshesArray, loadingOptions) {\n        this._positions = []; //values for the positions of vertices\n        this._normals = []; //Values for the normals\n        this._uvs = []; //Values for the textures\n        this._colors = [];\n        this._extColors = []; //Extension color\n        this._meshesFromObj = []; //[mesh] Contains all the obj meshes\n        this._indicesForBabylon = []; //The list of indices for VertexData\n        this._wrappedPositionForBabylon = []; //The list of position in vectors\n        this._wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices\n        this._wrappedColorsForBabylon = []; // Array with all color values to match with the indices\n        this._wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices\n        this._tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n        this._curPositionInIndices = 0;\n        this._hasMeshes = false; //Meshes are defined in the file\n        this._unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\n        this._unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\n        this._unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n        this._unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n        this._triangles = []; //Indices from new triangles coming from polygons\n        this._materialNameFromObj = \"\"; //The name of the current material\n        this._objMeshName = \"\"; //The name of the current obj mesh\n        this._increment = 1; //Id for meshes created by the multimaterial\n        this._isFirstMaterial = true;\n        this._grayColor = new Color4(0.5, 0.5, 0.5, 1);\n        this._hasLineData = false; //If this mesh has line segment(l) data\n        this._materialToUse = materialToUse;\n        this._babylonMeshesArray = babylonMeshesArray;\n        this._loadingOptions = loadingOptions;\n    }\n    /**\n     * Search for obj in the given array.\n     * This function is called to check if a couple of data already exists in an array.\n     *\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n     * @param obj Array<number>\n     * @returns {boolean}\n     */\n    _isInArray(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n    }\n    _isInArrayUV(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\n            return arr[obj[0]].idx[idx];\n        }\n        return -1;\n    }\n    /**\n     * This function set the data for each triangle.\n     * Data are position, normals and uvs\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\n     * If the tuple already exist, add only their indice\n     *\n     * @param indicePositionFromObj Integer The index in positions array\n     * @param indiceUvsFromObj Integer The index in uvs array\n     * @param indiceNormalFromObj Integer The index in normals array\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\n     * @param textureVectorFromOBJ Vector3 The value of uvs\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\n     * @param positionColorsFromOBJ\n     */\n    _setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {\n        //Check if this tuple already exists in the list of tuples\n        let _index;\n        if (this._loadingOptions.optimizeWithUV) {\n            _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\n        }\n        else {\n            _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\n        }\n        //If it not exists\n        if (_index === -1) {\n            //Add an new indice.\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\n            //We add vertices data in this order\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\n            //Push the position of vertice for Babylon\n            //Each element is a Vector3(x,y,z)\n            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\n            //Push the uvs for Babylon\n            //Each element is a Vector2(u,v)\n            //If the UVs are missing, set (u,v)=(0,0)\n            textureVectorFromOBJ = textureVectorFromOBJ ?? new Vector2(0, 0);\n            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\n            //Push the normals for Babylon\n            //Each element is a Vector3(x,y,z)\n            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n            if (positionColorsFromOBJ !== undefined) {\n                //Push the colors for Babylon\n                //Each element is a BABYLON.Color4(r,g,b,a)\n                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\n            }\n            //Add the tuple in the comparison list\n            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\n            if (this._loadingOptions.optimizeWithUV) {\n                this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\n            }\n        }\n        else {\n            //The tuple already exists\n            //Add the index of the already existing tuple\n            //At this index we can get the value of position, normal, color and uvs of vertex\n            this._indicesForBabylon.push(_index);\n        }\n    }\n    /**\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\n     */\n    _unwrapData() {\n        try {\n            //Every array has the same length\n            for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\n                //Push the x, y, z values of each element in the unwrapped array\n                this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x * this._handednessSign, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\n                this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x * this._handednessSign, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\n                this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n                if (this._loadingOptions.importVertexColors) {\n                    //Push the r, g, b, a values of each element in the unwrapped array\n                    this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);\n                }\n            }\n            // Reset arrays for the next new meshes\n            this._wrappedPositionForBabylon.length = 0;\n            this._wrappedNormalsForBabylon.length = 0;\n            this._wrappedUvsForBabylon.length = 0;\n            this._wrappedColorsForBabylon.length = 0;\n            this._tuplePosNorm.length = 0;\n            this._curPositionInIndices = 0;\n        }\n        catch (e) {\n            throw new Error(\"Unable to unwrap data while parsing OBJ data.\");\n        }\n    }\n    /**\n     * Create triangles from polygons\n     * It is important to notice that a triangle is a polygon\n     * We get 5 patterns of face defined in OBJ File :\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n     * Each pattern is divided by the same method\n     * @param faces Array[String] The indices of elements\n     * @param v Integer The variable to increment\n     */\n    _getTriangles(faces, v) {\n        //Work for each element of the array\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\n            //Add on the triangle variable the indexes to obtain triangles\n            this._pushTriangle(faces, faceIndex);\n        }\n        //Result obtained after 2 iterations:\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n    }\n    /**\n     * To get color between color and extension color\n     * @param index Integer The index of the element in the array\n     * @returns value of target color\n     */\n    _getColor(index) {\n        if (this._loadingOptions.importVertexColors) {\n            return this._extColors[index] ?? this._colors[index];\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 1\n     * In this pattern we get vertice positions\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern1(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        //For each element in the triangles array.\n        //This var could contains 1 to an infinity of triangles\n        for (let k = 0; k < this._triangles.length; k++) {\n            // Set position indice\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\n            this._setData(indicePositionFromObj, 0, 0, // In the pattern 1, normals and uvs are not defined\n            this._positions[indicePositionFromObj], // Get the vectors data\n            Vector2.Zero(), Vector3.Up(), // Create default vectors\n            this._getColor(indicePositionFromObj));\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 2\n     * In this pattern we get vertice positions and uvs\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern2(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1\"\n            //Split the data for getting position and uv\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\n            //Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            //Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            this._setData(indicePositionFromObj, indiceUvsFromObj, 0, //Default value for normals\n            this._positions[indicePositionFromObj], //Get the values for each element\n            this._uvs[indiceUvsFromObj] ?? Vector2.Zero(), Vector3.Up(), //Default value for normals\n            this._getColor(indicePositionFromObj));\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern3(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1/1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n            // Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            // Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            // Set normal indice\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\n            this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj] ?? Vector2.Zero(), this._normals[indiceNormalFromObj] ?? Vector3.Up() //Set the vector for each component\n            );\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 4\n     * In this pattern we get vertice positions and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern4(face, v) {\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1//1\"\n            //Split the data for getting position and normals\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\n            // We check indices, and normals\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\n            this._setData(indicePositionFromObj, 1, //Default value for uv\n            indiceNormalFromObj, this._positions[indicePositionFromObj], //Get each vector of data\n            Vector2.Zero(), this._normals[indiceNormalFromObj], this._getColor(indicePositionFromObj));\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /*\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern5(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"-1/-1/-1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n            // Set position indice\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\n            // Set uv indice\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\n            // Set normal indice\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\n            this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj], //Set the vector for each component\n            this._getColor(indicePositionFromObj));\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    _addPreviousObjMesh() {\n        //Check if it is not the first mesh. Otherwise we don't have data.\n        if (this._meshesFromObj.length > 0) {\n            //Get the previous mesh for applying the data about the faces\n            //=> in obj file, faces definition append after the name of the mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            //Set the data into Array for the mesh\n            this._unwrapData();\n            if (this._loadingOptions.useLegacyBehavior) {\n                // Reverse tab. Otherwise face are displayed in the wrong sens\n                this._indicesForBabylon.reverse();\n            }\n            //Set the information for the mesh\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n            this._handledMesh.indices = this._indicesForBabylon.slice();\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\n            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\n            this._handledMesh.hasLines = this._hasLineData;\n            if (this._loadingOptions.importVertexColors) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\n            }\n            //Reset the array for the next mesh\n            this._indicesForBabylon.length = 0;\n            this._unwrappedPositionsForBabylon.length = 0;\n            this._unwrappedColorsForBabylon.length = 0;\n            this._unwrappedNormalsForBabylon.length = 0;\n            this._unwrappedUVForBabylon.length = 0;\n            this._hasLineData = false;\n        }\n    }\n    _optimizeNormals(mesh) {\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\n        const mapVertices = {};\n        if (!positions || !normals) {\n            return;\n        }\n        for (let i = 0; i < positions.length / 3; i++) {\n            const x = positions[i * 3 + 0];\n            const y = positions[i * 3 + 1];\n            const z = positions[i * 3 + 2];\n            const key = x + \"_\" + y + \"_\" + z;\n            let lst = mapVertices[key];\n            if (!lst) {\n                lst = [];\n                mapVertices[key] = lst;\n            }\n            lst.push(i);\n        }\n        const normal = new Vector3();\n        for (const key in mapVertices) {\n            const lst = mapVertices[key];\n            if (lst.length < 2) {\n                continue;\n            }\n            const v0Idx = lst[0];\n            for (let i = 1; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\n            }\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\n            normal.normalize();\n            for (let i = 0; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[vIdx * 3 + 0] = normal.x;\n                normals[vIdx * 3 + 1] = normal.y;\n                normals[vIdx * 3 + 2] = normal.z;\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n    }\n    static _IsLineElement(line) {\n        return line.startsWith(\"l\");\n    }\n    static _IsObjectElement(line) {\n        return line.startsWith(\"o\");\n    }\n    static _IsGroupElement(line) {\n        return line.startsWith(\"g\");\n    }\n    static _GetZbrushMRGB(line, notParse) {\n        if (!line.startsWith(\"mrgb\")) {\n            return null;\n        }\n        line = line.replace(\"mrgb\", \"\").trim();\n        // if include vertex color , not load mrgb anymore\n        if (notParse) {\n            return [];\n        }\n        const regex = /[a-z0-9]/g;\n        const regArray = line.match(regex);\n        if (!regArray || regArray.length % 8 !== 0) {\n            return [];\n        }\n        const array = [];\n        for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {\n            //each item is MMRRGGBB, m is material index\n            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];\n            const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];\n            const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];\n            const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];\n            array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));\n        }\n        return array;\n    }\n    /**\n     * Function used to parse an OBJ string\n     * @param meshesNames defines the list of meshes to load (all if not defined)\n     * @param data defines the OBJ string\n     * @param scene defines the hosting scene\n     * @param assetContainer defines the asset container to load data in\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\n     */\n    parse(meshesNames, data, scene, assetContainer, onFileToLoadFound) {\n        //Move Santitize here to forbid delete zbrush data\n        // Sanitize data\n        data = data.replace(/#MRGB/g, \"mrgb\");\n        data = data.replace(/#.*$/gm, \"\").trim();\n        if (this._loadingOptions.useLegacyBehavior) {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n            this._handednessSign = 1;\n        }\n        else if (scene.useRightHandedSystem) {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);\n            this._handednessSign = 1;\n        }\n        else {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n            this._handednessSign = -1;\n        }\n        // Split the file into lines\n        // Preprocess line data\n        const linesOBJ = data.split(\"\\n\");\n        const lineLines = [];\n        let currentGroup = [];\n        lineLines.push(currentGroup);\n        for (let i = 0; i < linesOBJ.length; i++) {\n            const line = linesOBJ[i].trim().replace(/\\s\\s/g, \" \");\n            // Comment or newLine\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {\n                currentGroup = [];\n                lineLines.push(currentGroup);\n            }\n            if (SolidParser._IsLineElement(line)) {\n                const lineValues = line.split(\" \");\n                // create line elements with two vertices only\n                for (let i = 1; i < lineValues.length - 1; i++) {\n                    currentGroup.push(`l ${lineValues[i]} ${lineValues[i + 1]}`);\n                }\n            }\n            else {\n                currentGroup.push(line);\n            }\n        }\n        const lines = lineLines.flat();\n        // Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\n            let result;\n            // Comment or newLine\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            else if (SolidParser.VertexPattern.test(line)) {\n                //Get information about one position possible for the vertices\n                result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern\n                // Value of result with line: \"v 1.0 2.0 3.0\"\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\n                // Create a Vector3 with the position x, y, z\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n                if (this._loadingOptions.importVertexColors) {\n                    if (result.length >= 7) {\n                        const r = parseFloat(result[4]);\n                        const g = parseFloat(result[5]);\n                        const b = parseFloat(result[6]);\n                        this._colors.push(new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));\n                    }\n                    else {\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\n                        this._colors.push(this._grayColor);\n                    }\n                }\n            }\n            else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\n                //Create a Vector3 with the normals x, y, z\n                //Value of result\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of normals\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n            }\n            else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\n                //Create a Vector2 with the normals u, v\n                //Value of result\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n                //Add the Vector in the list of uvs\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\n                //Identify patterns of faces\n                //Face could be defined in different type of pattern\n            }\n            else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern4(result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\n                //Value of result:\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern5(result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"f 1 2 3\", \"1 2 3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n                1);\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1 2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1/1 2/2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {\n                for (const element of result) {\n                    this._extColors.push(element);\n                }\n            }\n            else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1/1/1 2/2/2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\n                // Create a new mesh corresponding to the name of the group.\n                // Definition of the mesh\n                const objMesh = {\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\n                    indices: null,\n                    positions: null,\n                    normals: null,\n                    uvs: null,\n                    colors: null,\n                    materialName: this._materialNameFromObj,\n                    isObject: SolidParser.ObjectDescriptor.test(line),\n                };\n                this._addPreviousObjMesh();\n                //Push the last mesh created with only the name\n                this._meshesFromObj.push(objMesh);\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\n                this._hasMeshes = true;\n                this._isFirstMaterial = true;\n                this._increment = 1;\n                //Keyword for applying a material\n            }\n            else if (SolidParser.UseMtlDescriptor.test(line)) {\n                //Get the name of the material\n                this._materialNameFromObj = line.substring(7).trim();\n                //If this new material is in the same mesh\n                if (!this._isFirstMaterial || !this._hasMeshes) {\n                    //Set the data for the previous mesh\n                    this._addPreviousObjMesh();\n                    //Create a new mesh\n                    const objMesh = \n                    //Set the name of the current obj mesh\n                    {\n                        name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\n                        indices: null,\n                        positions: null,\n                        normals: null,\n                        uvs: null,\n                        colors: null,\n                        materialName: this._materialNameFromObj,\n                        isObject: false,\n                    };\n                    this._increment++;\n                    //If meshes are already defined\n                    this._meshesFromObj.push(objMesh);\n                    this._hasMeshes = true;\n                }\n                //Set the material name if the previous line define a mesh\n                if (this._hasMeshes && this._isFirstMaterial) {\n                    //Set the material name to the previous mesh (1 material per mesh)\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\n                    this._isFirstMaterial = false;\n                }\n                // Keyword for loading the mtl file\n            }\n            else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\n                // Get the name of mtl file\n                onFileToLoadFound(line.substring(7).trim());\n                // Apply smoothing\n            }\n            else if (SolidParser.SmoothDescriptor.test(line)) {\n                // smooth shading => apply smoothing\n                // Today I don't know it work with babylon and with obj.\n                // With the obj file  an integer is set\n            }\n            else {\n                //If there is another possibility\n                Logger.Log(\"Unhandled expression at line : \" + line);\n            }\n        }\n        // At the end of the file, add the last mesh into the meshesFromObj array\n        if (this._hasMeshes) {\n            // Set the data for the last mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            if (this._loadingOptions.useLegacyBehavior) {\n                //Reverse indices for displaying faces in the good sense\n                this._indicesForBabylon.reverse();\n            }\n            //Get the good array\n            this._unwrapData();\n            //Set array\n            this._handledMesh.indices = this._indicesForBabylon;\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon;\n            this._handledMesh.uvs = this._unwrappedUVForBabylon;\n            this._handledMesh.hasLines = this._hasLineData;\n            if (this._loadingOptions.importVertexColors) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\n            }\n        }\n        // If any o or g keyword not found, create a mesh with a random id\n        if (!this._hasMeshes) {\n            let newMaterial = null;\n            if (this._indicesForBabylon.length) {\n                if (this._loadingOptions.useLegacyBehavior) {\n                    // reverse tab of indices\n                    this._indicesForBabylon.reverse();\n                }\n                //Get positions normals uvs\n                this._unwrapData();\n            }\n            else {\n                // There is no indices in the file. We will have to switch to point cloud rendering\n                for (const pos of this._positions) {\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\n                }\n                if (this._normals.length) {\n                    for (const normal of this._normals) {\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\n                    }\n                }\n                if (this._uvs.length) {\n                    for (const uv of this._uvs) {\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\n                    }\n                }\n                if (this._extColors.length) {\n                    for (const color of this._extColors) {\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n                    }\n                }\n                else {\n                    if (this._colors.length) {\n                        for (const color of this._colors) {\n                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n                        }\n                    }\n                }\n                if (!this._materialNameFromObj) {\n                    // Create a material with point cloud on\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\n                    newMaterial.pointsCloud = true;\n                    this._materialNameFromObj = newMaterial.name;\n                    if (!this._normals.length) {\n                        newMaterial.disableLighting = true;\n                        newMaterial.emissiveColor = Color3.White();\n                    }\n                }\n            }\n            //Set data for one mesh\n            this._meshesFromObj.push({\n                name: Geometry.RandomId(),\n                indices: this._indicesForBabylon,\n                positions: this._unwrappedPositionsForBabylon,\n                colors: this._unwrappedColorsForBabylon,\n                normals: this._unwrappedNormalsForBabylon,\n                uvs: this._unwrappedUVForBabylon,\n                materialName: this._materialNameFromObj,\n                directMaterial: newMaterial,\n                isObject: true,\n                hasLines: this._hasLineData,\n            });\n        }\n        //Set data for each mesh\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\n            //check meshesNames (stlFileLoader)\n            if (meshesNames && this._meshesFromObj[j].name) {\n                if (meshesNames instanceof Array) {\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\n                        continue;\n                    }\n                }\n                else {\n                    if (this._meshesFromObj[j].name !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n            //Get the current mesh\n            //Set the data with VertexBuffer for each mesh\n            this._handledMesh = this._meshesFromObj[j];\n            //Create a Mesh with the name of the obj mesh\n            scene._blockEntityCollection = !!assetContainer;\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\n            babylonMesh._parentContainer = assetContainer;\n            scene._blockEntityCollection = false;\n            this._handledMesh._babylonMesh = babylonMesh;\n            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.\n            if (!this._handledMesh.isObject) {\n                for (let k = j - 1; k >= 0; --k) {\n                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {\n                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh;\n                        break;\n                    }\n                }\n            }\n            //Push the name of the material to an array\n            //This is indispensable for the importMesh function\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\n            //If the mesh is a line mesh\n            if (this._handledMesh.hasLines) {\n                babylonMesh._internalMetadata ??= {};\n                babylonMesh._internalMetadata[\"_isLine\"] = true; //this is a line mesh\n            }\n            if (this._handledMesh.positions?.length === 0) {\n                //Push the mesh into an array\n                this._babylonMeshesArray.push(babylonMesh);\n                continue;\n            }\n            const vertexData = new VertexData(); //The container for the values\n            //Set the data for the babylonMesh\n            vertexData.uvs = this._handledMesh.uvs;\n            vertexData.indices = this._handledMesh.indices;\n            vertexData.positions = this._handledMesh.positions;\n            if (this._loadingOptions.computeNormals) {\n                const normals = new Array();\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\n                vertexData.normals = normals;\n            }\n            else {\n                vertexData.normals = this._handledMesh.normals;\n            }\n            if (this._loadingOptions.importVertexColors) {\n                vertexData.colors = this._handledMesh.colors;\n            }\n            //Set the data from the VertexBuffer to the current Mesh\n            vertexData.applyToMesh(babylonMesh);\n            if (this._loadingOptions.invertY) {\n                babylonMesh.scaling.y *= -1;\n            }\n            if (this._loadingOptions.optimizeNormals) {\n                this._optimizeNormals(babylonMesh);\n            }\n            //Push the mesh into an array\n            this._babylonMeshesArray.push(babylonMesh);\n            if (this._handledMesh.directMaterial) {\n                babylonMesh.material = this._handledMesh.directMaterial;\n            }\n        }\n    }\n}\n// Descriptor\n/** Object descriptor */\nSolidParser.ObjectDescriptor = /^o/;\n/** Group descriptor */\nSolidParser.GroupDescriptor = /^g/;\n/** Material lib descriptor */\nSolidParser.MtlLibGroupDescriptor = /^mtllib /;\n/** Use a material descriptor */\nSolidParser.UseMtlDescriptor = /^usemtl /;\n/** Smooth descriptor */\nSolidParser.SmoothDescriptor = /^s /;\n// Patterns\n/** Pattern used to detect a vertex */\nSolidParser.VertexPattern = /^v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\n/** Pattern used to detect a normal */\nSolidParser.NormalPattern = /^vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a UV set */\nSolidParser.UVPattern = /^vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a first kind of face (f vertex vertex vertex) */\nSolidParser.FacePattern1 = /^f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n/** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\nSolidParser.FacePattern2 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.FacePattern3 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\nSolidParser.FacePattern4 = /^f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\nSolidParser.FacePattern5 = /^f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a line(l vertex vertex) */\nSolidParser.LinePattern1 = /^l\\s+(([\\d]{1,}[\\s]?){2,})+/;\n/** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */\nSolidParser.LinePattern2 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\n/** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.LinePattern3 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\n//# sourceMappingURL=solidParser.js.map","import { Vector2 } from \"core/Maths/math.vector\";\nimport { Tools } from \"core/Misc/tools\";\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { OBJFileLoaderMetadata } from \"./objFileLoader.metadata\";\nimport { MTLFileLoader } from \"./mtlFileLoader\";\nimport { SolidParser } from \"./solidParser\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class OBJFileLoader {\n    /**\n     * Invert Y-Axis of referenced textures on load\n     */\n    static get INVERT_TEXTURE_Y() {\n        return MTLFileLoader.INVERT_TEXTURE_Y;\n    }\n    static set INVERT_TEXTURE_Y(value) {\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\n    }\n    /**\n     * Creates loader for .OBJ files\n     *\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\n     */\n    constructor(loadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = OBJFileLoaderMetadata.name;\n        /**\n         * Defines the extension the plugin is able to load.\n         */\n        this.extensions = OBJFileLoaderMetadata.extensions;\n        this._assetContainer = null;\n        this._loadingOptions = { ...OBJFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\n    }\n    static get _DefaultLoadingOptions() {\n        return {\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n            invertY: OBJFileLoader.INVERT_Y,\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            UVScaling: OBJFileLoader.UV_SCALING,\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\n            useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,\n        };\n    }\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl defines where to load data from\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     * @param onFailure\n     */\n    _loadMTL(url, rootUrl, onSuccess, onFailure) {\n        //The complete path to the mtl file\n        const pathOfFile = rootUrl + url;\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request, exception) => {\n            onFailure(pathOfFile, exception);\n        });\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new OBJFileLoader(options[OBJFileLoaderMetadata.name]);\n    }\n    /**\n     * If the data string can be loaded directly.\n     * @returns if the data can be loaded directly\n     */\n    canDirectLoad() {\n        return false;\n    }\n    /**\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    importMeshAsync(meshesNames, scene, data, rootUrl) {\n        //get the meshes from OBJ file\n        // eslint-disable-next-line github/no-then\n        return this._parseSolidAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            };\n        });\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return (this.importMeshAsync(null, scene, data, rootUrl)\n            // eslint-disable-next-line github/no-then\n            .then((result) => {\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            result.meshes.forEach((mesh) => {\n                const material = mesh.material;\n                if (material) {\n                    // Materials\n                    if (container.materials.indexOf(material) == -1) {\n                        container.materials.push(material);\n                        // Textures\n                        const textures = material.getActiveTextures();\n                        textures.forEach((t) => {\n                            if (container.textures.indexOf(t) == -1) {\n                                container.textures.push(t);\n                            }\n                        });\n                    }\n                }\n            });\n            this._assetContainer = null;\n            return container;\n        })\n            // eslint-disable-next-line github/no-then\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        }));\n    }\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene defines the scene where are displayed the data\n     * @param data defines the content of the obj file\n     * @param rootUrl defines the path to the folder\n     * @returns the list of loaded meshes\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _parseSolidAsync(meshesNames, scene, data, rootUrl) {\n        let fileToLoad = \"\"; //The name of the mtlFile to load\n        const materialsFromMTLFile = new MTLFileLoader();\n        const materialToUse = [];\n        const babylonMeshesArray = []; //The mesh for babylon\n        // Sanitize data\n        data = data.replace(/#.*$/gm, \"\").trim();\n        // Main function\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName) => {\n            fileToLoad = fileName;\n        });\n        // load the materials\n        const mtlPromises = [];\n        // Check if we have a file to load\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, (dataLoaded) => {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\n                        //Look at each material loaded in the mtl file\n                        for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            let startIndex = 0;\n                            const _indices = [];\n                            let _index;\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index === -1 && _indices.length === 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            }\n                            else {\n                                for (let o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    const mesh = babylonMeshesArray[_indices[o]];\n                                    const material = materialsFromMTLFile.materials[n];\n                                    mesh.material = material;\n                                    if (!mesh.getTotalIndices()) {\n                                        // No indices, we need to turn on point cloud\n                                        material.pointsCloud = true;\n                                    }\n                                }\n                            }\n                        }\n                        resolve();\n                    }\n                    catch (e) {\n                        Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\n                        if (this._loadingOptions.materialLoadingFailsSilently) {\n                            resolve();\n                        }\n                        else {\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                            reject(e);\n                        }\n                    }\n                }, (pathOfFile, exception) => {\n                    Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\n                    if (this._loadingOptions.materialLoadingFailsSilently) {\n                        resolve();\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(exception);\n                    }\n                });\n            }));\n        }\n        //Return an array with all Mesh\n        // eslint-disable-next-line github/no-then\n        return Promise.all(mtlPromises).then(() => {\n            const isLine = (mesh) => Boolean(mesh._internalMetadata?.[\"_isLine\"] ?? false);\n            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.\n            babylonMeshesArray.forEach((mesh) => {\n                if (isLine(mesh)) {\n                    let mat = mesh.material ?? new StandardMaterial(mesh.name + \"_line\", scene);\n                    // If another mesh is using this material and it is not a line then we need to clone it.\n                    const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;\n                    if (needClone) {\n                        mat = mat.clone(mat.name + \"_line\") ?? mat;\n                    }\n                    mat.wireframe = true;\n                    mesh.material = mat;\n                    if (mesh._internalMetadata) {\n                        mesh._internalMetadata[\"_isLine\"] = undefined;\n                    }\n                }\n            });\n            return babylonMeshesArray;\n        });\n    }\n}\n/**\n * Defines if UVs are optimized by default during load.\n */\nOBJFileLoader.OPTIMIZE_WITH_UV = true;\n/**\n * Invert model on y-axis (does a model scaling inversion)\n */\nOBJFileLoader.INVERT_Y = false;\n/**\n * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n */\nOBJFileLoader.IMPORT_VERTEX_COLORS = false;\n/**\n * Compute the normals for the model, even if normals are present in the file.\n */\nOBJFileLoader.COMPUTE_NORMALS = false;\n/**\n * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n */\nOBJFileLoader.OPTIMIZE_NORMALS = false;\n/**\n * Defines custom scaling of UV coordinates of loaded meshes.\n */\nOBJFileLoader.UV_SCALING = new Vector2(1, 1);\n/**\n * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n */\nOBJFileLoader.SKIP_MATERIALS = false;\n/**\n * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n *\n * Defaults to true for backwards compatibility.\n */\nOBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;\n/**\n * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.\n */\nOBJFileLoader.USE_LEGACY_BEHAVIOR = false;\n//Add this loader into the register plugin\nRegisterSceneLoaderPlugin(new OBJFileLoader());\n//# sourceMappingURL=objFileLoader.js.map"],"names":["MTLFileLoader","constructor","this","materials","parseMTL","scene","data","rootUrl","assetContainer","ArrayBuffer","lines","split","delimiterPattern","color","material","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","value","push","_blockEntityCollection","StandardMaterial","_parentContainer","map","parseFloat","diffuseColor","Color3","FromArray","ambientColor","specularColor","emissiveColor","specularPower","alpha","ambientTexture","_GetTexture","diffuseTexture","specularTexture","values","bumpMultiplierIndex","bumpMultiplier","splice","bumpTexture","join","level","opacityTexture","url","lastDelimiter","lastIndexOf","Texture","INVERT_TEXTURE_Y","SolidParser","materialToUse","babylonMeshesArray","loadingOptions","_positions","_normals","_uvs","_colors","_extColors","_meshesFromObj","_indicesForBabylon","_wrappedPositionForBabylon","_wrappedUvsForBabylon","_wrappedColorsForBabylon","_wrappedNormalsForBabylon","_tuplePosNorm","_curPositionInIndices","_hasMeshes","_unwrappedPositionsForBabylon","_unwrappedColorsForBabylon","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","_triangles","_materialNameFromObj","_objMeshName","_increment","_isFirstMaterial","_grayColor","Color4","_hasLineData","_materialToUse","_babylonMeshesArray","_loadingOptions","_isInArray","arr","obj","normals","idx","_isInArrayUV","uv","_setData","indicePositionFromObj","indiceUvsFromObj","indiceNormalFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_index","optimizeWithUV","Vector2","undefined","_unwrapData","l","x","_handednessSign","y","z","importVertexColors","r","g","b","a","e","Error","_getTriangles","faces","v","faceIndex","_pushTriangle","_getColor","index","_setDataForCurrentFaceWithPattern1","face","k","parseInt","Zero","Vector3","Up","_setDataForCurrentFaceWithPattern2","point","_setDataForCurrentFaceWithPattern3","_setDataForCurrentFaceWithPattern4","_setDataForCurrentFaceWithPattern5","_addPreviousObjMesh","_handledMesh","useLegacyBehavior","reverse","indices","slice","positions","uvs","hasLines","colors","_optimizeNormals","mesh","getVerticesData","VertexBuffer","PositionKind","NormalKind","mapVertices","lst","normal","v0Idx","vIdx","copyFromFloats","normalize","setVerticesData","_IsLineElement","startsWith","_IsObjectElement","_IsGroupElement","_GetZbrushMRGB","notParse","replace","regArray","match","array","regIndex","parse","meshesNames","onFileToLoadFound","useRightHandedSystem","linesOBJ","lineLines","currentGroup","lineValues","flat","result","VertexPattern","test","NormalPattern","exec","UVPattern","UVScaling","FacePattern3","FacePattern4","FacePattern5","FacePattern2","FacePattern1","LinePattern1","LinePattern2","element","LinePattern3","GroupDescriptor","ObjectDescriptor","objMesh","name","materialName","isObject","UseMtlDescriptor","toString","MtlLibGroupDescriptor","SmoothDescriptor","Logger","Log","newMaterial","Geometry","RandomId","pointsCloud","disableLighting","White","directMaterial","j","Array","babylonMesh","Mesh","_babylonMesh","parent","_internalMetadata","vertexData","VertexData","computeNormals","ComputeNormals","applyToMesh","invertY","scaling","optimizeNormals","OBJFileLoader","OBJFileLoaderMetadata","extensions","_assetContainer","_DefaultLoadingOptions","COMPUTE_NORMALS","OPTIMIZE_NORMALS","IMPORT_VERTEX_COLORS","INVERT_Y","invertTextureY","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","OPTIMIZE_WITH_UV","skipMaterials","SKIP_MATERIALS","USE_LEGACY_BEHAVIOR","_loadMTL","onSuccess","onFailure","pathOfFile","Tools","LoadFile","request","exception","createPlugin","options","canDirectLoad","importMeshAsync","_parseSolidAsync","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","loadAsync","loadAssetContainerAsync","container","AssetContainer","forEach","getActiveTextures","t","textures","catch","ex","fileToLoad","materialsFromMTLFile","fileName","mtlPromises","Promise","resolve","reject","dataLoaded","n","startIndex","_indices","dispose","o","getTotalIndices","Warn","all","isLine","Boolean","mat","getBindedMeshes","filter","clone","wireframe","RegisterSceneLoaderPlugin"],"mappings":"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"}