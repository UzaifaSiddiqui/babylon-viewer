import{bY as e,C as n}from"./index-VvGulz6u.esm.min.js";function l(e){return e.split(" ").filter((e=>""!==e)).map((e=>parseFloat(e)))}function t(e,n,t){for(;t.length!==n;){const n=l(e.lines[e.index++]);t.push(...n)}}function a(n,l,t){let a=0,r=0,i=0,o=0,s=0,u=0;for(let e=0;e<n.numberOfHorizontalAngles-1;e++)if(t<n.horizontalAngles[e+1]||e===n.numberOfHorizontalAngles-2){r=e,i=n.horizontalAngles[e],o=n.horizontalAngles[e+1];break}for(let e=0;e<n.numberOfVerticalAngles-1;e++)if(l<n.verticalAngles[e+1]||e===n.numberOfVerticalAngles-2){a=e,s=n.verticalAngles[e],u=n.verticalAngles[e+1];break}const c=o-i,f=u-s;if(0===f)return 0;const g=0===c?0:(t-i)/c,d=(l-s)/f,A=0===c?r:r+1,m=e(n.candelaValues[r][a],n.candelaValues[A][a],g),b=e(n.candelaValues[r][a+1],n.candelaValues[A][a+1],g);return e(m,b,d)}class r{constructor(){this.supportCascades=!1}loadCubeData(){throw".ies not supported in Cube."}loadData(e,r,i){const o=function(e){const n={lines:new TextDecoder("utf-8").decode(e).split("\n"),index:0},r={version:n.lines[0],candelaValues:[],horizontalAngles:[],verticalAngles:[],numberOfHorizontalAngles:0,numberOfVerticalAngles:0};for(n.index=1;n.lines.length>0&&!n.lines[n.index].includes("TILT=");)n.index++;n.lines[n.index].includes("INCLUDE"),n.index++;const i=l(n.lines[n.index++]);r.numberOfLights=i[0],r.lumensPerLamp=i[1],r.candelaMultiplier=i[2],r.numberOfVerticalAngles=i[3],r.numberOfHorizontalAngles=i[4],r.photometricType=i[5],r.unitsType=i[6],r.width=i[7],r.length=i[8],r.height=i[9];const o=l(n.lines[n.index++]);r.ballastFactor=o[0],r.fileGenerationType=o[1],r.inputWatts=o[2];for(let e=0;e<r.numberOfHorizontalAngles;e++)r.candelaValues[e]=[];t(n,r.numberOfVerticalAngles,r.verticalAngles),t(n,r.numberOfHorizontalAngles,r.horizontalAngles);for(let e=0;e<r.numberOfHorizontalAngles;e++)t(n,r.numberOfVerticalAngles,r.candelaValues[e]);let s=-1;for(let e=0;e<r.numberOfHorizontalAngles;e++)for(let n=0;n<r.numberOfVerticalAngles;n++)r.candelaValues[e][n]*=r.candelaValues[e][n]*r.candelaMultiplier*r.ballastFactor*r.fileGenerationType,s=Math.max(s,r.candelaValues[e][n]);if(s>0)for(let e=0;e<r.numberOfHorizontalAngles;e++)for(let n=0;n<r.numberOfVerticalAngles;n++)r.candelaValues[e][n]/=s;const u=180,c=360,f=new Float32Array(64800),g=r.horizontalAngles[0],d=r.horizontalAngles[r.numberOfHorizontalAngles-1];for(let e=0;e<64800;e++){let n=e%c;const l=Math.floor(e/c);d-g!==0&&(n<g||n>=d)&&(n%=2*d,n>d&&(n=2*d-n)),f[l+n*u]=a(r,l,n)}return{width:180,height:1,data:f}}(new Uint8Array(e.buffer,e.byteOffset,e.byteLength));i(o.width,o.height,!1,!1,(()=>{const e=r.getEngine();r.type=n.TEXTURETYPE_FLOAT,r.format=n.TEXTUREFORMAT_R,r._gammaSpace=!1,e._uploadDataToTextureDirectly(r,o.data)}))}}export{r as _IESTextureLoader};
//# sourceMappingURL=iesTextureLoader-Bj2RCR3p.esm.min.js.map
