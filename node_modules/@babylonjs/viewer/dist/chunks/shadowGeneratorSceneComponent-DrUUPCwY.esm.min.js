import{ShadowGenerator as e}from"./shadowGenerator-C6b4ZqcE.esm.min.js";import{S as t,C as s,T as i,j as n,h as r,m as a,Z as o,n as d,o as h,p as c,A as u,a1 as f,N as _,r as l,s as m,_ as p,E as g,k as x,O as S,a2 as M,P as C,V as E,M as v,L as R,G as T,a3 as A,F as b}from"./index-VvGulz6u.esm.min.js";import"./clipPlaneFragment-C3r_yKEC.esm.min.js";import"./packingFunctions-BIXXOBSk.esm.min.js";import"./bakedVertexAnimation-ZcUEZG1Y.esm.min.js";import"./morphTargetsVertex-COI8GCU6.esm.min.js";import"./clipPlaneVertex-D6MroPJQ.esm.min.js";import"./instancesDeclaration-C27zs-OM.esm.min.js";import"./pointCloudVertex-BTuK3ESl.esm.min.js";const D="depthPixelShader",w="#ifdef ALPHATEST\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\n#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}";t.ShadersStore[D]||(t.ShadersStore[D]=w);const P={name:D,shader:w};var F=Object.freeze({__proto__:null,depthPixelShader:P});const I="pointCloudVertexDeclaration";t.IncludesShadersStore[I]||(t.IncludesShadersStore[I]="#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n");const z="depthVertexShader",L="attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;varying vec4 vViewPos;\n#endif\n#include<pointCloudVertexDeclaration>\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef UV2\nvec2 uv2Updated=uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n#include<pointCloudVertex>\n}\n";t.ShadersStore[z]||(t.ShadersStore[z]=L);const O={name:z,shader:L};var B,U=Object.freeze({__proto__:null,depthVertexShader:O});class N{get shaderLanguage(){return this._shaderLanguage}setMaterialForRendering(e,t){this._depthMap.setMaterialForRendering(e,t)}constructor(e,t=s.TEXTURETYPE_FLOAT,a=null,o=!1,d=i.TRILINEAR_SAMPLINGMODE,h=!1,c){this._shaderLanguage=0,this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._shadersLoaded=!1,this._scene=e,this._storeNonLinearDepth=o,this._storeCameraSpaceZ=h,this.isPacked=t===s.TEXTURETYPE_UNSIGNED_BYTE,this.isPacked?this.clearColor=new n(1,1,1,1):this.clearColor=new n(h?0:1,0,0,1),this._initShaderSourceAsync(),N._SceneComponentInitialization(this._scene);const u=e.getEngine();this._camera=a,d!==i.NEAREST_SAMPLINGMODE&&(t!==s.TEXTURETYPE_FLOAT||u._caps.textureFloatLinearFiltering||(d=i.NEAREST_SAMPLINGMODE),t!==s.TEXTURETYPE_HALF_FLOAT||u._caps.textureHalfFloatLinearFiltering||(d=i.NEAREST_SAMPLINGMODE));const p=this.isPacked||!u._features.supportExtendedTextureFormats?s.TEXTUREFORMAT_RGBA:s.TEXTUREFORMAT_R;this._depthMap=new r(c??"DepthRenderer",{width:u.getRenderWidth(),height:u.getRenderHeight()},this._scene,!1,!0,t,!1,d,void 0,void 0,void 0,p),this._depthMap.wrapU=i.CLAMP_ADDRESSMODE,this._depthMap.wrapV=i.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add((e=>{e.clear(this.clearColor,!0,!0,!0)})),this._depthMap.onBeforeBindObservable.add((()=>{u._debugPushGroup?.("depth renderer",1)})),this._depthMap.onAfterUnbindObservable.add((()=>{u._debugPopGroup?.(1)})),this._depthMap.customIsReadyFunction=(e,t,s)=>{if((s||0===t)&&e.subMeshes)for(let t=0;t<e.subMeshes.length;++t){const s=e.subMeshes[t],i=s.getRenderingMesh(),n=i._getInstancesRenderList(s._id,!!s.getReplacementMesh()),r=u.getCaps().instancedArrays&&(null!==n.visibleInstances[s._id]&&void 0!==n.visibleInstances[s._id]||i.hasThinInstances);if(!this.isReady(s,r))return!1}return!0};const g=e=>{const t=e.getRenderingMesh(),i=e.getEffectiveMesh(),n=this._scene,r=n.getEngine(),a=e.getMaterial();if(i._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!a||i.infiniteDistance||a.disableDepthWrite||0===e.verticesCount||e._renderId===n.getRenderId())return;const o=i._getWorldMatrixDeterminant()<0;let d=a._getEffectiveOrientation(t);o&&(d=d===s.MATERIAL_ClockWiseSideOrientation?s.MATERIAL_CounterClockWiseSideOrientation:s.MATERIAL_ClockWiseSideOrientation);const h=d===s.MATERIAL_ClockWiseSideOrientation;r.setState(a.backFaceCulling,0,!1,h,this.reverseCulling?!a.cullBackFaces:a.cullBackFaces);const c=t._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(c.mustReturn)return;const u=r.getCaps().instancedArrays&&(null!==c.visibleInstances[e._id]&&void 0!==c.visibleInstances[e._id]||t.hasThinInstances),p=this._camera||n.activeCamera;if(this.isReady(e,u)&&p){e._renderId=n.getRenderId();const s=i._internalAbstractMeshDataInfo._materialForRenderPass?.[r.currentRenderPassId];let o=e._getDrawWrapper();!o&&s&&(o=s._getDrawWrapper());const d=p.mode===f.ORTHOGRAPHIC_CAMERA;if(!o)return;const h=o.effect;let g,x;if(r.enableEffect(o),u||t._bind(e,h,a.fillMode),s?s.bindForSubMesh(i.getWorldMatrix(),i,e):(h.setMatrix("viewProjection",n.getTransformMatrix()),h.setMatrix("world",i.getWorldMatrix()),this._storeCameraSpaceZ&&h.setMatrix("view",n.getViewMatrix())),d?(g=!r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1,x=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1):(g=r.useReverseDepthBuffer&&r.isNDCHalfZRange?p.minZ:r.isNDCHalfZRange?0:p.minZ,x=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:p.maxZ),h.setFloat2("depthValues",g,g+x),!s){if(a.needAlphaTestingForMesh(i)){const e=a.getAlphaTestTexture();e&&(h.setTexture("diffuseSampler",e),h.setMatrix("diffuseMatrix",e.getTextureMatrix()))}_(t,h),l(h,a,n),m(t,h),t.morphTargetManager&&t.morphTargetManager.isUsingTextureForTargets&&t.morphTargetManager._bind(h);const s=e.getMesh().bakedVertexAnimationManager;s&&s.isEnabled&&s.bind(h,u),a.pointsCloud&&h.setFloat("pointSize",a.pointSize)}t._processRendering(i,e,h,a.fillMode,c,u,((e,t)=>h.setMatrix("world",t)))}};this._depthMap.customRenderFunction=(e,t,s,i)=>{let n;if(i.length)for(n=0;n<i.length;n++)g(i.data[n]);for(n=0;n<e.length;n++)g(e.data[n]);for(n=0;n<t.length;n++)g(t.data[n]);if(this.forceDepthWriteTransparentMeshes)for(n=0;n<s.length;n++)g(s.data[n]);else for(n=0;n<s.length;n++)s.data[n].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}async _initShaderSourceAsync(e=!1){!this._scene.getEngine().isWebGPU||e||N.ForceGLSL?await Promise.all([Promise.resolve().then((function(){return U})),Promise.resolve().then((function(){return F}))]):(this._shaderLanguage=1,await Promise.all([import("./depth.vertex-DOsT-5r-.esm.min.js"),import("./depth.fragment-DLRFiDmm.esm.min.js")])),this._shadersLoaded=!0}isReady(e,t){if(!this._shadersLoaded)return!1;const s=this._scene.getEngine(),i=e.getMesh(),n=i.getScene(),r=i._internalAbstractMeshDataInfo._materialForRenderPass?.[s.currentRenderPassId];if(r)return r.isReadyForSubMesh(i,e,t);const f=e.getMaterial();if(!f||f.disableDepthWrite)return!1;const _=[],l=[a.PositionKind];let m=!1,p=!1;f.needAlphaTestingForMesh(i)&&f.getAlphaTestTexture()&&(_.push("#define ALPHATEST"),i.isVerticesDataPresent(a.UVKind)&&(l.push(a.UVKind),_.push("#define UV1"),m=!0),i.isVerticesDataPresent(a.UV2Kind)&&(l.push(a.UV2Kind),_.push("#define UV2"),p=!0));const g=new o;if(i.useBones&&i.computeBonesUsingShaders&&i.skeleton){l.push(a.MatricesIndicesKind),l.push(a.MatricesWeightsKind),i.numBoneInfluencers>4&&(l.push(a.MatricesIndicesExtraKind),l.push(a.MatricesWeightsExtraKind)),_.push("#define NUM_BONE_INFLUENCERS "+i.numBoneInfluencers),i.numBoneInfluencers>0&&g.addCPUSkinningFallback(0,i);const e=i.skeleton;e.isUsingTextureForMatrices?_.push("#define BONETEXTURE"):_.push("#define BonesPerMesh "+(e.bones.length+1))}else _.push("#define NUM_BONE_INFLUENCERS 0");const x=i.morphTargetManager?d(i.morphTargetManager,_,l,i,!0,!1,!1,m,p,!1):0;f.pointsCloud&&_.push("#define POINTSIZE"),t&&(_.push("#define INSTANCES"),h(l),e.getRenderingMesh().hasThinInstances&&_.push("#define THIN_INSTANCES"));const S=i.bakedVertexAnimationManager;S&&S.isEnabled&&(_.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&l.push("bakedVertexAnimationSettingsInstanced")),this._storeNonLinearDepth&&_.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&_.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&_.push("#define PACKED"),c(f,n,_);const M=e._getDrawWrapper(void 0,!0),C=M.defines,E=_.join("\n");if(C!==E){const e=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],t=["diffuseSampler","morphTargets","boneSampler","bakedVertexAnimationTexture"];u(e),M.setEffect(s.createEffect("depth",{attributes:l,uniformsNames:e,uniformBuffersNames:[],samplers:t,defines:E,fallbacks:g,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:x},shaderLanguage:this._shaderLanguage},s),E)}return M.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const t in this._scene._depthRenderer){this._scene._depthRenderer[t]===this&&e.push(t)}if(e.length>0){this._depthMap.dispose();for(const t of e)delete this._scene._depthRenderer[t]}}}N.ForceGLSL=!1,N._SceneComponentInitialization=e=>{throw p("DepthRendererSceneComponent")},function(e){e[e.NormalizedViewDepth=0]="NormalizedViewDepth",e[e.ViewDepth=1]="ViewDepth",e[e.ScreenDepth=2]="ScreenDepth"}(B||(B={}));class y extends g{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.resolve().then((function(){return q})))):t.push(Promise.resolve().then((function(){return j})))}constructor(e,t=null,s="",i){super({...i,name:e,engine:t||x.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:y.FragmentUrl,uniforms:y.Uniforms,defines:s}),this.textureWidth=0,this.textureHeight=0}bind(e=!1){super.bind(e);const t=this.drawWrapper.effect;1===this.textureWidth||1===this.textureHeight?t.setInt2("texSize",this.textureWidth,this.textureHeight):t.setFloat2("texSize",this.textureWidth,this.textureHeight)}}y.FragmentUrl="minmaxRedux",y.Uniforms=["texSize"];const V=new Float32Array(4),W=new Uint8Array(4),k={min:0,max:0};class H{get depthRedux(){return this._depthRedux}set depthRedux(e){this._depthRedux!==e&&(this._depthRedux=e,this._recreatePostProcesses())}get textureWidth(){return this._textureWidth}get textureHeight(){return this._textureHeight}constructor(e,t=!0){this.onAfterReductionPerformed=new S,this._textureWidth=0,this._textureHeight=0,this._scene=e,this._depthRedux=t,this.reductionSteps=[]}setTextureDimensions(e,t,s=0){return(e!==this._textureWidth||t!==this._textureHeight||s!==this._depthTextureType)&&(this._textureWidth=e,this._textureHeight=t,this._depthTextureType=s,this._recreatePostProcesses(),!0)}readMinMax(e){const t=e.type===x.TEXTURETYPE_FLOAT||e.type===x.TEXTURETYPE_HALF_FLOAT,s=t?V:W;this._scene.getEngine()._readTexturePixels(e,1,1,-1,0,s,!1),k.min=s[0],k.max=s[1],t||(k.min=k.min/255,k.max=k.max/255),k.min>=k.max&&(k.min=0,k.max=1),this.onAfterReductionPerformed.notifyObservers(k)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._textureWidth=0,this._textureHeight=0);for(let e=0;e<this.reductionSteps.length;++e)this.reductionSteps[e].dispose();this.reductionSteps.length=0}_recreatePostProcesses(){this.dispose(!1);const e=this._scene;let t=this.textureWidth,s=this.textureHeight;const i=new y("Initial reduction phase",e.getEngine(),"#define INITIAL"+(this._depthRedux?"\n#define DEPTH_REDUX":"")+(1===this._depthTextureType?"\n#define VIEW_DEPTH":""));i.textureWidth=t,i.textureHeight=s,this.reductionSteps.push(i);let n=1;for(;t>1||s>1;){t=Math.max(Math.round(t/2),1),s=Math.max(Math.round(s/2),1);const i=new y("Reduction phase "+n,e.getEngine(),"#define "+(1==t&&1==s?"LAST":1==t||1==s?"ONEBEFORELAST":"MAIN"));i.textureWidth=t,i.textureHeight=s,this.reductionSteps.push(i),n++}}}const Z="minmaxReduxPixelShader",G="varying vec2 vUV;uniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(textureSampler,coord,0).r;float f2=texelFetch(textureSampler,coord+ivec2(1,0),0).r;float f3=texelFetch(textureSampler,coord+ivec2(1,1),0).r;float f4=texelFetch(textureSampler,coord+ivec2(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nfloat minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\nvoid main(void)\n{glFragColor=vec4(0.);if (true) { \ndiscard;}}\n#endif\n";t.ShadersStore[Z]||(t.ShadersStore[Z]=G);const X={name:Z,shader:G};var j=Object.freeze({__proto__:null,minmaxReduxPixelShader:X});const K="minmaxReduxPixelShader",Y="varying vUV: vec2f;var textureSampler: texture_2d<f32>;\n#if defined(INITIAL)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).r;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).r;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).r;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nvar minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nlet maxz=max(max(max(f1,f2),f3),f4);\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(f1,f2),f3),f4);\n#endif\nfragmentOutputs.color=vec4f(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).rg;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).rg;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).rg;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform texSize: vec2i;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*vec2f(uniforms.texSize-1));let f1=textureLoad(textureSampler,coord % uniforms.texSize,0).rg;let f2=textureLoad(textureSampler,(coord+vec2i(1,0)) % uniforms.texSize,0).rg;let f3=textureLoad(textureSampler,(coord+vec2i(1,1)) % uniforms.texSize,0).rg;let f4=textureLoad(textureSampler,(coord+vec2i(0,1)) % uniforms.texSize,0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(0.);if (true) { \ndiscard;}}\n#endif\n";t.ShadersStoreWGSL[K]||(t.ShadersStoreWGSL[K]=Y);const $={name:K,shader:Y};var q=Object.freeze({__proto__:null,minmaxReduxPixelShaderWGSL:$});class J{get onAfterReductionPerformed(){return this._thinMinMaxReducer.onAfterReductionPerformed}constructor(e){this._onAfterUnbindObserver=null,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=e,this._postProcessManager=new M(e.getScene()),this._thinMinMaxReducer=new H(e.getScene()),this._reductionSteps=[],this._onContextRestoredObserver=e.getEngine().onContextRestoredObservable.add((()=>{this._postProcessManager._rebuild()}))}get sourceTexture(){return this._sourceTexture}setSourceTexture(e,t,i=s.TEXTURETYPE_HALF_FLOAT,n=!0){if(e!==this._sourceTexture&&(this._thinMinMaxReducer.depthRedux=t,this.deactivate(),this._sourceTexture=e,this._forceFullscreenViewport=n,this._thinMinMaxReducer.setTextureDimensions(e.getRenderWidth(),e.getRenderHeight()))){this._disposePostProcesses();const e=this._thinMinMaxReducer.reductionSteps;for(let t=0;t<e.length;++t){const r=e[t],a=new C(r.name,y.FragmentUrl,{effectWrapper:r,samplingMode:s.TEXTURE_NEAREST_NEAREST,engine:this._camera.getScene().getEngine(),textureType:i,textureFormat:s.TEXTUREFORMAT_RG,size:{width:r.textureWidth,height:r.textureHeight}});this._reductionSteps.push(a),a.autoClear=!1,a.forceFullscreenViewport=n,0===t&&(a.externalTextureSamplerBinding=!0,a.onApplyObservable.add((e=>{e.setTexture("textureSampler",this._sourceTexture)}))),t===e.length-1&&this._reductionSteps[t-1].onAfterRenderObservable.add((()=>{this._thinMinMaxReducer.readMinMax(a.inputTexture.texture)}))}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(e){this._sourceTexture&&(this._sourceTexture.refreshRate=e)}get activated(){return this._activated}activate(){!this._onAfterUnbindObserver&&this._sourceTexture&&(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add((()=>{const e=this._camera.getScene().getEngine();e._debugPushGroup?.("min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport,0,0,!0,this._reductionSteps.length-1),e.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length-1].inputTexture,!1),e._debugPopGroup?.(1)})),this._activated=!0)}deactivate(){this._onAfterUnbindObserver&&this._sourceTexture&&(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=void 0,this._disposePostProcesses(),this._postProcessManager.dispose(),this._postProcessManager=void 0,this._thinMinMaxReducer.dispose(),this._thinMinMaxReducer=void 0,this._sourceTexture=null)}_disposePostProcesses(){for(let e=0;e<this._reductionSteps.length;++e)this._reductionSteps[e].dispose();this._reductionSteps.length=0}}class Q extends J{get depthRenderer(){return this._depthRenderer}constructor(e){super(e)}setDepthRenderer(e=null,t=s.TEXTURETYPE_HALF_FLOAT,i=!0){const n=this._camera.getScene();this._depthRenderer&&(delete n._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),null===e&&(n._depthRenderer||(n._depthRenderer={}),this._depthRendererId="minmax_"+this._camera.id,(e=this._depthRenderer=new N(n,t,this._camera,!1,s.TEXTURE_NEAREST_SAMPLINGMODE,!1,`DepthRenderer ${this._depthRendererId}`)).enabled=!1,n._depthRenderer[this._depthRendererId]=e),super.setSourceTexture(e.getDepthMap(),!0,t,i)}setSourceTexture(e,t,i=s.TEXTURETYPE_HALF_FLOAT,n=!0){super.setSourceTexture(e,t,i,n)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(e=!0){super.dispose(e),this._depthRenderer&&e&&(this._depthRenderer.dispose(),this._depthRenderer=null)}}const ee=E.Up(),te=E.Zero(),se=new E,ie=new E,ne=new v;class re extends e{_validateFilter(t){return t===e.FILTER_NONE||t===e.FILTER_PCF||t===e.FILTER_PCSS?t:(R.Error('Unsupported filter "'+t+'"!'),e.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(e){(e=Math.min(Math.max(e,re.MIN_CASCADES_COUNT),re.MAX_CASCADES_COUNT))!==this._numCascades&&(this._numCascades=e,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(e){this._freezeShadowCastersBoundingInfoObservable&&e&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._freezeShadowCastersBoundingInfoObservable||e||(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add((()=>this._computeShadowCastersBoundingInfo()))),this._freezeShadowCastersBoundingInfo=e,e&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const e=this._shadowMap.renderList;for(let t=0;t<e.length;t++){const s=e[t];if(!s)continue;const i=s.getBoundingInfo().boundingBox;this._scbiMin.minimizeInPlace(i.minimumWorld),this._scbiMax.maximizeInPlace(i.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(e){this._shadowCastersBoundingInfo=e}setMinMaxDistance(e,t){this._minDistance===e&&this._maxDistance===t||(e>t&&(e=0,t=1),e<0&&(e=0),t>1&&(t=1),this._minDistance=e,this._maxDistance=t,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return re.CLASSNAME}getCascadeMinExtents(e){return e>=0&&e<this._numCascades?this._cascadeMinExtents[e]:null}getCascadeMaxExtents(e){return e>=0&&e<this._numCascades?this._cascadeMaxExtents[e]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(e){const t=this._getCamera();t?this._shadowMaxZ===e||e<t.minZ||e>t.maxZ&&0!==t.maxZ||(this._shadowMaxZ=e,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0):this._shadowMaxZ=e}get debug(){return this._debug}set debug(e){this._debug=e,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(e){this._depthClamp=e}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){this._cascadeBlendPercentage=e,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(e){const t=Math.min(Math.max(e,0),1);this._lambda!=t&&(this._lambda=t,this._breaksAreDirty=!0)}getCascadeViewMatrix(e){return e>=0&&e<this._numCascades?this._viewMatrices[e]:null}getCascadeProjectionMatrix(e){return e>=0&&e<this._numCascades?this._projectionMatrices[e]:null}getCascadeTransformMatrix(e){return e>=0&&e<this._numCascades?this._transformMatrices[e]:null}setDepthRenderer(e){this._depthRenderer=e,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){const t=this._getCamera();if(t){if(this._autoCalcDepthBounds=e,!e)return this._depthReducer&&this._depthReducer.deactivate(),void this.setMinMaxDistance(0,1);this._depthReducer||(this._depthReducer=new Q(t),this._depthReducer.onAfterReductionPerformed.add((e=>{let t=e.min,s=e.max;t>=s&&(t=0,s=1),t==this._minDistance&&s==this._maxDistance||this.setMinMaxDistance(t,s)})),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate??-1}set autoCalcDepthBoundsRefreshRate(e){this._depthReducer?.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=e)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const e=this._getCamera();if(!e)return;const t=e.minZ,s=e.maxZ||this._shadowMaxZ,i=s-t,n=this._minDistance,r=t+n*i,a=t+(this._shadowMaxZ<s&&this._shadowMaxZ>=t?Math.min((this._shadowMaxZ-t)/(s-t),this._maxDistance):this._maxDistance)*i,o=a-r,d=a/r;for(let e=0;e<this._cascades.length;++e){const s=(e+1)/this._numCascades,a=r*d**s,h=r+o*s,c=this._lambda*(a-h)+h;this._cascades[e].prevBreakDistance=0===e?n:this._cascades[e-1].breakDistance,this._cascades[e].breakDistance=(c-t)/i,this._viewSpaceFrustumsZ[e]=c,this._frustumLengths[e]=(this._cascades[e].breakDistance-this._cascades[e].prevBreakDistance)*i}this._breaksAreDirty=!1}_computeMatrices(){const t=this._scene;if(!this._getCamera())return;E.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),1===Math.abs(E.Dot(this._lightDirection,E.Up()))&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const s=t.getEngine().useReverseDepthBuffer;for(let i=0;i<this._numCascades;++i){this._computeFrustumInWorldSpace(i),this._computeCascadeFrustum(i),this._cascadeMaxExtents[i].subtractToRef(this._cascadeMinExtents[i],se),this._frustumCenter[i].addToRef(this._lightDirection.scale(this._cascadeMinExtents[i].z),this._shadowCameraPos[i]),v.LookAtLHToRef(this._shadowCameraPos[i],this._frustumCenter[i],ee,this._viewMatrices[i]);let n=0,r=se.z;const a=this._shadowCastersBoundingInfo;a.update(this._viewMatrices[i]);const o=a.boundingBox.minimumWorld.z,d=a.boundingBox.maximumWorld.z;o>r||(this._depthClamp&&this.filter!==e.FILTER_PCSS?(r=Math.min(r,d),n=Math.max(n,o),r=Math.max(n+1,r)):(n=Math.min(n,o),this.filter!==e.FILTER_PCSS&&(r=Math.min(r,d)))),v.OrthoOffCenterLHToRef(this._cascadeMinExtents[i].x,this._cascadeMaxExtents[i].x,this._cascadeMinExtents[i].y,this._cascadeMaxExtents[i].y,s?r:n,s?n:r,this._projectionMatrices[i],t.getEngine().isNDCHalfZRange),this._cascadeMinExtents[i].z=n,this._cascadeMaxExtents[i].z=r,this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i],this._transformMatrices[i]),E.TransformCoordinatesToRef(te,this._transformMatrices[i],se),se.scaleInPlace(this._mapSize/2),ie.copyFromFloats(Math.round(se.x),Math.round(se.y),Math.round(se.z)),ie.subtractInPlace(se).scaleInPlace(2/this._mapSize),v.TranslationToRef(ie.x,ie.y,0,ne),this._projectionMatrices[i].multiplyToRef(ne,this._projectionMatrices[i]),this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i],this._transformMatrices[i]),this._transformMatrices[i].copyToArray(this._transformMatricesAsArray,16*i)}}_computeFrustumInWorldSpace(e){const t=this._getCamera();if(!t)return;const s=this._cascades[e].prevBreakDistance,i=this._cascades[e].breakDistance,n=this._scene.getEngine().isNDCHalfZRange;t.getViewMatrix();const r=0===t.maxZ,a=t.maxZ;r&&(t.maxZ=this._shadowMaxZ,t.getProjectionMatrix(!0));const o=v.Invert(t.getTransformationMatrix());r&&(t.maxZ=a,t.getProjectionMatrix(!0));const d=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let t=0;t<re._FrustumCornersNdcSpace.length;++t)se.copyFrom(re._FrustumCornersNdcSpace[(t+d)%re._FrustumCornersNdcSpace.length]),n&&-1===se.z&&(se.z=0),E.TransformCoordinatesToRef(se,o,this._frustumCornersWorldSpace[e][t]);for(let t=0;t<re._FrustumCornersNdcSpace.length/2;++t)se.copyFrom(this._frustumCornersWorldSpace[e][t+4]).subtractInPlace(this._frustumCornersWorldSpace[e][t]),ie.copyFrom(se).scaleInPlace(s),se.scaleInPlace(i),se.addInPlace(this._frustumCornersWorldSpace[e][t]),this._frustumCornersWorldSpace[e][t+4].copyFrom(se),this._frustumCornersWorldSpace[e][t].addInPlace(ie)}_computeCascadeFrustum(e){this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[e].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[e].copyFromFloats(0,0,0);if(this._getCamera()){for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][t]);if(this._frustumCenter[e].scaleInPlace(1/this._frustumCornersWorldSpace[e].length),this.stabilizeCascades){let t=0;for(let s=0;s<this._frustumCornersWorldSpace[e].length;++s){const i=this._frustumCornersWorldSpace[e][s].subtractToRef(this._frustumCenter[e],se).length();t=Math.max(t,i)}t=Math.ceil(16*t)/16,this._cascadeMaxExtents[e].copyFromFloats(t,t,t),this._cascadeMinExtents[e].copyFromFloats(-t,-t,-t)}else{const t=this._frustumCenter[e];this._frustumCenter[e].addToRef(this._lightDirection,se),v.LookAtLHToRef(t,se,ee,ne);for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)E.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][t],ne,se),this._cascadeMinExtents[e].minimizeInPlace(se),this._cascadeMaxExtents[e].maximizeInPlace(se)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let e=0;e<this._numCascades;++e)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`))}static get IsSupported(){const e=T.LastCreatedEngine;return!!e&&e._features.supportCSM}constructor(e,t,s,i,n=!0){re.IsSupported?(super(e,t,s,i,n),this.usePercentageCloserFiltering=!0):R.Error("CascadedShadowMap is not supported by the current engine.")}_initializeGenerator(){this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??re.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new E(0,0,0),this._scbiMax=this._scbiMax??new E(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new A(new E(0,0,0),new E(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??this._getCamera()?.maxZ??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const e=this._scene.getEngine(),t={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new r(this._light.name+"_CSMShadowMap",t,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?s.TEXTUREFORMAT_RED:s.TEXTUREFORMAT_RGBA),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?s.GREATER:s.LESS,!0,void 0,void 0,void 0,`DepthStencilForCSMShadowGenerator-${this._light.name}`),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),null===this._shadowMap)return;this._transformMatricesAsArray=new Float32Array(16*this._numCascades),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(2*this._numCascades),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let e=0;e<this._numCascades;++e){this._cascades[e]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[e]=v.Zero(),this._projectionMatrices[e]=v.Zero(),this._transformMatrices[e]=v.Zero(),this._cascadeMinExtents[e]=new E,this._cascadeMaxExtents[e]=new E,this._frustumCenter[e]=new E,this._shadowCameraPos[e]=new E,this._frustumCornersWorldSpace[e]=new Array(re._FrustumCornersNdcSpace.length);for(let t=0;t<re._FrustumCornersNdcSpace.length;++t)this._frustumCornersWorldSpace[e][t]=new E}const t=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add((s=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[s]),this._currentLayer=s,this._filter===e.FILTER_PCF&&t.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(s),this.getCascadeProjectionMatrix(s)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())})),this._shadowMap.onBeforeBindObservable.add((()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),t._debugPushGroup?.(`cascaded shadow map generation for pass id ${t.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()})),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(e,t){t.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(t){t.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==e.FILTER_PCSS?"1":"0"))}prepareDefines(e,t){super.prepareDefines(e,t);const s=this._scene,i=this._light;if(!s.shadowsEnabled||!i.shadowEnabled)return;e["SHADOWCSM"+t]=!0,e["SHADOWCSMDEBUG"+t]=this.debug,e["SHADOWCSMNUM_CASCADES"+t]=this.numCascades,e["SHADOWCSM_RIGHTHANDED"+t]=s.useRightHandedSystem;const n=this._getCamera();n&&this._shadowMaxZ<=(n.maxZ||this._shadowMaxZ)&&(e["SHADOWCSMUSESHADOWMAXZ"+t]=!0),0===this.cascadeBlendPercentage&&(e["SHADOWCSMNOBLEND"+t]=!0)}bindShadowLight(t,s){const i=this._light;if(!this._scene.shadowsEnabled||!i.shadowEnabled)return;const n=this._getCamera();if(!n)return;const r=this.getShadowMap();if(!r)return;const a=r.getSize().width;if(s.setMatrices("lightMatrix"+t,this._transformMatricesAsArray),s.setArray("viewFrustumZ"+t,this._viewSpaceFrustumsZ),s.setFloat("cascadeBlendFactor"+t,0===this.cascadeBlendPercentage?1e4:1/this.cascadeBlendPercentage),s.setArray("frustumLengths"+t,this._frustumLengths),this._filter===e.FILTER_PCF)s.setDepthStencilTexture("shadowTexture"+t,r),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),a,1/a,this.frustumEdgeFalloff,t);else if(this._filter===e.FILTER_PCSS){for(let e=0;e<this._numCascades;++e)this._lightSizeUVCorrection[2*e+0]=0===e?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[e].x-this._cascadeMinExtents[e].x),this._lightSizeUVCorrection[2*e+1]=0===e?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[e].y-this._cascadeMinExtents[e].y),this._depthCorrection[e]=0===e?1:(this._cascadeMaxExtents[e].z-this._cascadeMinExtents[e].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);s.setDepthStencilTexture("shadowTexture"+t,r),s.setTexture("depthTexture"+t,r),s.setArray2("lightSizeUVCorrection"+t,this._lightSizeUVCorrection),s.setArray("depthCorrection"+t,this._depthCorrection),s.setFloat("penumbraDarkness"+t,this.penumbraDarkness),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/a,this._contactHardeningLightSizeUVRatio*a,this.frustumEdgeFalloff,t)}else s.setTexture("shadowTexture"+t,r),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),a,1/a,this.frustumEdgeFalloff,t);i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(n),this.getLight().getDepthMinZ(n)+this.getLight().getDepthMaxZ(n),t)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const e=super.serialize(),t=this.getShadowMap();if(!t)return e;if(e.numCascades=this._numCascades,e.debug=this._debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ,e.penumbraDarkness=this.penumbraDarkness,e.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,e.minDistance=this.minDistance,e.maxDistance=this.maxDistance,e.renderList=[],t.renderList)for(let s=0;s<t.renderList.length;s++){const i=t.renderList[s];e.renderList.push(i.id)}return e}static Parse(t,s){const i=e.Parse(t,s,((e,t,s)=>new re(e,t,void 0,s)));return void 0!==t.numCascades&&(i.numCascades=t.numCascades),void 0!==t.debug&&(i.debug=t.debug),void 0!==t.stabilizeCascades&&(i.stabilizeCascades=t.stabilizeCascades),void 0!==t.lambda&&(i.lambda=t.lambda),void 0!==t.cascadeBlendPercentage&&(i.cascadeBlendPercentage=t.cascadeBlendPercentage),void 0!==t.depthClamp&&(i.depthClamp=t.depthClamp),void 0!==t.autoCalcDepthBounds&&(i.autoCalcDepthBounds=t.autoCalcDepthBounds),void 0!==t.shadowMaxZ&&(i.shadowMaxZ=t.shadowMaxZ),void 0!==t.penumbraDarkness&&(i.penumbraDarkness=t.penumbraDarkness),void 0!==t.freezeShadowCastersBoundingInfo&&(i.freezeShadowCastersBoundingInfo=t.freezeShadowCastersBoundingInfo),void 0!==t.minDistance&&void 0!==t.maxDistance&&i.setMinMaxDistance(t.minDistance,t.maxDistance),i}}re._FrustumCornersNdcSpace=[new E(-1,1,-1),new E(1,1,-1),new E(1,-1,-1),new E(-1,-1,-1),new E(-1,1,1),new E(1,1,1),new E(1,-1,1),new E(-1,-1,1)],re.CLASSNAME="CascadedShadowGenerator",re.DEFAULT_CASCADES_COUNT=4,re.MIN_CASCADES_COUNT=2,re.MAX_CASCADES_COUNT=4,re._SceneComponentInitialization=e=>{throw p("ShadowGeneratorSceneComponent")};class ae{constructor(e){this.name=b.NAME_SHADOWGENERATOR,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(b.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(e){e.shadowGenerators=[];const t=this.scene.lights;for(const s of t){if(s.doNotSerialize)continue;const t=s.getShadowGenerators();if(t){const s=t.values();for(let t=s.next();!0!==t.done;t=s.next()){const s=t.value;s.doNotSerialize||e.shadowGenerators.push(s.serialize())}}}}addFromContainer(e){}removeFromContainer(e,t){}dispose(){}_gatherRenderTargets(e){const t=this.scene;if(this.scene.shadowsEnabled)for(let s=0;s<t.lights.length;s++){const i=t.lights[s],n=i.getShadowGenerators();if(i.isEnabled()&&i.shadowEnabled&&n){const s=n.values();for(let i=s.next();!0!==i.done;i=s.next()){const s=i.value.getShadowMap();-1!==t.textures.indexOf(s)&&e.push(s)}}}}}e._SceneComponentInitialization=e=>{let t=e._getComponent(b.NAME_SHADOWGENERATOR);t||(t=new ae(e),e._addComponent(t))};export{ae as ShadowGeneratorSceneComponent};
//# sourceMappingURL=shadowGeneratorSceneComponent-DrUUPCwY.esm.min.js.map
