{"version":3,"file":"objectModelMapping-CghNRpa4.esm.min.js","sources":["../../../../../dev/loaders/dist/glTF/2.0/Extensions/gltfPathToObjectConverter.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/objectModelMapping.js"],"sourcesContent":["/**\n * Adding an exception here will break traversing through the glTF object tree.\n * This is used for properties that might not be in the glTF object model, but are optional and have a default value.\n * For example, the path /nodes/\\{\\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.\n */\nexport const OptionalPathExceptionsList = [\n    {\n        // get the node as object when reading an extension\n        regex: new RegExp(`^/nodes/\\\\d+/extensions/`),\n    },\n];\n/**\n * A converter that takes a glTF Object Model JSON Pointer\n * and transforms it into an ObjectAccessorContainer, allowing\n * objects referenced in the glTF to be associated with their\n * respective Babylon.js objects.\n */\nexport class GLTFPathToObjectConverter {\n    constructor(_gltf, _infoTree) {\n        this._gltf = _gltf;\n        this._infoTree = _infoTree;\n    }\n    /**\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\n     * <assetIndex> := <digit> | <name>\n     * <propertyPath> := <extensionPath> | <standardPath>\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\n     * <standardPath> := <name> | <name>/<standardPath>\n     * <name> := W+\n     * <digit> := D+\n     *\n     * Examples:\n     *  - \"/nodes/0/rotation\"\n     * - \"/nodes.length\"\n     *  - \"/materials/2/emissiveFactor\"\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\n     *\n     * @param path The path to convert\n     * @returns The object and info associated with the path\n     */\n    convert(path) {\n        let objectTree = this._gltf;\n        let infoTree = this._infoTree;\n        let target = undefined;\n        if (!path.startsWith(\"/\")) {\n            throw new Error(\"Path must start with a /\");\n        }\n        const parts = path.split(\"/\");\n        parts.shift();\n        //if the last part has \".length\" in it, separate that as an extra part\n        if (parts[parts.length - 1].includes(\".length\")) {\n            const lastPart = parts[parts.length - 1];\n            const split = lastPart.split(\".\");\n            parts.pop();\n            parts.push(...split);\n        }\n        let ignoreObjectTree = false;\n        for (const part of parts) {\n            const isLength = part === \"length\";\n            if (isLength && !infoTree.__array__) {\n                throw new Error(`Path ${path} is invalid`);\n            }\n            if (infoTree.__ignoreObjectTree__) {\n                ignoreObjectTree = true;\n            }\n            if (infoTree.__array__ && !isLength) {\n                infoTree = infoTree.__array__;\n            }\n            else {\n                infoTree = infoTree[part];\n                if (!infoTree) {\n                    throw new Error(`Path ${path} is invalid`);\n                }\n            }\n            if (!ignoreObjectTree) {\n                if (objectTree === undefined) {\n                    // check if the path is in the exception list. If it is, break and return the last object that was found\n                    const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));\n                    if (!exception) {\n                        throw new Error(`Path ${path} is invalid`);\n                    }\n                }\n                else if (!isLength) {\n                    objectTree = objectTree?.[part];\n                }\n            }\n            if (infoTree.__target__ || isLength) {\n                target = objectTree;\n            }\n        }\n        return {\n            object: target,\n            info: infoTree,\n        };\n    }\n}\n//# sourceMappingURL=gltfPathToObjectConverter.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nconst nodesTree = {\n    length: {\n        type: \"number\",\n        get: (nodes) => nodes.length,\n        getTarget: (nodes) => nodes.map((node) => node._babylonTransformNode),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.position,\n            set: (value, node) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node) => node._babylonTransformNode?.rotationQuaternion,\n            set: (value, node) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.scaling,\n            set: (value, node) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node) => node._numMorphTargets,\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node, index) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node, index) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node) => Matrix.Compose(node._babylonTransformNode?.scaling, node._babylonTransformNode?.rotationQuaternion, node._babylonTransformNode?.position),\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate = node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                }\n                else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations) => animations.length,\n        getTarget: (animations) => animations.map((animation) => animation._babylonAnimationGroup),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes) => meshes.length,\n        getTarget: (meshes) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst camerasTree = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.fov,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\nconst materialsTree = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index, payload) => GetMaterial(material, index, payload).emissiveColor,\n            set: (value, material, index, payload) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index, payload) => GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value, material, index, payload) => {\n                    const texture = GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).metallic,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).roughness,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: GetMaterial,\n                        set: (value, material, index, payload) => (GetMaterial(material, index, payload).clearCoat.bumpTexture.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => value && GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\nconst extensionsTree = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light) => light._babylonLight?.diffuse,\n                    set: (value, light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.intensity,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.range,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.innerAngle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.innerAngle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.angle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.angle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) {\n                            light._babylonTexture.level = value;\n                        }\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) {\n                            return;\n                        }\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\nfunction GetTexture(material, payload, textureType, textureInObject) {\n    const babylonMaterial = GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction GetMaterial(material, _index, payload) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial;\n}\nfunction GenerateTextureMap(textureType, textureInObject) {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index, payload) => GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: GetMaterial,\n            set: (value, material, _index, payload) => (GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\nconst objectModelMapping = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key, interpolation) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        current.interpolation = interpolation;\n    }\n}\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey(key, accessor) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n//# sourceMappingURL=objectModelMapping.js.map"],"names":["OptionalPathExceptionsList","regex","RegExp","GLTFPathToObjectConverter","constructor","_gltf","_infoTree","this","convert","path","target","objectTree","infoTree","startsWith","Error","parts","split","shift","length","includes","pop","push","ignoreObjectTree","part","isLength","__array__","__ignoreObjectTree__","undefined","find","e","test","__target__","object","info","GetTexture","material","payload","textureType","textureInObject","babylonMaterial","GetMaterial","_index","_data","fillMode","Constants","MATERIAL_TriangleFillMode","GenerateTextureMap","offset","componentsCount","type","get","texture","Vector2","uOffset","vOffset","getTarget","set","value","x","y","getPropertyName","rotation","wAng","scale","uScale","vScale","index","objectModelMapping","cameras","orthographic","xmag","camera","_babylonCamera","orthoLeft","orthoRight","ymag","orthoBottom","orthoTop","zfar","maxZ","znear","minZ","perspective","aspectRatio","getEngine","getAspectRatio","isReadOnly","yfov","fov","nodes","map","node","_babylonTransformNode","translation","position","copyFrom","rotationQuaternion","scaling","weights","_numMorphTargets","_primitiveBabylonMeshes","morphTargetManager","influence","matrix","Matrix","Compose","globalMatrix","Identity","rootNode","parent","forceUpdate","_isDirty","rootMatrix","computeWorldMatrix","invert","multiplyToRef","extensions","EXT_lights_ies","multiplier","getChildren","child","SpotLight","intensity","light","color","diffuse","materials","emissiveFactor","emissiveColor","emissiveTexture","KHR_texture_transform","normalTexture","level","occlusionTexture","strength","ambientTextureStrength","mat","pbrMetallicRoughness","baseColorFactor","Color4","FromColor3","albedoColor","alpha","r","g","b","a","baseColorTexture","metallicFactor","metallic","roughnessFactor","roughness","metallicRoughnessTexture","KHR_materials_anisotropy","anisotropyStrength","anisotropy","anisotropyRotation","angle","anisotropyTexture","KHR_materials_clearcoat","clearcoatFactor","clearCoat","clearcoatRoughnessFactor","clearcoatTexture","clearcoatNormalTexture","bumpTexture","clearcoatRoughnessTexture","KHR_materials_dispersion","dispersion","subSurface","KHR_materials_emissive_strength","emissiveStrength","emissiveIntensity","KHR_materials_ior","ior","indexOfRefraction","KHR_materials_iridescence","iridescenceFactor","iridescence","iridescenceIor","iridescenceTexture","iridescenceThicknessMaximum","maximumThickness","iridescenceThicknessMinimum","minimumThickness","iridescenceThicknessTexture","KHR_materials_sheen","sheenColorFactor","sheen","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture","KHR_materials_specular","specularFactor","metallicF0Factor","specularColorFactor","metallicReflectanceColor","specularTexture","specularColorTexture","KHR_materials_transmission","transmissionFactor","refractionIntensity","transmissionTexture","KHR_materials_diffuse_transmission","diffuseTransmissionFactor","translucencyIntensity","diffuseTransmissionTexture","diffuseTransmissionColorFactor","translucencyColor","diffuseTransmissionColorTexture","KHR_materials_volume","attenuationColor","tintColor","attenuationDistance","tintColorAtDistance","thicknessFactor","thicknessTexture","KHR_lights_punctual","lights","_babylonLight","_lights","_light","range","spot","innerConeAngle","innerAngle","outerConeAngle","EXT_lights_image_based","_babylonTexture","Quaternion","FromRotationMatrix","getReflectionTextureMatrix","getScene","useRightHandedSystem","Inverse","FromQuaternionToRef","animations","animation","_babylonAnimationGroup","meshes","mesh","primitives","_instanceData","babylonSourceMesh","GetPathToObjectConverter","gltf","GetMappingForKey","key","keyParts","replace","current","SetInterpolationForKey","interpolation","AddObjectAccessorToKey","accessor","Object","assign"],"mappings":"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"}