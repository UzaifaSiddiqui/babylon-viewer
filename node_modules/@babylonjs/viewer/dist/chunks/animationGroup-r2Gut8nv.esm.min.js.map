{"version":3,"file":"animationGroup-r2Gut8nv.esm.min.js","sources":["../../../../../dev/core/dist/Animations/runtimeAnimation.js","../../../../../dev/core/dist/Animations/animatable.core.js","../../../../../dev/core/dist/Animations/animatable.js","../../../../../dev/core/dist/Animations/animationGroup.js"],"sourcesContent":["import { Matrix } from \"../Maths/math.vector\";\nimport { Animation, _StaticOffsetValueColor3, _StaticOffsetValueColor4, _StaticOffsetValueQuaternion, _StaticOffsetValueSize, _StaticOffsetValueVector2, _StaticOffsetValueVector3, } from \"./animation\";\n/**\n * Defines a runtime animation\n */\nexport class RuntimeAnimation {\n    /**\n     * Gets the current frame of the runtime animation\n     */\n    get currentFrame() {\n        return this._currentFrame;\n    }\n    /**\n     * Gets the weight of the runtime animation\n     */\n    get weight() {\n        return this._weight;\n    }\n    /**\n     * Gets the current value of the runtime animation\n     */\n    get currentValue() {\n        return this._currentValue;\n    }\n    /**\n     * Gets or sets the target path of the runtime animation\n     */\n    get targetPath() {\n        return this._targetPath;\n    }\n    /**\n     * Gets the actual target of the runtime animation\n     */\n    get target() {\n        return this._currentActiveTarget;\n    }\n    /**\n     * Gets the additive state of the runtime animation\n     */\n    get isAdditive() {\n        return this._host && this._host.isAdditive;\n    }\n    /**\n     * Create a new RuntimeAnimation object\n     * @param target defines the target of the animation\n     * @param animation defines the source animation object\n     * @param scene defines the hosting scene\n     * @param host defines the initiating Animatable\n     */\n    constructor(target, animation, scene, host) {\n        this._events = new Array();\n        /**\n         * The current frame of the runtime animation\n         */\n        this._currentFrame = 0;\n        /**\n         * The original value of the runtime animation\n         */\n        this._originalValue = new Array();\n        /**\n         * The original blend value of the runtime animation\n         */\n        this._originalBlendValue = null;\n        /**\n         * The offsets cache of the runtime animation\n         */\n        this._offsetsCache = {};\n        /**\n         * The high limits cache of the runtime animation\n         */\n        this._highLimitsCache = {};\n        /**\n         * Specifies if the runtime animation has been stopped\n         */\n        this._stopped = false;\n        /**\n         * The blending factor of the runtime animation\n         */\n        this._blendingFactor = 0;\n        /**\n         * The current value of the runtime animation\n         */\n        this._currentValue = null;\n        this._currentActiveTarget = null;\n        this._directTarget = null;\n        /**\n         * The target path of the runtime animation\n         */\n        this._targetPath = \"\";\n        /**\n         * The weight of the runtime animation\n         */\n        this._weight = 1.0;\n        /**\n         * The absolute frame offset of the runtime animation\n         */\n        this._absoluteFrameOffset = 0;\n        /**\n         * The previous elapsed time (since start of animation) of the runtime animation\n         */\n        this._previousElapsedTime = 0;\n        this._yoyoDirection = 1;\n        /**\n         * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\n         */\n        this._previousAbsoluteFrame = 0;\n        this._targetIsArray = false;\n        /** @internal */\n        this._coreRuntimeAnimation = null;\n        this._animation = animation;\n        this._target = target;\n        this._scene = scene;\n        this._host = host;\n        this._activeTargets = [];\n        animation._runtimeAnimations.push(this);\n        // State\n        this._animationState = {\n            key: 0,\n            repeatCount: 0,\n            loopMode: this._getCorrectLoopMode(),\n        };\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n            this._animationState.workValue = Matrix.Zero();\n        }\n        // Limits\n        this._keys = this._animation.getKeys();\n        this._minFrame = this._keys[0].frame;\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\n        this._minValue = this._keys[0].value;\n        this._maxValue = this._keys[this._keys.length - 1].value;\n        // Add a start key at frame 0 if missing\n        if (this._minFrame !== 0) {\n            const newKey = { frame: 0, value: this._minValue };\n            this._keys.splice(0, 0, newKey);\n        }\n        // Check data\n        if (this._target instanceof Array) {\n            let index = 0;\n            for (const target of this._target) {\n                this._preparePath(target, index);\n                this._getOriginalValues(index);\n                index++;\n            }\n            this._targetIsArray = true;\n        }\n        else {\n            this._preparePath(this._target);\n            this._getOriginalValues();\n            this._targetIsArray = false;\n            this._directTarget = this._activeTargets[0];\n        }\n        // Cloning events locally\n        const events = animation.getEvents();\n        if (events && events.length > 0) {\n            for (const e of events) {\n                this._events.push(e._clone());\n            }\n        }\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n    }\n    _preparePath(target, targetIndex = 0) {\n        const targetPropertyPath = this._animation.targetPropertyPath;\n        if (targetPropertyPath.length > 1) {\n            let property = target;\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\n                const name = targetPropertyPath[index];\n                property = property[name];\n                if (property === undefined) {\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\n                }\n            }\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n            this._activeTargets[targetIndex] = property;\n        }\n        else {\n            this._targetPath = targetPropertyPath[0];\n            this._activeTargets[targetIndex] = target;\n        }\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\n        }\n    }\n    /**\n     * Gets the animation from the runtime animation\n     */\n    get animation() {\n        return this._animation;\n    }\n    /**\n     * Resets the runtime animation to the beginning\n     * @param restoreOriginal defines whether to restore the target property to the original value\n     */\n    reset(restoreOriginal = false) {\n        if (restoreOriginal) {\n            if (this._target instanceof Array) {\n                let index = 0;\n                for (const target of this._target) {\n                    if (this._originalValue[index] !== undefined) {\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n                    }\n                    index++;\n                }\n            }\n            else {\n                if (this._originalValue[0] !== undefined) {\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n                }\n            }\n        }\n        this._offsetsCache = {};\n        this._highLimitsCache = {};\n        this._currentFrame = 0;\n        this._blendingFactor = 0;\n        // Events\n        for (let index = 0; index < this._events.length; index++) {\n            this._events[index].isDone = false;\n        }\n    }\n    /**\n     * Specifies if the runtime animation is stopped\n     * @returns Boolean specifying if the runtime animation is stopped\n     */\n    isStopped() {\n        return this._stopped;\n    }\n    /**\n     * Disposes of the runtime animation\n     */\n    dispose() {\n        const index = this._animation.runtimeAnimations.indexOf(this);\n        if (index > -1) {\n            this._animation.runtimeAnimations.splice(index, 1);\n        }\n    }\n    /**\n     * Apply the interpolated value to the target\n     * @param currentValue defines the value computed by the animation\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\n     */\n    setValue(currentValue, weight) {\n        if (this._targetIsArray) {\n            for (let index = 0; index < this._target.length; index++) {\n                const target = this._target[index];\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n            }\n            return;\n        }\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n    }\n    _getOriginalValues(targetIndex = 0) {\n        let originalValue;\n        const target = this._activeTargets[targetIndex];\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\n            // For bones\n            originalValue = target.getLocalMatrix();\n        }\n        else {\n            originalValue = target[this._targetPath];\n        }\n        if (originalValue && originalValue.clone) {\n            this._originalValue[targetIndex] = originalValue.clone();\n        }\n        else {\n            this._originalValue[targetIndex] = originalValue;\n        }\n    }\n    _registerTargetForLateAnimationBinding(runtimeAnimation, originalValue) {\n        const target = runtimeAnimation.target;\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n        if (!target._lateAnimationHolders) {\n            target._lateAnimationHolders = {};\n        }\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n                totalWeight: 0,\n                totalAdditiveWeight: 0,\n                animations: [],\n                additiveAnimations: [],\n                originalValue: originalValue,\n            };\n        }\n        if (runtimeAnimation.isAdditive) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n        }\n        else {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n        }\n    }\n    _setValue(target, destination, currentValue, weight, targetIndex) {\n        // Set value\n        this._currentActiveTarget = destination;\n        this._weight = weight;\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\n            if (!this._originalBlendValue) {\n                const originalValue = destination[this._targetPath];\n                if (originalValue.clone) {\n                    this._originalBlendValue = originalValue.clone();\n                }\n                else {\n                    this._originalBlendValue = originalValue;\n                }\n            }\n            if (this._originalBlendValue.m) {\n                // Matrix\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\n                    if (this._currentValue) {\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n                else {\n                    if (this._currentValue) {\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n            }\n            else {\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n            }\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n            this._blendingFactor += blendingSpeed;\n        }\n        else {\n            if (!this._currentValue) {\n                if (currentValue?.clone) {\n                    this._currentValue = currentValue.clone();\n                }\n                else {\n                    this._currentValue = currentValue;\n                }\n            }\n            else if (this._currentValue.copyFrom) {\n                this._currentValue.copyFrom(currentValue);\n            }\n            else {\n                this._currentValue = currentValue;\n            }\n        }\n        if (weight !== -1.0) {\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n        }\n        else {\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\n                if (this._currentValue.addToRef) {\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\n                }\n                else {\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\n                }\n            }\n            else {\n                destination[this._targetPath] = this._currentValue;\n            }\n        }\n        if (target.markAsDirty) {\n            target.markAsDirty(this._animation.targetProperty);\n        }\n    }\n    /**\n     * Gets the loop pmode of the runtime animation\n     * @returns Loop Mode\n     */\n    _getCorrectLoopMode() {\n        if (this._target && this._target.animationPropertiesOverride) {\n            return this._target.animationPropertiesOverride.loopMode;\n        }\n        return this._animation.loopMode;\n    }\n    /**\n     * Move the current animation to a given frame\n     * @param frame defines the frame to move to\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\n     */\n    goToFrame(frame, weight = -1) {\n        const keys = this._animation.getKeys();\n        if (frame < keys[0].frame) {\n            frame = keys[0].frame;\n        }\n        else if (frame > keys[keys.length - 1].frame) {\n            frame = keys[keys.length - 1].frame;\n        }\n        // Need to reset animation events\n        const events = this._events;\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                if (!events[index].onlyOnce) {\n                    // reset events in the future\n                    events[index].isDone = events[index].frame < frame;\n                }\n            }\n        }\n        this._currentFrame = frame;\n        const currentValue = this._animation._interpolate(frame, this._animationState);\n        this.setValue(currentValue, weight);\n    }\n    /**\n     * @internal Internal use only\n     */\n    _prepareForSpeedRatioChange(newSpeedRatio) {\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\n    }\n    /**\n     * Execute the current animation\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\n     * @param from defines the lower frame of the animation range\n     * @param to defines the upper frame of the animation range\n     * @param loop defines if the current animation must loop\n     * @param speedRatio defines the current speed ratio\n     * @param weight defines the weight of the animation (default is -1 so no weight)\n     * @returns a boolean indicating if the animation is running\n     */\n    animate(elapsedTimeSinceAnimationStart, from, to, loop, speedRatio, weight = -1.0) {\n        const animation = this._animation;\n        const targetPropertyPath = animation.targetPropertyPath;\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\n            this._stopped = true;\n            return false;\n        }\n        let returnValue = true;\n        let currentFrame;\n        const events = this._events;\n        let frameRange = 0;\n        if (!this._coreRuntimeAnimation) {\n            // Check limits\n            if (from < this._minFrame || from > this._maxFrame) {\n                from = this._minFrame;\n            }\n            if (to < this._minFrame || to > this._maxFrame) {\n                to = this._maxFrame;\n            }\n            frameRange = to - from;\n            let offsetValue;\n            // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\n            let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\n            let highLimitValue = 0;\n            // Apply the yoyo function if required\n            let yoyoLoop = false;\n            const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\n            if (yoyoMode) {\n                const position = (absoluteFrame - from) / frameRange;\n                // Apply the yoyo curve\n                const sin = Math.sin(position * Math.PI);\n                const yoyoPosition = Math.abs(sin);\n                // Map the yoyo position back to the range\n                absoluteFrame = yoyoPosition * frameRange + from;\n                const direction = sin >= 0 ? 1 : -1;\n                if (this._yoyoDirection !== direction) {\n                    yoyoLoop = true;\n                }\n                this._yoyoDirection = direction;\n            }\n            this._previousElapsedTime = elapsedTimeSinceAnimationStart;\n            this._previousAbsoluteFrame = absoluteFrame;\n            if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\n                // If we are out of range and not looping get back to caller\n                returnValue = false;\n                highLimitValue = animation._getKeyValue(this._maxValue);\n            }\n            else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\n                returnValue = false;\n                highLimitValue = animation._getKeyValue(this._minValue);\n            }\n            else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n                const keyOffset = to.toString() + from.toString();\n                if (!this._offsetsCache[keyOffset]) {\n                    this._animationState.repeatCount = 0;\n                    this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\n                    const fromValue = animation._interpolate(from, this._animationState);\n                    const toValue = animation._interpolate(to, this._animationState);\n                    this._animationState.loopMode = this._getCorrectLoopMode();\n                    switch (animation.dataType) {\n                        // Float\n                        case Animation.ANIMATIONTYPE_FLOAT:\n                            this._offsetsCache[keyOffset] = toValue - fromValue;\n                            break;\n                        // Quaternion\n                        case Animation.ANIMATIONTYPE_QUATERNION:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector3\n                        case Animation.ANIMATIONTYPE_VECTOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector2\n                        case Animation.ANIMATIONTYPE_VECTOR2:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Size\n                        case Animation.ANIMATIONTYPE_SIZE:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Color3\n                        case Animation.ANIMATIONTYPE_COLOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        default:\n                            break;\n                    }\n                    this._highLimitsCache[keyOffset] = toValue;\n                }\n                highLimitValue = this._highLimitsCache[keyOffset];\n                offsetValue = this._offsetsCache[keyOffset];\n            }\n            if (offsetValue === undefined) {\n                switch (animation.dataType) {\n                    // Float\n                    case Animation.ANIMATIONTYPE_FLOAT:\n                        offsetValue = 0;\n                        break;\n                    // Quaternion\n                    case Animation.ANIMATIONTYPE_QUATERNION:\n                        offsetValue = _StaticOffsetValueQuaternion;\n                        break;\n                    // Vector3\n                    case Animation.ANIMATIONTYPE_VECTOR3:\n                        offsetValue = _StaticOffsetValueVector3;\n                        break;\n                    // Vector2\n                    case Animation.ANIMATIONTYPE_VECTOR2:\n                        offsetValue = _StaticOffsetValueVector2;\n                        break;\n                    // Size\n                    case Animation.ANIMATIONTYPE_SIZE:\n                        offsetValue = _StaticOffsetValueSize;\n                        break;\n                    // Color3\n                    case Animation.ANIMATIONTYPE_COLOR3:\n                        offsetValue = _StaticOffsetValueColor3;\n                        break;\n                    case Animation.ANIMATIONTYPE_COLOR4:\n                        offsetValue = _StaticOffsetValueColor4;\n                        break;\n                }\n            }\n            // Compute value\n            if (this._host && this._host.syncRoot) {\n                // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\n                const syncRoot = this._host.syncRoot;\n                const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n                currentFrame = from + frameRange * hostNormalizedFrame;\n            }\n            else {\n                if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\n                    currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\n                }\n                else {\n                    currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\n                }\n            }\n            // Reset event/state if looping\n            if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\n                this._onLoop();\n                // Need to reset animation events\n                for (let index = 0; index < events.length; index++) {\n                    if (!events[index].onlyOnce) {\n                        // reset event, the animation is looping\n                        events[index].isDone = false;\n                    }\n                }\n                this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\n            }\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\n            this._animationState.highLimitValue = highLimitValue;\n            this._animationState.offsetValue = offsetValue;\n        }\n        else {\n            frameRange = to - from;\n            currentFrame = this._coreRuntimeAnimation.currentFrame;\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = this._coreRuntimeAnimation._animationState.repeatCount;\n            this._animationState.highLimitValue = this._coreRuntimeAnimation._animationState.highLimitValue;\n            this._animationState.offsetValue = this._coreRuntimeAnimation._animationState.offsetValue;\n        }\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\n        // Set value\n        this.setValue(currentValue, weight);\n        // Check events\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                // Make sure current frame has passed event frame and that event frame is within the current range\n                // Also, handle both forward and reverse animations\n                if ((frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)) {\n                    const event = events[index];\n                    if (!event.isDone) {\n                        // If event should be done only once, remove it.\n                        if (event.onlyOnce) {\n                            events.splice(index, 1);\n                            index--;\n                        }\n                        event.isDone = true;\n                        event.action(currentFrame);\n                    } // Don't do anything if the event has already been done.\n                }\n            }\n        }\n        if (!returnValue) {\n            this._stopped = true;\n        }\n        return returnValue;\n    }\n}\n//# sourceMappingURL=runtimeAnimation.js.map","import { Observable } from \"core/Misc/observable\";\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\nimport { Animation } from \"./animation\";\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\n/**\n * Class used to store an actual running animation\n */\nexport class Animatable {\n    /**\n     * Gets the root Animatable used to synchronize and normalize animations\n     */\n    get syncRoot() {\n        return this._syncRoot;\n    }\n    /**\n     * Gets the current frame of the first RuntimeAnimation\n     * Used to synchronize Animatables\n     */\n    get masterFrame() {\n        if (this._runtimeAnimations.length === 0) {\n            return 0;\n        }\n        return this._runtimeAnimations[0].currentFrame;\n    }\n    /**\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (value === -1) {\n            // -1 is ok and means no weight\n            this._weight = -1;\n            return;\n        }\n        // Else weight must be in [0, 1] range\n        this._weight = Math.min(Math.max(value, 0), 1.0);\n    }\n    /**\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    set speedRatio(value) {\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\n            const animation = this._runtimeAnimations[index];\n            animation._prepareForSpeedRatioChange(value);\n        }\n        this._speedRatio = value;\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\n        if (this._goToFrame !== null) {\n            this.goToFrame(this._goToFrame);\n        }\n    }\n    /**\n     * Gets the elapsed time since the animatable started in milliseconds\n     */\n    get elapsedTime() {\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\n    }\n    /**\n     * Creates a new Animatable\n     * @param scene defines the hosting scene\n     * @param target defines the target object\n     * @param fromFrame defines the starting frame number (default is 0)\n     * @param toFrame defines the ending frame number (default is 100)\n     * @param loopAnimation defines if the animation must loop (default is false)\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n     * @param animations defines a group of animation to add to the new Animatable\n     * @param onAnimationLoop defines a callback to call when animation loops\n     * @param isAdditive defines whether the animation should be evaluated additively\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\n     */\n    constructor(scene, \n    /** defines the target object */\n    target, \n    /** [0] defines the starting frame number (default is 0) */\n    fromFrame = 0, \n    /** [100] defines the ending frame number (default is 100) */\n    toFrame = 100, \n    /** [false] defines if the animation must loop (default is false)  */\n    loopAnimation = false, speedRatio = 1.0, \n    /** defines a callback to call when animation ends if it is not looping */\n    onAnimationEnd, animations, \n    /** defines a callback to call when animation loops */\n    onAnimationLoop, \n    /** [false] defines whether the animation should be evaluated additively */\n    isAdditive = false, \n    /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\n    playOrder = 0) {\n        this.target = target;\n        this.fromFrame = fromFrame;\n        this.toFrame = toFrame;\n        this.loopAnimation = loopAnimation;\n        this.onAnimationEnd = onAnimationEnd;\n        this.onAnimationLoop = onAnimationLoop;\n        this.isAdditive = isAdditive;\n        this.playOrder = playOrder;\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n        this._manualJumpDelay = null;\n        /** @hidden */\n        this._runtimeAnimations = new Array();\n        this._paused = false;\n        this._speedRatio = 1;\n        this._weight = -1.0;\n        this._previousWeight = -1.0;\n        this._syncRoot = null;\n        this._frameToSyncFromJump = null;\n        this._goToFrame = null;\n        /**\n         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n         * This will only apply for non looping animation (default is true)\n         */\n        this.disposeOnEnd = true;\n        /**\n         * Gets a boolean indicating if the animation has started\n         */\n        this.animationStarted = false;\n        /**\n         * Observer raised when the animation ends\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when the animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        this._scene = scene;\n        if (animations) {\n            this.appendAnimations(target, animations);\n        }\n        this._speedRatio = speedRatio;\n        scene._activeAnimatables.push(this);\n    }\n    // Methods\n    /**\n     * Synchronize and normalize current Animatable with a source Animatable\n     * This is useful when using animation weights and when animations are not of the same length\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n     * @returns the current Animatable\n     */\n    syncWith(root) {\n        this._syncRoot = root;\n        if (root) {\n            // Make sure this animatable will animate after the root\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                this._scene._activeAnimatables.splice(index, 1);\n                this._scene._activeAnimatables.push(this);\n            }\n        }\n        return this;\n    }\n    /**\n     * Gets the list of runtime animations\n     * @returns an array of RuntimeAnimation\n     */\n    getAnimations() {\n        return this._runtimeAnimations;\n    }\n    /**\n     * Adds more animations to the current animatable\n     * @param target defines the target of the animations\n     * @param animations defines the new animations to add\n     */\n    appendAnimations(target, animations) {\n        for (let index = 0; index < animations.length; index++) {\n            const animation = animations[index];\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n            newRuntimeAnimation._onLoop = () => {\n                this.onAnimationLoopObservable.notifyObservers(this);\n                if (this.onAnimationLoop) {\n                    this.onAnimationLoop();\n                }\n            };\n            this._runtimeAnimations.push(newRuntimeAnimation);\n        }\n    }\n    /**\n     * Gets the source animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the source animation for the given property\n     */\n    getAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index].animation;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets the runtime animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the runtime animation for the given property\n     */\n    getRuntimeAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Resets the animatable to its original state\n     */\n    reset() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].reset(true);\n        }\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n    }\n    /**\n     * Allows the animatable to blend with current running animations\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     * @param blendingSpeed defines the blending speed to use\n     */\n    enableBlending(blendingSpeed) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = true;\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n        }\n    }\n    /**\n     * Disable animation blending\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    disableBlending() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = false;\n        }\n    }\n    /**\n     * Jump directly to a given frame\n     * @param frame defines the frame to jump to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     */\n    goToFrame(frame, useWeight = false) {\n        const runtimeAnimations = this._runtimeAnimations;\n        if (runtimeAnimations[0]) {\n            const fps = runtimeAnimations[0].animation.framePerSecond;\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\n            this._manualJumpDelay = -delay;\n        }\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\n        }\n        this._goToFrame = frame;\n    }\n    /**\n     * Returns true if the animations for this animatable are paused\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Pause the animation\n     */\n    pause() {\n        if (this._paused) {\n            return;\n        }\n        this._paused = true;\n    }\n    /**\n     * Restart the animation\n     */\n    restart() {\n        this._paused = false;\n    }\n    _raiseOnAnimationEnd() {\n        if (this.onAnimationEnd) {\n            this.onAnimationEnd();\n        }\n        this.onAnimationEndObservable.notifyObservers(this);\n    }\n    /**\n     * Stop and delete the current animation\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     */\n    stop(animationName, targetMask, useGlobalSplice = false, skipOnAnimationEnd = false) {\n        if (animationName || targetMask) {\n            const idx = this._scene._activeAnimatables.indexOf(this);\n            if (idx > -1) {\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\n                    const runtimeAnimation = runtimeAnimations[index];\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\n                        continue;\n                    }\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\n                        continue;\n                    }\n                    runtimeAnimation.dispose();\n                    runtimeAnimations.splice(index, 1);\n                }\n                if (runtimeAnimations.length == 0) {\n                    if (!useGlobalSplice) {\n                        this._scene._activeAnimatables.splice(idx, 1);\n                    }\n                    if (!skipOnAnimationEnd) {\n                        this._raiseOnAnimationEnd();\n                    }\n                }\n            }\n        }\n        else {\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                if (!useGlobalSplice) {\n                    this._scene._activeAnimatables.splice(index, 1);\n                }\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n                this._runtimeAnimations.length = 0;\n                if (!skipOnAnimationEnd) {\n                    this._raiseOnAnimationEnd();\n                }\n            }\n        }\n    }\n    /**\n     * Wait asynchronously for the animation to end\n     * @returns a promise which will be fulfilled when the animation ends\n     */\n    async waitAsync() {\n        return await new Promise((resolve) => {\n            this.onAnimationEndObservable.add(() => {\n                resolve(this);\n            }, undefined, undefined, this, true);\n        });\n    }\n    /**\n     * @internal\n     */\n    _animate(delay) {\n        if (this._paused) {\n            this.animationStarted = false;\n            if (this._pausedDelay === null) {\n                this._pausedDelay = delay;\n            }\n            return true;\n        }\n        if (this._localDelayOffset === null) {\n            this._localDelayOffset = delay;\n            this._pausedDelay = null;\n        }\n        else if (this._pausedDelay !== null) {\n            this._localDelayOffset += delay - this._pausedDelay;\n            this._pausedDelay = null;\n        }\n        if (this._manualJumpDelay !== null) {\n            this._localDelayOffset += this.speedRatio < 0 ? -this._manualJumpDelay : this._manualJumpDelay;\n            this._manualJumpDelay = null;\n            this._frameToSyncFromJump = null;\n        }\n        this._goToFrame = null;\n        if (this._weight === 0 && this._previousWeight === 0) {\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\n            return true;\n        }\n        this._previousWeight = this._weight;\n        // Animating\n        let running = false;\n        const runtimeAnimations = this._runtimeAnimations;\n        let index;\n        for (index = 0; index < runtimeAnimations.length; index++) {\n            const animation = runtimeAnimations[index];\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n            running = running || isRunning;\n        }\n        this.animationStarted = running;\n        if (!running) {\n            if (this.disposeOnEnd) {\n                // Remove from active animatables\n                index = this._scene._activeAnimatables.indexOf(this);\n                this._scene._activeAnimatables.splice(index, 1);\n                // Dispose all runtime animations\n                for (index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n            }\n            this._raiseOnAnimationEnd();\n            if (this.disposeOnEnd) {\n                this.onAnimationEnd = null;\n                this.onAnimationLoop = null;\n                this.onAnimationLoopObservable.clear();\n                this.onAnimationEndObservable.clear();\n            }\n        }\n        return running;\n    }\n}\n/** @internal */\nfunction ProcessLateAnimationBindingsForMatrices(holder) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return holder.originalValue;\n    }\n    let normalizer = 1.0;\n    const finalPosition = TmpVectors.Vector3[0];\n    const finalScaling = TmpVectors.Vector3[1];\n    const finalQuaternion = TmpVectors.Quaternion[0];\n    let startIndex = 0;\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let scale = 1;\n    let skipOverride = false;\n    if (holder.totalWeight < 1.0) {\n        // We need to mix the original value in\n        scale = 1.0 - holder.totalWeight;\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    else {\n        startIndex = 1;\n        // We need to normalize the weights\n        normalizer = holder.totalWeight;\n        scale = originalAnimation.weight / normalizer;\n        if (scale == 1) {\n            if (holder.totalAdditiveWeight) {\n                skipOverride = true;\n            }\n            else {\n                return originalAnimation.currentValue;\n            }\n        }\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    // Add up the override animations\n    if (!skipOverride) {\n        finalScaling.scaleInPlace(scale);\n        finalPosition.scaleInPlace(scale);\n        finalQuaternion.scaleInPlace(scale);\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            if (runtimeAnimation.weight === 0) {\n                continue;\n            }\n            scale = runtimeAnimation.weight / normalizer;\n            const currentPosition = TmpVectors.Vector3[2];\n            const currentScaling = TmpVectors.Vector3[3];\n            const currentQuaternion = TmpVectors.Quaternion[1];\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\n        }\n        finalQuaternion.normalize();\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        const currentPosition = TmpVectors.Vector3[2];\n        const currentScaling = TmpVectors.Vector3[3];\n        const currentQuaternion = TmpVectors.Quaternion[1];\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n    }\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n    return workValue;\n}\n/** @internal */\nfunction ProcessLateAnimationBindingsForQuaternions(holder, refQuaternion) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return refQuaternion;\n    }\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let cumulativeQuaternion = refQuaternion;\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n        cumulativeQuaternion.copyFrom(originalValue);\n    }\n    else if (holder.animations.length === 1) {\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n        if (holder.totalAdditiveWeight === 0) {\n            return cumulativeQuaternion;\n        }\n    }\n    else if (holder.animations.length > 1) {\n        // Add up the override animations\n        let normalizer = 1.0;\n        let quaternions;\n        let weights;\n        if (holder.totalWeight < 1.0) {\n            const scale = 1.0 - holder.totalWeight;\n            quaternions = [];\n            weights = [];\n            quaternions.push(originalValue);\n            weights.push(scale);\n        }\n        else {\n            if (holder.animations.length === 2) {\n                // Slerp as soon as we can\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n                if (holder.totalAdditiveWeight === 0) {\n                    return refQuaternion;\n                }\n            }\n            quaternions = [];\n            weights = [];\n            normalizer = holder.totalWeight;\n        }\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            quaternions.push(runtimeAnimation.currentValue);\n            weights.push(runtimeAnimation.weight / normalizer);\n        }\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n        let cumulativeAmount = 0;\n        for (let index = 0; index < quaternions.length;) {\n            if (!index) {\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n                cumulativeQuaternion = refQuaternion;\n                cumulativeAmount = weights[index] + weights[index + 1];\n                index += 2;\n                continue;\n            }\n            cumulativeAmount += weights[index];\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n            index++;\n        }\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n    }\n    return cumulativeQuaternion;\n}\n/** @internal */\nfunction ProcessLateAnimationBindings(scene) {\n    if (!scene._registeredForLateAnimationBindings.length) {\n        return;\n    }\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\n        const target = scene._registeredForLateAnimationBindings.data[index];\n        for (const path in target._lateAnimationHolders) {\n            const holder = target._lateAnimationHolders[path];\n            const originalAnimation = holder.animations[0];\n            const originalValue = holder.originalValue;\n            if (originalValue === undefined || originalValue === null) {\n                continue;\n            }\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n            let finalValue = target[path];\n            if (matrixDecomposeMode) {\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\n            }\n            else {\n                const quaternionMode = originalValue.w !== undefined;\n                if (quaternionMode) {\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n                }\n                else {\n                    let startIndex = 0;\n                    let normalizer = 1.0;\n                    const originalAnimationIsLoopRelativeFromCurrent = originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\n                    if (holder.totalWeight < 1.0) {\n                        // We need to mix the original value in\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\n                        }\n                        else if (originalAnimation && originalValue.scale) {\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\n                        }\n                        else if (originalAnimation) {\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\n                        }\n                        else if (originalValue.clone) {\n                            finalValue = originalValue.clone();\n                        }\n                        else {\n                            finalValue = originalValue;\n                        }\n                    }\n                    else if (originalAnimation) {\n                        // We need to normalize the weights\n                        normalizer = holder.totalWeight;\n                        const scale = originalAnimation.weight / normalizer;\n                        if (scale !== 1) {\n                            if (originalAnimation.currentValue.scale) {\n                                finalValue = originalAnimation.currentValue.scale(scale);\n                            }\n                            else {\n                                finalValue = originalAnimation.currentValue * scale;\n                            }\n                        }\n                        else {\n                            finalValue = originalAnimation.currentValue;\n                        }\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            if (finalValue.addToRef) {\n                                finalValue.addToRef(originalValue, finalValue);\n                            }\n                            else {\n                                finalValue += originalValue;\n                            }\n                        }\n                        startIndex = 1;\n                    }\n                    // Add up the override animations\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n                        const runtimeAnimation = holder.animations[animIndex];\n                        const scale = runtimeAnimation.weight / normalizer;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                    // Add up the additive animations\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\n                        const scale = runtimeAnimation.weight;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                }\n            }\n            target[path] = finalValue;\n        }\n        target._lateAnimationHolders = {};\n    }\n    scene._registeredForLateAnimationBindings.reset();\n}\n/** @internal */\nexport function RegisterTargetForLateAnimationBinding(scene, runtimeAnimation, originalValue) {\n    const target = runtimeAnimation.target;\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n    if (!target._lateAnimationHolders) {\n        target._lateAnimationHolders = {};\n    }\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n            totalWeight: 0,\n            totalAdditiveWeight: 0,\n            animations: [],\n            additiveAnimations: [],\n            originalValue: originalValue,\n        };\n    }\n    if (runtimeAnimation.isAdditive) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n    }\n    else {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n    }\n}\n/**\n * Initialize all the inter dependecies between the animations and Scene and Bone\n * @param sceneClass defines the scene prototype to use\n * @param boneClass defines the bone prototype to use\n */\nexport function AddAnimationExtensions(sceneClass, boneClass) {\n    if (boneClass) {\n        boneClass.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {\n            // all animation may be coming from a library skeleton, so may need to create animation\n            if (this.animations.length === 0) {\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n                this.animations[0].setKeys([]);\n            }\n            // get animation info / verify there is such a range from the source bone\n            const sourceRange = source.animations[0].getRange(rangeName);\n            if (!sourceRange) {\n                return false;\n            }\n            const from = sourceRange.from;\n            const to = sourceRange.to;\n            const sourceKeys = source.animations[0].getKeys();\n            // rescaling prep\n            const sourceBoneLength = source.length;\n            const sourceParent = source.getParent();\n            const parent = this.getParent();\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n            const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n            const destKeys = this.animations[0].getKeys();\n            // loop vars declaration\n            let orig;\n            let origTranslation;\n            let mat;\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n                orig = sourceKeys[key];\n                if (orig.frame >= from && orig.frame <= to) {\n                    if (rescaleAsRequired) {\n                        mat = orig.value.clone();\n                        // scale based on parent ratio, when bone has parent\n                        if (parentScalingReqd) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\n                        }\n                        else if (dimensionsScalingReqd && skelDimensionsRatio) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n                            // use original when root bone, and no data for skelDimensionsRatio\n                        }\n                        else {\n                            mat = orig.value;\n                        }\n                    }\n                    else {\n                        mat = orig.value;\n                    }\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\n                }\n            }\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n            return true;\n        };\n    }\n    if (!sceneClass) {\n        return;\n    }\n    sceneClass.prototype._animate = function (customDeltaTime) {\n        if (!this.animationsEnabled) {\n            return;\n        }\n        // Getting time\n        const now = PrecisionDate.Now;\n        if (!this._animationTimeLast) {\n            if (this._pendingData.length > 0) {\n                return;\n            }\n            this._animationTimeLast = now;\n        }\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n        this._animationTimeLast = now;\n        const animatables = this._activeAnimatables;\n        if (animatables.length === 0) {\n            return;\n        }\n        this._animationTime += this.deltaTime;\n        const animationTime = this._animationTime;\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n                index--; // Array was updated\n            }\n        }\n        // Late animation bindings\n        ProcessLateAnimationBindings(this);\n    };\n    sceneClass.prototype.sortActiveAnimatables = function () {\n        this._activeAnimatables.sort((a, b) => {\n            return a.playOrder - b.playOrder;\n        });\n    };\n    sceneClass.prototype.beginWeightedAnimation = function (target, from, to, weight = 1.0, loop, speedRatio = 1.0, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n        returnedAnimatable.weight = weight;\n        return returnedAnimatable;\n    };\n    sceneClass.prototype.beginAnimation = function (target, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        if (stopCurrent) {\n            this.stopAnimation(target, undefined, targetMask);\n        }\n        if (!animatable) {\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n        }\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\n        // Local animations\n        if (target.animations && shouldRunTargetAnimations) {\n            animatable.appendAnimations(target, target.animations);\n        }\n        // Children animations\n        if (target.getAnimatables) {\n            const animatables = target.getAnimatables();\n            for (let index = 0; index < animatables.length; index++) {\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n            }\n        }\n        animatable.reset();\n        return animatable;\n    };\n    sceneClass.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        for (const child of children) {\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio = 1.0, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n        return animatable;\n    };\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        for (const child of children) {\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.getAnimatableByTarget = function (target) {\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                return this._activeAnimatables[index];\n            }\n        }\n        return null;\n    };\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target) {\n        const result = [];\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                result.push(this._activeAnimatables[index]);\n            }\n        }\n        return result;\n    };\n    sceneClass.prototype.stopAnimation = function (target, animationName, targetMask) {\n        const animatables = this.getAllAnimatablesByTarget(target);\n        for (const animatable of animatables) {\n            animatable.stop(animationName, targetMask);\n        }\n    };\n    sceneClass.prototype.stopAllAnimations = function () {\n        if (this._activeAnimatables) {\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\n                this._activeAnimatables[i].stop(undefined, undefined, true);\n            }\n            this._activeAnimatables.length = 0;\n        }\n        for (const group of this.animationGroups) {\n            group.stop();\n        }\n    };\n}\n//# sourceMappingURL=animatable.core.js.map","import { Bone } from \"../Bones/bone\";\nimport { AddAnimationExtensions } from \"./animatable.core\";\nimport { Scene } from \"core/scene\";\nexport * from \"./animatable.core\";\n// Connect everything!\nAddAnimationExtensions(Scene, Bone);\n//# sourceMappingURL=animatable.js.map","import { Animation } from \"./animation\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Tags } from \"../Misc/tags\";\nimport \"./animatable\";\n/**\n * This class defines the direct association between an animation and a target\n */\nexport class TargetedAnimation {\n    /**\n     * Returns the string \"TargetedAnimation\"\n     * @returns \"TargetedAnimation\"\n     */\n    getClassName() {\n        return \"TargetedAnimation\";\n    }\n    /**\n     * Serialize the object\n     * @returns the JSON object representing the current entity\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.animation = this.animation.serialize();\n        serializationObject.targetId = this.target.id;\n        return serializationObject;\n    }\n}\n/**\n * Use this class to create coordinated animations on multiple targets\n */\nexport class AnimationGroup {\n    /**\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\n     */\n    get mask() {\n        return this._mask;\n    }\n    set mask(value) {\n        if (this._mask === value) {\n            return;\n        }\n        this._mask = value;\n        this.syncWithMask(true);\n    }\n    /**\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\n     * Note however that the call won't have any effect if the animation group has not been started yet.\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\n     */\n    syncWithMask(forceUpdate = false) {\n        if (!this.mask && !forceUpdate) {\n            this._numActiveAnimatables = this._targetedAnimations.length;\n            return;\n        }\n        this._numActiveAnimatables = 0;\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\n                this._numActiveAnimatables++;\n                if (animatable.paused) {\n                    animatable.restart();\n                }\n            }\n            else {\n                if (!animatable.paused) {\n                    animatable.pause();\n                }\n            }\n        }\n    }\n    /**\n     * Removes all animations for the targets not retained by the animation group mask.\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\n     */\n    removeUnmaskedAnimations() {\n        if (!this.mask || this.mask.disabled) {\n            return;\n        }\n        // Removes all animatables (in case the animation group has already been started)\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask.retainsTarget(animatable.target.name)) {\n                animatable.stop();\n                this._animatables.splice(i, 1);\n                --i;\n            }\n        }\n        // Removes the targeted animations\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\n                this._targetedAnimations.splice(index, 1);\n                --index;\n            }\n        }\n    }\n    /**\n     * Gets or sets the first frame\n     */\n    get from() {\n        return this._from;\n    }\n    set from(value) {\n        if (this._from === value) {\n            return;\n        }\n        this._from = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.fromFrame = this._from;\n        }\n    }\n    /**\n     * Gets or sets the last frame\n     */\n    get to() {\n        return this._to;\n    }\n    set to(value) {\n        if (this._to === value) {\n            return;\n        }\n        this._to = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.toFrame = this._to;\n        }\n    }\n    /**\n     * Define if the animations are started\n     */\n    get isStarted() {\n        return this._isStarted;\n    }\n    /**\n     * Gets a value indicating that the current group is playing\n     */\n    get isPlaying() {\n        return this._isStarted && !this._isPaused;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    set speedRatio(value) {\n        if (this._speedRatio === value) {\n            return;\n        }\n        this._speedRatio = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.speedRatio = this._speedRatio;\n        }\n    }\n    /**\n     * Gets or sets if all animations should loop or not\n     */\n    get loopAnimation() {\n        return this._loopAnimation;\n    }\n    set loopAnimation(value) {\n        if (this._loopAnimation === value) {\n            return;\n        }\n        this._loopAnimation = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.loopAnimation = this._loopAnimation;\n        }\n    }\n    /**\n     * Gets or sets if all animations should be evaluated additively\n     */\n    get isAdditive() {\n        return this._isAdditive;\n    }\n    set isAdditive(value) {\n        if (this._isAdditive === value) {\n            return;\n        }\n        this._isAdditive = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.isAdditive = this._isAdditive;\n        }\n    }\n    /**\n     * Gets or sets the weight to apply to all animations of the group\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (this._weight === value) {\n            return;\n        }\n        this._weight = value;\n        this.setWeightForAllAnimatables(this._weight);\n    }\n    /**\n     * Gets the targeted animations for this animation group\n     */\n    get targetedAnimations() {\n        return this._targetedAnimations;\n    }\n    /**\n     * returning the list of animatables controlled by this animation group.\n     */\n    get animatables() {\n        return this._animatables;\n    }\n    /**\n     * Gets the list of target animations\n     */\n    get children() {\n        return this._targetedAnimations;\n    }\n    /**\n     * Gets or sets the order of play of the animation group (default: 0)\n     */\n    get playOrder() {\n        return this._playOrder;\n    }\n    set playOrder(value) {\n        if (this._playOrder === value) {\n            return;\n        }\n        this._playOrder = value;\n        if (this._animatables.length > 0) {\n            for (let i = 0; i < this._animatables.length; i++) {\n                this._animatables[i].playOrder = this._playOrder;\n            }\n            this._scene.sortActiveAnimatables();\n        }\n    }\n    /**\n     * Allows the animations of the animation group to blend with current running animations\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\n     */\n    get enableBlending() {\n        return this._enableBlending;\n    }\n    set enableBlending(value) {\n        if (this._enableBlending === value) {\n            return;\n        }\n        this._enableBlending = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.enableBlending = value;\n            }\n        }\n    }\n    /**\n     * Gets or sets the animation blending speed\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\n     */\n    get blendingSpeed() {\n        return this._blendingSpeed;\n    }\n    set blendingSpeed(value) {\n        if (this._blendingSpeed === value) {\n            return;\n        }\n        this._blendingSpeed = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.blendingSpeed = value;\n            }\n        }\n    }\n    /**\n     * Gets the length (in seconds) of the animation group\n     * This function assumes that all animations are played at the same framePerSecond speed!\n     * Note: you can only call this method after you've added at least one targeted animation!\n     * @param from Starting frame range (default is AnimationGroup.from)\n     * @param to Ending frame range (default is AnimationGroup.to)\n     * @returns The length in seconds\n     */\n    getLength(from, to) {\n        from = from ?? this._from;\n        to = to ?? this._to;\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\n        return (to - from) / fps;\n    }\n    /**\n     * Merge the array of animation groups into a new animation group\n     * @param animationGroups List of animation groups to merge\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\n     * @returns The new animation group or null if no animation groups were passed\n     */\n    static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {\n        if (animationGroups.length === 0) {\n            return null;\n        }\n        weight = weight ?? animationGroups[0].weight;\n        let beginFrame = Number.MAX_VALUE;\n        let endFrame = -Number.MAX_VALUE;\n        if (normalize) {\n            for (const animationGroup of animationGroups) {\n                if (animationGroup.from < beginFrame) {\n                    beginFrame = animationGroup.from;\n                }\n                if (animationGroup.to > endFrame) {\n                    endFrame = animationGroup.to;\n                }\n            }\n        }\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\n        for (const animationGroup of animationGroups) {\n            if (normalize) {\n                animationGroup.normalize(beginFrame, endFrame);\n            }\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\n            }\n            if (disposeSource) {\n                animationGroup.dispose();\n            }\n        }\n        return mergedAnimationGroup;\n    }\n    /**\n     * Instantiates a new Animation Group.\n     * This helps managing several animations at once.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n     * @param name Defines the name of the group\n     * @param scene Defines the scene the group belongs to\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\n     * @param playOrder Defines the order of play of the animation group (default is 0)\n     */\n    constructor(\n    /** The name of the animation group */\n    name, scene = null, weight = -1, playOrder = 0) {\n        this.name = name;\n        this._targetedAnimations = new Array();\n        this._animatables = new Array();\n        this._from = Number.MAX_VALUE;\n        this._to = -Number.MAX_VALUE;\n        this._speedRatio = 1;\n        this._loopAnimation = false;\n        this._isAdditive = false;\n        this._weight = -1;\n        this._playOrder = 0;\n        this._enableBlending = null;\n        this._blendingSpeed = null;\n        this._numActiveAnimatables = 0;\n        this._shouldStart = true;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * This observable will notify when one animation have ended\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when one animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        /**\n         * Observer raised when all animations have looped\n         */\n        this.onAnimationGroupLoopObservable = new Observable();\n        /**\n         * This observable will notify when all animations have ended.\n         */\n        this.onAnimationGroupEndObservable = new Observable();\n        /**\n         * This observable will notify when all animations have paused.\n         */\n        this.onAnimationGroupPauseObservable = new Observable();\n        /**\n         * This observable will notify when all animations are playing.\n         */\n        this.onAnimationGroupPlayObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the node\n         */\n        this.metadata = null;\n        this._mask = null;\n        this._animationLoopFlags = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._weight = weight;\n        this._playOrder = playOrder;\n        this.uniqueId = this._scene.getUniqueId();\n        this._scene.addAnimationGroup(this);\n    }\n    /**\n     * Add an animation (with its target) in the group\n     * @param animation defines the animation we want to add\n     * @param target defines the target of the animation\n     * @returns the TargetedAnimation object\n     */\n    addTargetedAnimation(animation, target) {\n        const targetedAnimation = new TargetedAnimation();\n        targetedAnimation.animation = animation;\n        targetedAnimation.target = target;\n        const keys = animation.getKeys();\n        if (this._from > keys[0].frame) {\n            this._from = keys[0].frame;\n        }\n        if (this._to < keys[keys.length - 1].frame) {\n            this._to = keys[keys.length - 1].frame;\n        }\n        if (this._enableBlending !== null) {\n            animation.enableBlending = this._enableBlending;\n        }\n        if (this._blendingSpeed !== null) {\n            animation.blendingSpeed = this._blendingSpeed;\n        }\n        this._targetedAnimations.push(targetedAnimation);\n        this._shouldStart = true;\n        return targetedAnimation;\n    }\n    /**\n     * Remove an animation from the group\n     * @param animation defines the animation we want to remove\n     */\n    removeTargetedAnimation(animation) {\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (targetedAnimation.animation === animation) {\n                this._targetedAnimations.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n     * It can add constant keys at begin or end\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n     * @returns the animation group\n     */\n    normalize(beginFrame = null, endFrame = null) {\n        if (beginFrame == null) {\n            beginFrame = this._from;\n        }\n        if (endFrame == null) {\n            endFrame = this._to;\n        }\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const keys = targetedAnimation.animation.getKeys();\n            const startKey = keys[0];\n            const endKey = keys[keys.length - 1];\n            if (startKey.frame > beginFrame) {\n                const newKey = {\n                    frame: beginFrame,\n                    value: startKey.value,\n                    inTangent: startKey.inTangent,\n                    outTangent: startKey.outTangent,\n                    interpolation: startKey.interpolation,\n                };\n                keys.splice(0, 0, newKey);\n            }\n            if (endKey.frame < endFrame) {\n                const newKey = {\n                    frame: endFrame,\n                    value: endKey.value,\n                    inTangent: endKey.inTangent,\n                    outTangent: endKey.outTangent,\n                    interpolation: endKey.interpolation,\n                };\n                keys.push(newKey);\n            }\n        }\n        this._from = beginFrame;\n        this._to = endFrame;\n        return this;\n    }\n    _processLoop(animatable, targetedAnimation, index) {\n        animatable.onAnimationLoop = () => {\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n            if (this._animationLoopFlags[index]) {\n                return;\n            }\n            this._animationLoopFlags[index] = true;\n            this._animationLoopCount++;\n            if (this._animationLoopCount === this._numActiveAnimatables) {\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\n                this._animationLoopCount = 0;\n                this._animationLoopFlags.length = 0;\n            }\n        };\n    }\n    /**\n     * Start all animations on given targets\n     * @param loop defines if animations must loop\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n     * @param from defines the from key (optional)\n     * @param to defines the to key (optional)\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\n     * @returns the current animation group\n     */\n    start(loop = false, speedRatio = 1, from, to, isAdditive) {\n        if (this._isStarted || this._targetedAnimations.length === 0) {\n            return this;\n        }\n        this._loopAnimation = loop;\n        this._shouldStart = false;\n        this._animationLoopCount = 0;\n        this._animationLoopFlags.length = 0;\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this._from, to !== undefined ? to : this._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this._isAdditive);\n            animatable.weight = this._weight;\n            animatable.playOrder = this._playOrder;\n            animatable.onAnimationEnd = () => {\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n                this._checkAnimationGroupEnded(animatable);\n            };\n            this._processLoop(animatable, targetedAnimation, index);\n            this._animatables.push(animatable);\n        }\n        this.syncWithMask();\n        this._scene.sortActiveAnimatables();\n        this._speedRatio = speedRatio;\n        this._isStarted = true;\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Pause all animations\n     * @returns the animation group\n     */\n    pause() {\n        if (!this._isStarted) {\n            return this;\n        }\n        this._isPaused = true;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.pause();\n        }\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Play all animations to initial state\n     * This function will start() the animations if they were not started or will restart() them if they were paused\n     * @param loop defines if animations must loop\n     * @returns the animation group\n     */\n    play(loop) {\n        // only if there are animatable available\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\n            if (loop !== undefined) {\n                this.loopAnimation = loop;\n            }\n            this.restart();\n        }\n        else {\n            this.stop();\n            this.start(loop, this._speedRatio);\n        }\n        return this;\n    }\n    /**\n     * Reset all animations to initial state\n     * @returns the animation group\n     */\n    reset() {\n        if (!this._isStarted) {\n            this.play();\n            this.goToFrame(0);\n            this.stop(true);\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.reset();\n        }\n        return this;\n    }\n    /**\n     * Restart animations from after pausing it\n     * @returns the animation group\n     */\n    restart() {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.restart();\n        }\n        this.syncWithMask();\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Stop all animations\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     * @returns the animation group\n     */\n    stop(skipOnAnimationEnd = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        const list = this._animatables.slice();\n        for (let index = 0; index < list.length; index++) {\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\n        }\n        // We will take care of removing all stopped animatables\n        let curIndex = 0;\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\n            const animatable = this._scene._activeAnimatables[index];\n            if (animatable._runtimeAnimations.length > 0) {\n                this._scene._activeAnimatables[curIndex++] = animatable;\n            }\n            else if (skipOnAnimationEnd) {\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\n            }\n        }\n        this._scene._activeAnimatables.length = curIndex;\n        this._isStarted = false;\n        return this;\n    }\n    /**\n     * Set animation weight for all animatables\n     *\n     * @since 6.12.4\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\n     * @param weight defines the weight to use\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    setWeightForAllAnimatables(weight) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.weight = weight;\n        }\n        return this;\n    }\n    /**\n     * Synchronize and normalize all animatables with a source animatable\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    syncAllAnimationsWith(root) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.syncWith(root);\n        }\n        return this;\n    }\n    /**\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\n     * @param frame the frame number to go to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     * @returns the animationGroup\n     */\n    goToFrame(frame, useWeight = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.goToFrame(frame, useWeight);\n        }\n        return this;\n    }\n    /**\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\n     * @returns current animation frame.\n     */\n    getCurrentFrame() {\n        return this.animatables[0]?.masterFrame || 0;\n    }\n    /**\n     * Dispose all associated resources\n     */\n    dispose() {\n        if (this.isStarted) {\n            this.stop();\n        }\n        this._targetedAnimations.length = 0;\n        this._animatables.length = 0;\n        // Remove from scene\n        const index = this._scene.animationGroups.indexOf(this);\n        if (index > -1) {\n            this._scene.animationGroups.splice(index, 1);\n        }\n        if (this._parentContainer) {\n            const index = this._parentContainer.animationGroups.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.animationGroups.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        this.onAnimationEndObservable.clear();\n        this.onAnimationGroupEndObservable.clear();\n        this.onAnimationGroupPauseObservable.clear();\n        this.onAnimationGroupPlayObservable.clear();\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationGroupLoopObservable.clear();\n    }\n    _checkAnimationGroupEnded(animatable, skipOnAnimationEnd = false) {\n        // animatable should be taken out of the array\n        const idx = this._animatables.indexOf(animatable);\n        if (idx > -1) {\n            this._animatables.splice(idx, 1);\n        }\n        // all animatables were removed? animation group ended!\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\n            this._isStarted = false;\n            if (!skipOnAnimationEnd) {\n                this.onAnimationGroupEndObservable.notifyObservers(this);\n            }\n            this._animatables.length = 0;\n        }\n    }\n    /**\n     * Clone the current animation group and returns a copy\n     * @param newName defines the name of the new group\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\n     * @param cloneAnimations defines if the animations should be cloned or referenced\n     * @returns the new animation group\n     */\n    clone(newName, targetConverter, cloneAnimations = false) {\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\n        newGroup._from = this.from;\n        newGroup._to = this.to;\n        newGroup._speedRatio = this.speedRatio;\n        newGroup._loopAnimation = this.loopAnimation;\n        newGroup._isAdditive = this.isAdditive;\n        newGroup._enableBlending = this.enableBlending;\n        newGroup._blendingSpeed = this.blendingSpeed;\n        newGroup.metadata = this.metadata;\n        newGroup.mask = this.mask;\n        for (const targetAnimation of this._targetedAnimations) {\n            newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n        }\n        return newGroup;\n    }\n    /**\n     * Serializes the animationGroup to an object\n     * @returns Serialized object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.from = this.from;\n        serializationObject.to = this.to;\n        serializationObject.speedRatio = this.speedRatio;\n        serializationObject.loopAnimation = this.loopAnimation;\n        serializationObject.isAdditive = this.isAdditive;\n        serializationObject.weight = this.weight;\n        serializationObject.playOrder = this.playOrder;\n        serializationObject.enableBlending = this.enableBlending;\n        serializationObject.blendingSpeed = this.blendingSpeed;\n        serializationObject.targetedAnimations = [];\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n        }\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        // Metadata\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        return serializationObject;\n    }\n    // Statics\n    /**\n     * Returns a new AnimationGroup object parsed from the source provided.\n     * @param parsedAnimationGroup defines the source\n     * @param scene defines the scene that will receive the animationGroup\n     * @returns a new AnimationGroup\n     */\n    static Parse(parsedAnimationGroup, scene) {\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n            const animation = Animation.Parse(targetedAnimation.animation);\n            const id = targetedAnimation.targetId;\n            if (targetedAnimation.animation.property === \"influence\") {\n                // morph target animation\n                const morphTarget = scene.getMorphTargetById(id);\n                if (morphTarget) {\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\n                }\n            }\n            else {\n                const targetNode = scene.getNodeById(id);\n                if (targetNode != null) {\n                    animationGroup.addTargetedAnimation(animation, targetNode);\n                }\n            }\n        }\n        if (Tags) {\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n        }\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n        }\n        if (parsedAnimationGroup.speedRatio !== undefined) {\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\n        }\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\n        }\n        if (parsedAnimationGroup.isAdditive !== undefined) {\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\n        }\n        if (parsedAnimationGroup.weight !== undefined) {\n            animationGroup._weight = parsedAnimationGroup.weight;\n        }\n        if (parsedAnimationGroup.playOrder !== undefined) {\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\n        }\n        if (parsedAnimationGroup.enableBlending !== undefined) {\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\n        }\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\n        }\n        if (parsedAnimationGroup.metadata !== undefined) {\n            animationGroup.metadata = parsedAnimationGroup.metadata;\n        }\n        return animationGroup;\n    }\n    /** @internal */\n    static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n        let options;\n        if (typeof referenceFrameOrOptions === \"object\") {\n            options = referenceFrameOrOptions;\n        }\n        else {\n            options = {\n                referenceFrame: referenceFrameOrOptions,\n                range: range,\n                cloneOriginalAnimationGroup: cloneOriginal,\n                clonedAnimationName: clonedName,\n            };\n        }\n        let animationGroup = sourceAnimationGroup;\n        if (options.cloneOriginalAnimationGroup) {\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\n        }\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\n        }\n        animationGroup.isAdditive = true;\n        if (options.clipKeys) {\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\n            let from = Number.MAX_VALUE;\n            let to = -Number.MAX_VALUE;\n            const targetedAnimations = animationGroup.targetedAnimations;\n            for (let index = 0; index < targetedAnimations.length; index++) {\n                const targetedAnimation = targetedAnimations[index];\n                const animation = targetedAnimation.animation;\n                const keys = animation.getKeys();\n                if (from > keys[0].frame) {\n                    from = keys[0].frame;\n                }\n                if (to < keys[keys.length - 1].frame) {\n                    to = keys[keys.length - 1].frame;\n                }\n            }\n            animationGroup._from = from;\n            animationGroup._to = to;\n        }\n        return animationGroup;\n    }\n    /**\n     * Creates a new animation, keeping only the keys that are inside a given key range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the keys outside the given range\n     */\n    static ClipKeys(sourceAnimationGroup, fromKey, toKey, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\n    }\n    /**\n     * Creates a new animation, keeping only the frames that are inside a given frame range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the frames outside the given range\n     */\n    static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the frames outside the given range\n     */\n    static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param start defines the lower bound of the range\n     * @param end defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {\n        let from = Number.MAX_VALUE;\n        let to = -Number.MAX_VALUE;\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\n            if (useFrame) {\n                // Make sure we have keys corresponding to the bounds of the frame range\n                animation.createKeyForFrame(start);\n                animation.createKeyForFrame(end);\n            }\n            const keys = animation.getKeys();\n            const newKeys = [];\n            let startFrame = Number.MAX_VALUE;\n            for (let k = 0; k < keys.length; k++) {\n                const key = keys[k];\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\n                    const newKey = {\n                        frame: key.frame,\n                        value: key.value.clone ? key.value.clone() : key.value,\n                        inTangent: key.inTangent,\n                        outTangent: key.outTangent,\n                        interpolation: key.interpolation,\n                        lockedTangent: key.lockedTangent,\n                    };\n                    if (startFrame === Number.MAX_VALUE) {\n                        startFrame = newKey.frame;\n                    }\n                    newKey.frame -= startFrame;\n                    newKeys.push(newKey);\n                }\n            }\n            if (newKeys.length === 0) {\n                targetedAnimations.splice(index, 1);\n                index--;\n                continue;\n            }\n            if (from > newKeys[0].frame) {\n                from = newKeys[0].frame;\n            }\n            if (to < newKeys[newKeys.length - 1].frame) {\n                to = newKeys[newKeys.length - 1].frame;\n            }\n            animation.setKeys(newKeys, true);\n            targetedAnimation.animation = animation; // in case the animation has been cloned\n        }\n        animationGroup._from = from;\n        animationGroup._to = to;\n        return animationGroup;\n    }\n    /**\n     * Returns the string \"AnimationGroup\"\n     * @returns \"AnimationGroup\"\n     */\n    getClassName() {\n        return \"AnimationGroup\";\n    }\n    /**\n     * Creates a detailed string about the object\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n     * @returns a string representing the object\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + this.getClassName();\n        if (fullDetails) {\n            ret += \", from: \" + this._from;\n            ret += \", to: \" + this._to;\n            ret += \", isStarted: \" + this._isStarted;\n            ret += \", speedRatio: \" + this._speedRatio;\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n            ret += \", animatables length: \" + this._animatables;\n        }\n        return ret;\n    }\n}\n//# sourceMappingURL=animationGroup.js.map"],"names":["RuntimeAnimation","currentFrame","this","_currentFrame","weight","_weight","currentValue","_currentValue","targetPath","_targetPath","target","_currentActiveTarget","isAdditive","_host","constructor","animation","scene","host","_events","Array","_originalValue","_originalBlendValue","_offsetsCache","_highLimitsCache","_stopped","_blendingFactor","_directTarget","_absoluteFrameOffset","_previousElapsedTime","_yoyoDirection","_previousAbsoluteFrame","_targetIsArray","_coreRuntimeAnimation","_animation","_target","_scene","_activeTargets","_runtimeAnimations","push","_animationState","key","repeatCount","loopMode","_getCorrectLoopMode","dataType","Animation","ANIMATIONTYPE_MATRIX","workValue","Matrix","Zero","_keys","getKeys","_minFrame","frame","_maxFrame","length","_minValue","value","_maxValue","newKey","splice","index","_preparePath","_getOriginalValues","events","getEvents","e","_clone","_enableBlending","animationPropertiesOverride","enableBlending","targetIndex","targetPropertyPath","property","name","undefined","Error","join","reset","restoreOriginal","_setValue","isDone","isStopped","dispose","runtimeAnimations","indexOf","setValue","originalValue","getLocalMatrix","clone","_registerTargetForLateAnimationBinding","runtimeAnimation","_registeredForLateAnimationBindings","pushNoDuplicate","_lateAnimationHolders","totalWeight","totalAdditiveWeight","animations","additiveAnimations","destination","m","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","Lerp","_UniversalLerp","blendingSpeed","copyFrom","ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT","addToRef","markAsDirty","targetProperty","goToFrame","keys","onlyOnce","_interpolate","_prepareForSpeedRatioChange","newSpeedRatio","newAbsoluteFrame","framePerSecond","animate","elapsedTimeSinceAnimationStart","from","to","loop","speedRatio","returnValue","frameRange","highLimitValue","offsetValue","absoluteFrame","yoyoLoop","yoyoMode","ANIMATIONLOOPMODE_YOYO","position","sin","Math","PI","abs","direction","_getKeyValue","ANIMATIONLOOPMODE_CYCLE","keyOffset","toString","fromValue","toValue","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_SIZE","ANIMATIONTYPE_COLOR3","subtract","_StaticOffsetValueQuaternion","_StaticOffsetValueVector3","_StaticOffsetValueVector2","_StaticOffsetValueSize","_StaticOffsetValueColor3","ANIMATIONTYPE_COLOR4","_StaticOffsetValueColor4","syncRoot","masterFrame","fromFrame","toFrame","_onLoop","event","action","Animatable","_syncRoot","min","max","_speedRatio","_goToFrame","elapsedTime","_localDelayOffset","_animationTime","loopAnimation","onAnimationEnd","onAnimationLoop","playOrder","_pausedDelay","_manualJumpDelay","_paused","_previousWeight","_frameToSyncFromJump","disposeOnEnd","animationStarted","onAnimationEndObservable","Observable","onAnimationLoopObservable","appendAnimations","_activeAnimatables","syncWith","root","getAnimations","newRuntimeAnimation","notifyObservers","getAnimationByTargetProperty","getRuntimeAnimationByTargetProperty","disableBlending","useWeight","fps","delay","paused","pause","restart","_raiseOnAnimationEnd","stop","animationName","targetMask","useGlobalSplice","skipOnAnimationEnd","idx","waitAsync","Promise","resolve","add","_animate","running","isRunning","clear","ProcessLateAnimationBindingsForMatrices","holder","normalizer","finalPosition","TmpVectors","Vector3","finalScaling","finalQuaternion","Quaternion","startIndex","originalAnimation","scale","skipOverride","decompose","scaleInPlace","animIndex","currentPosition","currentScaling","currentQuaternion","scaleAndAddToRef","Dot","normalize","multiplyToRef","SlerpToRef","ComposeToRef","ProcessLateAnimationBindingsForQuaternions","refQuaternion","cumulativeQuaternion","quaternions","weights","cumulativeAmount","sceneClass","boneClass","Scene","Bone","prototype","copyAnimationRange","source","rangeName","frameOffset","rescaleAsRequired","skelDimensionsRatio","setKeys","sourceRange","getRange","sourceKeys","sourceBoneLength","sourceParent","getParent","parent","parentScalingReqd","parentRatio","dimensionsScalingReqd","x","y","z","destKeys","orig","origTranslation","mat","nKeys","getTranslation","setTranslation","multiplyInPlace","createRange","customDeltaTime","animationsEnabled","now","PrecisionDate","Now","_animationTimeLast","_pendingData","deltaTime","useConstantAnimationDeltaTime","animationTimeScale","animatables","animationTime","animatable","data","path","matrixDecomposeMode","finalValue","w","Identity","originalAnimationIsLoopRelativeFromCurrent","ProcessLateAnimationBindings","sortActiveAnimatables","sort","a","b","beginWeightedAnimation","returnedAnimatable","beginAnimation","stopCurrent","tmp","stopAnimation","shouldRunTargetAnimations","getAnimatables","beginHierarchyAnimation","directDescendantsOnly","children","getDescendants","result","child","beginDirectAnimation","beginDirectHierarchyAnimation","getAnimatableByTarget","getAllAnimatablesByTarget","stopAllAnimations","i","group","animationGroups","TargetedAnimation","getClassName","serialize","serializationObject","targetId","id","AnimationGroup","mask","_mask","syncWithMask","forceUpdate","_numActiveAnimatables","_animatables","disabled","retainsTarget","_targetedAnimations","removeUnmaskedAnimations","targetedAnimation","_from","_to","isStarted","_isStarted","isPlaying","_isPaused","_loopAnimation","_isAdditive","setWeightForAllAnimatables","targetedAnimations","_playOrder","_blendingSpeed","getLength","MergeAnimationGroups","disposeSource","beginFrame","Number","MAX_VALUE","endFrame","animationGroup","mergedAnimationGroup","addTargetedAnimation","_shouldStart","_parentContainer","onAnimationGroupLoopObservable","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","onAnimationGroupPlayObservable","metadata","_animationLoopFlags","EngineStore","LastCreatedScene","uniqueId","getUniqueId","addAnimationGroup","removeTargetedAnimation","startKey","endKey","inTangent","outTangent","interpolation","_processLoop","_animationLoopCount","start","_checkAnimationGroupEnded","play","list","slice","curIndex","syncAllAnimationsWith","getCurrentFrame","newName","targetConverter","cloneAnimations","newGroup","targetAnimation","targetedAnimationIndex","Tags","HasTags","tags","GetTags","Parse","parsedAnimationGroup","morphTarget","getMorphTargetById","targetNode","getNodeById","AddTagsTo","MakeAnimationAdditive","sourceAnimationGroup","referenceFrameOrOptions","range","cloneOriginal","clonedName","options","referenceFrame","cloneOriginalAnimationGroup","clonedAnimationName","clonedAnimationGroupName","clipKeys","ClipKeys","fromKey","toKey","dontCloneAnimations","ClipKeysInPlace","ClipInPlace","ClipFrames","ClipFramesInPlace","end","useFrame","createKeyForFrame","newKeys","startFrame","k","lockedTangent","fullDetails","ret"],"mappings":"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"}