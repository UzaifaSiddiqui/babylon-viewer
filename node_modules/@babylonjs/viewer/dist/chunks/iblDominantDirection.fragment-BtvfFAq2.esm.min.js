import{S as e}from"./index-VvGulz6u.esm.min.js";import"./helperFunctions-DSBzZxDv.esm.min.js";import"./hdrFilteringFunctions-CVp-eoJE.esm.min.js";import"./pbrBRDFFunctions-CV3HxMWw.esm.min.js";const r="iblDominantDirectionPixelShader",i="#include<helperFunctions>\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nvar icdfSamplerSampler: sampler;var icdfSampler: texture_2d<f32>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var lightDir: vec3f=vec3f(0.0,0.0,0.0);for(var i: u32=0u; i<NUM_SAMPLES; i++)\n{var Xi: vec2f=hammersley(i,NUM_SAMPLES);var T: vec2f;T.x=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2(Xi.x,0.0),0.0).x;T.y=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2(T.x,Xi.y),0.0).y;var Ls: vec3f=uv_to_normal(vec2f(1.0-fract(T.x+0.25),T.y));lightDir+=Ls;}\nlightDir/=vec3f(f32(NUM_SAMPLES));fragmentOutputs.color=vec4f(lightDir,1.0);}";e.ShadersStoreWGSL[r]||(e.ShadersStoreWGSL[r]=i);const n={name:r,shader:i};export{n as iblDominantDirectionPixelShaderWGSL};
//# sourceMappingURL=iblDominantDirection.fragment-BtvfFAq2.esm.min.js.map
