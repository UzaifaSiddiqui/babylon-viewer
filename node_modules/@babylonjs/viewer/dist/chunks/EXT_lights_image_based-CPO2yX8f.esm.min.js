import{C as e,X as t,Q as s,M as n,bT as r,aC as i,bJ as a,bI as o}from"./index-VvGulz6u.esm.min.js";import{_ as l}from"./environmentTextureTools-DAgYJsj_.esm.min.js";import{CubeTexture as m}from"./cubeTexture-D4Iz4G5H.esm.min.js";import{GLTFLoader as c,ArrayItem as h}from"./glTFLoader-X6ZTOkAw.esm.min.js";import"./dumpTools-pAyGUYsv.esm.min.js";import"./abstractEngine.cubeTexture-n3SIAyxH.esm.min.js";import"./bone-DPw1oOFK.esm.min.js";import"./skeleton-BDCw4yVL.esm.min.js";import"./rawTexture-B-F8SA5B.esm.min.js";import"./assetContainer-Da0Xx6Do.esm.min.js";import"./objectModelMapping-CghNRpa4.esm.min.js";class d extends m{constructor(t,s,n,r=e.TEXTUREFORMAT_RGBA,i=e.TEXTURETYPE_UNSIGNED_BYTE,a=!1,o=!1,l=e.TEXTURE_TRILINEAR_SAMPLINGMODE,m=null){super("",t),this._texture=t.getEngine().createRawCubeTexture(s,n,r,i,a,o,l,m)}update(e,t,s,n,r=null){this._texture.getEngine().updateRawCubeTexture(this._texture,e,t,s,n,r)}updateRGBDAsync(e,t=null,s=.8,n=0){return l(this._texture,e,t,s,n).then((()=>{}))}clone(){return t.Clone((()=>{const e=this.getScene(),t=this._texture,s=new d(e,t._bufferViewArray,t.width,t.format,t.type,t.generateMipMaps,t.invertY,t.samplingMode,t._compression);return 13===t.source&&s.updateRGBDAsync(t._bufferViewArrayArray,t._sphericalPolynomial,t._lodGenerationScale,t._lodGenerationOffset),s}),this)}}const u="EXT_lights_image_based";class g{constructor(e){this.name=u,this._loader=e,this.enabled=this._loader.isExtensionUsed(u)}dispose(){this._loader=null,delete this._lights}onLoading(){const e=this._loader.gltf.extensions;if(e&&e[this.name]){const t=e[this.name];this._lights=t.lights}}loadSceneAsync(e,t){return c.LoadExtensionAsync(e,t,this.name,(async(s,n)=>{this._loader._allMaterialsDirtyRequired=!0;const r=new Array;r.push(this._loader.loadSceneAsync(e,t)),this._loader.logOpen(`${s}`);const i=h.Get(`${s}/light`,this._lights,n.light);return r.push(this._loadLightAsync(`/extensions/${this.name}/lights/${n.light}`,i).then((e=>{this._loader.babylonScene.environmentTexture=e}))),this._loader.logClose(),await Promise.all(r).then((()=>{}))}))}_loadLightAsync(e,t){if(!t._loaded){const a=new Array;this._loader.logOpen(`${e}`);const o=new Array(t.specularImages.length);for(let s=0;s<t.specularImages.length;s++){const n=t.specularImages[s];o[s]=new Array(n.length);for(let t=0;t<n.length;t++){const r=`${e}/specularImages/${s}/${t}`;this._loader.logOpen(`${r}`);const i=n[t],l=h.Get(r,this._loader.gltf.images,i);a.push(this._loader.loadImageAsync(`/images/${i}`,l).then((e=>{o[s][t]=e}))),this._loader.logClose()}}this._loader.logClose(),t._loaded=Promise.all(a).then((async()=>{const a=new d(this._loader.babylonScene,null,t.specularImageSize);if(a.name=t.name||"environment",t._babylonTexture=a,null!=t.intensity&&(a.level=t.intensity),t.rotation){let e=s.FromArray(t.rotation);this._loader.babylonScene.useRightHandedSystem||(e=s.Inverse(e)),n.FromQuaternionToRef(e,a.getReflectionTextureMatrix())}if(!t.irradianceCoefficients)throw new Error(`${e}: Irradiance coefficients are missing`);const l=r.FromArray(t.irradianceCoefficients);l.scaleInPlace(t.intensity),l.convertIrradianceToLambertianRadiance();const m=i.FromHarmonics(l),c=(o.length-1)/Math.log2(t.specularImageSize);return await a.updateRGBDAsync(o,m,c)}))}return t._loaded.then((()=>t._babylonTexture))}}a(u),o(u,!0,(e=>new g(e)));export{g as EXT_lights_image_based};
//# sourceMappingURL=EXT_lights_image_based-CPO2yX8f.esm.min.js.map
