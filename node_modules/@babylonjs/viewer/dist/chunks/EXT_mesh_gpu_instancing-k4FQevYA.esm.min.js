import{aR as e,V as s,Q as o,M as t,bJ as r,bI as n}from"./index-VvGulz6u.esm.min.js";import{GLTFLoader as a,ArrayItem as i}from"./glTFLoader-X6ZTOkAw.esm.min.js";import"./thinInstanceMesh-DZ2t0Ldc.esm.min.js";import"./bone-DPw1oOFK.esm.min.js";import"./skeleton-BDCw4yVL.esm.min.js";import"./rawTexture-B-F8SA5B.esm.min.js";import"./assetContainer-Da0Xx6Do.esm.min.js";import"./objectModelMapping-CghNRpa4.esm.min.js";const c="EXT_mesh_gpu_instancing";class m{constructor(e){this.name=c,this._loader=e,this.enabled=this._loader.isExtensionUsed(c)}dispose(){this._loader=null}loadNodeAsync(r,n,c){return a.LoadExtensionAsync(r,n,this.name,(async(r,a)=>{this._loader._disableInstancedMesh++;const m=this._loader.loadNodeAsync(`/nodes/${n.index}`,n,c);if(this._loader._disableInstancedMesh--,!n._primitiveBabylonMeshes)return await m;const l=new Array;let d=0;const u=e=>{if(null==a.attributes[e])return void l.push(Promise.resolve(null));const s=i.Get(`${r}/attributes/${e}`,this._loader.gltf.accessors,a.attributes[e]);if(l.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),0===d)d=s.count;else if(d!==s.count)throw new Error(`${r}/attributes: Instance buffer accessors do not have the same count.`)};return u("TRANSLATION"),u("ROTATION"),u("SCALE"),await m.then((async r=>{const[a,i,c]=await Promise.all(l),m=new Float32Array(16*d);e.Vector3[0].copyFromFloats(0,0,0),e.Quaternion[0].copyFromFloats(0,0,0,1),e.Vector3[1].copyFromFloats(1,1,1);for(let r=0;r<d;++r)a&&s.FromArrayToRef(a,3*r,e.Vector3[0]),i&&o.FromArrayToRef(i,4*r,e.Quaternion[0]),c&&s.FromArrayToRef(c,3*r,e.Vector3[1]),t.ComposeToRef(e.Vector3[1],e.Quaternion[0],e.Vector3[0],e.Matrix[0]),e.Matrix[0].copyToArray(m,16*r);for(const e of n._primitiveBabylonMeshes)e.thinInstanceSetBuffer("matrix",m,16,!0);return r}))}))}}r(c),n(c,!0,(e=>new m(e)));export{m as EXT_mesh_gpu_instancing};
//# sourceMappingURL=EXT_mesh_gpu_instancing-k4FQevYA.esm.min.js.map
