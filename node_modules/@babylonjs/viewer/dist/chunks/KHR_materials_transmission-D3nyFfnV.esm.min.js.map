{"version":3,"file":"KHR_materials_transmission-D3nyFfnV.esm.min.js","sources":["../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_materials_transmission.js"],"sourcesContent":["import { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\nimport { GLTFLoader } from \"../glTFLoader\";\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\nimport { Observable } from \"core/Misc/observable\";\nimport { Constants } from \"core/Engines/constants\";\nimport { Tools } from \"core/Misc/tools\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\n/**\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\n */\nclass TransmissionHelper {\n    /**\n     * Creates the default options for the helper.\n     * @returns the default options\n     */\n    static _GetDefaultOptions() {\n        return {\n            renderSize: 1024,\n            samples: 4,\n            lodGenerationScale: 1,\n            lodGenerationOffset: -4,\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\n            generateMipmaps: true,\n        };\n    }\n    /**\n     * constructor\n     * @param options Defines the options we want to customize the helper\n     * @param scene The scene to add the material to\n     */\n    constructor(options, scene) {\n        this._opaqueRenderTarget = null;\n        this._opaqueMeshesCache = [];\n        this._transparentMeshesCache = [];\n        this._materialObservers = {};\n        this._options = {\n            ...TransmissionHelper._GetDefaultOptions(),\n            ...options,\n        };\n        this._scene = scene;\n        this._scene._transmissionHelper = this;\n        this.onErrorObservable = new Observable();\n        this._scene.onDisposeObservable.addOnce(() => {\n            this.dispose();\n        });\n        this._parseScene();\n        this._setupRenderTargets();\n    }\n    /**\n     * Updates the background according to the new options\n     * @param options\n     */\n    updateOptions(options) {\n        // First check if any options are actually being changed. If not, exit.\n        const newValues = Object.keys(options).filter((key) => this._options[key] !== options[key]);\n        if (!newValues.length) {\n            return;\n        }\n        const newOptions = {\n            ...this._options,\n            ...options,\n        };\n        const oldOptions = this._options;\n        this._options = newOptions;\n        // If size changes, recreate everything\n        if (newOptions.renderSize !== oldOptions.renderSize ||\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\n            !this._opaqueRenderTarget) {\n            this._setupRenderTargets();\n        }\n        else {\n            this._opaqueRenderTarget.samples = newOptions.samples;\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\n        }\n    }\n    /**\n     * @returns the opaque render target texture or null if not available.\n     */\n    getOpaqueTarget() {\n        return this._opaqueRenderTarget;\n    }\n    _shouldRenderAsTransmission(material) {\n        if (!material) {\n            return false;\n        }\n        if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\n            return true;\n        }\n        return false;\n    }\n    _addMesh(mesh) {\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\n        Tools.SetImmediate(() => {\n            if (this._shouldRenderAsTransmission(mesh.material)) {\n                mesh.material.refractionTexture = this._opaqueRenderTarget;\n                if (this._transparentMeshesCache.indexOf(mesh) === -1) {\n                    this._transparentMeshesCache.push(mesh);\n                }\n            }\n            else {\n                if (this._opaqueMeshesCache.indexOf(mesh) === -1) {\n                    this._opaqueMeshesCache.push(mesh);\n                }\n            }\n        });\n    }\n    _removeMesh(mesh) {\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\n        delete this._materialObservers[mesh.uniqueId];\n        let idx = this._transparentMeshesCache.indexOf(mesh);\n        if (idx !== -1) {\n            this._transparentMeshesCache.splice(idx, 1);\n        }\n        idx = this._opaqueMeshesCache.indexOf(mesh);\n        if (idx !== -1) {\n            this._opaqueMeshesCache.splice(idx, 1);\n        }\n    }\n    _parseScene() {\n        this._scene.meshes.forEach(this._addMesh.bind(this));\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\n    }\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\n    _onMeshMaterialChanged(mesh) {\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\n        if (useTransmission) {\n            if (mesh.material instanceof PBRMaterial) {\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\n            }\n            if (opaqueIdx !== -1) {\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\n                this._transparentMeshesCache.push(mesh);\n            }\n            else if (transparentIdx === -1) {\n                this._transparentMeshesCache.push(mesh);\n            }\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\n        }\n        else {\n            if (transparentIdx !== -1) {\n                this._transparentMeshesCache.splice(transparentIdx, 1);\n                this._opaqueMeshesCache.push(mesh);\n            }\n            else if (opaqueIdx === -1) {\n                this._opaqueMeshesCache.push(mesh);\n            }\n        }\n    }\n    /**\n     * @internal\n     * Check if the opaque render target has not been disposed and can still be used.\n     * @returns\n     */\n    _isRenderTargetValid() {\n        return this._opaqueRenderTarget?.getInternalTexture() !== null;\n    }\n    /**\n     * @internal\n     * Setup the render targets according to the specified options.\n     */\n    _setupRenderTargets() {\n        if (this._opaqueRenderTarget) {\n            this._opaqueRenderTarget.dispose();\n        }\n        this._opaqueRenderTarget = new RenderTargetTexture(\"opaqueSceneTexture\", this._options.renderSize, this._scene, this._options.generateMipmaps, undefined, this._options.renderTargetTextureType);\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\n        this._opaqueRenderTarget.gammaSpace = false;\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\n        this._opaqueRenderTarget.samples = this._options.samples;\n        this._opaqueRenderTarget.renderSprites = true;\n        this._opaqueRenderTarget.renderParticles = true;\n        this._opaqueRenderTarget.disableImageProcessing = true;\n        let saveSceneEnvIntensity;\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\n            this._scene.environmentIntensity = 1.0;\n            if (!this._options.clearColor) {\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, this._scene.getEngine().useExactSrgbConversions);\n            }\n            else {\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\n            }\n        });\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\n        });\n        for (const mesh of this._transparentMeshesCache) {\n            if (this._shouldRenderAsTransmission(mesh.material)) {\n                mesh.material.refractionTexture = this._opaqueRenderTarget;\n            }\n        }\n    }\n    /**\n     * Dispose all the elements created by the Helper.\n     */\n    dispose() {\n        this._scene._transmissionHelper = undefined;\n        if (this._opaqueRenderTarget) {\n            this._opaqueRenderTarget.dispose();\n            this._opaqueRenderTarget = null;\n        }\n        this._transparentMeshesCache = [];\n        this._opaqueMeshesCache = [];\n    }\n}\nconst NAME = \"KHR_materials_transmission\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_transmission {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 175;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n        if (this.enabled) {\n            loader.parent.transparencyAsCoverage = true;\n        }\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n            // eslint-disable-next-line github/no-then\n            return await Promise.all(promises).then(() => { });\n        });\n    }\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\n    _loadTransparentPropertiesAsync(context, material, babylonMaterial, extension) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const pbrMaterial = babylonMaterial;\n        // Enables \"refraction\" texture which represents transmitted light.\n        pbrMaterial.subSurface.isRefractionEnabled = true;\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\n        // Albedo colour will tint transmission.\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\n        if (extension.transmissionFactor !== undefined) {\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\n            const scene = pbrMaterial.getScene();\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\n                new TransmissionHelper({}, pbrMaterial.getScene());\n            }\n            else if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper?._isRenderTargetValid()) {\n                // If the render target is not valid, recreate it.\n                scene._transmissionHelper?._setupRenderTargets();\n            }\n        }\n        else {\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\n            pbrMaterial.subSurface.isRefractionEnabled = false;\n            return Promise.resolve();\n        }\n        pbrMaterial.subSurface.minimumThickness = 0.0;\n        pbrMaterial.subSurface.maximumThickness = 0.0;\n        if (extension.transmissionTexture) {\n            extension.transmissionTexture.nonColorData = true;\n            // eslint-disable-next-line github/no-then\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then((texture) => {\n                texture.name = `${babylonMaterial.name} (Transmission)`;\n                pbrMaterial.subSurface.refractionIntensityTexture = texture;\n                pbrMaterial.subSurface.useGltfStyleTextures = true;\n            });\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_transmission(loader));\n//# sourceMappingURL=KHR_materials_transmission.js.map"],"names":["TransmissionHelper","_GetDefaultOptions","renderSize","samples","lodGenerationScale","lodGenerationOffset","renderTargetTextureType","Constants","TEXTURETYPE_HALF_FLOAT","generateMipmaps","constructor","options","scene","this","_opaqueRenderTarget","_opaqueMeshesCache","_transparentMeshesCache","_materialObservers","_options","_scene","_transmissionHelper","onErrorObservable","Observable","onDisposeObservable","addOnce","dispose","_parseScene","_setupRenderTargets","updateOptions","Object","keys","filter","key","length","newOptions","oldOptions","getOpaqueTarget","_shouldRenderAsTransmission","material","PBRMaterial","subSurface","isRefractionEnabled","_addMesh","mesh","uniqueId","onMaterialChangedObservable","add","_onMeshMaterialChanged","bind","Tools","SetImmediate","refractionTexture","indexOf","push","_removeMesh","remove","idx","splice","meshes","forEach","onNewMeshAddedObservable","onMeshRemovedObservable","transparentIdx","opaqueIdx","_isRenderTargetValid","getInternalTexture","saveSceneEnvIntensity","RenderTargetTexture","undefined","ignoreCameraViewport","renderList","clearColor","clone","gammaSpace","renderSprites","renderParticles","disableImageProcessing","onBeforeBindObservable","opaqueRenderTarget","environmentIntensity","copyFrom","toLinearSpaceToRef","getEngine","useExactSrgbConversions","onAfterUnbindObservable","NAME","KHR_materials_transmission","loader","name","order","_loader","enabled","isExtensionUsed","parent","transparencyAsCoverage","loadMaterialPropertiesAsync","context","babylonMaterial","GLTFLoader","LoadExtensionAsync","async","extensionContext","extension","promises","Array","_loadTransparentPropertiesAsync","Promise","all","then","Error","pbrMaterial","volumeIndexOfRefraction","useAlbedoToTintRefraction","transmissionFactor","refractionIntensity","resolve","getScene","minimumThickness","maximumThickness","transmissionTexture","nonColorData","loadTextureInfoAsync","texture","refractionIntensityTexture","useGltfStyleTextures","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}