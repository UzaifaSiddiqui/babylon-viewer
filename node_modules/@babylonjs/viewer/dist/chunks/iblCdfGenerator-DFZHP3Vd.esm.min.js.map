{"version":3,"file":"iblCdfGenerator-DFZHP3Vd.esm.min.js","sources":["../../../../../dev/core/dist/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js","../../../../../dev/core/dist/Materials/Textures/Procedurals/proceduralTexture.js","../../../../../dev/core/dist/Rendering/iblCdfGenerator.js"],"sourcesContent":["import { Tools } from \"../../../Misc/tools\";\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\n/**\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\n * in a given scene.\n */\nexport class ProceduralTextureSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do here.\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        // Nothing to do here.\n    }\n    _beforeClear() {\n        if (this.scene.proceduralTexturesEnabled) {\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\n                if (proceduralTexture._shouldRender()) {\n                    proceduralTexture.render();\n                }\n            }\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n        }\n    }\n}\n//# sourceMappingURL=proceduralTextureSceneComponent.js.map","import { __decorate } from \"tslib\";\nimport { serialize } from \"../../../Misc/decorators\";\nimport { Observable } from \"../../../Misc/observable\";\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\nimport { Material } from \"../../../Materials/material\";\nimport { Texture } from \"../../../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\nimport { RegisterClass } from \"../../../Misc/typeStore\";\nimport { EngineStore } from \"../../../Engines/engineStore\";\nimport { Constants } from \"../../../Engines/constants\";\nimport { DrawWrapper } from \"../../drawWrapper\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\n * This is the base class of any Procedural texture and contains most of the shareable code.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n */\nexport class ProceduralTexture extends Texture {\n    /**\n     * Gets the shader language type used to generate vertex and fragment source code.\n     */\n    get shaderLanguage() {\n        return this._shaderLanguage;\n    }\n    /**\n     * Instantiates a new procedural texture.\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n     * This is the base class of any Procedural texture and contains most of the shareable code.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n     * @param name  Define the name of the texture\n     * @param size Define the size of the texture to create\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\n     *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\n     *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\n     *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\n     * @param scene Define the scene the texture belongs to\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n     * @param generateMipMaps Define if the texture should creates mip maps or not\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\n     * @param textureType The FBO internal texture type\n     */\n    constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE) {\n        super(null, scene, !generateMipMaps);\n        /**\n         * Define if the texture is enabled or not (disabled texture will not render)\n         */\n        this.isEnabled = true;\n        /**\n         * Define if the texture must be cleared before rendering (default is true)\n         */\n        this.autoClear = true;\n        /**\n         * Event raised when the texture is generated\n         */\n        this.onGeneratedObservable = new Observable();\n        /**\n         * Event raised before the texture is generated\n         */\n        this.onBeforeGenerationObservable = new Observable();\n        /**\n         * Gets or sets the node material used to create this texture (null if the texture was manually created)\n         */\n        this.nodeMaterialSource = null;\n        /**\n         * Define the list of custom preprocessor defines used in the shader\n         */\n        this.defines = \"\";\n        /** @internal */\n        this._textures = {};\n        this._currentRefreshId = -1;\n        this._frameId = -1;\n        this._refreshRate = 1;\n        this._vertexBuffers = {};\n        this._uniforms = new Array();\n        this._samplers = new Array();\n        this._floats = {};\n        this._ints = {};\n        this._floatsArrays = {};\n        this._colors3 = {};\n        this._colors4 = {};\n        this._vectors2 = {};\n        this._vectors3 = {};\n        this._vectors4 = {};\n        this._matrices = {};\n        this._fallbackTextureUsed = false;\n        this._cachedDefines = null;\n        this._contentUpdateId = -1;\n        this._rtWrapper = null;\n        if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {\n            this._options = fallbackTexture;\n            this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;\n        }\n        else {\n            this._options = {};\n            this._fallbackTexture = fallbackTexture;\n        }\n        this._shaderLanguage = this._options.shaderLanguage ?? 0 /* ShaderLanguage.GLSL */;\n        scene = this.getScene() || EngineStore.LastCreatedScene;\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n        if (!component) {\n            component = new ProceduralTextureSceneComponent(scene);\n            scene._addComponent(component);\n        }\n        scene.proceduralTextures.push(this);\n        this._fullEngine = scene.getEngine();\n        this.name = name;\n        this.isRenderTarget = true;\n        this._size = size;\n        this._textureType = textureType;\n        this._generateMipMaps = generateMipMaps;\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\n        this.setFragment(fragment);\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\n        this._texture = rtWrapper.texture;\n        // VBO\n        const vertices = [];\n        vertices.push(1, 1);\n        vertices.push(-1, 1);\n        vertices.push(-1, -1);\n        vertices.push(1, -1);\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n        this._createIndexBuffer();\n    }\n    _createRtWrapper(isCube, size, generateMipMaps, textureType) {\n        if (isCube) {\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {\n                generateMipMaps: generateMipMaps,\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n                type: textureType,\n                ...this._options,\n            });\n            this.setFloat(\"face\", 0);\n        }\n        else {\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\n                generateMipMaps: generateMipMaps,\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n                type: textureType,\n                ...this._options,\n            });\n            if (this._rtWrapper.is3D) {\n                this.setFloat(\"layer\", 0);\n                this.setInt(\"layerNum\", 0);\n            }\n        }\n        return this._rtWrapper;\n    }\n    /**\n     * The effect that is created when initializing the post process.\n     * @returns The created effect corresponding the postprocess.\n     */\n    getEffect() {\n        return this._drawWrapper.effect;\n    }\n    /**\n     * @internal\n     */\n    _setEffect(effect) {\n        this._drawWrapper.effect = effect;\n    }\n    /**\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\n     */\n    getContent() {\n        if (this._contentData && this._frameId === this._contentUpdateId) {\n            return this._contentData;\n        }\n        if (this._contentData) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n            this._contentData.then((buffer) => {\n                this._contentData = this.readPixels(0, 0, buffer);\n                this._contentUpdateId = this._frameId;\n            });\n        }\n        else {\n            this._contentData = this.readPixels(0, 0);\n            this._contentUpdateId = this._frameId;\n        }\n        return this._contentData;\n    }\n    _createIndexBuffer() {\n        const engine = this._fullEngine;\n        // Indices\n        const indices = [];\n        indices.push(0);\n        indices.push(1);\n        indices.push(2);\n        indices.push(0);\n        indices.push(2);\n        indices.push(3);\n        this._indexBuffer = engine.createIndexBuffer(indices);\n    }\n    /** @internal */\n    _rebuild() {\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vb) {\n            vb._rebuild();\n        }\n        this._createIndexBuffer();\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n        }\n    }\n    /**\n     * Resets the texture in order to recreate its associated resources.\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\n     */\n    reset() {\n        this._drawWrapper.effect?.dispose();\n        this._drawWrapper.effect = null;\n        this._cachedDefines = null;\n    }\n    _getDefines() {\n        return this.defines;\n    }\n    /**\n     * Executes a function when the texture will be ready to be drawn.\n     * @param func The callback to be used.\n     */\n    executeWhenReady(func) {\n        if (this.isReady()) {\n            func(this);\n            return;\n        }\n        const effect = this.getEffect();\n        if (effect) {\n            effect.executeWhenCompiled(() => {\n                func(this);\n            });\n        }\n    }\n    /**\n     * Is the texture ready to be used ? (rendered at least once)\n     * @returns true if ready, otherwise, false.\n     */\n    isReady() {\n        const engine = this._fullEngine;\n        if (this.nodeMaterialSource) {\n            return this._drawWrapper.effect.isReady();\n        }\n        if (!this._fragment) {\n            return false;\n        }\n        if (this._fallbackTextureUsed) {\n            return true;\n        }\n        if (!this._texture) {\n            return false;\n        }\n        const defines = this._getDefines();\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\n            return true;\n        }\n        const shaders = {\n            vertex: \"procedural\",\n            fragmentElement: this._fragment.fragmentElement,\n            fragmentSource: this._fragment.fragmentSource,\n            fragment: typeof this._fragment === \"string\" ? this._fragment : undefined,\n        };\n        if (this._cachedDefines !== defines) {\n            this._cachedDefines = defines;\n            this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\n                this._rtWrapper?.dispose();\n                this._rtWrapper = this._texture = null;\n                if (this._fallbackTexture) {\n                    this._texture = this._fallbackTexture._texture;\n                    if (this._texture) {\n                        this._texture.incrementReferences();\n                    }\n                }\n                this._fallbackTextureUsed = true;\n            }, undefined, this._shaderLanguage, async () => {\n                if (this._options.extraInitializationsAsync) {\n                    if (this.shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n                        await Promise.all([import(\"../../../ShadersWGSL/procedural.vertex\"), this._options.extraInitializationsAsync()]);\n                    }\n                    else {\n                        await Promise.all([import(\"../../../Shaders/procedural.vertex\"), this._options.extraInitializationsAsync()]);\n                    }\n                }\n                else {\n                    if (this.shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n                        await import(\"../../../ShadersWGSL/procedural.vertex\");\n                    }\n                    else {\n                        await import(\"../../../Shaders/procedural.vertex\");\n                    }\n                }\n            });\n        }\n        return this._drawWrapper.effect.isReady();\n    }\n    /**\n     * Resets the refresh counter of the texture and start bak from scratch.\n     * Could be useful to regenerate the texture if it is setup to render only once.\n     */\n    resetRefreshCounter() {\n        this._currentRefreshId = -1;\n    }\n    /**\n     * Set the fragment shader to use in order to render the texture.\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\n     */\n    setFragment(fragment) {\n        this._fragment = fragment;\n    }\n    /**\n     * Define the refresh rate of the texture or the rendering frequency.\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n     */\n    get refreshRate() {\n        return this._refreshRate;\n    }\n    set refreshRate(value) {\n        this._refreshRate = value;\n        this.resetRefreshCounter();\n    }\n    /** @internal */\n    _shouldRender() {\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\n            if (this._texture) {\n                this._texture.isReady = false;\n            }\n            return false;\n        }\n        if (this._fallbackTextureUsed) {\n            return false;\n        }\n        if (this._currentRefreshId === -1) {\n            // At least render once\n            this._currentRefreshId = 1;\n            this._frameId++;\n            return true;\n        }\n        if (this.refreshRate === this._currentRefreshId) {\n            this._currentRefreshId = 1;\n            this._frameId++;\n            return true;\n        }\n        this._currentRefreshId++;\n        return false;\n    }\n    /**\n     * Get the size the texture is rendering at.\n     * @returns the size (on cube texture it is always squared)\n     */\n    getRenderSize() {\n        return this._size;\n    }\n    /**\n     * Resize the texture to new value.\n     * @param size Define the new size the texture should have\n     * @param generateMipMaps Define whether the new texture should create mip maps\n     */\n    resize(size, generateMipMaps) {\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\n            return;\n        }\n        const isCube = this._texture.isCube;\n        this._rtWrapper.dispose();\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\n        this._texture = rtWrapper.texture;\n        // Update properties\n        this._size = size;\n        this._generateMipMaps = generateMipMaps;\n    }\n    _checkUniform(uniformName) {\n        if (this._uniforms.indexOf(uniformName) === -1) {\n            this._uniforms.push(uniformName);\n        }\n    }\n    /**\n     * Set a texture in the shader program used to render.\n     * @param name Define the name of the uniform samplers as defined in the shader\n     * @param texture Define the texture to bind to this sampler\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setTexture(name, texture) {\n        if (this._samplers.indexOf(name) === -1) {\n            this._samplers.push(name);\n        }\n        this._textures[name] = texture;\n        return this;\n    }\n    /**\n     * Set a float in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setFloat(name, value) {\n        this._checkUniform(name);\n        this._floats[name] = value;\n        return this;\n    }\n    /**\n     * Set a int in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setInt(name, value) {\n        this._checkUniform(name);\n        this._ints[name] = value;\n        return this;\n    }\n    /**\n     * Set an array of floats in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setFloats(name, value) {\n        this._checkUniform(name);\n        this._floatsArrays[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 in the shader from a Color3.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setColor3(name, value) {\n        this._checkUniform(name);\n        this._colors3[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 in the shader from a Color4.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setColor4(name, value) {\n        this._checkUniform(name);\n        this._colors4[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec2 in the shader from a Vector2.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setVector2(name, value) {\n        this._checkUniform(name);\n        this._vectors2[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 in the shader from a Vector3.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setVector3(name, value) {\n        this._checkUniform(name);\n        this._vectors3[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 in the shader from a Vector4.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setVector4(name, value) {\n        this._checkUniform(name);\n        this._vectors4[name] = value;\n        return this;\n    }\n    /**\n     * Set a mat4 in the shader from a MAtrix.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setMatrix(name, value) {\n        this._checkUniform(name);\n        this._matrices[name] = value;\n        return this;\n    }\n    /**\n     * Render the texture to its associated render target.\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    render(useCameraPostProcess) {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = this._fullEngine;\n        // Render\n        engine.enableEffect(this._drawWrapper);\n        this.onBeforeGenerationObservable.notifyObservers(this);\n        engine.setState(false);\n        if (!this.nodeMaterialSource) {\n            // Texture\n            for (const name in this._textures) {\n                this._drawWrapper.effect.setTexture(name, this._textures[name]);\n            }\n            // Float\n            for (const name in this._ints) {\n                this._drawWrapper.effect.setInt(name, this._ints[name]);\n            }\n            // Float\n            for (const name in this._floats) {\n                this._drawWrapper.effect.setFloat(name, this._floats[name]);\n            }\n            // Floats\n            for (const name in this._floatsArrays) {\n                this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);\n            }\n            // Color3\n            for (const name in this._colors3) {\n                this._drawWrapper.effect.setColor3(name, this._colors3[name]);\n            }\n            // Color4\n            for (const name in this._colors4) {\n                const color = this._colors4[name];\n                this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);\n            }\n            // Vector2\n            for (const name in this._vectors2) {\n                this._drawWrapper.effect.setVector2(name, this._vectors2[name]);\n            }\n            // Vector3\n            for (const name in this._vectors3) {\n                this._drawWrapper.effect.setVector3(name, this._vectors3[name]);\n            }\n            // Vector4\n            for (const name in this._vectors4) {\n                this._drawWrapper.effect.setVector4(name, this._vectors4[name]);\n            }\n            // Matrix\n            for (const name in this._matrices) {\n                this._drawWrapper.effect.setMatrix(name, this._matrices[name]);\n            }\n        }\n        if (!this._texture || !this._rtWrapper) {\n            return;\n        }\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\n        const viewPort = engine.currentViewport;\n        if (this.isCube) {\n            for (let face = 0; face < 6; face++) {\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\n                // VBOs\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n                this._drawWrapper.effect.setFloat(\"face\", face);\n                // Clear\n                if (this.autoClear) {\n                    engine.clear(scene.clearColor, true, false, false);\n                }\n                // Draw order\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n                // Unbind and restore viewport\n                engine.unBindFramebuffer(this._rtWrapper, true);\n            }\n        }\n        else {\n            let numLayers = 1;\n            if (this._rtWrapper.is3D) {\n                numLayers = this._rtWrapper.depth;\n            }\n            else if (this._rtWrapper.is2DArray) {\n                numLayers = this._rtWrapper.layers;\n            }\n            for (let layer = 0; layer < numLayers; layer++) {\n                engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true, 0, layer);\n                // VBOs\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n                if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {\n                    this._drawWrapper.effect?.setFloat(\"layer\", numLayers !== 1 ? layer / (numLayers - 1) : 0);\n                    this._drawWrapper.effect?.setInt(\"layerNum\", layer);\n                    for (const name in this._textures) {\n                        this._drawWrapper.effect.setTexture(name, this._textures[name]);\n                    }\n                }\n                // Clear\n                if (this.autoClear) {\n                    engine.clear(scene.clearColor, true, false, false);\n                }\n                // Draw order\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n                // Unbind and restore viewport\n                engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);\n            }\n        }\n        if (viewPort) {\n            engine.setViewport(viewPort);\n        }\n        // Mipmaps\n        if (this.isCube) {\n            engine.generateMipMapsForCubemap(this._texture, true);\n        }\n        engine._debugPopGroup?.(1);\n        if (this.onGenerated) {\n            this.onGenerated();\n        }\n        this.onGeneratedObservable.notifyObservers(this);\n    }\n    /**\n     * Clone the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const textureSize = this.getSize();\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // RenderTarget Texture\n        newTexture.coordinatesMode = this.coordinatesMode;\n        return newTexture;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const index = scene.proceduralTextures.indexOf(this);\n        if (index >= 0) {\n            scene.proceduralTextures.splice(index, 1);\n        }\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vertexBuffer) {\n            vertexBuffer.dispose();\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\n        }\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n            this._indexBuffer = null;\n        }\n        this.onGeneratedObservable.clear();\n        this.onBeforeGenerationObservable.clear();\n        super.dispose();\n    }\n}\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"isEnabled\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"autoClear\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"_size\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"refreshRate\", null);\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\n//# sourceMappingURL=proceduralTexture.js.map","import { Constants } from \"../Engines/constants\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\nimport { PostProcess } from \"../PostProcesses/postProcess\";\nimport { Vector3, Vector4 } from \"../Maths/math.vector\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { Observable } from \"../Misc/observable\";\nimport { Engine } from \"../Engines/engine\";\nimport { _WarnImport } from \"../Misc/devTools\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"../Misc/logger\";\n/**\n * Build cdf maps to be used for IBL importance sampling.\n */\nexport class IblCdfGenerator {\n    /**\n     * Returns whether the CDF renderer is supported by the current engine\n     */\n    get isSupported() {\n        const engine = EngineStore.LastCreatedEngine;\n        if (!engine) {\n            return false;\n        }\n        return engine.getCaps().texelFetch;\n    }\n    /**\n     * Gets the IBL source texture being used by the CDF renderer\n     */\n    get iblSource() {\n        return this._iblSource;\n    }\n    /**\n     * Sets the IBL source texture to be used by the CDF renderer.\n     * This will trigger recreation of the CDF assets.\n     */\n    set iblSource(source) {\n        if (this._iblSource === source) {\n            return;\n        }\n        this._disposeTextures();\n        this._iblSource = source;\n        if (!source) {\n            return;\n        }\n        if (source.isCube) {\n            if (source.isReadyOrNotBlocking()) {\n                this._recreateAssetsFromNewIbl();\n            }\n            else {\n                source.onLoadObservable.addOnce(this._recreateAssetsFromNewIbl.bind(this, source));\n            }\n        }\n        else {\n            if (source.isReadyOrNotBlocking()) {\n                this._recreateAssetsFromNewIbl();\n            }\n            else {\n                source.onLoadObservable.addOnce(this._recreateAssetsFromNewIbl.bind(this, source));\n            }\n        }\n    }\n    _recreateAssetsFromNewIbl() {\n        if (this._debugPass) {\n            this._debugPass.dispose();\n        }\n        this._createTextures();\n        if (this._debugPass) {\n            // Recreate the debug pass because of the new textures\n            this._createDebugPass();\n        }\n    }\n    /**\n     * Return the cumulative distribution function (CDF) texture\n     * @returns Return the cumulative distribution function (CDF) texture\n     */\n    getIcdfTexture() {\n        return this._icdfPT ? this._icdfPT : this._dummyTexture;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * The name of the debug pass post process\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * Gets the debug pass post process\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPass) {\n            this._createDebugPass();\n        }\n        return this._debugPass;\n    }\n    /**\n     * Instanciates the CDF renderer\n     * @param sceneOrEngine Scene to attach to\n     * @returns The CDF renderer\n     */\n    constructor(sceneOrEngine) {\n        this._cachedDominantDirection = null;\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 1.0, 1.0);\n        this._debugPassName = \"CDF Debug\";\n        /**\n         * Observable that triggers when the CDF renderer is ready\n         */\n        this.onGeneratedObservable = new Observable();\n        if (sceneOrEngine) {\n            if (IblCdfGenerator._IsScene(sceneOrEngine)) {\n                this._scene = sceneOrEngine;\n            }\n            else {\n                this._engine = sceneOrEngine;\n            }\n        }\n        else {\n            this._scene = EngineStore.LastCreatedScene;\n        }\n        if (this._scene) {\n            this._engine = this._scene.getEngine();\n        }\n        if (!this.isSupported) {\n            Logger.Warn(\"CDF renderer is not supported by the current engine.\");\n            return;\n        }\n        const blackPixels = new Uint16Array([0, 0, 0, 255]);\n        this._dummyTexture = new RawTexture(blackPixels, 1, 1, Engine.TEXTUREFORMAT_RGBA, sceneOrEngine, false, false, undefined, Constants.TEXTURETYPE_HALF_FLOAT);\n        if (this._scene) {\n            IblCdfGenerator._SceneComponentInitialization(this._scene);\n        }\n    }\n    _createTextures() {\n        const size = this._iblSource ? { width: this._iblSource.getSize().width, height: this._iblSource.getSize().height } : { width: 1, height: 1 };\n        if (!this._iblSource) {\n            this._iblSource = RawTexture.CreateRTexture(new Uint8Array([255]), 1, 1, this._engine, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_BYTE);\n            this._iblSource.name = \"Placeholder IBL Source\";\n        }\n        if (this._iblSource.isCube) {\n            size.width *= 4;\n            size.height *= 2;\n            // Force the resolution to be a power of 2 because we rely on the\n            // auto-mipmap generation for the scaled luminance texture to produce\n            // a 1x1 mip that represents the true average pixel intensity of the IBL.\n            size.width = 1 << Math.floor(Math.log2(size.width));\n            size.height = 1 << Math.floor(Math.log2(size.height));\n        }\n        const isWebGPU = this._engine.isWebGPU;\n        // Create CDF maps (Cumulative Distribution Function) to assist in importance sampling\n        const cdfOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            format: Constants.TEXTUREFORMAT_R,\n            type: Constants.TEXTURETYPE_FLOAT,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            gammaSpace: false,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../ShadersWGSL/iblCdfx.fragment\"), import(\"../ShadersWGSL/iblCdfy.fragment\"), import(\"../ShadersWGSL/iblScaledLuminance.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../Shaders/iblCdfx.fragment\"), import(\"../Shaders/iblCdfy.fragment\"), import(\"../Shaders/iblScaledLuminance.fragment\")]);\n                }\n            },\n        };\n        const icdfOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            gammaSpace: false,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../ShadersWGSL/iblIcdf.fragment\"), import(\"../ShadersWGSL/iblDominantDirection.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../Shaders/iblIcdf.fragment\"), import(\"../Shaders/iblDominantDirection.fragment\")]);\n                }\n            },\n        };\n        this._cdfyPT = new ProceduralTexture(\"cdfyTexture\", { width: size.width, height: size.height + 1 }, \"iblCdfy\", this._scene, cdfOptions, false, false);\n        this._cdfyPT.autoClear = false;\n        this._cdfyPT.setTexture(\"iblSource\", this._iblSource);\n        this._cdfyPT.setInt(\"iblHeight\", size.height);\n        this._cdfyPT.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        this._cdfyPT.refreshRate = 0;\n        if (this._iblSource.isCube) {\n            this._cdfyPT.defines = \"#define IBL_USE_CUBE_MAP\\n\";\n        }\n        this._cdfxPT = new ProceduralTexture(\"cdfxTexture\", { width: size.width + 1, height: 1 }, \"iblCdfx\", this._scene, cdfOptions, false, false);\n        this._cdfxPT.autoClear = false;\n        this._cdfxPT.setTexture(\"cdfy\", this._cdfyPT);\n        this._cdfxPT.refreshRate = 0;\n        this._cdfxPT.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        this._scaledLuminancePT = new ProceduralTexture(\"iblScaledLuminance\", { width: size.width, height: size.height }, \"iblScaledLuminance\", this._scene, { ...cdfOptions, samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, generateMipMaps: true }, true, false);\n        this._scaledLuminancePT.autoClear = false;\n        this._scaledLuminancePT.setTexture(\"iblSource\", this._iblSource);\n        this._scaledLuminancePT.setInt(\"iblHeight\", size.height);\n        this._scaledLuminancePT.setInt(\"iblWidth\", size.width);\n        this._scaledLuminancePT.refreshRate = 0;\n        if (this._iblSource.isCube) {\n            this._scaledLuminancePT.defines = \"#define IBL_USE_CUBE_MAP\\n\";\n        }\n        this._icdfPT = new ProceduralTexture(\"icdfTexture\", { width: size.width, height: size.height }, \"iblIcdf\", this._scene, icdfOptions, false, false);\n        this._icdfPT.autoClear = false;\n        this._icdfPT.setTexture(\"cdfy\", this._cdfyPT);\n        this._icdfPT.setTexture(\"cdfx\", this._cdfxPT);\n        this._icdfPT.setTexture(\"iblSource\", this._iblSource);\n        this._icdfPT.setTexture(\"scaledLuminanceSampler\", this._scaledLuminancePT);\n        this._icdfPT.refreshRate = 0;\n        this._icdfPT.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        this._icdfPT.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        if (this._iblSource.isCube) {\n            this._icdfPT.defines = \"#define IBL_USE_CUBE_MAP\\n\";\n        }\n        // Once the textures are generated, notify that they are ready to use.\n        this._icdfPT.onGeneratedObservable.addOnce(() => {\n            this.onGeneratedObservable.notifyObservers();\n        });\n        this._dominantDirectionPT = new ProceduralTexture(\"iblDominantDirection\", { width: 1, height: 1 }, \"iblDominantDirection\", this._scene, icdfOptions, false, false);\n        this._dominantDirectionPT.autoClear = false;\n        this._dominantDirectionPT.setTexture(\"icdfSampler\", this._icdfPT);\n        this._dominantDirectionPT.refreshRate = 0;\n        this._dominantDirectionPT.defines = \"#define NUM_SAMPLES 32u\\n\";\n    }\n    _disposeTextures() {\n        this._cdfyPT?.dispose();\n        this._cdfxPT?.dispose();\n        this._icdfPT?.dispose();\n        this._scaledLuminancePT?.dispose();\n        this._dominantDirectionPT?.dispose();\n    }\n    _createDebugPass() {\n        if (this._debugPass) {\n            this._debugPass.dispose();\n        }\n        const isWebGPU = this._engine.isWebGPU;\n        const debugOptions = {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\n            engine: this._engine,\n            textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            uniforms: [\"sizeParams\"],\n            samplers: [\"cdfy\", \"icdf\", \"cdfx\", \"iblSource\"],\n            defines: this._iblSource?.isCube ? \"#define IBL_USE_CUBE_MAP\\n\" : \"\",\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializations: (useWebGPU, list) => {\n                if (useWebGPU) {\n                    list.push(import(\"../ShadersWGSL/iblCdfDebug.fragment\"));\n                }\n                else {\n                    list.push(import(\"../Shaders/iblCdfDebug.fragment\"));\n                }\n            },\n        };\n        this._debugPass = new PostProcess(this._debugPassName, \"iblCdfDebug\", debugOptions);\n        const debugEffect = this._debugPass.getEffect();\n        if (debugEffect) {\n            debugEffect.defines = this._iblSource?.isCube ? \"#define IBL_USE_CUBE_MAP\\n\" : \"\";\n        }\n        if (this._iblSource?.isCube) {\n            this._debugPass.updateEffect(\"#define IBL_USE_CUBE_MAP\\n\");\n        }\n        this._debugPass.onApplyObservable.add((effect) => {\n            effect.setTexture(\"cdfy\", this._cdfyPT);\n            effect.setTexture(\"icdf\", this._icdfPT);\n            effect.setTexture(\"cdfx\", this._cdfxPT);\n            effect.setTexture(\"iblSource\", this._iblSource);\n            effect.setFloat4(\"sizeParams\", this._debugSizeParams.x, this._debugSizeParams.y, this._debugSizeParams.z, this._debugSizeParams.w);\n        });\n    }\n    /**\n     * Checks if the CDF renderer is ready\n     * @returns true if the CDF renderer is ready\n     */\n    isReady() {\n        return (this._iblSource &&\n            this._iblSource.name !== \"Placeholder IBL Source\" &&\n            this._iblSource.isReady() &&\n            this._cdfyPT &&\n            this._cdfyPT.isReady() &&\n            this._icdfPT &&\n            this._icdfPT.isReady() &&\n            this._cdfxPT &&\n            this._cdfxPT.isReady() &&\n            this._scaledLuminancePT &&\n            this._scaledLuminancePT.isReady());\n    }\n    /**\n     * Explicitly trigger generation of CDF maps when they are ready to render.\n     * @returns Promise that resolves when the CDF maps are rendered.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\n    renderWhenReady() {\n        this._cachedDominantDirection = null;\n        // Once the textures are generated, notify that they are ready to use.\n        this._icdfPT.onGeneratedObservable.addOnce(() => {\n            this.onGeneratedObservable.notifyObservers();\n        });\n        const promises = [];\n        const renderTargets = [this._cdfyPT, this._cdfxPT, this._scaledLuminancePT, this._icdfPT];\n        for (const target of renderTargets) {\n            promises.push(new Promise((resolve) => {\n                if (target.isReady()) {\n                    resolve();\n                }\n                else {\n                    target.getEffect().executeWhenCompiled(() => {\n                        resolve();\n                    });\n                }\n            }));\n        }\n        // eslint-disable-next-line github/no-then\n        return Promise.all(promises).then(() => {\n            for (const target of renderTargets) {\n                target.render();\n            }\n        });\n    }\n    /**\n     * Finds the average direction of the highest intensity areas of the IBL source\n     * @returns Async promise that resolves to the dominant direction of the IBL source\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    findDominantDirection() {\n        if (this._cachedDominantDirection) {\n            return Promise.resolve(this._cachedDominantDirection);\n        }\n        return new Promise((resolve) => {\n            this._dominantDirectionPT.onGeneratedObservable.addOnce(() => {\n                const data = new Float32Array(4);\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                this._dominantDirectionPT.readPixels(0, 0, data, true).then(() => {\n                    const dominantDirection = new Vector3(data[0], data[1], data[2]);\n                    this._cachedDominantDirection = dominantDirection;\n                    resolve(dominantDirection);\n                });\n            });\n            if (this.isReady()) {\n                if (this._dominantDirectionPT.isReady()) {\n                    this._dominantDirectionPT.render();\n                }\n                else {\n                    this._dominantDirectionPT.getEffect().executeWhenCompiled(() => {\n                        this._dominantDirectionPT.render();\n                    });\n                }\n            }\n            else {\n                this.onGeneratedObservable.addOnce(() => {\n                    if (this._dominantDirectionPT.isReady()) {\n                        this._dominantDirectionPT.render();\n                    }\n                    else {\n                        this._dominantDirectionPT.getEffect().executeWhenCompiled(() => {\n                            this._dominantDirectionPT.render();\n                        });\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * Disposes the CDF renderer and associated resources\n     */\n    dispose() {\n        this._disposeTextures();\n        this._dummyTexture.dispose();\n        if (this._debugPass) {\n            this._debugPass.dispose();\n        }\n        this.onGeneratedObservable.clear();\n    }\n    static _IsScene(sceneOrEngine) {\n        return sceneOrEngine.getClassName() === \"Scene\";\n    }\n}\n/**\n * @internal\n */\nIblCdfGenerator._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"IblCdfGeneratorSceneComponentSceneComponent\");\n};\n//# sourceMappingURL=iblCdfGenerator.js.map"],"names":["ProceduralTextureSceneComponent","constructor","scene","this","name","SceneComponentConstants","NAME_PROCEDURALTEXTURE","register","_beforeClearStage","registerStep","STEP_BEFORECLEAR_PROCEDURALTEXTURE","_beforeClear","rebuild","dispose","proceduralTexturesEnabled","Tools","StartPerformanceCounter","proceduralTextures","length","proceduralIndex","proceduralTexture","_shouldRender","render","EndPerformanceCounter","ProceduralTexture","Texture","shaderLanguage","_shaderLanguage","size","fragment","fallbackTexture","generateMipMaps","isCube","textureType","Constants","TEXTURETYPE_UNSIGNED_BYTE","super","isEnabled","autoClear","onGeneratedObservable","Observable","onBeforeGenerationObservable","nodeMaterialSource","defines","_textures","_currentRefreshId","_frameId","_refreshRate","_vertexBuffers","_uniforms","Array","_samplers","_floats","_ints","_floatsArrays","_colors3","_colors4","_vectors2","_vectors3","_vectors4","_matrices","_fallbackTextureUsed","_cachedDefines","_contentUpdateId","_rtWrapper","_options","_fallbackTexture","component","getScene","EngineStore","LastCreatedScene","_getComponent","_addComponent","push","_fullEngine","getEngine","isRenderTarget","_size","_textureType","_generateMipMaps","_drawWrapper","DrawWrapper","setFragment","rtWrapper","_createRtWrapper","_texture","texture","vertices","VertexBuffer","PositionKind","_createIndexBuffer","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","type","setFloat","createRenderTargetTexture","is3D","setInt","getEffect","effect","_setEffect","getContent","_contentData","then","buffer","readPixels","engine","indices","_indexBuffer","createIndexBuffer","_rebuild","vb","refreshRate","RenderTargetTexture","REFRESHRATE_RENDER_ONCE","reset","_getDefines","executeWhenReady","func","isReady","executeWhenCompiled","_fragment","shaders","vertex","fragmentElement","fragmentSource","undefined","createEffect","incrementReferences","async","extraInitializationsAsync","Promise","all","import","resetRefreshCounter","value","getRenderSize","resize","_checkUniform","uniformName","indexOf","setTexture","setFloats","setColor3","setColor4","setVector2","setVector3","setVector4","setMatrix","useCameraPostProcess","enableEffect","notifyObservers","setState","setArray","color","setFloat4","r","g","b","a","_debugPushGroup","viewPort","currentViewport","face","bindFramebuffer","bindBuffers","clear","clearColor","drawElementsType","Material","TriangleFillMode","unBindFramebuffer","numLayers","depth","is2DArray","layers","layer","setViewport","generateMipMapsForCubemap","_debugPopGroup","onGenerated","clone","textureSize","getSize","newTexture","width","hasAlpha","level","coordinatesMode","index","splice","vertexBuffer","_releaseBuffer","__decorate","serialize","prototype","RegisterClass","IblCdfGenerator","isSupported","LastCreatedEngine","getCaps","texelFetch","iblSource","_iblSource","source","_disposeTextures","isReadyOrNotBlocking","_recreateAssetsFromNewIbl","onLoadObservable","addOnce","bind","_debugPass","_createTextures","_createDebugPass","getIcdfTexture","_icdfPT","_dummyTexture","setDebugDisplayParams","x","y","widthScale","heightScale","_debugSizeParams","set","debugPassName","_debugPassName","getDebugPassPP","sceneOrEngine","_cachedDominantDirection","debugEnabled","Vector4","_IsScene","_scene","_engine","Logger","Warn","blackPixels","Uint16Array","RawTexture","Engine","TEXTUREFORMAT_RGBA","TEXTURETYPE_HALF_FLOAT","_SceneComponentInitialization","height","CreateRTexture","Uint8Array","TEXTURE_NEAREST_SAMPLINGMODE","Math","floor","log2","isWebGPU","cdfOptions","format","TEXTUREFORMAT_R","TEXTURETYPE_FLOAT","samplingMode","gammaSpace","icdfOptions","_cdfyPT","wrapV","TEXTURE_CLAMP_ADDRESSMODE","_cdfxPT","wrapU","_scaledLuminancePT","TEXTURE_TRILINEAR_SAMPLINGMODE","_dominantDirectionPT","debugOptions","getRenderWidth","getRenderHeight","BILINEAR_SAMPLINGMODE","uniforms","samplers","extraInitializations","useWebGPU","list","PostProcess","debugEffect","updateEffect","onApplyObservable","add","z","w","renderWhenReady","promises","renderTargets","target","resolve","findDominantDirection","data","Float32Array","dominantDirection","Vector3","getClassName","_","_WarnImport"],"mappings":"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"}