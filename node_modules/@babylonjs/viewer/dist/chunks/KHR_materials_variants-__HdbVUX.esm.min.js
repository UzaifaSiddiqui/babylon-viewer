import{GLTFLoader as t,ArrayItem as a}from"./glTFLoader-X6ZTOkAw.esm.min.js";import{g as e,bJ as n,bI as s}from"./index-VvGulz6u.esm.min.js";import"./bone-DPw1oOFK.esm.min.js";import"./skeleton-BDCw4yVL.esm.min.js";import"./rawTexture-B-F8SA5B.esm.min.js";import"./assetContainer-Da0Xx6Do.esm.min.js";import"./objectModelMapping-CghNRpa4.esm.min.js";const i="KHR_materials_variants";class r{constructor(t){this.name=i,this._loader=t,this.enabled=this._loader.isExtensionUsed(i)}dispose(){this._loader=null}static GetAvailableVariants(t){const a=this._GetExtensionMetadata(t);return a?Object.keys(a.variants):[]}getAvailableVariants(t){return r.GetAvailableVariants(t)}static SelectVariant(t,a){const e=this._GetExtensionMetadata(t);if(!e)throw new Error(`Cannot select variant on a glTF mesh that does not have the ${i} extension`);const n=t=>{const a=e.variants[t];if(a)for(const t of a)t.mesh.material=t.material};if(a instanceof Array)for(const t of a)n(t);else n(a);e.lastSelected=a}selectVariant(t,a){r.SelectVariant(t,a)}static Reset(t){const a=this._GetExtensionMetadata(t);if(!a)throw new Error(`Cannot reset on a glTF mesh that does not have the ${i} extension`);for(const t of a.original)t.mesh.material=t.material;a.lastSelected=null}reset(t){r.Reset(t)}static GetLastSelectedVariant(t){const a=this._GetExtensionMetadata(t);if(!a)throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${i} extension`);return a.lastSelected}getLastSelectedVariant(t){return r.GetLastSelectedVariant(t)}static _GetExtensionMetadata(t){return t?._internalMetadata?.gltf?.[i]||null}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const a=t[this.name];this._variants=a.variants}}onReady(){const t=this._loader.rootBabylonMesh;if(t){const a=this._loader.parent.extensionOptions[i];a?.defaultVariant&&r.SelectVariant(t,a.defaultVariant),a?.onLoaded?.({get variants(){return r.GetAvailableVariants(t)},get selectedVariant(){const a=r.GetLastSelectedVariant(t);return a?Array.isArray(a)?a[0]:a:r.GetAvailableVariants(t)[0]},set selectedVariant(a){r.SelectVariant(t,a)}})}}_loadMeshPrimitiveAsync(n,s,o,l,d,m){return t.LoadExtensionAsync(n,d,this.name,(async(c,h)=>{const f=new Array;return f.push(this._loader._loadMeshPrimitiveAsync(n,s,o,l,d,(s=>{if(m(s),s instanceof e){const e=t._GetDrawMode(n,d.mode),o=this._loader.rootBabylonMesh,l=o?o._internalMetadata=o._internalMetadata||{}:{},m=l.gltf=l.gltf||{},_=m[i]=m[i]||{lastSelected:null,original:[],variants:{}};_.original.push({mesh:s,material:s.material});for(let t=0;t<h.mappings.length;++t){const n=h.mappings[t],l=a.Get(`${c}/mappings/${t}/material`,this._loader.gltf.materials,n.material);f.push(this._loader._loadMaterialAsync(`#/materials/${n.material}`,l,s,e,(t=>{for(let e=0;e<n.variants.length;++e){const l=n.variants[e],d=a.Get(`/extensions/${i}/variants/${l}`,this._variants,l);_.variants[d.name]=_.variants[d.name]||[],_.variants[d.name].push({mesh:s,material:t}),s.onClonedObservable.add((t=>{const a=t;let e=null,n=a;do{if(n=n.parent,!n)return;e=r._GetExtensionMetadata(n)}while(null===e);if(o&&e===r._GetExtensionMetadata(o)){n._internalMetadata={};for(const t in o._internalMetadata)n._internalMetadata[t]=o._internalMetadata[t];n._internalMetadata.gltf=[];for(const t in o._internalMetadata.gltf)n._internalMetadata.gltf[t]=o._internalMetadata.gltf[t];n._internalMetadata.gltf[i]={lastSelected:null,original:[],variants:{}};for(const t of e.original)n._internalMetadata.gltf[i].original.push({mesh:t.mesh,material:t.material});for(const t in e.variants)if(Object.prototype.hasOwnProperty.call(e.variants,t)){n._internalMetadata.gltf[i].variants[t]=[];for(const a of e.variants[t])n._internalMetadata.gltf[i].variants[t].push({mesh:a.mesh,material:a.material})}e=n._internalMetadata.gltf[i]}for(const t of e.original)t.mesh===s&&(t.mesh=a);for(const t of e.variants[d.name])t.mesh===s&&(t.mesh=a)}))}})))}}}))),await Promise.all(f).then((([t])=>t))}))}}n(i),s(i,!0,(t=>new r(t)));export{r as KHR_materials_variants};
//# sourceMappingURL=KHR_materials_variants-__HdbVUX.esm.min.js.map
