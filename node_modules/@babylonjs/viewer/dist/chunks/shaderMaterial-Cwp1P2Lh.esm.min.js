import{J as s,M as t,m as e,o as r,n as i,K as o,A as n,p as a,D as h,q as c,N as f,r as u,U as _,W as l,s as x,X as p,T as d,Q as m,Y as y,G as A,Z as g,C as v,R as T}from"./index-VvGulz6u.esm.min.js";const M={effect:null,subMesh:null};class O extends s{constructor(s,e,r,i={},o=!0){super(s,e,o),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new t,this._cachedWorldViewProjectionMatrix=new t,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=r,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...i}}get shaderPath(){return this._shaderPath}set shaderPath(s){this._shaderPath=s}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(s){-1===this._options.uniforms.indexOf(s)&&this._options.uniforms.push(s)}setTexture(s,t){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._textures[s]=t,this}removeTexture(s){delete this._textures[s]}setTextureArray(s,t){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._checkUniform(s),this._textureArrays[s]=t,this}setExternalTexture(s,t){return-1===this._options.externalTextures.indexOf(s)&&this._options.externalTextures.push(s),this._externalTextures[s]=t,this}setFloat(s,t){return this._checkUniform(s),this._floats[s]=t,this}setInt(s,t){return this._checkUniform(s),this._ints[s]=t,this}setUInt(s,t){return this._checkUniform(s),this._uints[s]=t,this}setFloats(s,t){return this._checkUniform(s),this._floatsArrays[s]=t,this}setColor3(s,t){return this._checkUniform(s),this._colors3[s]=t,this}setColor3Array(s,t){return this._checkUniform(s),this._colors3Arrays[s]=t.reduce(((s,t)=>(s.push(t.r,t.g,t.b),s)),[]),this}setColor4(s,t){return this._checkUniform(s),this._colors4[s]=t,this}setColor4Array(s,t){return this._checkUniform(s),this._colors4Arrays[s]=t.reduce(((s,t)=>(s.push(t.r,t.g,t.b,t.a),s)),[]),this}setVector2(s,t){return this._checkUniform(s),this._vectors2[s]=t,this}setVector3(s,t){return this._checkUniform(s),this._vectors3[s]=t,this}setVector4(s,t){return this._checkUniform(s),this._vectors4[s]=t,this}setQuaternion(s,t){return this._checkUniform(s),this._quaternions[s]=t,this}setQuaternionArray(s,t){return this._checkUniform(s),this._quaternionsArrays[s]=t.reduce(((s,t)=>(t.toArray(s,s.length),s)),[]),this}setMatrix(s,t){return this._checkUniform(s),this._matrices[s]=t,this}setMatrices(s,t){this._checkUniform(s);const e=new Float32Array(16*t.length);for(let s=0;s<t.length;s++){t[s].copyToArray(e,16*s)}return this._matrixArrays[s]=e,this}setMatrix3x3(s,t){return this._checkUniform(s),this._matrices3x3[s]=t,this}setMatrix2x2(s,t){return this._checkUniform(s),this._matrices2x2[s]=t,this}setArray2(s,t){return this._checkUniform(s),this._vectors2Arrays[s]=t,this}setArray3(s,t){return this._checkUniform(s),this._vectors3Arrays[s]=t,this}setArray4(s,t){return this._checkUniform(s),this._vectors4Arrays[s]=t,this}setUniformBuffer(s,t){return-1===this._options.uniformBuffers.indexOf(s)&&this._options.uniformBuffers.push(s),this._uniformBuffers[s]=t,this}setTextureSampler(s,t){return-1===this._options.samplerObjects.indexOf(s)&&this._options.samplerObjects.push(s),this._textureSamplers[s]=t,this}setStorageBuffer(s,t){return-1===this._options.storageBuffers.indexOf(s)&&this._options.storageBuffers.push(s),this._storageBuffers[s]=t,this}setDefine(s,t){const e=s.trimEnd()+" ",r=this.options.defines.findIndex((t=>t===s||t.startsWith(e)));return r>=0&&this.options.defines.splice(r,1),("boolean"!=typeof t||t)&&this.options.defines.push(e+t),this}isReadyForSubMesh(s,t,e){return this.isReady(s,e,t)}isReady(s,t,c){const f=c&&this._storeEffectOnSubMeshes;if(this.isFrozen){const s=f?c._drawWrapper:this._drawWrapper;if(s.effect&&s._wasPreviouslyReady&&s._wasPreviouslyUsingInstances===t)return!0}const u=this.getScene(),_=u.getEngine(),l=[],x=[];let p=null,d=this._shaderPath,m=this._options.uniforms,y=this._options.uniformBuffers,A=this._options.samplers;_.getCaps().multiview&&u.activeCamera&&u.activeCamera.outputRenderTarget&&u.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,l.push("#define MULTIVIEW"),-1!==m.indexOf("viewProjection")&&-1===m.indexOf("viewProjectionR")&&m.push("viewProjectionR"));for(let s=0;s<this._options.defines.length;s++){const t=0===this._options.defines[s].indexOf("#define")?this._options.defines[s]:`#define ${this._options.defines[s]}`;l.push(t)}for(let s=0;s<this._options.attributes.length;s++)x.push(this._options.attributes[s]);if(s&&s.isVerticesDataPresent(e.ColorKind)&&(-1===x.indexOf(e.ColorKind)&&x.push(e.ColorKind),l.push("#define VERTEXCOLOR")),t&&(l.push("#define INSTANCES"),r(x,this._materialHelperNeedsPreviousMatrices),s?.hasThinInstances&&(l.push("#define THIN_INSTANCES"),s&&s.isVerticesDataPresent(e.ColorInstanceKind)&&(x.push(e.ColorInstanceKind),l.push("#define INSTANCESCOLOR")))),s&&s.useBones&&s.computeBonesUsingShaders&&s.skeleton){x.push(e.MatricesIndicesKind),x.push(e.MatricesWeightsKind),s.numBoneInfluencers>4&&(x.push(e.MatricesIndicesExtraKind),x.push(e.MatricesWeightsExtraKind));const t=s.skeleton;l.push("#define NUM_BONE_INFLUENCERS "+s.numBoneInfluencers),p=new g,p.addCPUSkinningFallback(0,s),t.isUsingTextureForMatrices?(l.push("#define BONETEXTURE"),-1===m.indexOf("boneTextureWidth")&&m.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(l.push("#define BonesPerMesh "+(t.bones.length+1)),-1===m.indexOf("mBones")&&m.push("mBones"))}else l.push("#define NUM_BONE_INFLUENCERS 0");let v=0;const T=s?s.morphTargetManager:null;if(T){const t=-1!==l.indexOf("#define UV1"),e=-1!==l.indexOf("#define UV2"),r=-1!==l.indexOf("#define TANGENT"),o=-1!==l.indexOf("#define NORMAL"),n=-1!==l.indexOf("#define VERTEXCOLOR");v=i(T,l,x,s,!0,o,r,t,e,n),T.isUsingTextureForTargets&&(-1===m.indexOf("morphTargetTextureIndices")&&m.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),v>0&&(m=m.slice(),m.push("morphTargetInfluences"),m.push("morphTargetCount"),m.push("morphTargetTextureInfo"),m.push("morphTargetTextureIndices"))}else l.push("#define NUM_MORPH_INFLUENCERS 0");if(s){const t=s.bakedVertexAnimationManager;t&&t.isEnabled&&(l.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===m.indexOf("bakedVertexAnimationSettings")&&m.push("bakedVertexAnimationSettings"),-1===m.indexOf("bakedVertexAnimationTextureSizeInverted")&&m.push("bakedVertexAnimationTextureSizeInverted"),-1===m.indexOf("bakedVertexAnimationTime")&&m.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),o(x,s,l)}for(const s in this._textures)if(!this._textures[s].isReady())return!1;s&&this.needAlphaTestingForMesh(s)&&l.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&(n(m),a(this,u,l)),u.fogEnabled&&s?.applyFog&&u.fogMode!==h.FOGMODE_NONE&&(l.push("#define FOG"),-1===m.indexOf("view")&&m.push("view"),-1===m.indexOf("vFogInfos")&&m.push("vFogInfos"),-1===m.indexOf("vFogColor")&&m.push("vFogColor")),this._useLogarithmicDepth&&(l.push("#define LOGARITHMICDEPTH"),-1===m.indexOf("logarithmicDepthConstant")&&m.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(m=m.slice(),y=y.slice(),A=A.slice(),d=this.customShaderNameResolve(this.name,m,y,A,l,x));const O=f?c._getDrawWrapper(void 0,!0):this._drawWrapper,b=O?.effect??null,w=O?.defines??null,S=l.join("\n");let E=b;return w!==S&&(E=_.createEffect(d,{attributes:x,uniformsNames:m,uniformBuffersNames:y,samplers:A,defines:S,fallbacks:p,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:v},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},_),f?c.setEffect(E,S,this._materialContext):O&&O.setEffect(E,S),this._onEffectCreatedObservable&&(M.effect=E,M.subMesh=c??s?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(M))),O._wasPreviouslyUsingInstances=!!t,!!E?.isReady()&&(b!==E&&u.resetCachedMaterial(),O._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(s,t){const e=t??this.getEffect();if(!e)return;const r=this._options.uniforms;-1!==r.indexOf("world")&&e.setMatrix("world",s);const i=this.getScene();-1!==r.indexOf("worldView")&&(s.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),e.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==r.indexOf("worldViewProjection")&&(s.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),e.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==r.indexOf("view")&&e.setMatrix("view",i.getViewMatrix())}bindForSubMesh(s,t,e){this.bind(s,t,e._drawWrapperOverride?.effect,e)}bind(s,t,e,r){const i=r&&this._storeEffectOnSubMeshes,o=e??(i?r.effect:this.getEffect());if(!o)return;const n=this.getScene();this._activeEffect=o,this.bindOnlyWorldMatrix(s,e);const a=this._options.uniformBuffers;let h=!1;if(o&&a&&a.length>0&&n.getEngine().supportsUniformBuffers)for(let e=0;e<a.length;++e){switch(a[e]){case"Mesh":t&&(t.getMeshUniformBuffer().bindToEffect(o,"Mesh"),t.transferToEffect(s));break;case"Scene":c(o,n.getSceneUniformBuffer()),n.finalizeSceneUbo(),h=!0}}const p=t&&i?this._mustRebind(n,o,r,t.visibility):n.getCachedMaterial()!==this;if(o&&p){let s;for(s in h||-1===this._options.uniforms.indexOf("view")||o.setMatrix("view",n.getViewMatrix()),h||-1===this._options.uniforms.indexOf("projection")||o.setMatrix("projection",n.getProjectionMatrix()),h||-1===this._options.uniforms.indexOf("viewProjection")||(o.setMatrix("viewProjection",n.getTransformMatrix()),this._multiview&&o.setMatrix("viewProjectionR",n._transformMatrixR)),n.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&o.setVector3("cameraPosition",n.activeCamera.globalPosition),f(t,o),u(o,this,n),this._useLogarithmicDepth&&_(i?r.materialDefines:o.defines,o,n),t&&l(n,t,o),this._textures)o.setTexture(s,this._textures[s]);for(s in this._textureArrays)o.setTextureArray(s,this._textureArrays[s]);for(s in this._ints)o.setInt(s,this._ints[s]);for(s in this._uints)o.setUInt(s,this._uints[s]);for(s in this._floats)o.setFloat(s,this._floats[s]);for(s in this._floatsArrays)o.setArray(s,this._floatsArrays[s]);for(s in this._colors3)o.setColor3(s,this._colors3[s]);for(s in this._colors3Arrays)o.setArray3(s,this._colors3Arrays[s]);for(s in this._colors4){const t=this._colors4[s];o.setFloat4(s,t.r,t.g,t.b,t.a)}for(s in this._colors4Arrays)o.setArray4(s,this._colors4Arrays[s]);for(s in this._vectors2)o.setVector2(s,this._vectors2[s]);for(s in this._vectors3)o.setVector3(s,this._vectors3[s]);for(s in this._vectors4)o.setVector4(s,this._vectors4[s]);for(s in this._quaternions)o.setQuaternion(s,this._quaternions[s]);for(s in this._matrices)o.setMatrix(s,this._matrices[s]);for(s in this._matrixArrays)o.setMatrices(s,this._matrixArrays[s]);for(s in this._matrices3x3)o.setMatrix3x3(s,this._matrices3x3[s]);for(s in this._matrices2x2)o.setMatrix2x2(s,this._matrices2x2[s]);for(s in this._vectors2Arrays)o.setArray2(s,this._vectors2Arrays[s]);for(s in this._vectors3Arrays)o.setArray3(s,this._vectors3Arrays[s]);for(s in this._vectors4Arrays)o.setArray4(s,this._vectors4Arrays[s]);for(s in this._quaternionsArrays)o.setArray4(s,this._quaternionsArrays[s]);for(s in this._uniformBuffers){const t=this._uniformBuffers[s].getBuffer();t&&o.bindUniformBuffer(t,s)}const e=n.getEngine(),a=e.setExternalTexture;if(a)for(s in this._externalTextures)a.call(e,s,this._externalTextures[s]);const c=e.setTextureSampler;if(c)for(s in this._textureSamplers)c.call(e,s,this._textureSamplers[s]);const x=e.setStorageBuffer;if(x)for(s in this._storageBuffers)x.call(e,s,this._storageBuffers[s])}if(o&&t&&(p||!this.isFrozen)){x(t,o),t.morphTargetManager&&t.morphTargetManager.isUsingTextureForTargets&&t.morphTargetManager._bind(o);const s=t.bakedVertexAnimationManager;if(s&&s.isEnabled){const s=i?r._drawWrapper:this._drawWrapper;t.bakedVertexAnimationManager?.bind(o,!!s._wasPreviouslyUsingInstances)}}this._afterBind(t,o,r)}getActiveTextures(){const s=super.getActiveTextures();for(const t in this._textures)s.push(this._textures[t]);for(const t in this._textureArrays){const e=this._textureArrays[t];for(let t=0;t<e.length;t++)s.push(e[t])}return s}hasTexture(s){if(super.hasTexture(s))return!0;for(const t in this._textures)if(this._textures[t]===s)return!0;for(const t in this._textureArrays){const e=this._textureArrays[t];for(let t=0;t<e.length;t++)if(e[t]===s)return!0}return!1}clone(s){const t=p.Clone((()=>new O(s,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);t.name=s,t.id=s,"object"==typeof t._shaderPath&&(t._shaderPath={...t._shaderPath}),this._options={...this._options};const e=Object.keys(this._options);for(const s of e){const t=this._options[s];Array.isArray(t)&&(this._options[s]=t.slice(0))}this.stencil.copyTo(t.stencil);for(const s in this._textures)t.setTexture(s,this._textures[s]);for(const s in this._textureArrays)t.setTextureArray(s,this._textureArrays[s]);for(const s in this._externalTextures)t.setExternalTexture(s,this._externalTextures[s]);for(const s in this._ints)t.setInt(s,this._ints[s]);for(const s in this._uints)t.setUInt(s,this._uints[s]);for(const s in this._floats)t.setFloat(s,this._floats[s]);for(const s in this._floatsArrays)t.setFloats(s,this._floatsArrays[s]);for(const s in this._colors3)t.setColor3(s,this._colors3[s]);for(const s in this._colors3Arrays)t._colors3Arrays[s]=this._colors3Arrays[s];for(const s in this._colors4)t.setColor4(s,this._colors4[s]);for(const s in this._colors4Arrays)t._colors4Arrays[s]=this._colors4Arrays[s];for(const s in this._vectors2)t.setVector2(s,this._vectors2[s]);for(const s in this._vectors3)t.setVector3(s,this._vectors3[s]);for(const s in this._vectors4)t.setVector4(s,this._vectors4[s]);for(const s in this._quaternions)t.setQuaternion(s,this._quaternions[s]);for(const s in this._quaternionsArrays)t._quaternionsArrays[s]=this._quaternionsArrays[s];for(const s in this._matrices)t.setMatrix(s,this._matrices[s]);for(const s in this._matrixArrays)t._matrixArrays[s]=this._matrixArrays[s].slice();for(const s in this._matrices3x3)t.setMatrix3x3(s,this._matrices3x3[s]);for(const s in this._matrices2x2)t.setMatrix2x2(s,this._matrices2x2[s]);for(const s in this._vectors2Arrays)t.setArray2(s,this._vectors2Arrays[s]);for(const s in this._vectors3Arrays)t.setArray3(s,this._vectors3Arrays[s]);for(const s in this._vectors4Arrays)t.setArray4(s,this._vectors4Arrays[s]);for(const s in this._uniformBuffers)t.setUniformBuffer(s,this._uniformBuffers[s]);for(const s in this._textureSamplers)t.setTextureSampler(s,this._textureSamplers[s]);for(const s in this._storageBuffers)t.setStorageBuffer(s,this._storageBuffers[s]);return t}dispose(s,t,e){if(t){let s;for(s in this._textures)this._textures[s].dispose();for(s in this._textureArrays){const t=this._textureArrays[s];for(let s=0;s<t.length;s++)t[s].dispose()}}this._textures={},super.dispose(s,t,e)}serialize(){const s=p.Serialize(this);let t;for(t in s.customType="BABYLON.ShaderMaterial",s.uniqueId=this.uniqueId,s.options=this._options,s.shaderPath=this._shaderPath,s.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,s.stencil=this.stencil.serialize(),s.textures={},this._textures)s.textures[t]=this._textures[t].serialize();for(t in s.textureArrays={},this._textureArrays){s.textureArrays[t]=[];const e=this._textureArrays[t];for(let r=0;r<e.length;r++)s.textureArrays[t].push(e[r].serialize())}for(t in s.ints={},this._ints)s.ints[t]=this._ints[t];for(t in s.uints={},this._uints)s.uints[t]=this._uints[t];for(t in s.floats={},this._floats)s.floats[t]=this._floats[t];for(t in s.floatsArrays={},this._floatsArrays)s.floatsArrays[t]=this._floatsArrays[t];for(t in s.colors3={},this._colors3){const e=this._colors3[t];s.colors3[t]=[e.r,e.g,e.b]}for(t in s.colors3Arrays={},this._colors3Arrays)s.colors3Arrays[t]=this._colors3Arrays[t];for(t in s.colors4={},this._colors4){const e=this._colors4[t];s.colors4[t]=[e.r,e.g,e.b,e.a]}for(t in s.colors4Arrays={},this._colors4Arrays)s.colors4Arrays[t]=this._colors4Arrays[t];for(t in s.vectors2={},this._vectors2){const e=this._vectors2[t];s.vectors2[t]=[e.x,e.y]}for(t in s.vectors3={},this._vectors3){const e=this._vectors3[t];s.vectors3[t]=[e.x,e.y,e.z]}for(t in s.vectors4={},this._vectors4){const e=this._vectors4[t];s.vectors4[t]=[e.x,e.y,e.z,e.w]}for(t in s.quaternions={},this._quaternions)s.quaternions[t]=this._quaternions[t].asArray();for(t in s.matrices={},this._matrices)s.matrices[t]=this._matrices[t].asArray();for(t in s.matrixArray={},this._matrixArrays)s.matrixArray[t]=this._matrixArrays[t];for(t in s.matrices3x3={},this._matrices3x3)s.matrices3x3[t]=this._matrices3x3[t];for(t in s.matrices2x2={},this._matrices2x2)s.matrices2x2[t]=this._matrices2x2[t];for(t in s.vectors2Arrays={},this._vectors2Arrays)s.vectors2Arrays[t]=this._vectors2Arrays[t];for(t in s.vectors3Arrays={},this._vectors3Arrays)s.vectors3Arrays[t]=this._vectors3Arrays[t];for(t in s.vectors4Arrays={},this._vectors4Arrays)s.vectors4Arrays[t]=this._vectors4Arrays[t];for(t in s.quaternionsArrays={},this._quaternionsArrays)s.quaternionsArrays[t]=this._quaternionsArrays[t];return s}static Parse(s,e,r){const i=p.Parse((()=>new O(s.name,e,s.shaderPath,s.options,s.storeEffectOnSubMeshes)),s,e,r);let o;for(o in s.stencil&&i.stencil.parse(s.stencil,e,r),s.textures)i.setTexture(o,d.Parse(s.textures[o],e,r));for(o in s.textureArrays){const t=s.textureArrays[o],n=[];for(let s=0;s<t.length;s++)n.push(d.Parse(t[s],e,r));i.setTextureArray(o,n)}for(o in s.ints)i.setInt(o,s.ints[o]);for(o in s.uints)i.setUInt(o,s.uints[o]);for(o in s.floats)i.setFloat(o,s.floats[o]);for(o in s.floatsArrays)i.setFloats(o,s.floatsArrays[o]);for(o in s.colors3){const t=s.colors3[o];i.setColor3(o,{r:t[0],g:t[1],b:t[2]})}for(o in s.colors3Arrays){const t=s.colors3Arrays[o].reduce(((s,t,e)=>(e%3==0?s.push([t]):s[s.length-1].push(t),s)),[]).map((s=>({r:s[0],g:s[1],b:s[2]})));i.setColor3Array(o,t)}for(o in s.colors4){const t=s.colors4[o];i.setColor4(o,{r:t[0],g:t[1],b:t[2],a:t[3]})}for(o in s.colors4Arrays){const t=s.colors4Arrays[o].reduce(((s,t,e)=>(e%4==0?s.push([t]):s[s.length-1].push(t),s)),[]).map((s=>({r:s[0],g:s[1],b:s[2],a:s[3]})));i.setColor4Array(o,t)}for(o in s.vectors2){const t=s.vectors2[o];i.setVector2(o,{x:t[0],y:t[1]})}for(o in s.vectors3){const t=s.vectors3[o];i.setVector3(o,{x:t[0],y:t[1],z:t[2]})}for(o in s.vectors4){const t=s.vectors4[o];i.setVector4(o,{x:t[0],y:t[1],z:t[2],w:t[3]})}for(o in s.quaternions)i.setQuaternion(o,m.FromArray(s.quaternions[o]));for(o in s.matrices)i.setMatrix(o,t.FromArray(s.matrices[o]));for(o in s.matrixArray)i._matrixArrays[o]=new Float32Array(s.matrixArray[o]);for(o in s.matrices3x3)i.setMatrix3x3(o,s.matrices3x3[o]);for(o in s.matrices2x2)i.setMatrix2x2(o,s.matrices2x2[o]);for(o in s.vectors2Arrays)i.setArray2(o,s.vectors2Arrays[o]);for(o in s.vectors3Arrays)i.setArray3(o,s.vectors3Arrays[o]);for(o in s.vectors4Arrays)i.setArray4(o,s.vectors4Arrays[o]);for(o in s.quaternionsArrays)i.setArray4(o,s.quaternionsArrays[o]);return i}static async ParseFromFileAsync(s,t,e,r=""){return await new Promise(((i,o)=>{const n=new y;n.addEventListener("readystatechange",(()=>{if(4==n.readyState)if(200==n.status){const t=JSON.parse(n.responseText),o=this.Parse(t,e||A.LastCreatedScene,r);s&&(o.name=s),i(o)}else o("Unable to load the ShaderMaterial")})),n.open("GET",t),n.send()}))}static async ParseFromSnippetAsync(s,t,e=""){return await new Promise(((r,i)=>{const o=new y;o.addEventListener("readystatechange",(()=>{if(4==o.readyState)if(200==o.status){const i=JSON.parse(JSON.parse(o.responseText).jsonPayload),n=JSON.parse(i.shaderMaterial),a=this.Parse(n,t||A.LastCreatedScene,e);a.snippetId=s,r(a)}else i("Unable to load the snippet "+s)})),o.open("GET",this.SnippetUrl+"/"+s.replace(/#/g,"/")),o.send()}))}}O.SnippetUrl=v.SnippetUrl,O.CreateFromSnippetAsync=O.ParseFromSnippetAsync,T("BABYLON.ShaderMaterial",O);export{O as ShaderMaterial};
//# sourceMappingURL=shaderMaterial-Cwp1P2Lh.esm.min.js.map
