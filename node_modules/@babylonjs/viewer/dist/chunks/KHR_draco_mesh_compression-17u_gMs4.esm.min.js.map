{"version":3,"file":"KHR_draco_mesh_compression-17u_gMs4.esm.min.js","sources":["../../../../../dev/core/dist/Meshes/Compression/dracoCompressionWorker.js","../../../../../dev/core/dist/Meshes/Compression/dracoCodec.js","../../../../../dev/core/dist/Meshes/Compression/dracoDecoder.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_draco_mesh_compression.js"],"sourcesContent":["/**\n * @internal\n */\nexport function EncodeMesh(module /** EncoderModule */, attributes, indices, options) {\n    const encoderModule = module;\n    let encoder = null;\n    let meshBuilder = null;\n    let mesh = null;\n    let encodedNativeBuffer = null;\n    const attributeIDs = {}; // Babylon kind -> Draco unique id\n    // Double-check that at least a position attribute is provided\n    const positionAttribute = attributes.find((a) => a.dracoName === \"POSITION\");\n    if (!positionAttribute) {\n        throw new Error(\"Position attribute is required for Draco encoding\");\n    }\n    // If no indices are provided, assume mesh is unindexed. Let's generate them, since Draco meshes require them.\n    // TODO: This may be the POINT_CLOUD case, but need to investigate. Should work for now-- just less efficient.\n    if (!indices) {\n        // Assume position attribute is the largest attribute.\n        const positionVerticesCount = positionAttribute.data.length / positionAttribute.size;\n        indices = new (positionVerticesCount > 65535 ? Uint32Array : Uint16Array)(positionVerticesCount);\n        for (let i = 0; i < positionVerticesCount; i++) {\n            indices[i] = i;\n        }\n    }\n    try {\n        encoder = new encoderModule.Encoder();\n        meshBuilder = new encoderModule.MeshBuilder();\n        mesh = new encoderModule.Mesh();\n        // Add the faces\n        meshBuilder.AddFacesToMesh(mesh, indices.length / 3, indices);\n        const addAttributeMap = new Map([\n            [Float32Array, (mb, m, a, c, s, d) => mb.AddFloatAttribute(m, a, c, s, d)],\n            [Uint32Array, (mb, m, a, c, s, d) => mb.AddUInt32Attribute(m, a, c, s, d)],\n            [Uint16Array, (mb, m, a, c, s, d) => mb.AddUInt16Attribute(m, a, c, s, d)],\n            [Uint8Array, (mb, m, a, c, s, d) => mb.AddUInt8Attribute(m, a, c, s, d)],\n            [Int32Array, (mb, m, a, c, s, d) => mb.AddInt32Attribute(m, a, c, s, d)],\n            [Int16Array, (mb, m, a, c, s, d) => mb.AddInt16Attribute(m, a, c, s, d)],\n            [Int8Array, (mb, m, a, c, s, d) => mb.AddInt8Attribute(m, a, c, s, d)],\n        ]);\n        // Add the attributes\n        for (const attribute of attributes) {\n            if (attribute.data instanceof Uint8ClampedArray) {\n                attribute.data = new Uint8Array(attribute.data); // Draco does not support Uint8ClampedArray\n            }\n            const addAttribute = addAttributeMap.get(attribute.data.constructor);\n            const verticesCount = attribute.data.length / attribute.size;\n            attributeIDs[attribute.kind] = addAttribute(meshBuilder, mesh, encoderModule[attribute.dracoName], verticesCount, attribute.size, attribute.data);\n            if (options.quantizationBits && options.quantizationBits[attribute.dracoName]) {\n                encoder.SetAttributeQuantization(encoderModule[attribute.dracoName], options.quantizationBits[attribute.dracoName]);\n            }\n        }\n        // Set the options\n        if (options.method) {\n            encoder.SetEncodingMethod(encoderModule[options.method]);\n        }\n        if (options.encodeSpeed !== undefined && options.decodeSpeed !== undefined) {\n            encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\n        }\n        // Encode to native buffer\n        encodedNativeBuffer = new encoderModule.DracoInt8Array();\n        const encodedLength = encoder.EncodeMeshToDracoBuffer(mesh, encodedNativeBuffer);\n        if (encodedLength <= 0) {\n            throw new Error(\"Draco encoding failed.\");\n        }\n        // Copy the native buffer data to worker heap\n        const encodedData = new Int8Array(encodedLength);\n        for (let i = 0; i < encodedLength; i++) {\n            encodedData[i] = encodedNativeBuffer.GetValue(i);\n        }\n        return { data: encodedData, attributeIds: attributeIDs };\n    }\n    finally {\n        if (mesh) {\n            encoderModule.destroy(mesh);\n        }\n        if (meshBuilder) {\n            encoderModule.destroy(meshBuilder);\n        }\n        if (encoder) {\n            encoderModule.destroy(encoder);\n        }\n        if (encodedNativeBuffer) {\n            encoderModule.destroy(encodedNativeBuffer);\n        }\n    }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\n */\nexport function EncoderWorkerFunction() {\n    let encoderPromise;\n    onmessage = (event) => {\n        const message = event.data;\n        switch (message.id) {\n            case \"init\": {\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\n                if (message.url) {\n                    importScripts(message.url);\n                }\n                const initEncoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\n                encoderPromise = DracoEncoderModule(initEncoderObject);\n                postMessage({ id: \"initDone\" });\n                break;\n            }\n            case \"encodeMesh\": {\n                if (!encoderPromise) {\n                    throw new Error(\"Draco encoder module is not available\");\n                }\n                // eslint-disable-next-line github/no-then\n                encoderPromise.then((encoder) => {\n                    const result = EncodeMesh(encoder, message.attributes, message.indices, message.options);\n                    postMessage({ id: \"encodeMeshDone\", encodedMeshData: result }, result ? [result.data.buffer] : undefined);\n                });\n                break;\n            }\n        }\n    };\n}\n/**\n * @internal\n */\nexport function DecodeMesh(module /** DecoderModule */, data, attributeIDs, onIndicesData, onAttributeData) {\n    const decoderModule = module;\n    let decoder = null;\n    let buffer = null;\n    let geometry = null;\n    try {\n        decoder = new decoderModule.Decoder();\n        buffer = new decoderModule.DecoderBuffer();\n        buffer.Init(data, data.byteLength);\n        let status;\n        const type = decoder.GetEncodedGeometryType(buffer);\n        switch (type) {\n            case decoderModule.TRIANGULAR_MESH: {\n                const mesh = new decoderModule.Mesh();\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\n                if (!status.ok() || mesh.ptr === 0) {\n                    throw new Error(status.error_msg());\n                }\n                const numFaces = mesh.num_faces();\n                const numIndices = numFaces * 3;\n                const byteLength = numIndices * 4;\n                const ptr = decoderModule._malloc(byteLength);\n                try {\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n                    const indices = new Uint32Array(numIndices);\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n                    onIndicesData(indices);\n                }\n                finally {\n                    decoderModule._free(ptr);\n                }\n                geometry = mesh;\n                break;\n            }\n            case decoderModule.POINT_CLOUD: {\n                const pointCloud = new decoderModule.PointCloud();\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\n                if (!status.ok() || !pointCloud.ptr) {\n                    throw new Error(status.error_msg());\n                }\n                geometry = pointCloud;\n                break;\n            }\n            default: {\n                throw new Error(`Invalid geometry type ${type}`);\n            }\n        }\n        const numPoints = geometry.num_points();\n        const processAttribute = (decoder, geometry, kind, attribute /** Attribute */) => {\n            const dataType = attribute.data_type();\n            const numComponents = attribute.num_components();\n            const normalized = attribute.normalized();\n            const byteStride = attribute.byte_stride();\n            const byteOffset = attribute.byte_offset();\n            const dataTypeInfo = {\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\n            };\n            const info = dataTypeInfo[dataType];\n            if (!info) {\n                throw new Error(`Invalid data type ${dataType}`);\n            }\n            const numValues = numPoints * numComponents;\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\n            const ptr = decoderModule._malloc(byteLength);\n            try {\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\n            }\n            finally {\n                decoderModule._free(ptr);\n            }\n        };\n        if (attributeIDs) {\n            for (const kind in attributeIDs) {\n                const id = attributeIDs[kind];\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\n                processAttribute(decoder, geometry, kind, attribute);\n            }\n        }\n        else {\n            const dracoAttributeTypes = {\n                position: decoderModule.POSITION,\n                normal: decoderModule.NORMAL,\n                color: decoderModule.COLOR,\n                uv: decoderModule.TEX_COORD,\n            };\n            for (const kind in dracoAttributeTypes) {\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\n                if (id !== -1) {\n                    const attribute = decoder.GetAttribute(geometry, id);\n                    processAttribute(decoder, geometry, kind, attribute);\n                }\n            }\n        }\n        return numPoints;\n    }\n    finally {\n        if (geometry) {\n            decoderModule.destroy(geometry);\n        }\n        if (buffer) {\n            decoderModule.destroy(buffer);\n        }\n        if (decoder) {\n            decoderModule.destroy(decoder);\n        }\n    }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\n */\nexport function DecoderWorkerFunction() {\n    let decoderPromise;\n    onmessage = (event) => {\n        const message = event.data;\n        switch (message.id) {\n            case \"init\": {\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\n                if (message.url) {\n                    importScripts(message.url);\n                }\n                const initDecoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\n                decoderPromise = DracoDecoderModule(initDecoderObject);\n                postMessage({ id: \"initDone\" });\n                break;\n            }\n            case \"decodeMesh\": {\n                if (!decoderPromise) {\n                    throw new Error(\"Draco decoder module is not available\");\n                }\n                // eslint-disable-next-line github/no-then\n                decoderPromise.then((decoder) => {\n                    const numPoints = DecodeMesh(decoder, message.dataView, message.attributes, (indices) => {\n                        postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\n                    }, (kind, data, size, offset, stride, normalized) => {\n                        postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\n                    });\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\n                });\n                break;\n            }\n        }\n    };\n}\n// For backwards compatibility\nexport { DecoderWorkerFunction as workerFunction };\n/**\n * Initializes a worker that was created for the draco agent pool\n * @param worker  The worker to initialize\n * @param wasmBinary The wasm binary to load into the worker\n * @param moduleUrl The url to the draco decoder module (optional)\n * @returns A promise that resolves when the worker is initialized\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport async function initializeWebWorker(worker, wasmBinary, moduleUrl) {\n    return await new Promise((resolve, reject) => {\n        const onError = (error) => {\n            worker.removeEventListener(\"error\", onError);\n            worker.removeEventListener(\"message\", onMessage);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(error);\n        };\n        const onMessage = (event) => {\n            if (event.data.id === \"initDone\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n            }\n        };\n        worker.addEventListener(\"error\", onError);\n        worker.addEventListener(\"message\", onMessage);\n        // Load with either JS-only or WASM version\n        if (!wasmBinary) {\n            worker.postMessage({\n                id: \"init\",\n                url: moduleUrl,\n            });\n        }\n        else {\n            // clone the array buffer to make it transferable\n            const clone = wasmBinary.slice(0);\n            worker.postMessage({\n                id: \"init\",\n                url: moduleUrl,\n                wasmBinary: clone,\n            }, [clone]);\n        }\n        // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers\n    });\n}\n//# sourceMappingURL=dracoCompressionWorker.js.map","import { Tools } from \"../../Misc/tools\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\nimport { initializeWebWorker } from \"./dracoCompressionWorker\";\n/**\n * @internal\n */\nexport function _GetDefaultNumWorkers() {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n        return 1;\n    }\n    // Use 50% of the available logical processors but capped at 4.\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n}\n/**\n * @internal\n */\nexport function _IsConfigurationAvailable(config) {\n    return !!((config.wasmUrl && (config.wasmBinary || config.wasmBinaryUrl) && typeof WebAssembly === \"object\") || config.fallbackUrl);\n    // TODO: Account for jsModule\n}\n/**\n * Base class for a Draco codec.\n * @internal\n */\nexport class DracoCodec {\n    /**\n     * Constructor\n     * @param configuration The configuration for the DracoCodec instance.\n     */\n    constructor(configuration) {\n        // check if the codec binary and worker pool was injected\n        // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available\n        if (configuration.workerPool) {\n            // Set the promise accordingly\n            this._workerPoolPromise = Promise.resolve(configuration.workerPool);\n            return;\n        }\n        // to avoid making big changes to the code here, if wasmBinary is provided use it in the wasmBinaryPromise\n        const wasmBinaryProvided = configuration.wasmBinary;\n        const numberOfWorkers = configuration.numWorkers ?? _GetDefaultNumWorkers();\n        const useWorkers = numberOfWorkers && typeof Worker === \"function\" && typeof URL === \"function\";\n        const urlNeeded = useWorkers || !configuration.jsModule;\n        // code maintained here for back-compat with no changes\n        const codecInfo = configuration.wasmUrl && configuration.wasmBinaryUrl && typeof WebAssembly === \"object\"\n            ? {\n                url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.wasmUrl, true) : \"\",\n                wasmBinaryPromise: wasmBinaryProvided\n                    ? Promise.resolve(wasmBinaryProvided)\n                    : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(configuration.wasmBinaryUrl, true)),\n            }\n            : {\n                url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.fallbackUrl) : \"\",\n                wasmBinaryPromise: Promise.resolve(undefined),\n            };\n        // If using workers, initialize a worker pool with either the wasm or url?\n        if (useWorkers) {\n            // eslint-disable-next-line github/no-then\n            this._workerPoolPromise = codecInfo.wasmBinaryPromise.then((wasmBinary) => {\n                const workerContent = this._getWorkerContent();\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\n                // eslint-disable-next-line @typescript-eslint/promise-function-async\n                return new AutoReleaseWorkerPool(numberOfWorkers, () => {\n                    const worker = new Worker(workerBlobUrl);\n                    return initializeWebWorker(worker, wasmBinary, codecInfo.url);\n                });\n            });\n        }\n        else {\n            // eslint-disable-next-line github/no-then\n            this._modulePromise = codecInfo.wasmBinaryPromise.then(async (wasmBinary) => {\n                if (!this._isModuleAvailable()) {\n                    if (!configuration.jsModule) {\n                        if (!codecInfo.url) {\n                            throw new Error(\"Draco codec module is not available\");\n                        }\n                        await Tools.LoadBabylonScriptAsync(codecInfo.url);\n                    }\n                }\n                return await this._createModuleAsync(wasmBinary, configuration.jsModule);\n            });\n        }\n    }\n    /**\n     * Returns a promise that resolves when ready. Call this manually to ensure the draco codec is ready before use.\n     * @returns a promise that resolves when ready\n     */\n    async whenReadyAsync() {\n        if (this._workerPoolPromise) {\n            await this._workerPoolPromise;\n            return;\n        }\n        if (this._modulePromise) {\n            await this._modulePromise;\n            return;\n        }\n    }\n    /**\n     * Stop all async operations and release resources.\n     */\n    dispose() {\n        if (this._workerPoolPromise) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n            this._workerPoolPromise.then((workerPool) => {\n                workerPool.dispose();\n            });\n        }\n        delete this._workerPoolPromise;\n        delete this._modulePromise;\n    }\n}\n//# sourceMappingURL=dracoCodec.js.map","import { _IsConfigurationAvailable, DracoCodec } from \"./dracoCodec\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Geometry } from \"../geometry\";\nimport { VertexBuffer } from \"../buffer\";\nimport { Logger } from \"../../Misc/logger\";\nimport { DecodeMesh, DecoderWorkerFunction } from \"./dracoCompressionWorker\";\n/**\n * @experimental This class is an experimental version of `DracoCompression` and is subject to change.\n *\n * Draco Decoder (https://google.github.io/draco/)\n *\n * This class wraps the Draco decoder module.\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the Babylon.js cdn https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoDecoder.DefaultConfiguration = {\n *          wasmUrl: \"<url to the WebAssembly library>\",\n *          wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *          fallbackUrl: \"<url to the fallback JavaScript library>\",\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoDecoder.DefaultAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoDecoder object and call decodeMeshToGeometryAsync:\n * ```javascript\n *     var geometry = await DracoDecoder.Default.decodeMeshToGeometryAsync(data);\n * ```\n */\nexport class DracoDecoder extends DracoCodec {\n    /**\n     * Returns true if the decoder's `DefaultConfiguration` is available.\n     */\n    static get DefaultAvailable() {\n        return _IsConfigurationAvailable(DracoDecoder.DefaultConfiguration);\n    }\n    /**\n     * Default instance for the DracoDecoder.\n     */\n    static get Default() {\n        DracoDecoder._Default ??= new DracoDecoder();\n        return DracoDecoder._Default;\n    }\n    /**\n     * Reset the default DracoDecoder object to null and disposing the removed default instance.\n     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,\n     * unless the static worker pool is no longer needed.\n     * @param skipDispose set to true to not dispose the removed default instance\n     */\n    static ResetDefault(skipDispose) {\n        if (DracoDecoder._Default) {\n            if (!skipDispose) {\n                DracoDecoder._Default.dispose();\n            }\n            DracoDecoder._Default = null;\n        }\n    }\n    _isModuleAvailable() {\n        return typeof DracoDecoderModule !== \"undefined\";\n    }\n    async _createModuleAsync(wasmBinary, jsModule /** DracoDecoderModule */) {\n        const module = await (jsModule || DracoDecoderModule)({ wasmBinary });\n        return { module };\n    }\n    _getWorkerContent() {\n        return `${DecodeMesh}(${DecoderWorkerFunction})()`;\n    }\n    /**\n     * Creates a new Draco decoder.\n     * @param configuration Optional override of the configuration for the DracoDecoder. If not provided, defaults to {@link DracoDecoder.DefaultConfiguration}.\n     */\n    constructor(configuration = DracoDecoder.DefaultConfiguration) {\n        super(configuration);\n    }\n    /**\n     * Decode Draco compressed mesh data to mesh data.\n     * @param data The ArrayBuffer or ArrayBufferView of the compressed Draco data\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization\n     * @returns A promise that resolves with the decoded mesh data\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride) {\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\n        const applyGltfNormalizedOverride = (kind, normalized) => {\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\n                if (normalized !== gltfNormalizedOverride[kind]) {\n                    Logger.Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);\n                }\n                return gltfNormalizedOverride[kind];\n            }\n            else {\n                return normalized;\n            }\n        };\n        if (this._workerPoolPromise) {\n            // eslint-disable-next-line github/no-then\n            return this._workerPoolPromise.then(async (workerPool) => {\n                return await new Promise((resolve, reject) => {\n                    workerPool.push((worker, onComplete) => {\n                        let resultIndices = null;\n                        const resultAttributes = [];\n                        const onError = (error) => {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                            reject(error);\n                            onComplete();\n                        };\n                        const onMessage = (event) => {\n                            const message = event.data;\n                            switch (message.id) {\n                                case \"indices\": {\n                                    resultIndices = message.data;\n                                    break;\n                                }\n                                case \"attribute\": {\n                                    resultAttributes.push({\n                                        kind: message.kind,\n                                        data: message.data,\n                                        size: message.size,\n                                        byteOffset: message.byteOffset,\n                                        byteStride: message.byteStride,\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\n                                    });\n                                    break;\n                                }\n                                case \"decodeMeshDone\": {\n                                    worker.removeEventListener(\"error\", onError);\n                                    worker.removeEventListener(\"message\", onMessage);\n                                    resolve({ indices: resultIndices, attributes: resultAttributes, totalVertices: message.totalVertices });\n                                    onComplete();\n                                    break;\n                                }\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        const dataViewCopy = dataView.slice();\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\n                    });\n                });\n            });\n        }\n        if (this._modulePromise) {\n            // eslint-disable-next-line github/no-then\n            return this._modulePromise.then((decoder) => {\n                let resultIndices = null;\n                const resultAttributes = [];\n                const numPoints = DecodeMesh(decoder.module, dataView, attributes, (indices) => {\n                    resultIndices = indices;\n                }, (kind, data, size, byteOffset, byteStride, normalized) => {\n                    resultAttributes.push({\n                        kind,\n                        data,\n                        size,\n                        byteOffset,\n                        byteStride,\n                        normalized,\n                    });\n                });\n                return { indices: resultIndices, attributes: resultAttributes, totalVertices: numPoints };\n            });\n        }\n        throw new Error(\"Draco decoder module is not available\");\n    }\n    /**\n     * Decode Draco compressed mesh data to Babylon geometry.\n     * @param name The name to use when creating the geometry\n     * @param scene The scene to use when creating the geometry\n     * @param data The ArrayBuffer or ArrayBufferView of the Draco compressed data\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n     * @returns A promise that resolves with the decoded geometry\n     */\n    async decodeMeshToGeometryAsync(name, scene, data, attributes) {\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);\n        const geometry = new Geometry(name, scene);\n        if (meshData.indices) {\n            geometry.setIndices(meshData.indices);\n        }\n        for (const attribute of meshData.attributes) {\n            geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n        }\n        return geometry;\n    }\n    /** @internal */\n    async _decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride, boundingInfo) {\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);\n        const geometry = new Geometry(name, scene);\n        if (boundingInfo) {\n            geometry._boundingInfo = boundingInfo;\n            geometry.useBoundingInfoFromGeometry = true;\n        }\n        if (meshData.indices) {\n            geometry.setIndices(meshData.indices);\n        }\n        for (const attribute of meshData.attributes) {\n            geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n        }\n        return geometry;\n    }\n}\n/**\n * Default configuration for the DracoDecoder. Defaults to the following:\n * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.\n * - wasmUrl: `\"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"`\n * - wasmBinaryUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"`\n * - fallbackUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.js\"`\n */\nDracoDecoder.DefaultConfiguration = {\n    wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\n    wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\n    fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\n};\nDracoDecoder._Default = null;\n//# sourceMappingURL=dracoDecoder.js.map","/* eslint-disable github/no-then */\nimport { DracoDecoder } from \"core/Meshes/Compression/dracoDecoder\";\nimport { VertexBuffer } from \"core/Buffers/buffer\";\nimport { GLTFLoader, ArrayItem, LoadBoundingInfoFromPositionAccessor } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"KHR_draco_mesh_compression\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_draco_mesh_compression {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines whether to use the normalized flag from the glTF accessor instead of the Draco data. Defaults to true.\n         */\n        this.useNormalizedFlagFromAccessor = true;\n        this._loader = loader;\n        this.enabled = DracoDecoder.DefaultAvailable && this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        delete this.dracoDecoder;\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadVertexDataAsync(context, primitive, babylonMesh) {\n        return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, async (extensionContext, extension) => {\n            if (primitive.mode != undefined) {\n                if (primitive.mode !== 4 /* MeshPrimitiveMode.TRIANGLES */ && primitive.mode !== 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */) {\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\n                }\n            }\n            const attributes = {};\n            const normalized = {};\n            const loadAttribute = (name, kind) => {\n                const uniqueId = extension.attributes[name];\n                if (uniqueId == undefined) {\n                    return;\n                }\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n                    babylonMesh._delayInfo.push(kind);\n                }\n                attributes[kind] = uniqueId;\n                if (this.useNormalizedFlagFromAccessor) {\n                    const accessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[name]);\n                    if (accessor) {\n                        normalized[kind] = accessor.normalized || false;\n                    }\n                }\n            };\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n            loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\n            loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\n            loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\n            loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\n            const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView);\n            if (!bufferView._dracoBabylonGeometry) {\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(async (data) => {\n                    const dracoDecoder = this.dracoDecoder || DracoDecoder.Default;\n                    const positionAccessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[\"POSITION\"]);\n                    const babylonBoundingInfo = !this._loader.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton && positionAccessor ? LoadBoundingInfoFromPositionAccessor(positionAccessor) : null;\n                    return await dracoDecoder\n                        ._decodeMeshToGeometryForGltfAsync(babylonMesh.name, this._loader.babylonScene, data, attributes, normalized, babylonBoundingInfo)\n                        .catch((error) => {\n                        throw new Error(`${context}: ${error.message}`);\n                    });\n                });\n            }\n            return await bufferView._dracoBabylonGeometry;\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_draco_mesh_compression(loader));\n//# sourceMappingURL=KHR_draco_mesh_compression.js.map"],"names":["DecodeMesh","module","data","attributeIDs","onIndicesData","onAttributeData","decoderModule","decoder","buffer","geometry","status","Decoder","DecoderBuffer","Init","byteLength","type","GetEncodedGeometryType","TRIANGULAR_MESH","mesh","Mesh","DecodeBufferToMesh","ok","ptr","Error","error_msg","numIndices","num_faces","_malloc","GetTrianglesUInt32Array","indices","Uint32Array","set","HEAPF32","_free","POINT_CLOUD","pointCloud","PointCloud","DecodeBufferToPointCloud","numPoints","num_points","processAttribute","kind","attribute","dataType","data_type","numComponents","num_components","normalized","byteStride","byte_stride","byteOffset","byte_offset","info","DT_FLOAT32","typedArrayConstructor","Float32Array","heap","DT_INT8","Int8Array","HEAP8","DT_INT16","Int16Array","HEAP16","DT_INT32","Int32Array","HEAP32","DT_UINT8","Uint8Array","HEAPU8","DT_UINT16","Uint16Array","HEAPU16","DT_UINT32","HEAPU32","numValues","BYTES_PER_ELEMENT","GetAttributeDataArrayForAllPoints","slice","id","GetAttributeByUniqueId","dracoAttributeTypes","position","POSITION","normal","NORMAL","color","COLOR","uv","TEX_COORD","GetAttributeId","GetAttribute","destroy","DecoderWorkerFunction","decoderPromise","onmessage","event","message","url","importScripts","initDecoderObject","wasmBinary","DracoDecoderModule","postMessage","then","dataView","attributes","size","offset","stride","totalVertices","DracoCodec","constructor","configuration","workerPool","this","_workerPoolPromise","Promise","resolve","wasmBinaryProvided","numberOfWorkers","numWorkers","navigator","hardwareConcurrency","Math","min","floor","useWorkers","Worker","URL","urlNeeded","jsModule","codecInfo","wasmUrl","wasmBinaryUrl","WebAssembly","Tools","GetBabylonScriptURL","wasmBinaryPromise","LoadFileAsync","fallbackUrl","undefined","workerContent","_getWorkerContent","workerBlobUrl","createObjectURL","Blob","AutoReleaseWorkerPool","async","worker","moduleUrl","reject","onError","error","removeEventListener","onMessage","addEventListener","clone","initializeWebWorker","_modulePromise","_isModuleAvailable","LoadBabylonScriptAsync","_createModuleAsync","whenReadyAsync","dispose","DracoDecoder","DefaultAvailable","config","DefaultConfiguration","Default","_Default","ResetDefault","skipDispose","super","decodeMeshToMeshDataAsync","gltfNormalizedOverride","ArrayBuffer","push","onComplete","resultIndices","resultAttributes","Logger","Warn","dataViewCopy","decodeMeshToGeometryAsync","name","scene","meshData","Geometry","setIndices","setVerticesBuffer","VertexBuffer","getEngine","_decodeMeshToGeometryForGltfAsync","boundingInfo","_boundingInfo","useBoundingInfoFromGeometry","_DefaultCdnUrl","NAME","KHR_draco_mesh_compression","loader","useNormalizedFlagFromAccessor","_loader","enabled","isExtensionUsed","dracoDecoder","_loadVertexDataAsync","context","primitive","babylonMesh","GLTFLoader","LoadExtensionAsync","extensionContext","extension","mode","loadAttribute","uniqueId","_delayInfo","indexOf","accessor","ArrayItem","TryGet","gltf","accessors","PositionKind","NormalKind","TangentKind","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","MatricesIndicesKind","MatricesWeightsKind","ColorKind","bufferView","Get","bufferViews","_dracoBabylonGeometry","loadBufferViewAsync","index","positionAccessor","babylonBoundingInfo","parent","alwaysComputeBoundingBox","skeleton","LoadBoundingInfoFromPositionAccessor","babylonScene","catch","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}