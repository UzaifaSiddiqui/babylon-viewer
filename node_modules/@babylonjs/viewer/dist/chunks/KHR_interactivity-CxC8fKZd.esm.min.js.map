{"version":3,"file":"KHR_interactivity-CxC8fKZd.esm.min.js","sources":["../../../../../dev/core/dist/FlowGraph/serialization.js","../../../../../dev/core/dist/FlowGraph/flowGraphAssetsContext.js","../../../../../dev/core/dist/FlowGraph/flowGraphLogger.js","../../../../../dev/core/dist/FlowGraph/flowGraphConnection.js","../../../../../dev/core/dist/FlowGraph/flowGraph.js","../../../../../dev/core/dist/FlowGraph/flowGraphContext.js","../../../../../dev/core/dist/FlowGraph/flowGraphDataConnection.js","../../../../../dev/core/dist/FlowGraph/flowGraphBlock.js","../../../../../dev/core/dist/FlowGraph/flowGraphSignalConnection.js","../../../../../dev/core/dist/FlowGraph/flowGraphExecutionBlock.js","../../../../../dev/core/dist/FlowGraph/flowGraphSceneEventCoordinator.js","../../../../../dev/core/dist/FlowGraph/utils.js","../../../../../dev/core/dist/FlowGraph/flowGraphCoordinator.js","../../../../../dev/core/dist/FlowGraph/Blocks/flowGraphBlockFactory.js","../../../../../dev/core/dist/FlowGraph/flowGraphExecutionBlockWithOutSignal.js","../../../../../dev/core/dist/FlowGraph/flowGraphAsyncExecutionBlock.js","../../../../../dev/core/dist/FlowGraph/flowGraphEventBlock.js","../../../../../dev/core/dist/FlowGraph/flowGraphParser.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_interactivity.js"],"sourcesContent":["import { Color3, Color4 } from \"../Maths/math.color\";\nimport { Matrix, Quaternion, Vector2, Vector3, Vector4 } from \"../Maths/math.vector\";\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\nimport { getRichTypeByFlowGraphType } from \"./flowGraphRichTypes\";\nimport { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\nfunction IsMeshClassName(className) {\n    return (className === \"Mesh\" ||\n        className === \"AbstractMesh\" ||\n        className === \"GroundMesh\" ||\n        className === \"InstanceMesh\" ||\n        className === \"LinesMesh\" ||\n        className === \"GoldbergMesh\" ||\n        className === \"GreasedLineMesh\" ||\n        className === \"TrailMesh\");\n}\nfunction IsVectorClassName(className) {\n    return (className === \"Vector2\" /* FlowGraphTypes.Vector2 */ ||\n        className === \"Vector3\" /* FlowGraphTypes.Vector3 */ ||\n        className === \"Vector4\" /* FlowGraphTypes.Vector4 */ ||\n        className === \"Quaternion\" /* FlowGraphTypes.Quaternion */ ||\n        className === \"Color3\" /* FlowGraphTypes.Color3 */ ||\n        className === \"Color4\" /* FlowGraphTypes.Color4 */);\n}\nfunction IsMatrixClassName(className) {\n    return className === \"Matrix\" /* FlowGraphTypes.Matrix */ || className === \"Matrix2D\" /* FlowGraphTypes.Matrix2D */ || className === \"Matrix3D\" /* FlowGraphTypes.Matrix3D */;\n}\nfunction IsAnimationGroupClassName(className) {\n    return className === \"AnimationGroup\";\n}\nfunction ParseVector(className, value, flipHandedness = false) {\n    if (className === \"Vector2\" /* FlowGraphTypes.Vector2 */) {\n        return Vector2.FromArray(value);\n    }\n    else if (className === \"Vector3\" /* FlowGraphTypes.Vector3 */) {\n        if (flipHandedness) {\n            value[2] *= -1;\n        }\n        return Vector3.FromArray(value);\n    }\n    else if (className === \"Vector4\" /* FlowGraphTypes.Vector4 */) {\n        return Vector4.FromArray(value);\n    }\n    else if (className === \"Quaternion\" /* FlowGraphTypes.Quaternion */) {\n        if (flipHandedness) {\n            value[2] *= -1;\n            value[3] *= -1;\n        }\n        return Quaternion.FromArray(value);\n    }\n    else if (className === \"Color3\" /* FlowGraphTypes.Color3 */) {\n        return new Color3(value[0], value[1], value[2]);\n    }\n    else if (className === \"Color4\" /* FlowGraphTypes.Color4 */) {\n        return new Color4(value[0], value[1], value[2], value[3]);\n    }\n    else {\n        throw new Error(`Unknown vector class name ${className}`);\n    }\n}\n/**\n * The default function that serializes values in a context object to a serialization object\n * @param key the key where the value should be stored in the serialization object\n * @param value the value to store\n * @param serializationObject the object where the value will be stored\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function defaultValueSerializationFunction(key, value, serializationObject) {\n    const className = value?.getClassName?.() ?? \"\";\n    if (IsVectorClassName(className) || IsMatrixClassName(className)) {\n        serializationObject[key] = {\n            value: value.asArray(),\n            className,\n        };\n    }\n    else if (className === \"FlowGraphInteger\" /* FlowGraphTypes.Integer */) {\n        serializationObject[key] = {\n            value: value.value,\n            className,\n        };\n    }\n    else {\n        if (className && (value.id || value.name)) {\n            serializationObject[key] = {\n                id: value.id,\n                name: value.name,\n                className,\n            };\n        }\n        else {\n            // only if it is not an object\n            if (typeof value !== \"object\") {\n                serializationObject[key] = value;\n            }\n            else {\n                throw new Error(`Could not serialize value ${value}`);\n            }\n        }\n    }\n}\n/**\n * The default function that parses values stored in a serialization object\n * @param key the key to the value that will be parsed\n * @param serializationObject the object that will be parsed\n * @param assetsContainer the assets container that will be used to find the objects\n * @param scene\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function defaultValueParseFunction(key, serializationObject, assetsContainer, scene) {\n    const intermediateValue = serializationObject[key];\n    let finalValue;\n    const className = intermediateValue?.type ?? intermediateValue?.className;\n    if (IsMeshClassName(className)) {\n        let nodes = scene.meshes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\n        if (nodes.length === 0) {\n            nodes = scene.transformNodes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\n        }\n        finalValue = intermediateValue.uniqueId ? nodes.find((m) => m.uniqueId === intermediateValue.uniqueId) : nodes[0];\n    }\n    else if (IsVectorClassName(className)) {\n        finalValue = ParseVector(className, intermediateValue.value);\n    }\n    else if (IsAnimationGroupClassName(className)) {\n        // do not use the scene.getAnimationGroupByName because it is possible that two AGs will have the same name\n        const ags = scene.animationGroups.filter((ag) => ag.name === intermediateValue.name);\n        // uniqueId changes on each load. this is used for the glTF loader, that uses serialization after the scene was loaded.\n        finalValue = ags.length === 1 ? ags[0] : ags.find((ag) => ag.uniqueId === intermediateValue.uniqueId);\n    }\n    else if (className === \"Matrix\" /* FlowGraphTypes.Matrix */) {\n        finalValue = Matrix.FromArray(intermediateValue.value);\n    }\n    else if (className === \"Matrix2D\" /* FlowGraphTypes.Matrix2D */) {\n        finalValue = new FlowGraphMatrix2D(intermediateValue.value);\n    }\n    else if (className === \"Matrix3D\" /* FlowGraphTypes.Matrix3D */) {\n        finalValue = new FlowGraphMatrix3D(intermediateValue.value);\n    }\n    else if (className === \"FlowGraphInteger\" /* FlowGraphTypes.Integer */) {\n        finalValue = FlowGraphInteger.FromValue(intermediateValue.value);\n    }\n    else if (className === \"number\" /* FlowGraphTypes.Number */ || className === \"string\" /* FlowGraphTypes.String */ || className === \"boolean\" /* FlowGraphTypes.Boolean */) {\n        finalValue = intermediateValue.value[0];\n    }\n    else if (intermediateValue && intermediateValue.value !== undefined) {\n        finalValue = intermediateValue.value;\n    }\n    else {\n        if (Array.isArray(intermediateValue)) {\n            // configuration data of an event\n            finalValue = intermediateValue.reduce((acc, val) => {\n                if (!val.eventData) {\n                    return acc;\n                }\n                acc[val.id] = {\n                    type: getRichTypeByFlowGraphType(val.type),\n                };\n                if (typeof val.value !== \"undefined\") {\n                    acc[val.id].value = defaultValueParseFunction(\"value\", val, assetsContainer, scene);\n                }\n                return acc;\n            }, {});\n        }\n        else {\n            finalValue = intermediateValue;\n        }\n    }\n    return finalValue;\n}\n/**\n * Given a name of a flow graph block class, return if this\n * class needs to be created with a path converter. Used in\n * parsing.\n * @param className the name of the flow graph block class\n * @returns a boolean indicating if the class needs a path converter\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function needsPathConverter(className) {\n    // I am not using the ClassName property here because it was causing a circular dependency\n    // that jest didn't like!\n    return className === \"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */;\n}\n//# sourceMappingURL=serialization.js.map","/**\n * The type of the assets that flow graph supports\n */\nexport var FlowGraphAssetType;\n(function (FlowGraphAssetType) {\n    FlowGraphAssetType[\"Animation\"] = \"Animation\";\n    FlowGraphAssetType[\"AnimationGroup\"] = \"AnimationGroup\";\n    FlowGraphAssetType[\"Mesh\"] = \"Mesh\";\n    FlowGraphAssetType[\"Material\"] = \"Material\";\n    FlowGraphAssetType[\"Camera\"] = \"Camera\";\n    FlowGraphAssetType[\"Light\"] = \"Light\";\n    // Further asset types will be added here when needed.\n})(FlowGraphAssetType || (FlowGraphAssetType = {}));\n/**\n * Returns the asset with the given index and type from the assets context.\n * @param assetsContext The assets context to get the asset from\n * @param type The type of the asset\n * @param index The index of the asset\n * @param useIndexAsUniqueId If set to true, instead of the index in the array it will search for the unique id of the asset.\n * @returns The asset or null if not found\n */\nexport function GetFlowGraphAssetWithType(assetsContext, type, index, useIndexAsUniqueId) {\n    switch (type) {\n        case \"Animation\" /* FlowGraphAssetType.Animation */:\n            return useIndexAsUniqueId\n                ? (assetsContext.animations.find((a) => a.uniqueId === index) ?? null)\n                : (assetsContext.animations[index] ?? null);\n        case \"AnimationGroup\" /* FlowGraphAssetType.AnimationGroup */:\n            return useIndexAsUniqueId\n                ? (assetsContext.animationGroups.find((a) => a.uniqueId === index) ?? null)\n                : (assetsContext.animationGroups[index] ?? null);\n        case \"Mesh\" /* FlowGraphAssetType.Mesh */:\n            return useIndexAsUniqueId\n                ? (assetsContext.meshes.find((a) => a.uniqueId === index) ?? null)\n                : (assetsContext.meshes[index] ?? null);\n        case \"Material\" /* FlowGraphAssetType.Material */:\n            return useIndexAsUniqueId\n                ? (assetsContext.materials.find((a) => a.uniqueId === index) ?? null)\n                : (assetsContext.materials[index] ?? null);\n        case \"Camera\" /* FlowGraphAssetType.Camera */:\n            return useIndexAsUniqueId\n                ? (assetsContext.cameras.find((a) => a.uniqueId === index) ?? null)\n                : (assetsContext.cameras[index] ?? null);\n        case \"Light\" /* FlowGraphAssetType.Light */:\n            return useIndexAsUniqueId\n                ? (assetsContext.lights.find((a) => a.uniqueId === index) ?? null)\n                : (assetsContext.lights[index] ?? null);\n        default:\n            return null;\n    }\n}\n//# sourceMappingURL=flowGraphAssetsContext.js.map","import { Logger } from \"core/Misc/logger\";\nexport var FlowGraphAction;\n(function (FlowGraphAction) {\n    FlowGraphAction[\"ExecuteBlock\"] = \"ExecuteBlock\";\n    FlowGraphAction[\"ExecuteEvent\"] = \"ExecuteEvent\";\n    FlowGraphAction[\"TriggerConnection\"] = \"TriggerConnection\";\n    FlowGraphAction[\"ContextVariableSet\"] = \"ContextVariableSet\";\n    FlowGraphAction[\"GlobalVariableSet\"] = \"GlobalVariableSet\";\n    FlowGraphAction[\"GlobalVariableDelete\"] = \"GlobalVariableDelete\";\n    FlowGraphAction[\"GlobalVariableGet\"] = \"GlobalVariableGet\";\n    FlowGraphAction[\"AddConnection\"] = \"AddConnection\";\n    FlowGraphAction[\"GetConnectionValue\"] = \"GetConnectionValue\";\n    FlowGraphAction[\"SetConnectionValue\"] = \"SetConnectionValue\";\n    FlowGraphAction[\"ActivateSignal\"] = \"ActivateSignal\";\n    FlowGraphAction[\"ContextVariableGet\"] = \"ContextVariableGet\";\n})(FlowGraphAction || (FlowGraphAction = {}));\n/**\n * This class will be responsible of logging the flow graph activity.\n * Note that using this class might reduce performance, as it will log every action, according to the configuration.\n * It attaches to a flow graph and uses meta-programming to replace the methods of the flow graph to add logging abilities.\n */\nexport class FlowGraphLogger {\n    constructor() {\n        /**\n         * Whether to log to the console.\n         */\n        this.logToConsole = false;\n        /**\n         * The log cache of the flow graph.\n         * Each item is a logged item, in order of execution.\n         */\n        this.log = [];\n    }\n    addLogItem(item) {\n        if (!item.time) {\n            item.time = Date.now();\n        }\n        this.log.push(item);\n        if (this.logToConsole) {\n            const value = item.payload?.value;\n            if (typeof value === \"object\" && value.getClassName) {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(value.getClassName())}: ${value.toString()}`);\n            }\n            else {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(item.payload)}`);\n            }\n        }\n    }\n    getItemsOfType(action) {\n        return this.log.filter((i) => i.action === action);\n    }\n}\n//# sourceMappingURL=flowGraphLogger.js.map","import { RandomGUID } from \"../Misc/guid\";\n/**\n * The type of a connection point - input or output.\n */\nexport var FlowGraphConnectionType;\n(function (FlowGraphConnectionType) {\n    FlowGraphConnectionType[FlowGraphConnectionType[\"Input\"] = 0] = \"Input\";\n    FlowGraphConnectionType[FlowGraphConnectionType[\"Output\"] = 1] = \"Output\";\n})(FlowGraphConnectionType || (FlowGraphConnectionType = {}));\n/**\n * The base connection class.\n */\nexport class FlowGraphConnection {\n    constructor(name, _connectionType, \n    /* @internal */ _ownerBlock) {\n        this._ownerBlock = _ownerBlock;\n        /** @internal */\n        this._connectedPoint = [];\n        /**\n         * A uniquely identifying string for the connection.\n         */\n        this.uniqueId = RandomGUID();\n        /**\n         * Used for parsing connections.\n         * @internal\n         */\n        // disable warning as this is used for parsing\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.connectedPointIds = [];\n        this.name = name;\n        this._connectionType = _connectionType;\n    }\n    /**\n     * The type of the connection\n     */\n    get connectionType() {\n        return this._connectionType;\n    }\n    /**\n     * @internal\n     * Override this to indicate if a point can connect to more than one point.\n     */\n    _isSingularConnection() {\n        return true;\n    }\n    /**\n     * Returns if a point is connected to any other point.\n     * @returns boolean indicating if the point is connected.\n     */\n    isConnected() {\n        return this._connectedPoint.length > 0;\n    }\n    /**\n     * Connects two connections together.\n     * @param point the connection to connect to.\n     */\n    connectTo(point) {\n        if (this._connectionType === point._connectionType) {\n            throw new Error(`Cannot connect two points of type ${this.connectionType}`);\n        }\n        if ((this._isSingularConnection() && this._connectedPoint.length > 0) || (point._isSingularConnection() && point._connectedPoint.length > 0)) {\n            throw new Error(\"Max number of connections for point reached\");\n        }\n        this._connectedPoint.push(point);\n        point._connectedPoint.push(this);\n    }\n    /**\n     * Disconnects two connections.\n     * @param point the connection to disconnect from.\n     * @param removeFromLocal if true, the connection will be removed from the local connection list.\n     */\n    disconnectFrom(point, removeFromLocal = true) {\n        const indexLocal = this._connectedPoint.indexOf(point);\n        const indexConnected = point._connectedPoint.indexOf(this);\n        if (indexLocal === -1 || indexConnected === -1) {\n            return;\n        }\n        if (removeFromLocal) {\n            this._connectedPoint.splice(indexLocal, 1);\n        }\n        point._connectedPoint.splice(indexConnected, 1);\n    }\n    /**\n     * Disconnects all connected points.\n     */\n    disconnectFromAll() {\n        for (const point of this._connectedPoint) {\n            this.disconnectFrom(point, false);\n        }\n        this._connectedPoint.length = 0;\n    }\n    dispose() {\n        for (const point of this._connectedPoint) {\n            this.disconnectFrom(point);\n        }\n    }\n    /**\n     * Saves the connection to a JSON object.\n     * @param serializationObject the object to serialize to.\n     */\n    serialize(serializationObject = {}) {\n        serializationObject.uniqueId = this.uniqueId;\n        serializationObject.name = this.name;\n        serializationObject._connectionType = this._connectionType;\n        serializationObject.connectedPointIds = [];\n        serializationObject.className = this.getClassName();\n        for (const point of this._connectedPoint) {\n            serializationObject.connectedPointIds.push(point.uniqueId);\n        }\n    }\n    /**\n     * @returns class name of the connection.\n     */\n    getClassName() {\n        return \"FGConnection\";\n    }\n    /**\n     * Deserialize from a object into this\n     * @param serializationObject the object to deserialize from.\n     */\n    deserialize(serializationObject) {\n        this.uniqueId = serializationObject.uniqueId;\n        this.name = serializationObject.name;\n        this._connectionType = serializationObject._connectionType;\n        this.connectedPointIds = serializationObject.connectedPointIds;\n    }\n}\n//# sourceMappingURL=flowGraphConnection.js.map","import { Observable } from \"../Misc/observable\";\nimport { FlowGraphContext } from \"./flowGraphContext\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\nimport { FlowGraphSceneEventCoordinator } from \"./flowGraphSceneEventCoordinator\";\nimport { _IsDescendantOf } from \"./utils\";\nexport var FlowGraphState;\n(function (FlowGraphState) {\n    /**\n     * The graph is stopped\n     */\n    FlowGraphState[FlowGraphState[\"Stopped\"] = 0] = \"Stopped\";\n    /**\n     * The graph is running\n     */\n    FlowGraphState[FlowGraphState[\"Started\"] = 1] = \"Started\";\n})(FlowGraphState || (FlowGraphState = {}));\n/**\n * Class used to represent a flow graph.\n * A flow graph is a graph of blocks that can be used to create complex logic.\n * Blocks can be added to the graph and connected to each other.\n * The graph can then be started, which will init and start all of its event blocks.\n *\n * @experimental FlowGraph is still in development and is subject to change.\n */\nexport class FlowGraph {\n    /**\n     * The state of the graph\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * The state of the graph\n     */\n    set state(value) {\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(value);\n    }\n    /**\n     * Construct a Flow Graph\n     * @param params construction parameters. currently only the scene\n     */\n    constructor(params) {\n        /**\n         * An observable that is triggered when the state of the graph changes.\n         */\n        this.onStateChangedObservable = new Observable();\n        /** @internal */\n        this._eventBlocks = {\n            [\"SceneReady\" /* FlowGraphEventType.SceneReady */]: [],\n            [\"SceneDispose\" /* FlowGraphEventType.SceneDispose */]: [],\n            [\"SceneBeforeRender\" /* FlowGraphEventType.SceneBeforeRender */]: [],\n            [\"MeshPick\" /* FlowGraphEventType.MeshPick */]: [],\n            [\"PointerDown\" /* FlowGraphEventType.PointerDown */]: [],\n            [\"PointerUp\" /* FlowGraphEventType.PointerUp */]: [],\n            [\"PointerMove\" /* FlowGraphEventType.PointerMove */]: [],\n            [\"PointerOver\" /* FlowGraphEventType.PointerOver */]: [],\n            [\"PointerOut\" /* FlowGraphEventType.PointerOut */]: [],\n            [\"SceneAfterRender\" /* FlowGraphEventType.SceneAfterRender */]: [],\n            [\"NoTrigger\" /* FlowGraphEventType.NoTrigger */]: [],\n        };\n        this._executionContexts = [];\n        /**\n         * The state of the graph\n         */\n        this._state = 0 /* FlowGraphState.Stopped */;\n        this._scene = params.scene;\n        this._sceneEventCoordinator = new FlowGraphSceneEventCoordinator(this._scene);\n        this._coordinator = params.coordinator;\n        this._eventObserver = this._sceneEventCoordinator.onEventTriggeredObservable.add((event) => {\n            for (const context of this._executionContexts) {\n                const order = this._getContextualOrder(event.type, context);\n                for (const block of order) {\n                    // iterate contexts\n                    if (!block._executeEvent(context, event.payload)) {\n                        break;\n                    }\n                }\n            }\n            // custom behavior(s) of specific events\n            switch (event.type) {\n                case \"SceneReady\" /* FlowGraphEventType.SceneReady */:\n                    this._sceneEventCoordinator.sceneReadyTriggered = true;\n                    break;\n                case \"SceneBeforeRender\" /* FlowGraphEventType.SceneBeforeRender */:\n                    for (const context of this._executionContexts) {\n                        context._notifyOnTick(event.payload);\n                    }\n                    break;\n                case \"SceneDispose\" /* FlowGraphEventType.SceneDispose */:\n                    this.dispose();\n                    break;\n            }\n        });\n    }\n    /**\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\n     * @returns the context, where you can get and set variables\n     */\n    createContext() {\n        const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });\n        this._executionContexts.push(context);\n        return context;\n    }\n    /**\n     * Returns the execution context at a given index\n     * @param index the index of the context\n     * @returns the execution context at that index\n     */\n    getContext(index) {\n        return this._executionContexts[index];\n    }\n    /**\n     * Add an event block. When the graph is started, it will start listening to events\n     * from the block and execute the graph when they are triggered.\n     * @param block the event block to be added\n     */\n    addEventBlock(block) {\n        if (block.type === \"PointerOver\" /* FlowGraphEventType.PointerOver */ || block.type === \"PointerOut\" /* FlowGraphEventType.PointerOut */) {\n            this._scene.constantlyUpdateMeshUnderPointer = true;\n        }\n        // don't add if NoTrigger, but still start the pending tasks\n        if (block.type !== \"NoTrigger\" /* FlowGraphEventType.NoTrigger */) {\n            this._eventBlocks[block.type].push(block);\n        }\n        // if already started, sort and add to the pending\n        if (this.state === 1 /* FlowGraphState.Started */) {\n            for (const context of this._executionContexts) {\n                block._startPendingTasks(context);\n            }\n        }\n        else {\n            this.onStateChangedObservable.addOnce((state) => {\n                if (state === 1 /* FlowGraphState.Started */) {\n                    for (const context of this._executionContexts) {\n                        block._startPendingTasks(context);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\n     */\n    start() {\n        if (this.state === 1 /* FlowGraphState.Started */) {\n            return;\n        }\n        if (this._executionContexts.length === 0) {\n            this.createContext();\n        }\n        this.onStateChangedObservable.add((state) => {\n            if (state === 1 /* FlowGraphState.Started */) {\n                this._startPendingEvents();\n                // the only event we need to check is the scene ready event. If the scene is already ready when the graph starts, we should start the pending tasks.\n                if (this._scene.isReady(true)) {\n                    this._sceneEventCoordinator.onEventTriggeredObservable.notifyObservers({ type: \"SceneReady\" /* FlowGraphEventType.SceneReady */ });\n                }\n            }\n        });\n        this.state = 1 /* FlowGraphState.Started */;\n    }\n    _startPendingEvents() {\n        for (const context of this._executionContexts) {\n            for (const type in this._eventBlocks) {\n                const order = this._getContextualOrder(type, context);\n                for (const block of order) {\n                    block._startPendingTasks(context);\n                }\n            }\n        }\n    }\n    _getContextualOrder(type, context) {\n        const order = this._eventBlocks[type].sort((a, b) => b.initPriority - a.initPriority);\n        if (type === \"MeshPick\" /* FlowGraphEventType.MeshPick */) {\n            const meshPickOrder = [];\n            for (const block1 of order) {\n                // If the block is a mesh pick, guarantee that picks of children meshes come before picks of parent meshes\n                const mesh1 = block1.asset.getValue(context);\n                let i = 0;\n                for (; i < order.length; i++) {\n                    const block2 = order[i];\n                    const mesh2 = block2.asset.getValue(context);\n                    if (mesh1 && mesh2 && _IsDescendantOf(mesh1, mesh2)) {\n                        break;\n                    }\n                }\n                meshPickOrder.splice(i, 0, block1);\n            }\n            return meshPickOrder;\n        }\n        return order;\n    }\n    /**\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\n     */\n    dispose() {\n        if (this.state === 0 /* FlowGraphState.Stopped */) {\n            return;\n        }\n        this.state = 0 /* FlowGraphState.Stopped */;\n        for (const context of this._executionContexts) {\n            context._clearPendingBlocks();\n        }\n        this._executionContexts.length = 0;\n        for (const type in this._eventBlocks) {\n            this._eventBlocks[type].length = 0;\n        }\n        this._eventObserver?.remove();\n        this._sceneEventCoordinator.dispose();\n    }\n    /**\n     * Executes a function in all blocks of a flow graph, starting with the event blocks.\n     * @param visitor the function to execute.\n     */\n    visitAllBlocks(visitor) {\n        const visitList = [];\n        const idsAddedToVisitList = new Set();\n        for (const type in this._eventBlocks) {\n            for (const block of this._eventBlocks[type]) {\n                visitList.push(block);\n                idsAddedToVisitList.add(block.uniqueId);\n            }\n        }\n        while (visitList.length > 0) {\n            const block = visitList.pop();\n            visitor(block);\n            for (const dataIn of block.dataInputs) {\n                for (const connection of dataIn._connectedPoint) {\n                    if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\n                        visitList.push(connection._ownerBlock);\n                        idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\n                    }\n                }\n            }\n            if (block instanceof FlowGraphExecutionBlock) {\n                for (const signalOut of block.signalOutputs) {\n                    for (const connection of signalOut._connectedPoint) {\n                        if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\n                            visitList.push(connection._ownerBlock);\n                            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Serializes a graph\n     * @param serializationObject the object to write the values in\n     * @param valueSerializeFunction a function to serialize complex values\n     */\n    serialize(serializationObject = {}, valueSerializeFunction) {\n        serializationObject.allBlocks = [];\n        this.visitAllBlocks((block) => {\n            const serializedBlock = {};\n            block.serialize(serializedBlock);\n            serializationObject.allBlocks.push(serializedBlock);\n        });\n        serializationObject.executionContexts = [];\n        for (const context of this._executionContexts) {\n            const serializedContext = {};\n            context.serialize(serializedContext, valueSerializeFunction);\n            serializationObject.executionContexts.push(serializedContext);\n        }\n    }\n}\n//# sourceMappingURL=flowGraph.js.map","import { __decorate } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { RandomGUID } from \"../Misc/guid\";\nimport { defaultValueSerializationFunction } from \"./serialization\";\nimport { Observable } from \"../Misc/observable\";\nimport { GetFlowGraphAssetWithType } from \"./flowGraphAssetsContext\";\nimport { FlowGraphLogger } from \"./flowGraphLogger\";\n/**\n * The context represents the current state and execution of the flow graph.\n * It contains both user-defined variables, which are derived from\n * a more general variable definition, and execution variables that\n * are set by the blocks.\n */\nexport class FlowGraphContext {\n    /**\n     * Enable logging on this context\n     */\n    get enableLogging() {\n        return this._enableLogging;\n    }\n    set enableLogging(value) {\n        if (this._enableLogging === value) {\n            return;\n        }\n        this._enableLogging = value;\n        if (this._enableLogging) {\n            this.logger = new FlowGraphLogger();\n            this.logger.logToConsole = true;\n        }\n        else {\n            this.logger = null;\n        }\n    }\n    constructor(params) {\n        /**\n         * A randomly generated GUID for each context.\n         */\n        this.uniqueId = RandomGUID();\n        /**\n         * These are the variables defined by a user.\n         */\n        this._userVariables = {};\n        /**\n         * These are the variables set by the blocks.\n         */\n        this._executionVariables = {};\n        /**\n         * A context-specific global variables, available to all blocks in the context.\n         */\n        this._globalContextVariables = {};\n        /**\n         * These are the values for the data connection points\n         */\n        this._connectionValues = {};\n        /**\n         * These are blocks that have currently pending tasks/listeners that need to be cleaned up.\n         */\n        this._pendingBlocks = [];\n        /**\n         * A monotonically increasing ID for each execution.\n         * Incremented for every block executed.\n         */\n        this._executionId = 0;\n        /**\n         * Observable that is triggered when a node is executed.\n         */\n        this.onNodeExecutedObservable = new Observable();\n        /**\n         * Whether to treat data as right-handed.\n         * This is used when serializing data from a right-handed system, while running the context in a left-handed system, for example in glTF parsing.\n         * Default is false.\n         */\n        this.treatDataAsRightHanded = false;\n        this._enableLogging = false;\n        this._configuration = params;\n        this.assetsContext = params.assetsContext ?? params.scene;\n    }\n    /**\n     * Check if a user-defined variable is defined.\n     * @param name the name of the variable\n     * @returns true if the variable is defined\n     */\n    hasVariable(name) {\n        return name in this._userVariables;\n    }\n    /**\n     * Set a user-defined variable.\n     * @param name the name of the variable\n     * @param value the value of the variable\n     */\n    setVariable(name, value) {\n        this._userVariables[name] = value;\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n            action: \"ContextVariableSet\" /* FlowGraphAction.ContextVariableSet */,\n            payload: {\n                name,\n                value,\n            },\n        });\n    }\n    /**\n     * Get an assets from the assets context based on its type and index in the array\n     * @param type The type of the asset\n     * @param index The index of the asset\n     * @returns The asset or null if not found\n     */\n    getAsset(type, index) {\n        return GetFlowGraphAssetWithType(this.assetsContext, type, index);\n    }\n    /**\n     * Get a user-defined variable.\n     * @param name the name of the variable\n     * @returns the value of the variable\n     */\n    getVariable(name) {\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n            action: \"ContextVariableGet\" /* FlowGraphAction.ContextVariableGet */,\n            payload: {\n                name,\n                value: this._userVariables[name],\n            },\n        });\n        return this._userVariables[name];\n    }\n    /**\n     * Gets all user variables map\n     */\n    get userVariables() {\n        return this._userVariables;\n    }\n    /**\n     * Get the scene that the context belongs to.\n     * @returns the scene\n     */\n    getScene() {\n        return this._configuration.scene;\n    }\n    _getUniqueIdPrefixedName(obj, name) {\n        return `${obj.uniqueId}_${name}`;\n    }\n    /**\n     * @internal\n     * @param name name of the variable\n     * @param defaultValue default value to return if the variable is not defined\n     * @returns the variable value or the default value if the variable is not defined\n     */\n    _getGlobalContextVariable(name, defaultValue) {\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n            action: \"GlobalVariableGet\" /* FlowGraphAction.GlobalVariableGet */,\n            payload: {\n                name,\n                defaultValue,\n                possibleValue: this._globalContextVariables[name],\n            },\n        });\n        if (this._hasGlobalContextVariable(name)) {\n            return this._globalContextVariables[name];\n        }\n        else {\n            return defaultValue;\n        }\n    }\n    /**\n     * Set a global context variable\n     * @internal\n     * @param name the name of the variable\n     * @param value the value of the variable\n     */\n    _setGlobalContextVariable(name, value) {\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n            action: \"GlobalVariableSet\" /* FlowGraphAction.GlobalVariableSet */,\n            payload: { name, value },\n        });\n        this._globalContextVariables[name] = value;\n    }\n    /**\n     * Delete a global context variable\n     * @internal\n     * @param name the name of the variable\n     */\n    _deleteGlobalContextVariable(name) {\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n            action: \"GlobalVariableDelete\" /* FlowGraphAction.GlobalVariableDelete */,\n            payload: { name },\n        });\n        delete this._globalContextVariables[name];\n    }\n    /**\n     * Check if a global context variable is defined\n     * @internal\n     * @param name the name of the variable\n     * @returns true if the variable is defined\n     */\n    _hasGlobalContextVariable(name) {\n        return name in this._globalContextVariables;\n    }\n    /**\n     * Set an internal execution variable\n     * @internal\n     * @param name\n     * @param value\n     */\n    _setExecutionVariable(block, name, value) {\n        this._executionVariables[this._getUniqueIdPrefixedName(block, name)] = value;\n    }\n    /**\n     * Get an internal execution variable\n     * @internal\n     * @param name\n     * @returns\n     */\n    _getExecutionVariable(block, name, defaultValue) {\n        if (this._hasExecutionVariable(block, name)) {\n            return this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\n        }\n        else {\n            return defaultValue;\n        }\n    }\n    /**\n     * Delete an internal execution variable\n     * @internal\n     * @param block\n     * @param name\n     */\n    _deleteExecutionVariable(block, name) {\n        delete this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\n    }\n    /**\n     * Check if an internal execution variable is defined\n     * @internal\n     * @param block\n     * @param name\n     * @returns\n     */\n    _hasExecutionVariable(block, name) {\n        return this._getUniqueIdPrefixedName(block, name) in this._executionVariables;\n    }\n    /**\n     * Check if a connection value is defined\n     * @internal\n     * @param connectionPoint\n     * @returns\n     */\n    _hasConnectionValue(connectionPoint) {\n        return connectionPoint.uniqueId in this._connectionValues;\n    }\n    /**\n     * Set a connection value\n     * @internal\n     * @param connectionPoint\n     * @param value\n     */\n    _setConnectionValue(connectionPoint, value) {\n        this._connectionValues[connectionPoint.uniqueId] = value;\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n            action: \"SetConnectionValue\" /* FlowGraphAction.SetConnectionValue */,\n            payload: {\n                connectionPointId: connectionPoint.uniqueId,\n                value,\n            },\n        });\n    }\n    /**\n     * Set a connection value by key\n     * @internal\n     * @param key the key of the connection value\n     * @param value the value of the connection\n     */\n    _setConnectionValueByKey(key, value) {\n        this._connectionValues[key] = value;\n    }\n    /**\n     * Get a connection value\n     * @internal\n     * @param connectionPoint\n     * @returns\n     */\n    _getConnectionValue(connectionPoint) {\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n            action: \"GetConnectionValue\" /* FlowGraphAction.GetConnectionValue */,\n            payload: {\n                connectionPointId: connectionPoint.uniqueId,\n                value: this._connectionValues[connectionPoint.uniqueId],\n            },\n        });\n        return this._connectionValues[connectionPoint.uniqueId];\n    }\n    /**\n     * Get the configuration\n     * @internal\n     * @param name\n     * @param value\n     */\n    get configuration() {\n        return this._configuration;\n    }\n    /**\n     * Check if there are any pending blocks in this context\n     * @returns true if there are pending blocks\n     */\n    get hasPendingBlocks() {\n        return this._pendingBlocks.length > 0;\n    }\n    /**\n     * Add a block to the list of blocks that have pending tasks.\n     * @internal\n     * @param block\n     */\n    _addPendingBlock(block) {\n        // check if block is already in the array\n        if (this._pendingBlocks.includes(block)) {\n            return;\n        }\n        this._pendingBlocks.push(block);\n        // sort pending blocks by priority\n        this._pendingBlocks.sort((a, b) => a.priority - b.priority);\n    }\n    /**\n     * Remove a block from the list of blocks that have pending tasks.\n     * @internal\n     * @param block\n     */\n    _removePendingBlock(block) {\n        const index = this._pendingBlocks.indexOf(block);\n        if (index !== -1) {\n            this._pendingBlocks.splice(index, 1);\n        }\n    }\n    /**\n     * Clear all pending blocks.\n     * @internal\n     */\n    _clearPendingBlocks() {\n        for (const block of this._pendingBlocks) {\n            block._cancelPendingTasks(this);\n        }\n        this._pendingBlocks.length = 0;\n    }\n    /**\n     * @internal\n     * Function that notifies the node executed observable\n     * @param node\n     */\n    _notifyExecuteNode(node) {\n        this.onNodeExecutedObservable.notifyObservers(node);\n        this.logger?.addLogItem({\n            time: Date.now(),\n            className: node.getClassName(),\n            uniqueId: node.uniqueId,\n            action: \"ExecuteBlock\" /* FlowGraphAction.ExecuteBlock */,\n        });\n    }\n    _notifyOnTick(framePayload) {\n        // set the values as global variables\n        this._setGlobalContextVariable(\"timeSinceStart\", framePayload.timeSinceStart);\n        this._setGlobalContextVariable(\"deltaTime\", framePayload.deltaTime);\n        // iterate the pending blocks and run each one's onFrame function\n        for (const block of this._pendingBlocks) {\n            block._executeOnTick?.(this);\n        }\n    }\n    /**\n     * @internal\n     */\n    _increaseExecutionId() {\n        this._executionId++;\n    }\n    /**\n     * A monotonically increasing ID for each execution.\n     * Incremented for every block executed.\n     */\n    get executionId() {\n        return this._executionId;\n    }\n    /**\n     * Serializes a context\n     * @param serializationObject the object to write the values in\n     * @param valueSerializationFunction a function to serialize complex values\n     */\n    serialize(serializationObject = {}, valueSerializationFunction = defaultValueSerializationFunction) {\n        serializationObject.uniqueId = this.uniqueId;\n        serializationObject._userVariables = {};\n        for (const key in this._userVariables) {\n            valueSerializationFunction(key, this._userVariables[key], serializationObject._userVariables);\n        }\n        serializationObject._connectionValues = {};\n        for (const key in this._connectionValues) {\n            valueSerializationFunction(key, this._connectionValues[key], serializationObject._connectionValues);\n        }\n        // serialize assets context, if not scene\n        if (this.assetsContext !== this.getScene()) {\n            serializationObject._assetsContext = {\n                meshes: this.assetsContext.meshes.map((m) => m.id),\n                materials: this.assetsContext.materials.map((m) => m.id),\n                textures: this.assetsContext.textures.map((m) => m.name),\n                animations: this.assetsContext.animations.map((m) => m.name),\n                lights: this.assetsContext.lights.map((m) => m.id),\n                cameras: this.assetsContext.cameras.map((m) => m.id),\n                sounds: this.assetsContext.sounds?.map((m) => m.name),\n                skeletons: this.assetsContext.skeletons.map((m) => m.id),\n                particleSystems: this.assetsContext.particleSystems.map((m) => m.name),\n                geometries: this.assetsContext.geometries.map((m) => m.id),\n                multiMaterials: this.assetsContext.multiMaterials.map((m) => m.id),\n                transformNodes: this.assetsContext.transformNodes.map((m) => m.id),\n            };\n        }\n    }\n    /**\n     * @returns the class name of the object.\n     */\n    getClassName() {\n        return \"FlowGraphContext\";\n    }\n}\n__decorate([\n    serialize()\n], FlowGraphContext.prototype, \"uniqueId\", void 0);\n//# sourceMappingURL=flowGraphContext.js.map","import { RegisterClass } from \"../Misc/typeStore\";\nimport { FlowGraphConnection } from \"./flowGraphConnection\";\nimport { Observable } from \"core/Misc/observable\";\nimport { defaultValueSerializationFunction } from \"./serialization\";\n/**\n * Represents a connection point for data.\n * An unconnected input point can have a default value.\n * An output point will only have a value if it is connected to an input point. Furthermore,\n * if the point belongs to a \"function\" node, the node will run its function to update the value.\n */\nexport class FlowGraphDataConnection extends FlowGraphConnection {\n    /**\n     * Create a new data connection point.\n     * @param name the name of the connection\n     * @param connectionType the type of the connection\n     * @param ownerBlock the block that owns this connection\n     * @param richType the type of the data in this block\n     * @param _defaultValue the default value of the connection\n     * @param _optional if the connection is optional\n     */\n    constructor(name, connectionType, ownerBlock, \n    /**\n     * the type of the data in this block\n     */\n    richType, \n    /**\n     * [any] the default value of the connection\n     */\n    _defaultValue = richType.defaultValue, \n    /**\n     * [false] if the connection is optional\n     */\n    _optional = false) {\n        super(name, connectionType, ownerBlock);\n        this.richType = richType;\n        this._defaultValue = _defaultValue;\n        this._optional = _optional;\n        this._isDisabled = false;\n        /**\n         * This is used for debugging purposes! It is the last value that was set to this connection with ANY context.\n         * Do not use this value for anything else, as it might be wrong if used in a different context.\n         */\n        this._lastValue = null;\n        /**\n         * a data transformer function, if needed.\n         * This can be used, for example, to force seconds into milliseconds output, if it makes sense in your case.\n         */\n        this.dataTransformer = null;\n        /**\n         * An observable that is triggered when the value of the connection changes.\n         */\n        this.onValueChangedObservable = new Observable();\n    }\n    /**\n     * Whether or not the connection is optional.\n     * Currently only used for UI control.\n     */\n    get optional() {\n        return this._optional;\n    }\n    /**\n     * is this connection disabled\n     * If the connection is disabled you will not be able to connect anything to it.\n     */\n    get isDisabled() {\n        return this._isDisabled;\n    }\n    set isDisabled(value) {\n        if (this._isDisabled === value) {\n            return;\n        }\n        this._isDisabled = value;\n        if (this._isDisabled) {\n            this.disconnectFromAll();\n        }\n    }\n    /**\n     * An output data block can connect to multiple input data blocks,\n     * but an input data block can only connect to one output data block.\n     * @returns true if the connection is singular\n     */\n    _isSingularConnection() {\n        return this.connectionType === 0 /* FlowGraphConnectionType.Input */;\n    }\n    /**\n     * Set the value of the connection in a specific context.\n     * @param value the value to set\n     * @param context the context to which the value is set\n     */\n    setValue(value, context) {\n        // check if the value is different\n        if (context._getConnectionValue(this) === value) {\n            return;\n        }\n        context._setConnectionValue(this, value);\n        this.onValueChangedObservable.notifyObservers(value);\n    }\n    /**\n     * Reset the value of the connection to the default value.\n     * @param context the context in which the value is reset\n     */\n    resetToDefaultValue(context) {\n        context._setConnectionValue(this, this._defaultValue);\n    }\n    /**\n     * Connect this point to another point.\n     * @param point the point to connect to.\n     */\n    connectTo(point) {\n        if (this._isDisabled) {\n            return;\n        }\n        super.connectTo(point);\n    }\n    _getValueOrDefault(context) {\n        const val = context._getConnectionValue(this) ?? this._defaultValue;\n        return this.dataTransformer ? this.dataTransformer(val) : val;\n    }\n    /**\n     * Gets the value of the connection in a specific context.\n     * @param context the context from which the value is retrieved\n     * @returns the value of the connection\n     */\n    getValue(context) {\n        if (this.connectionType === 1 /* FlowGraphConnectionType.Output */) {\n            context._notifyExecuteNode(this._ownerBlock);\n            this._ownerBlock._updateOutputs(context);\n            const value = this._getValueOrDefault(context);\n            this._lastValue = value;\n            return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\n        }\n        const value = !this.isConnected() ? this._getValueOrDefault(context) : this._connectedPoint[0].getValue(context);\n        this._lastValue = value;\n        return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\n    }\n    /**\n     * @internal\n     */\n    _getLastValue() {\n        return this._lastValue;\n    }\n    /**\n     * @returns class name of the object.\n     */\n    getClassName() {\n        return \"FlowGraphDataConnection\";\n    }\n    /**\n     * Serializes this object.\n     * @param serializationObject the object to serialize to\n     */\n    serialize(serializationObject = {}) {\n        super.serialize(serializationObject);\n        serializationObject.richType = {};\n        this.richType.serialize(serializationObject.richType);\n        serializationObject.optional = this._optional;\n        defaultValueSerializationFunction(\"defaultValue\", this._defaultValue, serializationObject);\n    }\n}\nRegisterClass(\"FlowGraphDataConnection\", FlowGraphDataConnection);\n//# sourceMappingURL=flowGraphDataConnection.js.map","import { RandomGUID } from \"../Misc/guid\";\nimport { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\nimport { defaultValueSerializationFunction } from \"./serialization\";\n/**\n * A block in a flow graph. The most basic form\n * of a block has inputs and outputs that contain\n * data.\n */\nexport class FlowGraphBlock {\n    /** Constructor is protected so only subclasses can be instantiated\n     * @param config optional configuration for this block\n     * @internal - do not use directly. Extend this class instead.\n     */\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        this.config = config;\n        /**\n         * A randomly generated GUID for each block.\n         */\n        this.uniqueId = RandomGUID();\n        this.name = this.config?.name ?? this.getClassName();\n        this.dataInputs = [];\n        this.dataOutputs = [];\n    }\n    /**\n     * @internal\n     * This function is called when the block needs to update its output flows.\n     * @param _context the context in which it is running\n     */\n    _updateOutputs(_context) {\n        // empty by default, overridden in data blocks\n    }\n    /**\n     * Registers a data input on the block.\n     * @param name the name of the input\n     * @param richType the type of the input\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\n     * @returns the created connection\n     */\n    registerDataInput(name, richType, defaultValue) {\n        const input = new FlowGraphDataConnection(name, 0 /* FlowGraphConnectionType.Input */, this, richType, defaultValue);\n        this.dataInputs.push(input);\n        return input;\n    }\n    /**\n     * Registers a data output on the block.\n     * @param name the name of the input\n     * @param richType the type of the input\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\n     * @returns the created connection\n     */\n    registerDataOutput(name, richType, defaultValue) {\n        const output = new FlowGraphDataConnection(name, 1 /* FlowGraphConnectionType.Output */, this, richType, defaultValue);\n        this.dataOutputs.push(output);\n        return output;\n    }\n    /**\n     * Given the name of a data input, returns the connection if it exists\n     * @param name the name of the input\n     * @returns the connection if it exists, undefined otherwise\n     */\n    getDataInput(name) {\n        return this.dataInputs.find((i) => i.name === name);\n    }\n    /**\n     * Given the name of a data output, returns the connection if it exists\n     * @param name the name of the output\n     * @returns the connection if it exists, undefined otherwise\n     */\n    getDataOutput(name) {\n        return this.dataOutputs.find((i) => i.name === name);\n    }\n    /**\n     * Serializes this block\n     * @param serializationObject the object to serialize to\n     * @param _valueSerializeFunction a function that serializes a specific value\n     */\n    serialize(serializationObject = {}, _valueSerializeFunction = defaultValueSerializationFunction) {\n        serializationObject.uniqueId = this.uniqueId;\n        serializationObject.config = {};\n        if (this.config) {\n            const config = this.config;\n            const keys = Object.keys(config);\n            for (const key of keys) {\n                _valueSerializeFunction(key, config[key], serializationObject.config);\n            }\n        }\n        serializationObject.dataInputs = [];\n        serializationObject.dataOutputs = [];\n        serializationObject.className = this.getClassName();\n        for (const input of this.dataInputs) {\n            const serializedInput = {};\n            input.serialize(serializedInput);\n            serializationObject.dataInputs.push(serializedInput);\n        }\n        for (const output of this.dataOutputs) {\n            const serializedOutput = {};\n            output.serialize(serializedOutput);\n            serializationObject.dataOutputs.push(serializedOutput);\n        }\n    }\n    /**\n     * Deserializes this block\n     * @param _serializationObject the object to deserialize from\n     */\n    deserialize(_serializationObject) {\n        // no-op by default\n    }\n    _log(context, action, payload) {\n        context.logger?.addLogItem({\n            action,\n            payload,\n            className: this.getClassName(),\n            uniqueId: this.uniqueId,\n        });\n    }\n    /**\n     * Gets the class name of this block\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FlowGraphBlock\";\n    }\n}\n//# sourceMappingURL=flowGraphBlock.js.map","import { FlowGraphConnection } from \"./flowGraphConnection\";\nimport { RegisterClass } from \"../Misc/typeStore\";\n/**\n * Represents a connection point for a signal.\n * When an output point is activated, it will activate the connected input point.\n * When an input point is activated, it will execute the block it belongs to.\n */\nexport class FlowGraphSignalConnection extends FlowGraphConnection {\n    constructor() {\n        super(...arguments);\n        /**\n         * The priority of the signal. Signals with higher priority will be executed first.\n         * Set priority before adding the connection as sorting happens only when the connection is added.\n         */\n        this.priority = 0;\n    }\n    _isSingularConnection() {\n        return false;\n    }\n    connectTo(point) {\n        super.connectTo(point);\n        // sort according to priority to handle execution order\n        this._connectedPoint.sort((a, b) => b.priority - a.priority);\n    }\n    /**\n     * @internal\n     */\n    _activateSignal(context) {\n        context.logger?.addLogItem({\n            action: \"ActivateSignal\" /* FlowGraphAction.ActivateSignal */,\n            className: this._ownerBlock.getClassName(),\n            uniqueId: this._ownerBlock.uniqueId,\n            payload: {\n                connectionType: this.connectionType,\n                name: this.name,\n            },\n        });\n        if (this.connectionType === 0 /* FlowGraphConnectionType.Input */) {\n            context._notifyExecuteNode(this._ownerBlock);\n            this._ownerBlock._execute(context, this);\n            context._increaseExecutionId();\n        }\n        else {\n            for (const connectedPoint of this._connectedPoint) {\n                connectedPoint._activateSignal(context);\n            }\n        }\n    }\n}\nRegisterClass(\"FlowGraphSignalConnection\", FlowGraphSignalConnection);\n//# sourceMappingURL=flowGraphSignalConnection.js.map","import { FlowGraphBlock } from \"./flowGraphBlock\";\nimport { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\n/**\n * A block that executes some action. Always has an input signal (which is not used by event blocks).\n * Can have one or more output signals.\n */\nexport class FlowGraphExecutionBlock extends FlowGraphBlock {\n    constructor(config) {\n        super(config);\n        /**\n         * The priority of the block. Higher priority blocks will be executed first.\n         * Note that priority cannot be change AFTER the block was added as sorting happens when the block is added to the execution queue.\n         */\n        this.priority = 0;\n        this.signalInputs = [];\n        this.signalOutputs = [];\n        this.in = this._registerSignalInput(\"in\");\n        this.error = this._registerSignalOutput(\"error\");\n    }\n    _registerSignalInput(name) {\n        const input = new FlowGraphSignalConnection(name, 0 /* FlowGraphConnectionType.Input */, this);\n        this.signalInputs.push(input);\n        return input;\n    }\n    _registerSignalOutput(name) {\n        const output = new FlowGraphSignalConnection(name, 1 /* FlowGraphConnectionType.Output */, this);\n        this.signalOutputs.push(output);\n        return output;\n    }\n    _unregisterSignalInput(name) {\n        const index = this.signalInputs.findIndex((input) => input.name === name);\n        if (index !== -1) {\n            this.signalInputs[index].dispose();\n            this.signalInputs.splice(index, 1);\n        }\n    }\n    _unregisterSignalOutput(name) {\n        const index = this.signalOutputs.findIndex((output) => output.name === name);\n        if (index !== -1) {\n            this.signalOutputs[index].dispose();\n            this.signalOutputs.splice(index, 1);\n        }\n    }\n    _reportError(context, error) {\n        this.error.payload = typeof error === \"string\" ? new Error(error) : error;\n        this.error._activateSignal(context);\n    }\n    /**\n     * Given a name of a signal input, return that input if it exists\n     * @param name the name of the input\n     * @returns if the input exists, the input. Otherwise, undefined.\n     */\n    getSignalInput(name) {\n        return this.signalInputs.find((input) => input.name === name);\n    }\n    /**\n     * Given a name of a signal output, return that input if it exists\n     * @param name the name of the input\n     * @returns if the input exists, the input. Otherwise, undefined.\n     */\n    getSignalOutput(name) {\n        return this.signalOutputs.find((output) => output.name === name);\n    }\n    /**\n     * Serializes this block\n     * @param serializationObject the object to serialize in\n     */\n    serialize(serializationObject = {}) {\n        super.serialize(serializationObject);\n        serializationObject.signalInputs = [];\n        serializationObject.signalOutputs = [];\n        for (const input of this.signalInputs) {\n            const serializedInput = {};\n            input.serialize(serializedInput);\n            serializationObject.signalInputs.push(serializedInput);\n        }\n        for (const output of this.signalOutputs) {\n            const serializedOutput = {};\n            output.serialize(serializedOutput);\n            serializationObject.signalOutputs.push(serializedOutput);\n        }\n    }\n    /**\n     * Deserializes from an object\n     * @param serializationObject the object to deserialize from\n     */\n    deserialize(serializationObject) {\n        for (let i = 0; i < serializationObject.signalInputs.length; i++) {\n            const signalInput = this.getSignalInput(serializationObject.signalInputs[i].name);\n            if (signalInput) {\n                signalInput.deserialize(serializationObject.signalInputs[i]);\n            }\n            else {\n                throw new Error(\"Could not find signal input with name \" + serializationObject.signalInputs[i].name + \" in block \" + serializationObject.className);\n            }\n        }\n        for (let i = 0; i < serializationObject.signalOutputs.length; i++) {\n            const signalOutput = this.getSignalOutput(serializationObject.signalOutputs[i].name);\n            if (signalOutput) {\n                signalOutput.deserialize(serializationObject.signalOutputs[i]);\n            }\n            else {\n                throw new Error(\"Could not find signal output with name \" + serializationObject.signalOutputs[i].name + \" in block \" + serializationObject.className);\n            }\n        }\n    }\n    /**\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FlowGraphExecutionBlock\";\n    }\n}\n//# sourceMappingURL=flowGraphExecutionBlock.js.map","import { PointerEventTypes } from \"core/Events/pointerEvents\";\nimport { Observable } from \"core/Misc/observable\";\n/**\n * This class is responsible for coordinating the events that are triggered in the scene.\n * It registers all observers needed to track certain events and triggers the blocks that are listening to them.\n * Abstracting the events from the class will allow us to easily change the events that are being listened to, and trigger them in any order.\n */\nexport class FlowGraphSceneEventCoordinator {\n    constructor(scene) {\n        /**\n         * register to this observable to get flow graph event notifications.\n         */\n        this.onEventTriggeredObservable = new Observable();\n        /**\n         * Was scene-ready already triggered?\n         */\n        this.sceneReadyTriggered = false;\n        this._pointerUnderMeshState = {};\n        this._startingTime = 0;\n        this._scene = scene;\n        this._initialize();\n    }\n    _initialize() {\n        this._sceneReadyObserver = this._scene.onReadyObservable.add(() => {\n            if (!this.sceneReadyTriggered) {\n                this.onEventTriggeredObservable.notifyObservers({ type: \"SceneReady\" /* FlowGraphEventType.SceneReady */ });\n                this.sceneReadyTriggered = true;\n            }\n        });\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n            this.onEventTriggeredObservable.notifyObservers({ type: \"SceneDispose\" /* FlowGraphEventType.SceneDispose */ });\n        });\n        this._sceneOnBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n            const deltaTime = this._scene.getEngine().getDeltaTime() / 1000; // set in seconds\n            this.onEventTriggeredObservable.notifyObservers({\n                type: \"SceneBeforeRender\" /* FlowGraphEventType.SceneBeforeRender */,\n                payload: {\n                    timeSinceStart: this._startingTime,\n                    deltaTime,\n                },\n            });\n            this._startingTime += deltaTime;\n        });\n        this._meshPickedObserver = this._scene.onPointerObservable.add((pointerInfo) => {\n            this.onEventTriggeredObservable.notifyObservers({ type: \"MeshPick\" /* FlowGraphEventType.MeshPick */, payload: pointerInfo });\n        }, PointerEventTypes.POINTERPICK); // should it be pointerdown?\n        this._meshUnderPointerObserver = this._scene.onMeshUnderPointerUpdatedObservable.add((data) => {\n            // check if the data has changed. Check the state of the last change and see if it is a mesh or null.\n            // if it is a mesh and the previous state was null, trigger over event. If it is null and the previous state was a mesh, trigger out event.\n            // if it is a mesh and the previous state was a mesh, trigger out from the old mesh and over the new mesh\n            // if it is null and the previous state was null, do nothing.\n            const pointerId = data.pointerId;\n            const mesh = data.mesh;\n            const previousState = this._pointerUnderMeshState[pointerId];\n            if (!previousState && mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: \"PointerOver\" /* FlowGraphEventType.PointerOver */, payload: { pointerId, mesh } });\n            }\n            else if (previousState && !mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: \"PointerOut\" /* FlowGraphEventType.PointerOut */, payload: { pointerId, mesh: previousState } });\n            }\n            else if (previousState && mesh && previousState !== mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: \"PointerOut\" /* FlowGraphEventType.PointerOut */, payload: { pointerId, mesh: previousState, over: mesh } });\n                this.onEventTriggeredObservable.notifyObservers({ type: \"PointerOver\" /* FlowGraphEventType.PointerOver */, payload: { pointerId, mesh, out: previousState } });\n            }\n            this._pointerUnderMeshState[pointerId] = mesh;\n        }, PointerEventTypes.POINTERMOVE);\n    }\n    dispose() {\n        this._sceneDisposeObserver?.remove();\n        this._sceneReadyObserver?.remove();\n        this._sceneOnBeforeRenderObserver?.remove();\n        this._meshPickedObserver?.remove();\n        this._meshUnderPointerObserver?.remove();\n        this.onEventTriggeredObservable.clear();\n    }\n}\n//# sourceMappingURL=flowGraphSceneEventCoordinator.js.map","/**\n * @internal\n * Returns if mesh1 is a descendant of mesh2\n * @param mesh1\n * @param mesh2\n * @returns\n */\nexport function _IsDescendantOf(mesh1, mesh2) {\n    return !!(mesh1.parent && (mesh1.parent === mesh2 || _IsDescendantOf(mesh1.parent, mesh2)));\n}\n/**\n * @internal\n */\nexport function _GetClassNameOf(v) {\n    if (v.getClassName) {\n        return v.getClassName();\n    }\n    return;\n}\n/**\n * @internal\n * Check if two classname are the same and are vector or quaternion classes.\n * @param className the first class name\n * @param className2 the second class name\n * @returns whether the two class names are the same and are vector or quaternion classes.\n */\nexport function _AreSameVectorOrQuaternionClass(className, className2) {\n    return (className === className2 &&\n        (className === \"Vector2\" /* FlowGraphTypes.Vector2 */ || className === \"Vector3\" /* FlowGraphTypes.Vector3 */ || className === \"Vector4\" /* FlowGraphTypes.Vector4 */ || className === \"Quaternion\" /* FlowGraphTypes.Quaternion */));\n}\n/**\n * @internal\n * Check if two classname are the same and are matrix classes.\n * @param className the first class name\n * @param className2 the second class name\n * @returns whether the two class names are the same and are matrix classes.\n */\nexport function _AreSameMatrixClass(className, className2) {\n    return className === className2 && (className === \"Matrix\" /* FlowGraphTypes.Matrix */ || className === \"Matrix2D\" /* FlowGraphTypes.Matrix2D */ || className === \"Matrix3D\" /* FlowGraphTypes.Matrix3D */);\n}\n/**\n * @internal\n * Check if two classname are the same and are integer classes.\n * @param className the first class name\n * @param className2 the second class name\n * @returns whether the two class names are the same and are integer classes.\n */\nexport function _AreSameIntegerClass(className, className2) {\n    return className === \"FlowGraphInteger\" && className2 === \"FlowGraphInteger\";\n}\n/**\n * Check if an object has a numeric value.\n * @param a the object to check if it is a number.\n * @param validIfNaN whether to consider NaN as a valid number.\n * @returns whether a is a FlowGraphNumber (Integer or number).\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function isNumeric(a, validIfNaN) {\n    const isNumeric = typeof a === \"number\" || typeof a?.value === \"number\";\n    if (isNumeric && !validIfNaN) {\n        return !isNaN(getNumericValue(a));\n    }\n    return isNumeric;\n}\n/**\n * Get the numeric value of a FlowGraphNumber.\n * @param a the object to get the numeric value from.\n * @returns the numeric value.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getNumericValue(a) {\n    return typeof a === \"number\" ? a : a.value;\n}\n//# sourceMappingURL=utils.js.map","import { Observable } from \"core/Misc/observable\";\nimport { FlowGraph } from \"./flowGraph\";\nimport { Logger } from \"core/Misc/logger\";\n/**\n * This class holds all of the existing flow graphs and is responsible for creating new ones.\n * It also handles starting/stopping multiple graphs and communication between them through an Event Coordinator\n * This is the entry point for the flow graph system.\n * @experimental This class is still in development and is subject to change.\n */\nexport class FlowGraphCoordinator {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        this.config = config;\n        /**\n         * When set to true (default) custom events will be dispatched synchronously.\n         * This means that the events will be dispatched immediately when they are triggered.\n         */\n        this.dispatchEventsSynchronously = true;\n        this._flowGraphs = [];\n        this._customEventsMap = new Map();\n        this._eventExecutionCounter = new Map();\n        this._executeOnNextFrame = [];\n        this._eventUniqueId = 0;\n        // When the scene is disposed, dispose all graphs currently running on it.\n        this._disposeObserver = this.config.scene.onDisposeObservable.add(() => {\n            this.dispose();\n        });\n        this._onBeforeRenderObserver = this.config.scene.onBeforeRenderObservable.add(() => {\n            // Reset the event execution counter at the beginning of each frame.\n            this._eventExecutionCounter.clear();\n            // duplicate the _executeOnNextFrame array to avoid modifying it while iterating over it\n            const executeOnNextFrame = this._executeOnNextFrame.slice(0);\n            if (executeOnNextFrame.length) {\n                // Execute the events that were triggered on the next frame.\n                for (const event of executeOnNextFrame) {\n                    this.notifyCustomEvent(event.id, event.data, false);\n                    // remove the event from the array\n                    const index = this._executeOnNextFrame.findIndex((e) => e.uniqueId === event.uniqueId);\n                    if (index !== -1) {\n                        this._executeOnNextFrame.splice(index, 1);\n                    }\n                }\n            }\n        });\n        // Add itself to the SceneCoordinators list for the Inspector.\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\n        coordinators.push(this);\n    }\n    /**\n     * Creates a new flow graph and adds it to the list of existing flow graphs\n     * @returns a new flow graph\n     */\n    createGraph() {\n        const graph = new FlowGraph({ scene: this.config.scene, coordinator: this });\n        this._flowGraphs.push(graph);\n        return graph;\n    }\n    /**\n     * Removes a flow graph from the list of existing flow graphs and disposes it\n     * @param graph the graph to remove\n     */\n    removeGraph(graph) {\n        const index = this._flowGraphs.indexOf(graph);\n        if (index !== -1) {\n            graph.dispose();\n            this._flowGraphs.splice(index, 1);\n        }\n    }\n    /**\n     * Starts all graphs\n     */\n    start() {\n        for (const graph of this._flowGraphs) {\n            graph.start();\n        }\n    }\n    /**\n     * Disposes all graphs\n     */\n    dispose() {\n        for (const graph of this._flowGraphs) {\n            graph.dispose();\n        }\n        this._flowGraphs.length = 0;\n        this._disposeObserver?.remove();\n        this._onBeforeRenderObserver?.remove();\n        // Remove itself from the SceneCoordinators list for the Inspector.\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\n        const index = coordinators.indexOf(this);\n        if (index !== -1) {\n            coordinators.splice(index, 1);\n        }\n    }\n    /**\n     * Serializes this coordinator to a JSON object.\n     * @param serializationObject the object to serialize to\n     * @param valueSerializeFunction the function to use to serialize the value\n     */\n    serialize(serializationObject, valueSerializeFunction) {\n        serializationObject._flowGraphs = [];\n        for (const graph of this._flowGraphs) {\n            const serializedGraph = {};\n            graph.serialize(serializedGraph, valueSerializeFunction);\n            serializationObject._flowGraphs.push(serializedGraph);\n        }\n        serializationObject.dispatchEventsSynchronously = this.dispatchEventsSynchronously;\n    }\n    /**\n     * Gets the list of flow graphs\n     */\n    get flowGraphs() {\n        return this._flowGraphs;\n    }\n    /**\n     * Get an observable that will be notified when the event with the given id is fired.\n     * @param id the id of the event\n     * @returns the observable for the event\n     */\n    getCustomEventObservable(id) {\n        let observable = this._customEventsMap.get(id);\n        if (!observable) {\n            // receive event is initialized before scene start, so no need to notify if triggered. but possible!\n            observable = new Observable( /*undefined, true*/);\n            this._customEventsMap.set(id, observable);\n        }\n        return observable;\n    }\n    /**\n     * Notifies the observable for the given event id with the given data.\n     * @param id the id of the event\n     * @param data the data to send with the event\n     * @param async if true, the event will be dispatched asynchronously\n     */\n    notifyCustomEvent(id, data, async = !this.dispatchEventsSynchronously) {\n        if (async) {\n            this._executeOnNextFrame.push({ id, data, uniqueId: this._eventUniqueId++ });\n            return;\n        }\n        // check if we are not exceeding the max number of events\n        if (this._eventExecutionCounter.has(id)) {\n            const count = this._eventExecutionCounter.get(id);\n            this._eventExecutionCounter.set(id, count + 1);\n            if (count >= FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\n                if (count === FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\n                    Logger.Warn(`FlowGraphCoordinator: Too many executions of event \"${id}\".`);\n                }\n                return;\n            }\n        }\n        else {\n            this._eventExecutionCounter.set(id, 1);\n        }\n        const observable = this._customEventsMap.get(id);\n        if (observable) {\n            observable.notifyObservers(data);\n        }\n    }\n}\n/**\n * The maximum number of events per type.\n * This is used to limit the number of events that can be created in a single scene.\n * This is to prevent infinite loops.\n */\nFlowGraphCoordinator.MaxEventsPerType = 30;\n/**\n * The maximum number of execution of a specific event in a single frame.\n */\nFlowGraphCoordinator.MaxEventTypeExecutionPerFrame = 30;\n/**\n * @internal\n * A list of all the coordinators per scene. Will be used by the inspector\n */\nFlowGraphCoordinator.SceneCoordinators = new Map();\n//# sourceMappingURL=flowGraphCoordinator.js.map","/**\n * Any external module that wishes to add a new block to the flow graph can add to this object using the helper function.\n */\nconst CustomBlocks = {};\n/**\n * If you want to add a new block to the block factory, you should use this function.\n * Please be sure to choose a unique name and define the responsible module.\n * @param module the name of the module that is responsible for the block\n * @param blockName the name of the block. This should be unique.\n * @param factory an async factory function to generate the block\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function addToBlockFactory(module, blockName, factory) {\n    CustomBlocks[`${module}/${blockName}`] = factory;\n}\n/**\n * a function to get a factory function for a block.\n * @param blockName the block name to initialize. If the block comes from an external module, the name should be in the format \"module/blockName\"\n * @returns an async factory function that will return the block class when called.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function blockFactory(blockName) {\n    switch (blockName) {\n        case \"FlowGraphPlayAnimationBlock\" /* FlowGraphBlockNames.PlayAnimation */:\n            return async () => (await import(\"./Execution/Animation/flowGraphPlayAnimationBlock\")).FlowGraphPlayAnimationBlock;\n        case \"FlowGraphStopAnimationBlock\" /* FlowGraphBlockNames.StopAnimation */:\n            return async () => (await import(\"./Execution/Animation/flowGraphStopAnimationBlock\")).FlowGraphStopAnimationBlock;\n        case \"FlowGraphPauseAnimationBlock\" /* FlowGraphBlockNames.PauseAnimation */:\n            return async () => (await import(\"./Execution/Animation/flowGraphPauseAnimationBlock\")).FlowGraphPauseAnimationBlock;\n        case \"FlowGraphInterpolationBlock\" /* FlowGraphBlockNames.ValueInterpolation */:\n            return async () => (await import(\"./Execution/Animation/flowGraphInterpolationBlock\")).FlowGraphInterpolationBlock;\n        case \"FlowGraphSceneReadyEventBlock\" /* FlowGraphBlockNames.SceneReadyEvent */:\n            return async () => (await import(\"./Event/flowGraphSceneReadyEventBlock\")).FlowGraphSceneReadyEventBlock;\n        case \"FlowGraphSceneTickEventBlock\" /* FlowGraphBlockNames.SceneTickEvent */:\n            return async () => (await import(\"./Event/flowGraphSceneTickEventBlock\")).FlowGraphSceneTickEventBlock;\n        case \"FlowGraphSendCustomEventBlock\" /* FlowGraphBlockNames.SendCustomEvent */:\n            return async () => (await import(\"./Event/flowGraphSendCustomEventBlock\")).FlowGraphSendCustomEventBlock;\n        case \"FlowGraphReceiveCustomEventBlock\" /* FlowGraphBlockNames.ReceiveCustomEvent */:\n            return async () => (await import(\"./Event/flowGraphReceiveCustomEventBlock\")).FlowGraphReceiveCustomEventBlock;\n        case \"FlowGraphMeshPickEventBlock\" /* FlowGraphBlockNames.MeshPickEvent */:\n            return async () => (await import(\"./Event/flowGraphMeshPickEventBlock\")).FlowGraphMeshPickEventBlock;\n        case \"FlowGraphEBlock\" /* FlowGraphBlockNames.E */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEBlock;\n        case \"FlowGraphPIBlock\" /* FlowGraphBlockNames.PI */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPiBlock;\n        case \"FlowGraphInfBlock\" /* FlowGraphBlockNames.Inf */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphInfBlock;\n        case \"FlowGraphNaNBlock\" /* FlowGraphBlockNames.NaN */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNaNBlock;\n        case \"FlowGraphRandomBlock\" /* FlowGraphBlockNames.Random */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRandomBlock;\n        case \"FlowGraphAddBlock\" /* FlowGraphBlockNames.Add */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAddBlock;\n        case \"FlowGraphSubtractBlock\" /* FlowGraphBlockNames.Subtract */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSubtractBlock;\n        case \"FlowGraphMultiplyBlock\" /* FlowGraphBlockNames.Multiply */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMultiplyBlock;\n        case \"FlowGraphDivideBlock\" /* FlowGraphBlockNames.Divide */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDivideBlock;\n        case \"FlowGraphAbsBlock\" /* FlowGraphBlockNames.Abs */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAbsBlock;\n        case \"FlowGraphSignBlock\" /* FlowGraphBlockNames.Sign */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSignBlock;\n        case \"FlowGraphTruncBlock\" /* FlowGraphBlockNames.Trunc */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTruncBlock;\n        case \"FlowGraphFloorBlock\" /* FlowGraphBlockNames.Floor */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFloorBlock;\n        case \"FlowGraphCeilBlock\" /* FlowGraphBlockNames.Ceil */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCeilBlock;\n        case \"FlowGraphRoundBlock\" /* FlowGraphBlockNames.Round */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRoundBlock;\n        case \"FlowGraphFractBlock\" /* FlowGraphBlockNames.Fraction */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFractionBlock;\n        case \"FlowGraphNegationBlock\" /* FlowGraphBlockNames.Negation */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNegationBlock;\n        case \"FlowGraphModuloBlock\" /* FlowGraphBlockNames.Modulo */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphModuloBlock;\n        case \"FlowGraphMinBlock\" /* FlowGraphBlockNames.Min */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMinBlock;\n        case \"FlowGraphMaxBlock\" /* FlowGraphBlockNames.Max */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMaxBlock;\n        case \"FlowGraphClampBlock\" /* FlowGraphBlockNames.Clamp */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphClampBlock;\n        case \"FlowGraphSaturateBlock\" /* FlowGraphBlockNames.Saturate */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSaturateBlock;\n        case \"FlowGraphMathInterpolationBlock\" /* FlowGraphBlockNames.MathInterpolation */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMathInterpolationBlock;\n        case \"FlowGraphEqualityBlock\" /* FlowGraphBlockNames.Equality */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEqualityBlock;\n        case \"FlowGraphLessThanBlock\" /* FlowGraphBlockNames.LessThan */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanBlock;\n        case \"FlowGraphLessThanOrEqualBlock\" /* FlowGraphBlockNames.LessThanOrEqual */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanOrEqualBlock;\n        case \"FlowGraphGreaterThanBlock\" /* FlowGraphBlockNames.GreaterThan */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanBlock;\n        case \"FlowGraphGreaterThanOrEqualBlock\" /* FlowGraphBlockNames.GreaterThanOrEqual */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanOrEqualBlock;\n        case \"FlowGraphIsNaNBlock\" /* FlowGraphBlockNames.IsNaN */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsNanBlock;\n        case \"FlowGraphIsInfBlock\" /* FlowGraphBlockNames.IsInfinity */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsInfinityBlock;\n        case \"FlowGraphDegToRadBlock\" /* FlowGraphBlockNames.DegToRad */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDegToRadBlock;\n        case \"FlowGraphRadToDegBlock\" /* FlowGraphBlockNames.RadToDeg */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRadToDegBlock;\n        case \"FlowGraphSinBlock\" /* FlowGraphBlockNames.Sin */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinBlock;\n        case \"FlowGraphCosBlock\" /* FlowGraphBlockNames.Cos */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCosBlock;\n        case \"FlowGraphTanBlock\" /* FlowGraphBlockNames.Tan */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanBlock;\n        case \"FlowGraphASinBlock\" /* FlowGraphBlockNames.Asin */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinBlock;\n        case \"FlowGraphACosBlock\" /* FlowGraphBlockNames.Acos */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcosBlock;\n        case \"FlowGraphATanBlock\" /* FlowGraphBlockNames.Atan */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanBlock;\n        case \"FlowGraphATan2Block\" /* FlowGraphBlockNames.Atan2 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtan2Block;\n        case \"FlowGraphSinhBlock\" /* FlowGraphBlockNames.Sinh */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinhBlock;\n        case \"FlowGraphCoshBlock\" /* FlowGraphBlockNames.Cosh */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCoshBlock;\n        case \"FlowGraphTanhBlock\" /* FlowGraphBlockNames.Tanh */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanhBlock;\n        case \"FlowGraphASinhBlock\" /* FlowGraphBlockNames.Asinh */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinhBlock;\n        case \"FlowGraphACoshBlock\" /* FlowGraphBlockNames.Acosh */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcoshBlock;\n        case \"FlowGraphATanhBlock\" /* FlowGraphBlockNames.Atanh */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanhBlock;\n        case \"FlowGraphExponentialBlock\" /* FlowGraphBlockNames.Exponential */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphExpBlock;\n        case \"FlowGraphLogBlock\" /* FlowGraphBlockNames.Log */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLogBlock;\n        case \"FlowGraphLog2Block\" /* FlowGraphBlockNames.Log2 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog2Block;\n        case \"FlowGraphLog10Block\" /* FlowGraphBlockNames.Log10 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog10Block;\n        case \"FlowGraphSquareRootBlock\" /* FlowGraphBlockNames.SquareRoot */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSquareRootBlock;\n        case \"FlowGraphPowerBlock\" /* FlowGraphBlockNames.Power */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPowerBlock;\n        case \"FlowGraphCubeRootBlock\" /* FlowGraphBlockNames.CubeRoot */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCubeRootBlock;\n        case \"FlowGraphBitwiseAndBlock\" /* FlowGraphBlockNames.BitwiseAnd */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseAndBlock;\n        case \"FlowGraphBitwiseOrBlock\" /* FlowGraphBlockNames.BitwiseOr */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseOrBlock;\n        case \"FlowGraphBitwiseNotBlock\" /* FlowGraphBlockNames.BitwiseNot */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseNotBlock;\n        case \"FlowGraphBitwiseXorBlock\" /* FlowGraphBlockNames.BitwiseXor */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseXorBlock;\n        case \"FlowGraphBitwiseLeftShiftBlock\" /* FlowGraphBlockNames.BitwiseLeftShift */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseLeftShiftBlock;\n        case \"FlowGraphBitwiseRightShiftBlock\" /* FlowGraphBlockNames.BitwiseRightShift */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseRightShiftBlock;\n        case \"FlowGraphLengthBlock\" /* FlowGraphBlockNames.Length */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphLengthBlock;\n        case \"FlowGraphNormalizeBlock\" /* FlowGraphBlockNames.Normalize */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphNormalizeBlock;\n        case \"FlowGraphDotBlock\" /* FlowGraphBlockNames.Dot */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphDotBlock;\n        case \"FlowGraphCrossBlock\" /* FlowGraphBlockNames.Cross */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphCrossBlock;\n        case \"FlowGraphRotate2DBlock\" /* FlowGraphBlockNames.Rotate2D */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate2DBlock;\n        case \"FlowGraphRotate3DBlock\" /* FlowGraphBlockNames.Rotate3D */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate3DBlock;\n        case \"FlowGraphTransposeBlock\" /* FlowGraphBlockNames.Transpose */:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphTransposeBlock;\n        case \"FlowGraphDeterminantBlock\" /* FlowGraphBlockNames.Determinant */:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphDeterminantBlock;\n        case \"FlowGraphInvertMatrixBlock\" /* FlowGraphBlockNames.InvertMatrix */:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphInvertMatrixBlock;\n        case \"FlowGraphMatrixMultiplicationBlock\" /* FlowGraphBlockNames.MatrixMultiplication */:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixMultiplicationBlock;\n        case \"FlowGraphBranchBlock\" /* FlowGraphBlockNames.Branch */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphBranchBlock\")).FlowGraphBranchBlock;\n        case \"FlowGraphSetDelayBlock\" /* FlowGraphBlockNames.SetDelay */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSetDelayBlock\")).FlowGraphSetDelayBlock;\n        case \"FlowGraphCancelDelayBlock\" /* FlowGraphBlockNames.CancelDelay */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCancelDelayBlock\")).FlowGraphCancelDelayBlock;\n        case \"FlowGraphCallCounterBlock\" /* FlowGraphBlockNames.CallCounter */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCounterBlock\")).FlowGraphCallCounterBlock;\n        case \"FlowGraphDebounceBlock\" /* FlowGraphBlockNames.Debounce */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDebounceBlock\")).FlowGraphDebounceBlock;\n        case \"FlowGraphThrottleBlock\" /* FlowGraphBlockNames.Throttle */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphThrottleBlock\")).FlowGraphThrottleBlock;\n        case \"FlowGraphDoNBlock\" /* FlowGraphBlockNames.DoN */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDoNBlock\")).FlowGraphDoNBlock;\n        case \"FlowGraphFlipFlopBlock\" /* FlowGraphBlockNames.FlipFlop */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphFlipFlopBlock\")).FlowGraphFlipFlopBlock;\n        case \"FlowGraphForLoopBlock\" /* FlowGraphBlockNames.ForLoop */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphForLoopBlock\")).FlowGraphForLoopBlock;\n        case \"FlowGraphMultiGateBlock\" /* FlowGraphBlockNames.MultiGate */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphMultiGateBlock\")).FlowGraphMultiGateBlock;\n        case \"FlowGraphSequenceBlock\" /* FlowGraphBlockNames.Sequence */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSequenceBlock\")).FlowGraphSequenceBlock;\n        case \"FlowGraphSwitchBlock\" /* FlowGraphBlockNames.Switch */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSwitchBlock\")).FlowGraphSwitchBlock;\n        case \"FlowGraphWaitAllBlock\" /* FlowGraphBlockNames.WaitAll */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWaitAllBlock\")).FlowGraphWaitAllBlock;\n        case \"FlowGraphWhileLoopBlock\" /* FlowGraphBlockNames.WhileLoop */:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWhileLoopBlock\")).FlowGraphWhileLoopBlock;\n        case \"FlowGraphConsoleLogBlock\" /* FlowGraphBlockNames.ConsoleLog */:\n            return async () => (await import(\"./Execution/flowGraphConsoleLogBlock\")).FlowGraphConsoleLogBlock;\n        case \"FlowGraphConditionalBlock\" /* FlowGraphBlockNames.Conditional */:\n            return async () => (await import(\"./Data/flowGraphConditionalDataBlock\")).FlowGraphConditionalDataBlock;\n        case \"FlowGraphConstantBlock\" /* FlowGraphBlockNames.Constant */:\n            return async () => (await import(\"./Data/flowGraphConstantBlock\")).FlowGraphConstantBlock;\n        case \"FlowGraphTransformCoordinatesSystemBlock\" /* FlowGraphBlockNames.TransformCoordinatesSystem */:\n            return async () => (await import(\"./Data/flowGraphTransformCoordinatesSystemBlock\")).FlowGraphTransformCoordinatesSystemBlock;\n        case \"FlowGraphGetAssetBlock\" /* FlowGraphBlockNames.GetAsset */:\n            return async () => (await import(\"./Data/flowGraphGetAssetBlock\")).FlowGraphGetAssetBlock;\n        case \"FlowGraphGetPropertyBlock\" /* FlowGraphBlockNames.GetProperty */:\n            return async () => (await import(\"./Data/flowGraphGetPropertyBlock\")).FlowGraphGetPropertyBlock;\n        case \"FlowGraphSetPropertyBlock\" /* FlowGraphBlockNames.SetProperty */:\n            return async () => (await import(\"./Execution/flowGraphSetPropertyBlock\")).FlowGraphSetPropertyBlock;\n        case \"FlowGraphGetVariableBlock\" /* FlowGraphBlockNames.GetVariable */:\n            return async () => (await import(\"./Data/flowGraphGetVariableBlock\")).FlowGraphGetVariableBlock;\n        case \"FlowGraphSetVariableBlock\" /* FlowGraphBlockNames.SetVariable */:\n            return async () => (await import(\"./Execution/flowGraphSetVariableBlock\")).FlowGraphSetVariableBlock;\n        case \"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */:\n            return async () => (await import(\"./Data/Transformers/flowGraphJsonPointerParserBlock\")).FlowGraphJsonPointerParserBlock;\n        case \"FlowGraphLeadingZerosBlock\" /* FlowGraphBlockNames.LeadingZeros */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLeadingZerosBlock;\n        case \"FlowGraphTrailingZerosBlock\" /* FlowGraphBlockNames.TrailingZeros */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTrailingZerosBlock;\n        case \"FlowGraphOneBitsCounterBlock\" /* FlowGraphBlockNames.OneBitsCounter */:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphOneBitsCounterBlock;\n        case \"FlowGraphCombineVector2Block\" /* FlowGraphBlockNames.CombineVector2 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector2Block;\n        case \"FlowGraphCombineVector3Block\" /* FlowGraphBlockNames.CombineVector3 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector3Block;\n        case \"FlowGraphCombineVector4Block\" /* FlowGraphBlockNames.CombineVector4 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector4Block;\n        case \"FlowGraphCombineMatrixBlock\" /* FlowGraphBlockNames.CombineMatrix */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineMatrixBlock;\n        case \"FlowGraphExtractVector2Block\" /* FlowGraphBlockNames.ExtractVector2 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector2Block;\n        case \"FlowGraphExtractVector3Block\" /* FlowGraphBlockNames.ExtractVector3 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector3Block;\n        case \"FlowGraphExtractVector4Block\" /* FlowGraphBlockNames.ExtractVector4 */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector4Block;\n        case \"FlowGraphExtractMatrixBlock\" /* FlowGraphBlockNames.ExtractMatrix */:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractMatrixBlock;\n        case \"FlowGraphTransformVectorBlock\" /* FlowGraphBlockNames.TransformVector */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformBlock;\n        case \"FlowGraphTransformCoordinatesBlock\" /* FlowGraphBlockNames.TransformCoordinates */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformCoordinatesBlock;\n        case \"FlowGraphConjugateBlock\" /* FlowGraphBlockNames.Conjugate */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphConjugateBlock;\n        case \"FlowGraphAngleBetweenBlock\" /* FlowGraphBlockNames.AngleBetween */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAngleBetweenBlock;\n        case \"FlowGraphQuaternionFromAxisAngleBlock\" /* FlowGraphBlockNames.QuaternionFromAxisAngle */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromAxisAngleBlock;\n        case \"FlowGraphAxisAngleFromQuaternionBlock\" /* FlowGraphBlockNames.AxisAngleFromQuaternion */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAxisAngleFromQuaternionBlock;\n        case \"FlowGraphQuaternionFromDirectionsBlock\" /* FlowGraphBlockNames.QuaternionFromDirections */:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromDirectionsBlock;\n        case \"FlowGraphMatrixDecompose\" /* FlowGraphBlockNames.MatrixDecompose */:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixDecomposeBlock;\n        case \"FlowGraphMatrixCompose\" /* FlowGraphBlockNames.MatrixCompose */:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixComposeBlock;\n        case \"FlowGraphBooleanToFloat\" /* FlowGraphBlockNames.BooleanToFloat */:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToFloat;\n        case \"FlowGraphBooleanToInt\" /* FlowGraphBlockNames.BooleanToInt */:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToInt;\n        case \"FlowGraphFloatToBoolean\" /* FlowGraphBlockNames.FloatToBoolean */:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToBoolean;\n        case \"FlowGraphIntToBoolean\" /* FlowGraphBlockNames.IntToBoolean */:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToBoolean;\n        case \"FlowGraphIntToFloat\" /* FlowGraphBlockNames.IntToFloat */:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToFloat;\n        case \"FlowGraphFloatToInt\" /* FlowGraphBlockNames.FloatToInt */:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToInt;\n        case \"FlowGraphEasingBlock\" /* FlowGraphBlockNames.Easing */:\n            return async () => (await import(\"./Execution/Animation/flowGraphEasingBlock\")).FlowGraphEasingBlock;\n        case \"FlowGraphBezierCurveEasing\" /* FlowGraphBlockNames.BezierCurveEasing */:\n            return async () => (await import(\"./Execution/Animation/flowGraphBezierCurveEasingBlock\")).FlowGraphBezierCurveEasingBlock;\n        case \"FlowGraphPointerOverEventBlock\" /* FlowGraphBlockNames.PointerOverEvent */:\n            return async () => (await import(\"./Event/flowGraphPointerOverEventBlock\")).FlowGraphPointerOverEventBlock;\n        case \"FlowGraphPointerOutEventBlock\" /* FlowGraphBlockNames.PointerOutEvent */:\n            return async () => (await import(\"./Event/flowGraphPointerOutEventBlock\")).FlowGraphPointerOutEventBlock;\n        case \"FlowGraphContextBlock\" /* FlowGraphBlockNames.Context */:\n            return async () => (await import(\"./Data/Utils/flowGraphContextBlock\")).FlowGraphContextBlock;\n        case \"FlowGraphArrayIndexBlock\" /* FlowGraphBlockNames.ArrayIndex */:\n            return async () => (await import(\"./Data/Utils/flowGraphArrayIndexBlock\")).FlowGraphArrayIndexBlock;\n        case \"FlowGraphCodeExecutionBlock\" /* FlowGraphBlockNames.CodeExecution */:\n            return async () => (await import(\"./Data/Utils/flowGraphCodeExecutionBlock\")).FlowGraphCodeExecutionBlock;\n        case \"FlowGraphIndexOfBlock\" /* FlowGraphBlockNames.IndexOf */:\n            return async () => (await import(\"./Data/Utils/flowGraphIndexOfBlock\")).FlowGraphIndexOfBlock;\n        case \"FlowGraphFunctionReference\" /* FlowGraphBlockNames.FunctionReference */:\n            return async () => (await import(\"./Data/Utils/flowGraphFunctionReferenceBlock\")).FlowGraphFunctionReferenceBlock;\n        case \"FlowGraphDataSwitchBlock\" /* FlowGraphBlockNames.DataSwitch */:\n            return async () => (await import(\"./Data/flowGraphDataSwitchBlock\")).FlowGraphDataSwitchBlock;\n        default:\n            // check if the block is a custom block\n            if (CustomBlocks[blockName]) {\n                return CustomBlocks[blockName];\n            }\n            throw new Error(`Unknown block name ${blockName}`);\n    }\n}\n//# sourceMappingURL=flowGraphBlockFactory.js.map","import { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\n/**\n * An execution block that has an out signal. This signal is triggered when the synchronous execution of this block is done.\n * Most execution blocks will inherit from this, except for the ones that have multiple signals to be triggered.\n * (such as if blocks)\n */\nexport class FlowGraphExecutionBlockWithOutSignal extends FlowGraphExecutionBlock {\n    constructor(config) {\n        super(config);\n        this.out = this._registerSignalOutput(\"out\");\n    }\n}\n//# sourceMappingURL=flowGraphExecutionBlockWithOutSignal.js.map","import { FlowGraphExecutionBlockWithOutSignal } from \"./flowGraphExecutionBlockWithOutSignal\";\n/**\n * An async execution block can start tasks that will be executed asynchronously.\n * It should also be responsible for clearing it in _cancelPendingTasks.\n */\nexport class FlowGraphAsyncExecutionBlock extends FlowGraphExecutionBlockWithOutSignal {\n    constructor(config, events) {\n        super(config);\n        this._eventsSignalOutputs = {};\n        this.done = this._registerSignalOutput(\"done\");\n        if (events) {\n            for (const eventName of events) {\n                this._eventsSignalOutputs[eventName] = this._registerSignalOutput(eventName + \"Event\");\n            }\n        }\n    }\n    /**\n     * @internal\n     * This function can be overridden to execute any\n     * logic that should be executed on every frame\n     * while the async task is pending.\n     * @param context the context in which it is running\n     */\n    _executeOnTick(_context) { }\n    /**\n     * @internal\n     * @param context\n     */\n    _startPendingTasks(context) {\n        if (context._getExecutionVariable(this, \"_initialized\", false)) {\n            this._cancelPendingTasks(context);\n            this._resetAfterCanceled(context);\n        }\n        this._preparePendingTasks(context);\n        context._addPendingBlock(this);\n        this.out._activateSignal(context);\n        context._setExecutionVariable(this, \"_initialized\", true);\n    }\n    _resetAfterCanceled(context) {\n        context._deleteExecutionVariable(this, \"_initialized\");\n        context._removePendingBlock(this);\n    }\n}\n//# sourceMappingURL=flowGraphAsyncExecutionBlock.js.map","import { FlowGraphAsyncExecutionBlock } from \"./flowGraphAsyncExecutionBlock\";\n/**\n * A type of block that listens to an event observable and activates\n * its output signal when the event is triggered.\n */\nexport class FlowGraphEventBlock extends FlowGraphAsyncExecutionBlock {\n    constructor() {\n        super(...arguments);\n        /**\n         * the priority of initialization of this block.\n         * For example, scene start should have a negative priority because it should be initialized last.\n         */\n        this.initPriority = 0;\n        /**\n         * The type of the event\n         */\n        this.type = \"NoTrigger\" /* FlowGraphEventType.NoTrigger */;\n    }\n    /**\n     * @internal\n     */\n    _execute(context) {\n        context._notifyExecuteNode(this);\n        this.done._activateSignal(context);\n    }\n}\n//# sourceMappingURL=flowGraphEventBlock.js.map","import { blockFactory } from \"./Blocks/flowGraphBlockFactory\";\nimport { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\nimport { defaultValueParseFunction, needsPathConverter } from \"./serialization\";\nimport { getRichTypeByFlowGraphType, RichType } from \"./flowGraphRichTypes\";\n/**\n * Given a list of blocks, find an output data connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetDataOutConnectionByUniqueId(blocks, uniqueId) {\n    for (const block of blocks) {\n        for (const dataOut of block.dataOutputs) {\n            if (dataOut.uniqueId === uniqueId) {\n                return dataOut;\n            }\n        }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n}\n/**\n * Given a list of blocks, find an input signal connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetSignalInConnectionByUniqueId(blocks, uniqueId) {\n    for (const block of blocks) {\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalIn of block.signalInputs) {\n                if (signalIn.uniqueId === uniqueId) {\n                    return signalIn;\n                }\n            }\n        }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n}\n/**\n * Parses a serialized coordinator.\n * @param serializedObject the object to parse\n * @param options the options to use when parsing\n * @returns the parsed coordinator\n */\nexport async function ParseCoordinatorAsync(serializedObject, options) {\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    const coordinator = new FlowGraphCoordinator({ scene: options.scene });\n    if (serializedObject.dispatchEventsSynchronously) {\n        coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;\n    }\n    await options.scene.whenReadyAsync();\n    // if custom default values are defined, set them in the global context\n    if (serializedObject._defaultValues) {\n        for (const key in serializedObject._defaultValues) {\n            // key is the FlowGraphType, value is the default value\n            const value = serializedObject._defaultValues[key];\n            getRichTypeByFlowGraphType(key).defaultValue = value;\n        }\n    }\n    // async-parse the flow graphs. This can be done in parallel\n    await Promise.all(serializedObject._flowGraphs?.map(async (serializedGraph) => await ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter })));\n    return coordinator;\n}\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @returns the parsed graph\n */\nexport async function ParseFlowGraphAsync(serializationObject, options) {\n    // get all classes types needed for the blocks using the block factory\n    const resolvedClasses = await Promise.all(serializationObject.allBlocks.map(async (serializedBlock) => {\n        const classFactory = blockFactory(serializedBlock.className);\n        return await classFactory();\n    }));\n    // async will be used when we start using the block async factory\n    return ParseFlowGraph(serializationObject, options, resolvedClasses);\n}\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @param resolvedClasses the resolved classes for the blocks\n * @returns the parsed graph\n */\nexport function ParseFlowGraph(serializationObject, options, resolvedClasses) {\n    const graph = options.coordinator.createGraph();\n    const blocks = [];\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    // Parse all blocks\n    // for (const serializedBlock of serializationObject.allBlocks) {\n    for (let i = 0; i < serializationObject.allBlocks.length; i++) {\n        const serializedBlock = serializationObject.allBlocks[i];\n        const block = ParseFlowGraphBlockWithClassType(serializedBlock, { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction }, resolvedClasses[i]);\n        blocks.push(block);\n        if (block instanceof FlowGraphEventBlock) {\n            graph.addEventBlock(block);\n        }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n        for (const dataIn of block.dataInputs) {\n            for (const serializedConnection of dataIn.connectedPointIds) {\n                const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n                dataIn.connectTo(connection);\n            }\n        }\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalOut of block.signalOutputs) {\n                for (const serializedConnection of signalOut.connectedPointIds) {\n                    const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n                    signalOut.connectTo(connection);\n                }\n            }\n        }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n        ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);\n    }\n    return graph;\n}\n/**\n * Parses a context\n * @param serializationObject the object containing the context serialization values\n * @param options the options for parsing the context\n * @param rightHanded whether the serialized data is right handed\n * @returns\n */\nexport function ParseFlowGraphContext(serializationObject, options, rightHanded) {\n    const result = options.graph.createContext();\n    if (serializationObject.enableLogging) {\n        result.enableLogging = true;\n    }\n    result.treatDataAsRightHanded = rightHanded || false;\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    result.uniqueId = serializationObject.uniqueId;\n    const scene = result.getScene();\n    // check if assets context is available\n    if (serializationObject._assetsContext) {\n        const ac = serializationObject._assetsContext;\n        const assetsContext = {\n            meshes: ac.meshes?.map((m) => scene.getMeshById(m)),\n            lights: ac.lights?.map((l) => scene.getLightByName(l)),\n            cameras: ac.cameras?.map((c) => scene.getCameraByName(c)),\n            materials: ac.materials?.map((m) => scene.getMaterialById(m)),\n            textures: ac.textures?.map((t) => scene.getTextureByName(t)),\n            animations: ac.animations?.map((a) => scene.animations.find((anim) => anim.name === a)),\n            skeletons: ac.skeletons?.map((s) => scene.getSkeletonByName(s)),\n            particleSystems: ac.particleSystems?.map((ps) => scene.getParticleSystemById(ps)),\n            animationGroups: ac.animationGroups?.map((ag) => scene.getAnimationGroupByName(ag)),\n            transformNodes: ac.transformNodes?.map((tn) => scene.getTransformNodeById(tn)),\n            rootNodes: [],\n            multiMaterials: [],\n            morphTargetManagers: [],\n            geometries: [],\n            actionManagers: [],\n            environmentTexture: null,\n            postProcesses: [],\n            sounds: null,\n            effectLayers: [],\n            layers: [],\n            reflectionProbes: [],\n            lensFlareSystems: [],\n            proceduralTextures: [],\n            getNodes: function () {\n                throw new Error(\"Function not implemented.\");\n            },\n        };\n        result.assetsContext = assetsContext;\n    }\n    for (const key in serializationObject._userVariables) {\n        const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);\n        result.userVariables[key] = value;\n    }\n    for (const key in serializationObject._connectionValues) {\n        const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);\n        result._setConnectionValueByKey(key, value);\n    }\n    return result;\n}\n/**\n * Parses a block from a serialization object\n * This function is async due to the factory method that is used to create the block's class. If you load the class externally use ParseBlockWithClassType\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @returns the parsed block\n */\nexport async function ParseBlockAsync(serializationObject, parseOptions) {\n    const classFactory = blockFactory(serializationObject.className);\n    const classType = await classFactory();\n    return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);\n}\n/**\n * Parses a block from a serialization object\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @param classType the class type of the block. This is used when the class is not loaded asynchronously\n * @returns the parsed block\n */\nexport function ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType) {\n    const parsedConfig = {};\n    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;\n    if (serializationObject.config) {\n        for (const key in serializationObject.config) {\n            parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);\n        }\n    }\n    if (needsPathConverter(serializationObject.className)) {\n        if (!parseOptions.pathConverter) {\n            throw new Error(\"Path converter is required for this block\");\n        }\n        parsedConfig.pathConverter = parseOptions.pathConverter;\n    }\n    const obj = new classType(parsedConfig);\n    obj.uniqueId = serializationObject.uniqueId;\n    for (let i = 0; i < serializationObject.dataInputs.length; i++) {\n        const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);\n        if (dataInput) {\n            dataInput.deserialize(serializationObject.dataInputs[i]);\n        }\n        else {\n            throw new Error(\"Could not find data input with name \" + serializationObject.dataInputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {\n        const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);\n        if (dataOutput) {\n            dataOutput.deserialize(serializationObject.dataOutputs[i]);\n        }\n        else {\n            throw new Error(\"Could not find data output with name \" + serializationObject.dataOutputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    obj.metadata = serializationObject.metadata;\n    obj.deserialize && obj.deserialize(serializationObject);\n    return obj;\n}\n/**\n * Parses a connection from an object\n * @param serializationObject the object to parse from.\n * @param ownerBlock the block that owns the connection.\n * @param classType the class type of the connection.\n * @returns the parsed connection.\n */\nexport function ParseGraphConnectionWithClassType(serializationObject = {}, ownerBlock, classType) {\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n/**\n * Parses a data connection from a serialized object.\n * @param serializationObject the object to parse from\n * @param ownerBlock the block that owns the connection\n * @param classType the class type of the data connection\n * @returns the parsed connection\n */\nexport function ParseGraphDataConnection(serializationObject, ownerBlock, classType) {\n    const richType = ParseRichType(serializationObject.richType);\n    const defaultValue = serializationObject.defaultValue;\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n/**\n * Parses a rich type from a serialization object.\n * @param serializationObject a serialization object\n * @returns the parsed rich type\n */\nfunction ParseRichType(serializationObject) {\n    return new RichType(serializationObject.typeName, serializationObject.defaultValue);\n}\n//# sourceMappingURL=flowGraphParser.js.map","import { getMappingForDeclaration, getMappingForFullOperationName } from \"./declarationMapper\";\nimport { Logger } from \"core/Misc/logger\";\nimport { RandomGUID } from \"core/Misc/guid\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const gltfTypeToBabylonType = {\n    float: { length: 1, flowGraphType: \"number\" /* FlowGraphTypes.Number */, elementType: \"number\" },\n    bool: { length: 1, flowGraphType: \"boolean\" /* FlowGraphTypes.Boolean */, elementType: \"boolean\" },\n    float2: { length: 2, flowGraphType: \"Vector2\" /* FlowGraphTypes.Vector2 */, elementType: \"number\" },\n    float3: { length: 3, flowGraphType: \"Vector3\" /* FlowGraphTypes.Vector3 */, elementType: \"number\" },\n    float4: { length: 4, flowGraphType: \"Vector4\" /* FlowGraphTypes.Vector4 */, elementType: \"number\" },\n    float4x4: { length: 16, flowGraphType: \"Matrix\" /* FlowGraphTypes.Matrix */, elementType: \"number\" },\n    float2x2: { length: 4, flowGraphType: \"Matrix2D\" /* FlowGraphTypes.Matrix2D */, elementType: \"number\" },\n    float3x3: { length: 9, flowGraphType: \"Matrix3D\" /* FlowGraphTypes.Matrix3D */, elementType: \"number\" },\n    int: { length: 1, flowGraphType: \"FlowGraphInteger\" /* FlowGraphTypes.Integer */, elementType: \"number\" },\n};\nexport class InteractivityGraphToFlowGraphParser {\n    constructor(_interactivityGraph, _gltf, _animationTargetFps = 60) {\n        this._interactivityGraph = _interactivityGraph;\n        this._gltf = _gltf;\n        this._animationTargetFps = _animationTargetFps;\n        /**\n         * Note - the graph should be rejected if the same type is defined twice.\n         * We currently don't validate that.\n         */\n        this._types = [];\n        this._mappings = [];\n        this._staticVariables = [];\n        this._events = [];\n        this._internalEventsCounter = 0;\n        this._nodes = [];\n        // start with types\n        this._parseTypes();\n        // continue with declarations\n        this._parseDeclarations();\n        this._parseVariables();\n        this._parseEvents();\n        this._parseNodes();\n    }\n    get arrays() {\n        return {\n            types: this._types,\n            mappings: this._mappings,\n            staticVariables: this._staticVariables,\n            events: this._events,\n            nodes: this._nodes,\n        };\n    }\n    _parseTypes() {\n        if (!this._interactivityGraph.types) {\n            return;\n        }\n        for (const type of this._interactivityGraph.types) {\n            this._types.push(gltfTypeToBabylonType[type.signature]);\n        }\n    }\n    _parseDeclarations() {\n        if (!this._interactivityGraph.declarations) {\n            return;\n        }\n        for (const declaration of this._interactivityGraph.declarations) {\n            // make sure we have the mapping for this operation\n            const mapping = getMappingForDeclaration(declaration);\n            // mapping is defined, because we generate an empty mapping if it's not found\n            if (!mapping) {\n                Logger.Error([\"No mapping found for declaration\", declaration]);\n                throw new Error(\"Error parsing declarations\");\n            }\n            this._mappings.push({\n                flowGraphMapping: mapping,\n                fullOperationName: declaration.extension ? declaration.op + \":\" + declaration.extension : declaration.op,\n            });\n        }\n    }\n    _parseVariables() {\n        if (!this._interactivityGraph.variables) {\n            return;\n        }\n        for (const variable of this._interactivityGraph.variables) {\n            const parsed = this._parseVariable(variable);\n            // set the default values here\n            this._staticVariables.push(parsed);\n        }\n    }\n    _parseVariable(variable, dataTransform) {\n        const type = this._types[variable.type];\n        if (!type) {\n            Logger.Error([\"No type found for variable\", variable]);\n            throw new Error(\"Error parsing variables\");\n        }\n        if (variable.value) {\n            if (variable.value.length !== type.length) {\n                Logger.Error([\"Invalid value length for variable\", variable, type]);\n                throw new Error(\"Error parsing variables\");\n            }\n        }\n        const value = variable.value || [];\n        if (!value.length) {\n            switch (type.flowGraphType) {\n                case \"boolean\" /* FlowGraphTypes.Boolean */:\n                    value.push(false);\n                    break;\n                case \"FlowGraphInteger\" /* FlowGraphTypes.Integer */:\n                    value.push(0);\n                    break;\n                case \"number\" /* FlowGraphTypes.Number */:\n                    value.push(NaN);\n                    break;\n                case \"Vector2\" /* FlowGraphTypes.Vector2 */:\n                    value.push(NaN, NaN);\n                    break;\n                case \"Vector3\" /* FlowGraphTypes.Vector3 */:\n                    value.push(NaN, NaN, NaN);\n                    break;\n                case \"Vector4\" /* FlowGraphTypes.Vector4 */:\n                case \"Matrix2D\" /* FlowGraphTypes.Matrix2D */:\n                case \"Quaternion\" /* FlowGraphTypes.Quaternion */:\n                    value.fill(NaN, 0, 4);\n                    break;\n                case \"Matrix\" /* FlowGraphTypes.Matrix */:\n                    value.fill(NaN, 0, 16);\n                    break;\n                case \"Matrix3D\" /* FlowGraphTypes.Matrix3D */:\n                    value.fill(NaN, 0, 9);\n                    break;\n                default:\n                    break;\n            }\n        }\n        // in case of NaN, Infinity, we need to parse the string to the object itself\n        if (type.elementType === \"number\" && typeof value[0] === \"string\") {\n            value[0] = parseFloat(value[0]);\n        }\n        return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };\n    }\n    _parseEvents() {\n        if (!this._interactivityGraph.events) {\n            return;\n        }\n        for (const event of this._interactivityGraph.events) {\n            const converted = {\n                eventId: event.id || \"internalEvent_\" + this._internalEventsCounter++,\n            };\n            if (event.values) {\n                converted.eventData = Object.keys(event.values).map((key) => {\n                    const eventValue = event.values?.[key];\n                    if (!eventValue) {\n                        Logger.Error([\"No value found for event key\", key]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const type = this._types[eventValue.type];\n                    if (!type) {\n                        Logger.Error([\"No type found for event value\", eventValue]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const value = typeof eventValue.value !== \"undefined\" ? this._parseVariable(eventValue) : undefined;\n                    return {\n                        id: key,\n                        type: type.flowGraphType,\n                        eventData: true,\n                        value,\n                    };\n                });\n            }\n            this._events.push(converted);\n        }\n    }\n    _parseNodes() {\n        if (!this._interactivityGraph.nodes) {\n            return;\n        }\n        for (const node of this._interactivityGraph.nodes) {\n            // some validation\n            if (typeof node.declaration !== \"number\") {\n                Logger.Error([\"No declaration found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            const mapping = this._mappings[node.declaration];\n            if (!mapping) {\n                Logger.Error([\"No mapping found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            if (mapping.flowGraphMapping.validation) {\n                const validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);\n                if (!validationResult.valid) {\n                    throw new Error(`Error validating interactivity node ${this._interactivityGraph.declarations?.[node.declaration].op} - ${validationResult.error}`);\n                }\n            }\n            const blocks = [];\n            // create block(s) for this node using the mapping\n            for (const blockType of mapping.flowGraphMapping.blocks) {\n                const block = this._getEmptyBlock(blockType, mapping.fullOperationName);\n                this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);\n                blocks.push(block);\n            }\n            this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });\n        }\n    }\n    _getEmptyBlock(className, type) {\n        const uniqueId = RandomGUID();\n        const dataInputs = [];\n        const dataOutputs = [];\n        const signalInputs = [];\n        const signalOutputs = [];\n        const config = {};\n        const metadata = {};\n        return {\n            uniqueId,\n            className,\n            dataInputs,\n            dataOutputs,\n            signalInputs,\n            signalOutputs,\n            config,\n            type,\n            metadata,\n        };\n    }\n    _parseNodeConfiguration(node, block, nodeMapping, blockType) {\n        const configuration = block.config;\n        if (node.configuration) {\n            const keys = Object.keys(node.configuration);\n            for (const key of keys) {\n                const value = node.configuration?.[key];\n                // value is always an array, never a number or string\n                if (!value) {\n                    Logger.Error([\"No value found for node configuration\", key]);\n                    throw new Error(\"Error parsing node configuration\");\n                }\n                const configMapping = nodeMapping.configuration?.[key];\n                const belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;\n                if (belongsToBlock) {\n                    // get the right name for the configuration key\n                    const configKey = configMapping?.name || key;\n                    if ((!value || typeof value.value === \"undefined\") && typeof configMapping?.defaultValue !== \"undefined\") {\n                        configuration[configKey] = {\n                            value: configMapping.defaultValue,\n                        };\n                    }\n                    else if (value.value.length >= 0) {\n                        // supporting int[] and int/boolean/string\n                        configuration[configKey] = {\n                            value: value.value.length === 1 ? value.value[0] : value.value,\n                        };\n                    }\n                    else {\n                        Logger.Warn([\"Invalid value for node configuration\", value]);\n                    }\n                    // make sure we transform the data if needed\n                    if (configMapping && configMapping.dataTransformer) {\n                        configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];\n                    }\n                }\n            }\n        }\n    }\n    _parseNodeConnections(context) {\n        for (let i = 0; i < this._nodes.length; i++) {\n            // get the corresponding gltf node\n            const gltfNode = this._interactivityGraph.nodes?.[i];\n            if (!gltfNode) {\n                // should never happen but let's still check\n                Logger.Error([\"No node found for interactivity node\", this._nodes[i]]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowGraphBlocks = this._nodes[i];\n            const outputMapper = this._mappings[gltfNode.declaration];\n            // validate\n            if (!outputMapper) {\n                Logger.Error([\"No mapping found for node\", gltfNode]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowsFromGLTF = gltfNode.flows || {};\n            const flowsKeys = Object.keys(flowsFromGLTF).sort(); // sorting as some operations require sorted keys\n            // connect the flows\n            for (const flowKey of flowsKeys) {\n                const flow = flowsFromGLTF[flowKey];\n                const flowMapping = outputMapper.flowGraphMapping.outputs?.flows?.[flowKey];\n                const socketOutName = flowMapping?.name || flowKey;\n                // create a serialized socket\n                const socketOut = this._createNewSocketConnection(socketOutName, true);\n                const block = (flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.signalOutputs.push(socketOut);\n                // get the input node of this block\n                const inputNodeId = flow.node;\n                const nodeIn = this._nodes[inputNodeId];\n                if (!nodeIn) {\n                    Logger.Error([\"No node found for input node id\", inputNodeId]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                // get the mapper for the input node - in case it mapped to multiple blocks\n                const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);\n                if (!inputMapper) {\n                    Logger.Error([\"No mapping found for input node\", nodeIn]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                let flowInMapping = inputMapper.inputs?.flows?.[flow.socket || \"in\"];\n                let arrayMapping = false;\n                if (!flowInMapping) {\n                    for (const key in inputMapper.inputs?.flows) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            flowInMapping = inputMapper.inputs?.flows?.[key];\n                        }\n                    }\n                }\n                const nodeInSocketName = flowInMapping ? (arrayMapping ? flowInMapping.name.replace(\"$1\", flow.socket || \"\") : flowInMapping.name) : flow.socket || \"in\";\n                const inputBlock = (flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock)) || nodeIn.blocks[0];\n                // in all of the flow graph input connections, find the one with the same name as the socket\n                let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);\n                // if the socket doesn't exist, create the input socket for the connection\n                if (!socketIn) {\n                    socketIn = this._createNewSocketConnection(nodeInSocketName);\n                    inputBlock.signalInputs.push(socketIn);\n                }\n                // connect the sockets\n                socketIn.connectedPointIds.push(socketOut.uniqueId);\n                socketOut.connectedPointIds.push(socketIn.uniqueId);\n            }\n            // connect the values\n            const valuesFromGLTF = gltfNode.values || {};\n            const valuesKeys = Object.keys(valuesFromGLTF);\n            for (const valueKey of valuesKeys) {\n                const value = valuesFromGLTF[valueKey];\n                let valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[valueKey];\n                let arrayMapping = false;\n                if (!valueMapping) {\n                    for (const key in outputMapper.flowGraphMapping.inputs?.values) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[key];\n                        }\n                    }\n                }\n                const socketInName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", valueKey) : valueMapping.name) : valueKey;\n                // create a serialized socket\n                const socketIn = this._createNewSocketConnection(socketInName);\n                const block = (valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.dataInputs.push(socketIn);\n                if (value.value !== undefined) {\n                    const convertedValue = this._parseVariable(value, valueMapping && valueMapping.dataTransformer);\n                    context._connectionValues[socketIn.uniqueId] = convertedValue;\n                }\n                else if (typeof value.node !== \"undefined\") {\n                    const nodeOutId = value.node;\n                    const nodeOutSocketName = value.socket || \"value\";\n                    const nodeOut = this._nodes[nodeOutId];\n                    if (!nodeOut) {\n                        Logger.Error([\"No node found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    const outputMapper = getMappingForFullOperationName(nodeOut.fullOperationName);\n                    if (!outputMapper) {\n                        Logger.Error([\"No mapping found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    let valueMapping = outputMapper.outputs?.values?.[nodeOutSocketName];\n                    let arrayMapping = false;\n                    // check if there is an array mapping defined\n                    if (!valueMapping) {\n                        // search for a value mapping that has an array mapping\n                        for (const key in outputMapper.outputs?.values) {\n                            if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                                arrayMapping = true;\n                                valueMapping = outputMapper.outputs?.values?.[key];\n                            }\n                        }\n                    }\n                    const socketOutName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", nodeOutSocketName) : valueMapping?.name) : nodeOutSocketName;\n                    const outBlock = (valueMapping && valueMapping.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping.toBlock)) || nodeOut.blocks[0];\n                    let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);\n                    // if the socket doesn't exist, create it\n                    if (!socketOut) {\n                        socketOut = this._createNewSocketConnection(socketOutName, true);\n                        outBlock.dataOutputs.push(socketOut);\n                    }\n                    // connect the sockets\n                    socketIn.connectedPointIds.push(socketOut.uniqueId);\n                    socketOut.connectedPointIds.push(socketIn.uniqueId);\n                }\n                else {\n                    Logger.Error([\"Invalid value for value connection\", value]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n            }\n            // inter block connections\n            if (outputMapper.flowGraphMapping.interBlockConnectors) {\n                for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {\n                    const input = connector.input;\n                    const output = connector.output;\n                    const isVariable = connector.isVariable;\n                    this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);\n                }\n            }\n            if (outputMapper.flowGraphMapping.extraProcessor) {\n                const declaration = this._interactivityGraph.declarations?.[gltfNode.declaration];\n                if (!declaration) {\n                    Logger.Error([\"No declaration found for extra processor\", gltfNode]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(gltfNode, declaration, outputMapper.flowGraphMapping, this, flowGraphBlocks.blocks, context, this._gltf);\n            }\n        }\n    }\n    _createNewSocketConnection(name, isOutput) {\n        return {\n            uniqueId: RandomGUID(),\n            name,\n            _connectionType: isOutput ? 1 /* FlowGraphConnectionType.Output */ : 0 /* FlowGraphConnectionType.Input */,\n            connectedPointIds: [],\n        };\n    }\n    _connectFlowGraphNodes(input, output, serializedInput, serializedOutput, isVariable) {\n        const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;\n        const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;\n        const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);\n        const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);\n        // of not found add it to the array\n        if (!inputArray.find((s) => s.name === input)) {\n            inputArray.push(inputConnection);\n        }\n        if (!outputArray.find((s) => s.name === output)) {\n            outputArray.push(outputConnection);\n        }\n        // connect the sockets\n        inputConnection.connectedPointIds.push(outputConnection.uniqueId);\n        outputConnection.connectedPointIds.push(inputConnection.uniqueId);\n    }\n    getVariableName(index) {\n        return \"staticVariable_\" + index;\n    }\n    serializeToFlowGraph() {\n        const context = {\n            uniqueId: RandomGUID(),\n            _userVariables: {},\n            _connectionValues: {},\n        };\n        this._parseNodeConnections(context);\n        for (let i = 0; i < this._staticVariables.length; i++) {\n            const variable = this._staticVariables[i];\n            context._userVariables[this.getVariableName(i)] = variable;\n        }\n        const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), []);\n        return {\n            rightHanded: true,\n            allBlocks,\n            executionContexts: [context],\n        };\n    }\n}\n//# sourceMappingURL=interactivityGraphParser.js.map","import { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\nimport { ParseFlowGraphAsync } from \"core/FlowGraph/flowGraphParser\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport { AddObjectAccessorToKey, GetPathToObjectConverter } from \"./objectModelMapping\";\nimport { InteractivityGraphToFlowGraphParser } from \"./KHR_interactivity/interactivityGraphParser\";\nimport { addToBlockFactory } from \"core/FlowGraph/Blocks/flowGraphBlockFactory\";\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\nconst NAME = \"KHR_interactivity\";\n/**\n * Loader extension for KHR_interactivity\n */\nexport class KHR_interactivity {\n    /**\n     * @internal\n     * @param _loader\n     */\n    constructor(_loader) {\n        this._loader = _loader;\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n        this._pathConverter = GetPathToObjectConverter(this._loader.gltf);\n        // avoid starting animations automatically.\n        _loader._skipStartAnimationStep = true;\n        // Update object model with new pointers\n        const scene = _loader.babylonScene;\n        if (scene) {\n            _AddInteractivityObjectModel(scene);\n        }\n    }\n    dispose() {\n        this._loader = null;\n        delete this._pathConverter;\n    }\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises\n    async onReady() {\n        if (!this._loader.babylonScene || !this._pathConverter) {\n            return;\n        }\n        const scene = this._loader.babylonScene;\n        const interactivityDefinition = this._loader.gltf.extensions?.KHR_interactivity;\n        if (!interactivityDefinition) {\n            // This can technically throw, but it's not a critical error\n            return;\n        }\n        const coordinator = new FlowGraphCoordinator({ scene });\n        coordinator.dispatchEventsSynchronously = false; // glTF interactivity dispatches events asynchronously\n        const graphs = interactivityDefinition.graphs.map((graph) => {\n            const parser = new InteractivityGraphToFlowGraphParser(graph, this._loader.gltf, this._loader.parent.targetFps);\n            return parser.serializeToFlowGraph();\n        });\n        // parse each graph async\n        await Promise.all(graphs.map(async (graph) => await ParseFlowGraphAsync(graph, { coordinator, pathConverter: this._pathConverter })));\n        coordinator.start();\n    }\n}\n/**\n * @internal\n * populates the object model with the interactivity extension\n */\nexport function _AddInteractivityObjectModel(scene) {\n    // Note - all of those are read-only, as per the specs!\n    // active camera rotation\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/rotation\", {\n        get: () => {\n            if (!scene.activeCamera) {\n                return new Quaternion(NaN, NaN, NaN, NaN);\n            }\n            const quat = Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();\n            if (!scene.useRightHandedSystem) {\n                quat.w *= -1; // glTF uses right-handed system, while babylon uses left-handed\n                quat.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\n            }\n            return quat;\n        },\n        type: \"Quaternion\",\n        getTarget: () => scene.activeCamera,\n    });\n    // activeCamera position\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/position\", {\n        get: () => {\n            if (!scene.activeCamera) {\n                return new Vector3(NaN, NaN, NaN);\n            }\n            const pos = scene.activeCamera.getWorldMatrix().getTranslation(); // not global position\n            if (!scene.useRightHandedSystem) {\n                pos.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\n            }\n            return pos;\n        },\n        type: \"Vector3\",\n        getTarget: () => scene.activeCamera,\n    });\n    // /animations/{} pointers:\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/isPlaying\", {\n        get: (animation) => {\n            return animation._babylonAnimationGroup?.isPlaying ?? false;\n        },\n        type: \"boolean\",\n        getTarget: (animation) => {\n            return animation._babylonAnimationGroup;\n        },\n    });\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/minTime\", {\n        get: (animation) => {\n            return (animation._babylonAnimationGroup?.from ?? 0) / 60; // fixed factor for duration-to-frames conversion\n        },\n        type: \"number\",\n        getTarget: (animation) => {\n            return animation._babylonAnimationGroup;\n        },\n    });\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/maxTime\", {\n        get: (animation) => {\n            return (animation._babylonAnimationGroup?.to ?? 0) / 60; // fixed factor for duration-to-frames conversion\n        },\n        type: \"number\",\n        getTarget: (animation) => {\n            return animation._babylonAnimationGroup;\n        },\n    });\n    // playhead\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/playhead\", {\n        get: (animation) => {\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\n        },\n        type: \"number\",\n        getTarget: (animation) => {\n            return animation._babylonAnimationGroup;\n        },\n    });\n    //virtualPlayhead - TODO, do we support this property in our animations? getCurrentFrame  is the only method we have for this.\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/virtualPlayhead\", {\n        get: (animation) => {\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\n        },\n        type: \"number\",\n        getTarget: (animation) => {\n            return animation._babylonAnimationGroup;\n        },\n    });\n}\n// Register flow graph blocks. Do it here so they are available when the extension is enabled.\naddToBlockFactory(NAME, \"FlowGraphGLTFDataProvider\", async () => {\n    return (await import(\"./KHR_interactivity/flowGraphGLTFDataProvider\")).FlowGraphGLTFDataProvider;\n});\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_interactivity(loader));\n//# sourceMappingURL=KHR_interactivity.js.map"],"names":["IsVectorClassName","className","defaultValueSerializationFunction","key","value","serializationObject","getClassName","IsMatrixClassName","asArray","id","name","Error","defaultValueParseFunction","assetsContainer","scene","intermediateValue","finalValue","type","IsMeshClassName","nodes","meshes","filter","m","length","transformNodes","uniqueId","find","flipHandedness","Vector2","FromArray","Vector3","Vector4","Quaternion","Color3","Color4","ParseVector","IsAnimationGroupClassName","ags","animationGroups","ag","Matrix","FlowGraphMatrix2D","FlowGraphMatrix3D","FlowGraphInteger","FromValue","undefined","Array","isArray","reduce","acc","val","eventData","getRichTypeByFlowGraphType","FlowGraphAssetType","FlowGraphAction","FlowGraphConnectionType","FlowGraphState","GetFlowGraphAssetWithType","assetsContext","index","useIndexAsUniqueId","animations","a","materials","cameras","lights","FlowGraphLogger","constructor","this","logToConsole","log","addLogItem","item","time","Date","now","push","payload","Logger","Log","split","action","JSON","stringify","toString","getItemsOfType","i","FlowGraphContext","enableLogging","_enableLogging","logger","params","RandomGUID","_userVariables","_executionVariables","_globalContextVariables","_connectionValues","_pendingBlocks","_executionId","onNodeExecutedObservable","Observable","treatDataAsRightHanded","_configuration","hasVariable","setVariable","getAsset","getVariable","userVariables","getScene","_getUniqueIdPrefixedName","obj","_getGlobalContextVariable","defaultValue","possibleValue","_hasGlobalContextVariable","_setGlobalContextVariable","_deleteGlobalContextVariable","_setExecutionVariable","block","_getExecutionVariable","_hasExecutionVariable","_deleteExecutionVariable","_hasConnectionValue","connectionPoint","_setConnectionValue","connectionPointId","_setConnectionValueByKey","_getConnectionValue","configuration","hasPendingBlocks","_addPendingBlock","includes","sort","b","priority","_removePendingBlock","indexOf","splice","_clearPendingBlocks","_cancelPendingTasks","_notifyExecuteNode","node","notifyObservers","_notifyOnTick","framePayload","timeSinceStart","deltaTime","_executeOnTick","_increaseExecutionId","executionId","serialize","valueSerializationFunction","_assetsContext","map","textures","sounds","skeletons","particleSystems","geometries","multiMaterials","__decorate","prototype","FlowGraphConnection","_connectionType","_ownerBlock","_connectedPoint","connectedPointIds","connectionType","_isSingularConnection","isConnected","connectTo","point","disconnectFrom","removeFromLocal","indexLocal","indexConnected","disconnectFromAll","dispose","deserialize","FlowGraphDataConnection","ownerBlock","richType","_defaultValue","_optional","super","_isDisabled","_lastValue","dataTransformer","onValueChangedObservable","optional","isDisabled","setValue","context","resetToDefaultValue","_getValueOrDefault","getValue","_updateOutputs","typeTransformer","_getLastValue","RegisterClass","FlowGraphBlock","config","dataInputs","dataOutputs","_context","registerDataInput","input","registerDataOutput","output","getDataInput","getDataOutput","_valueSerializeFunction","keys","Object","serializedInput","serializedOutput","_serializationObject","_log","FlowGraphSignalConnection","arguments","_activateSignal","_execute","connectedPoint","FlowGraphExecutionBlock","signalInputs","signalOutputs","in","_registerSignalInput","error","_registerSignalOutput","_unregisterSignalInput","findIndex","_unregisterSignalOutput","_reportError","getSignalInput","getSignalOutput","signalInput","signalOutput","FlowGraphSceneEventCoordinator","onEventTriggeredObservable","sceneReadyTriggered","_pointerUnderMeshState","_startingTime","_scene","_initialize","_sceneReadyObserver","onReadyObservable","add","_sceneDisposeObserver","onDisposeObservable","_sceneOnBeforeRenderObserver","onBeforeRenderObservable","getEngine","getDeltaTime","_meshPickedObserver","onPointerObservable","pointerInfo","PointerEventTypes","POINTERPICK","_meshUnderPointerObserver","onMeshUnderPointerUpdatedObservable","data","pointerId","mesh","previousState","over","out","POINTERMOVE","remove","clear","_IsDescendantOf","mesh1","mesh2","parent","_GetClassNameOf","v","_AreSameVectorOrQuaternionClass","className2","_AreSameMatrixClass","_AreSameIntegerClass","isNumeric","validIfNaN","isNaN","getNumericValue","FlowGraph","state","_state","onStateChangedObservable","_eventBlocks","SceneReady","SceneDispose","SceneBeforeRender","MeshPick","PointerDown","PointerUp","PointerMove","PointerOver","PointerOut","SceneAfterRender","NoTrigger","_executionContexts","_sceneEventCoordinator","_coordinator","coordinator","_eventObserver","event","order","_getContextualOrder","_executeEvent","createContext","getContext","addEventBlock","constantlyUpdateMeshUnderPointer","_startPendingTasks","addOnce","start","_startPendingEvents","isReady","initPriority","meshPickOrder","block1","asset","visitAllBlocks","visitor","visitList","idsAddedToVisitList","Set","pop","dataIn","connection","has","signalOut","valueSerializeFunction","allBlocks","serializedBlock","executionContexts","serializedContext","FlowGraphCoordinator","dispatchEventsSynchronously","_flowGraphs","_customEventsMap","Map","_eventExecutionCounter","_executeOnNextFrame","_eventUniqueId","_disposeObserver","_onBeforeRenderObserver","executeOnNextFrame","slice","notifyCustomEvent","e","SceneCoordinators","get","createGraph","graph","removeGraph","coordinators","serializedGraph","flowGraphs","getCustomEventObservable","observable","set","async","count","MaxEventTypeExecutionPerFrame","Warn","MaxEventsPerType","CustomBlocks","FlowGraphExecutionBlockWithOutSignal","FlowGraphAsyncExecutionBlock","events","_eventsSignalOutputs","done","eventName","_resetAfterCanceled","_preparePendingTasks","FlowGraphEventBlock","GetDataOutConnectionByUniqueId","blocks","dataOut","GetSignalInConnectionByUniqueId","signalIn","ParseFlowGraphAsync","options","resolvedClasses","Promise","all","classFactory","blockName","import","FlowGraphPlayAnimationBlock","FlowGraphStopAnimationBlock","FlowGraphPauseAnimationBlock","FlowGraphInterpolationBlock","FlowGraphSceneReadyEventBlock","FlowGraphSceneTickEventBlock","FlowGraphSendCustomEventBlock","FlowGraphReceiveCustomEventBlock","FlowGraphMeshPickEventBlock","FlowGraphEBlock","FlowGraphPiBlock","FlowGraphInfBlock","FlowGraphNaNBlock","FlowGraphRandomBlock","FlowGraphAddBlock","FlowGraphSubtractBlock","FlowGraphMultiplyBlock","FlowGraphDivideBlock","FlowGraphAbsBlock","FlowGraphSignBlock","FlowGraphTruncBlock","FlowGraphFloorBlock","FlowGraphCeilBlock","FlowGraphRoundBlock","FlowGraphFractionBlock","FlowGraphNegationBlock","FlowGraphModuloBlock","FlowGraphMinBlock","FlowGraphMaxBlock","FlowGraphClampBlock","FlowGraphSaturateBlock","FlowGraphMathInterpolationBlock","FlowGraphEqualityBlock","FlowGraphLessThanBlock","FlowGraphLessThanOrEqualBlock","FlowGraphGreaterThanBlock","FlowGraphGreaterThanOrEqualBlock","FlowGraphIsNanBlock","FlowGraphIsInfinityBlock","FlowGraphDegToRadBlock","FlowGraphRadToDegBlock","FlowGraphSinBlock","FlowGraphCosBlock","FlowGraphTanBlock","FlowGraphAsinBlock","FlowGraphAcosBlock","FlowGraphAtanBlock","FlowGraphAtan2Block","FlowGraphSinhBlock","FlowGraphCoshBlock","FlowGraphTanhBlock","FlowGraphAsinhBlock","FlowGraphAcoshBlock","FlowGraphAtanhBlock","FlowGraphExpBlock","FlowGraphLogBlock","FlowGraphLog2Block","FlowGraphLog10Block","FlowGraphSquareRootBlock","FlowGraphPowerBlock","FlowGraphCubeRootBlock","FlowGraphBitwiseAndBlock","FlowGraphBitwiseOrBlock","FlowGraphBitwiseNotBlock","FlowGraphBitwiseXorBlock","FlowGraphBitwiseLeftShiftBlock","FlowGraphBitwiseRightShiftBlock","FlowGraphLengthBlock","FlowGraphNormalizeBlock","FlowGraphDotBlock","FlowGraphCrossBlock","FlowGraphRotate2DBlock","FlowGraphRotate3DBlock","FlowGraphTransposeBlock","FlowGraphDeterminantBlock","FlowGraphInvertMatrixBlock","FlowGraphMatrixMultiplicationBlock","FlowGraphBranchBlock","FlowGraphSetDelayBlock","FlowGraphCancelDelayBlock","FlowGraphCallCounterBlock","FlowGraphDebounceBlock","FlowGraphThrottleBlock","FlowGraphDoNBlock","FlowGraphFlipFlopBlock","FlowGraphForLoopBlock","FlowGraphMultiGateBlock","FlowGraphSequenceBlock","FlowGraphSwitchBlock","FlowGraphWaitAllBlock","FlowGraphWhileLoopBlock","FlowGraphConsoleLogBlock","FlowGraphConditionalDataBlock","FlowGraphConstantBlock","FlowGraphTransformCoordinatesSystemBlock","FlowGraphGetAssetBlock","FlowGraphGetPropertyBlock","FlowGraphSetPropertyBlock","FlowGraphGetVariableBlock","FlowGraphSetVariableBlock","FlowGraphJsonPointerParserBlock","FlowGraphLeadingZerosBlock","FlowGraphTrailingZerosBlock","FlowGraphOneBitsCounterBlock","FlowGraphCombineVector2Block","FlowGraphCombineVector3Block","FlowGraphCombineVector4Block","FlowGraphCombineMatrixBlock","FlowGraphExtractVector2Block","FlowGraphExtractVector3Block","FlowGraphExtractVector4Block","FlowGraphExtractMatrixBlock","FlowGraphTransformBlock","FlowGraphTransformCoordinatesBlock","FlowGraphConjugateBlock","FlowGraphAngleBetweenBlock","FlowGraphQuaternionFromAxisAngleBlock","FlowGraphAxisAngleFromQuaternionBlock","FlowGraphQuaternionFromDirectionsBlock","FlowGraphMatrixDecomposeBlock","FlowGraphMatrixComposeBlock","FlowGraphBooleanToFloat","FlowGraphBooleanToInt","FlowGraphFloatToBoolean","FlowGraphIntToBoolean","FlowGraphIntToFloat","FlowGraphFloatToInt","FlowGraphEasingBlock","FlowGraphBezierCurveEasingBlock","FlowGraphPointerOverEventBlock","FlowGraphPointerOutEventBlock","FlowGraphContextBlock","FlowGraphArrayIndexBlock","FlowGraphCodeExecutionBlock","FlowGraphIndexOfBlock","FlowGraphFunctionReferenceBlock","FlowGraphDataSwitchBlock","blockFactory","valueParseFunction","ParseFlowGraphBlockWithClassType","pathConverter","serializedConnection","ParseFlowGraphContext","rightHanded","ParseFlowGraph","result","ac","getMeshById","l","getLightByName","c","getCameraByName","getMaterialById","t","getTextureByName","anim","s","getSkeletonByName","ps","getParticleSystemById","getAnimationGroupByName","tn","getTransformNodeById","rootNodes","morphTargetManagers","actionManagers","environmentTexture","postProcesses","effectLayers","layers","reflectionProbes","lensFlareSystems","proceduralTextures","getNodes","parseOptions","classType","parsedConfig","dataInput","dataOutput","metadata","gltfTypeToBabylonType","float","flowGraphType","elementType","bool","float2","float3","float4","float4x4","float2x2","float3x3","int","InteractivityGraphToFlowGraphParser","_interactivityGraph","_gltf","_animationTargetFps","_types","_mappings","_staticVariables","_events","_internalEventsCounter","_nodes","_parseTypes","_parseDeclarations","_parseVariables","_parseEvents","_parseNodes","arrays","types","mappings","staticVariables","signature","declarations","declaration","mapping","getMappingForDeclaration","flowGraphMapping","fullOperationName","extension","op","variables","variable","parsed","_parseVariable","dataTransform","NaN","fill","parseFloat","converted","eventId","values","eventValue","validation","validationResult","valid","blockType","_getEmptyBlock","_parseNodeConfiguration","nodeMapping","configMapping","toBlock","configKey","_parseNodeConnections","gltfNode","flowGraphBlocks","outputMapper","flowsFromGLTF","flows","flowsKeys","flowKey","flow","flowMapping","outputs","socketOutName","socketOut","_createNewSocketConnection","inputNodeId","nodeIn","inputMapper","getMappingForFullOperationName","flowInMapping","inputs","socket","arrayMapping","startsWith","endsWith","nodeInSocketName","replace","inputBlock","socketIn","valuesFromGLTF","valuesKeys","valueKey","valueMapping","socketInName","convertedValue","nodeOutId","nodeOutSocketName","nodeOut","outBlock","interBlockConnectors","connector","isVariable","_connectFlowGraphNodes","inputBlockIndex","outputBlockIndex","extraProcessor","isOutput","inputArray","outputArray","inputConnection","outputConnection","getVariableName","serializeToFlowGraph","concat","NAME","KHR_interactivity","_loader","enabled","isExtensionUsed","_pathConverter","GetPathToObjectConverter","gltf","_skipStartAnimationStep","babylonScene","_AddInteractivityObjectModel","onReady","interactivityDefinition","extensions","graphs","targetFps","AddObjectAccessorToKey","activeCamera","quat","FromRotationMatrix","getWorldMatrix","normalize","useRightHandedSystem","w","x","getTarget","pos","getTranslation","animation","_babylonAnimationGroup","isPlaying","from","to","getCurrentFrame","factory","FlowGraphGLTFDataProvider","unregisterGLTFExtension","registerGLTFExtension","loader"],"mappings":"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"}