{"version":3,"file":"flowGraphWaitAllBlock-BSSFuIoX.esm.min.js","sources":["../../../../../dev/core/dist/FlowGraph/Blocks/Execution/ControlFlow/flowGraphWaitAllBlock.js"],"sourcesContent":["import { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\nimport { RichTypeFlowGraphInteger } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { FlowGraphInteger } from \"core/FlowGraph/CustomTypes/flowGraphInteger\";\n/**\n * A block that waits for all input flows to be activated before activating its output flow.\n */\nexport class FlowGraphWaitAllBlock extends FlowGraphExecutionBlockWithOutSignal {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(config);\n        this.config = config;\n        /**\n         * An array of input signals\n         */\n        this.inFlows = [];\n        this._cachedActivationState = [];\n        this.reset = this._registerSignalInput(\"reset\");\n        this.completed = this._registerSignalOutput(\"completed\");\n        this.remainingInputs = this.registerDataOutput(\"remainingInputs\", RichTypeFlowGraphInteger, new FlowGraphInteger(this.config.inputSignalCount || 0));\n        // The first inFlow is the default input signal all execution blocks have\n        for (let i = 0; i < this.config.inputSignalCount; i++) {\n            this.inFlows.push(this._registerSignalInput(`in_${i}`));\n        }\n        // no need for in\n        this._unregisterSignalInput(\"in\");\n    }\n    _getCurrentActivationState(context) {\n        const activationState = this._cachedActivationState;\n        activationState.length = 0;\n        if (!context._hasExecutionVariable(this, \"activationState\")) {\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\n                activationState.push(false);\n            }\n        }\n        else {\n            const contextActivationState = context._getExecutionVariable(this, \"activationState\", []);\n            for (let i = 0; i < contextActivationState.length; i++) {\n                activationState.push(contextActivationState[i]);\n            }\n        }\n        return activationState;\n    }\n    _execute(context, callingSignal) {\n        const activationState = this._getCurrentActivationState(context);\n        if (callingSignal === this.reset) {\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\n                activationState[i] = false;\n            }\n        }\n        else {\n            const index = this.inFlows.indexOf(callingSignal);\n            if (index >= 0) {\n                activationState[index] = true;\n            }\n        }\n        this.remainingInputs.setValue(new FlowGraphInteger(activationState.filter((v) => !v).length), context);\n        context._setExecutionVariable(this, \"activationState\", activationState.slice());\n        if (!activationState.includes(false)) {\n            this.completed._activateSignal(context);\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\n                activationState[i] = false;\n            }\n        }\n        else {\n            callingSignal !== this.reset && this.out._activateSignal(context);\n        }\n    }\n    /**\n     * @returns class name of the block.\n     */\n    getClassName() {\n        return \"FlowGraphWaitAllBlock\" /* FlowGraphBlockNames.WaitAll */;\n    }\n    /**\n     * Serializes this block into a object\n     * @param serializationObject the object to serialize to\n     */\n    serialize(serializationObject) {\n        super.serialize(serializationObject);\n        serializationObject.config.inputFlows = this.config.inputSignalCount;\n    }\n}\nRegisterClass(\"FlowGraphWaitAllBlock\" /* FlowGraphBlockNames.WaitAll */, FlowGraphWaitAllBlock);\n//# sourceMappingURL=flowGraphWaitAllBlock.js.map"],"names":["FlowGraphWaitAllBlock","FlowGraphExecutionBlockWithOutSignal","constructor","config","super","this","inFlows","_cachedActivationState","reset","_registerSignalInput","completed","_registerSignalOutput","remainingInputs","registerDataOutput","RichTypeFlowGraphInteger","FlowGraphInteger","inputSignalCount","i","push","_unregisterSignalInput","_getCurrentActivationState","context","activationState","length","_hasExecutionVariable","contextActivationState","_getExecutionVariable","_execute","callingSignal","index","indexOf","setValue","filter","v","_setExecutionVariable","slice","includes","out","_activateSignal","getClassName","serialize","serializationObject","inputFlows","RegisterClass"],"mappings":"gOAOO,MAAMA,UAA8BC,EACvC,WAAAC,CAIAC,GACIC,MAAMD,GACNE,KAAKF,OAASA,EAIdE,KAAKC,QAAU,GACfD,KAAKE,uBAAyB,GAC9BF,KAAKG,MAAQH,KAAKI,qBAAqB,SACvCJ,KAAKK,UAAYL,KAAKM,sBAAsB,aAC5CN,KAAKO,gBAAkBP,KAAKQ,mBAAmB,kBAAmBC,EAA0B,IAAIC,EAAiBV,KAAKF,OAAOa,kBAAoB,IAEjJ,IAAK,IAAIC,EAAI,EAAGA,EAAIZ,KAAKF,OAAOa,iBAAkBC,IAC9CZ,KAAKC,QAAQY,KAAKb,KAAKI,qBAAqB,MAAMQ,MAGtDZ,KAAKc,uBAAuB,KACpC,CACI,0BAAAC,CAA2BC,GACvB,MAAMC,EAAkBjB,KAAKE,uBAE7B,GADAe,EAAgBC,OAAS,EACpBF,EAAQG,sBAAsBnB,KAAM,mBAKpC,CACD,MAAMoB,EAAyBJ,EAAQK,sBAAsBrB,KAAM,kBAAmB,IACtF,IAAK,IAAIY,EAAI,EAAGA,EAAIQ,EAAuBF,OAAQN,IAC/CK,EAAgBJ,KAAKO,EAAuBR,GAE5D,MATY,IAAK,IAAIA,EAAI,EAAGA,EAAIZ,KAAKF,OAAOa,iBAAkBC,IAC9CK,EAAgBJ,MAAK,GAS7B,OAAOI,CACf,CACI,QAAAK,CAASN,EAASO,GACd,MAAMN,EAAkBjB,KAAKe,2BAA2BC,GACxD,GAAIO,IAAkBvB,KAAKG,MACvB,IAAK,IAAIS,EAAI,EAAGA,EAAIZ,KAAKF,OAAOa,iBAAkBC,IAC9CK,EAAgBL,IAAK,MAGxB,CACD,MAAMY,EAAQxB,KAAKC,QAAQwB,QAAQF,GAC/BC,GAAS,IACTP,EAAgBO,IAAS,EAEzC,CAGQ,GAFAxB,KAAKO,gBAAgBmB,SAAS,IAAIhB,EAAiBO,EAAgBU,QAAQC,IAAOA,IAAGV,QAASF,GAC9FA,EAAQa,sBAAsB7B,KAAM,kBAAmBiB,EAAgBa,SAClEb,EAAgBc,UAAS,GAO1BR,IAAkBvB,KAAKG,OAASH,KAAKgC,IAAIC,gBAAgBjB,OAPvB,CAClChB,KAAKK,UAAU4B,gBAAgBjB,GAC/B,IAAK,IAAIJ,EAAI,EAAGA,EAAIZ,KAAKF,OAAOa,iBAAkBC,IAC9CK,EAAgBL,IAAK,CAErC,CAIA,CAII,YAAAsB,GACI,MAAO,uBACf,CAKI,SAAAC,CAAUC,GACNrC,MAAMoC,UAAUC,GAChBA,EAAoBtC,OAAOuC,WAAarC,KAAKF,OAAOa,gBAC5D,EAEA2B,EAAc,wBAA2D3C"}