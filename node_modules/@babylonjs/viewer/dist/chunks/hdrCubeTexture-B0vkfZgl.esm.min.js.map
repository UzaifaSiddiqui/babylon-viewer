{"version":3,"file":"hdrCubeTexture-B0vkfZgl.esm.min.js","sources":["../../../../../dev/core/dist/Materials/Textures/Filtering/hdrFiltering.js","../../../../../dev/core/dist/Materials/Textures/Filtering/hdrIrradianceFiltering.js","../../../../../dev/core/dist/Materials/Textures/hdrCubeTexture.js"],"sourcesContent":["import { Vector3 } from \"../../../Maths/math\";\nimport { ILog2 } from \"../../../Maths/math.scalar.functions\";\nimport { Constants } from \"../../../Engines/constants\";\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\n/**\n * Filters HDR maps to get correct renderings of PBR reflections\n */\nexport class HDRFiltering {\n    /**\n     * Instantiates HDR filter for reflection maps\n     *\n     * @param engine Thin engine\n     * @param options Options\n     */\n    constructor(engine, options = {}) {\n        this._lodGenerationOffset = 0;\n        this._lodGenerationScale = 0.8;\n        /**\n         * Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless\n         * you care about baking speed.\n         */\n        this.quality = Constants.TEXTURE_FILTERING_QUALITY_OFFLINE;\n        /**\n         * Scales pixel intensity for the input HDR map.\n         */\n        this.hdrScale = 1;\n        // pass\n        this._engine = engine;\n        this.hdrScale = options.hdrScale || this.hdrScale;\n        this.quality = options.quality || this.quality;\n    }\n    _createRenderTarget(size) {\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n        if (this._engine.getCaps().textureHalfFloatRender) {\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\n        }\n        else if (this._engine.getCaps().textureFloatRender) {\n            textureType = Constants.TEXTURETYPE_FLOAT;\n        }\n        const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\n            format: Constants.TEXTUREFORMAT_RGBA,\n            type: textureType,\n            createMipMaps: true,\n            generateMipMaps: false,\n            generateDepthBuffer: false,\n            generateStencilBuffer: false,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            label: \"HDR_Radiance_Filtering_Target\",\n        });\n        this._engine.updateTextureWrappingMode(rtWrapper.texture, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE);\n        this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, rtWrapper.texture, true);\n        return rtWrapper;\n    }\n    _prefilterInternal(texture) {\n        const width = texture.getSize().width;\n        const mipmapsCount = ILog2(width) + 1;\n        const effect = this._effectWrapper.effect;\n        const outputTexture = this._createRenderTarget(width);\n        this._effectRenderer.saveStates();\n        this._effectRenderer.setViewport();\n        const intTexture = texture.getInternalTexture();\n        if (intTexture) {\n            // Just in case generate fresh clean mips.\n            this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, intTexture, true);\n        }\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n        const directions = [\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], // PositiveX\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], // NegativeX\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], // PositiveY\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], // NegativeY\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], // PositiveZ\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\n        ];\n        effect.setFloat(\"hdrScale\", this.hdrScale);\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n        effect.setTexture(\"inputTexture\", texture);\n        for (let face = 0; face < 6; face++) {\n            effect.setVector3(\"up\", directions[face][0]);\n            effect.setVector3(\"right\", directions[face][1]);\n            effect.setVector3(\"front\", directions[face][2]);\n            for (let lod = 0; lod < mipmapsCount; lod++) {\n                this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\n                this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n                let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\n                if (lod === 0) {\n                    alpha = 0;\n                }\n                effect.setFloat(\"alphaG\", alpha);\n                this._effectRenderer.draw();\n            }\n        }\n        // Cleanup\n        this._effectRenderer.restoreStates();\n        this._engine.restoreDefaultFramebuffer();\n        this._engine._releaseTexture(texture._texture);\n        // Internal Swap\n        const type = outputTexture.texture.type;\n        const format = outputTexture.texture.format;\n        outputTexture._swapAndDie(texture._texture);\n        texture._texture.type = type;\n        texture._texture.format = format;\n        // New settings\n        texture.gammaSpace = false;\n        texture.lodGenerationOffset = this._lodGenerationOffset;\n        texture.lodGenerationScale = this._lodGenerationScale;\n        texture._prefiltered = true;\n        return texture;\n    }\n    _createEffect(texture, onCompiled) {\n        const defines = [];\n        if (texture.gammaSpace) {\n            defines.push(\"#define GAMMA_INPUT\");\n        }\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n        const isWebGPU = this._engine.isWebGPU;\n        const effectWrapper = new EffectWrapper({\n            engine: this._engine,\n            name: \"hdrFiltering\",\n            vertexShader: \"hdrFiltering\",\n            fragmentShader: \"hdrFiltering\",\n            samplerNames: [\"inputTexture\"],\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\n            useShaderStore: true,\n            defines,\n            onCompiled: onCompiled,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../../ShadersWGSL/hdrFiltering.vertex\"), import(\"../../../ShadersWGSL/hdrFiltering.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../../Shaders/hdrFiltering.vertex\"), import(\"../../../Shaders/hdrFiltering.fragment\")]);\n                }\n            },\n        });\n        return effectWrapper;\n    }\n    /**\n     * Get a value indicating if the filter is ready to be used\n     * @param texture Texture to filter\n     * @returns true if the filter is ready\n     */\n    isReady(texture) {\n        return texture.isReady() && this._effectWrapper.effect.isReady();\n    }\n    /**\n     * Prefilters a cube texture to have mipmap levels representing roughness values.\n     * Prefiltering will be invoked at the end of next rendering pass.\n     * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\n     * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\n     * @param texture Texture to filter\n     * @returns Promise called when prefiltering is done\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    async prefilter(texture) {\n        if (!this._engine._features.allowTexturePrefiltering) {\n            throw new Error(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n        }\n        this._effectRenderer = new EffectRenderer(this._engine);\n        this._effectWrapper = this._createEffect(texture);\n        await this._effectWrapper.effect.whenCompiledAsync();\n        this._prefilterInternal(texture);\n        this._effectRenderer.dispose();\n        this._effectWrapper.dispose();\n    }\n}\n//# sourceMappingURL=hdrFiltering.js.map","import { Vector3 } from \"../../../Maths/math\";\nimport { ILog2 } from \"../../../Maths/math.scalar.functions\";\nimport { BaseTexture } from \"../baseTexture\";\nimport { Constants } from \"../../../Engines/constants\";\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\nimport { IblCdfGenerator } from \"../../../Rendering/iblCdfGenerator\";\n/**\n * Filters HDR maps to get correct renderings of PBR reflections\n */\nexport class HDRIrradianceFiltering {\n    /**\n     * Instantiates HDR filter for irradiance map\n     *\n     * @param engine Thin engine\n     * @param options Options\n     */\n    constructor(engine, options = {}) {\n        /**\n         * Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless\n         * you care about baking speed.\n         */\n        this.quality = Constants.TEXTURE_FILTERING_QUALITY_OFFLINE;\n        /**\n         * Scales pixel intensity for the input HDR map.\n         */\n        this.hdrScale = 1;\n        /**\n         * Use the Cumulative Distribution Function (CDF) for filtering\n         */\n        this.useCdf = false;\n        // pass\n        this._engine = engine;\n        this.hdrScale = options.hdrScale || this.hdrScale;\n        this.quality = options.quality || this.quality;\n        this.useCdf = options.useCdf || this.useCdf;\n    }\n    _createRenderTarget(size) {\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n        if (this._engine.getCaps().textureHalfFloatRender) {\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\n        }\n        else if (this._engine.getCaps().textureFloatRender) {\n            textureType = Constants.TEXTURETYPE_FLOAT;\n        }\n        const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\n            format: Constants.TEXTUREFORMAT_RGBA,\n            type: textureType,\n            createMipMaps: false,\n            generateMipMaps: false,\n            generateDepthBuffer: false,\n            generateStencilBuffer: false,\n            samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\n            label: \"HDR_Irradiance_Filtering_Target\",\n        });\n        this._engine.updateTextureWrappingMode(rtWrapper.texture, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE);\n        return rtWrapper;\n    }\n    _prefilterInternal(texture) {\n        const width = texture.getSize().width;\n        const mipmapsCount = ILog2(width);\n        const effect = this._effectWrapper.effect;\n        // Choose a power of 2 size for the irradiance map.\n        // It can be much smaller than the original texture.\n        const irradianceSize = Math.max(32, 1 << ILog2(width >> 3));\n        const outputTexture = this._createRenderTarget(irradianceSize);\n        this._effectRenderer.saveStates();\n        this._effectRenderer.setViewport();\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n        const directions = [\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], // PositiveX\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], // NegativeX\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], // PositiveY\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], // NegativeY\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], // PositiveZ\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\n        ];\n        effect.setFloat(\"hdrScale\", this.hdrScale);\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n        effect.setTexture(\"inputTexture\", texture);\n        if (this._cdfGenerator) {\n            effect.setTexture(\"icdfTexture\", this._cdfGenerator.getIcdfTexture());\n        }\n        for (let face = 0; face < 6; face++) {\n            effect.setVector3(\"up\", directions[face][0]);\n            effect.setVector3(\"right\", directions[face][1]);\n            effect.setVector3(\"front\", directions[face][2]);\n            this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true);\n            this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n            this._effectRenderer.draw();\n        }\n        // Cleanup\n        this._effectRenderer.restoreStates();\n        this._engine.restoreDefaultFramebuffer();\n        effect.setTexture(\"inputTexture\", null);\n        effect.setTexture(\"icdfTexture\", null);\n        const irradianceTexture = new BaseTexture(texture.getScene(), outputTexture.texture);\n        irradianceTexture.name = texture.name + \"_irradiance\";\n        irradianceTexture.displayName = texture.name + \"_irradiance\";\n        irradianceTexture.gammaSpace = false;\n        return irradianceTexture;\n    }\n    _createEffect(texture, onCompiled) {\n        const defines = [];\n        if (texture.gammaSpace) {\n            defines.push(\"#define GAMMA_INPUT\");\n        }\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n        const isWebGPU = this._engine.isWebGPU;\n        const samplers = [\"inputTexture\"];\n        if (this._cdfGenerator) {\n            samplers.push(\"icdfTexture\");\n            defines.push(\"#define IBL_CDF_FILTERING\");\n        }\n        const effectWrapper = new EffectWrapper({\n            engine: this._engine,\n            name: \"HDRIrradianceFiltering\",\n            vertexShader: \"hdrIrradianceFiltering\",\n            fragmentShader: \"hdrIrradianceFiltering\",\n            samplerNames: samplers,\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\"],\n            useShaderStore: true,\n            defines,\n            onCompiled: onCompiled,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../../ShadersWGSL/hdrIrradianceFiltering.vertex\"), import(\"../../../ShadersWGSL/hdrIrradianceFiltering.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../../Shaders/hdrIrradianceFiltering.vertex\"), import(\"../../../Shaders/hdrIrradianceFiltering.fragment\")]);\n                }\n            },\n        });\n        return effectWrapper;\n    }\n    /**\n     * Get a value indicating if the filter is ready to be used\n     * @param texture Texture to filter\n     * @returns true if the filter is ready\n     */\n    isReady(texture) {\n        return texture.isReady() && this._effectWrapper.effect.isReady();\n    }\n    /**\n     * Prefilters a cube texture to contain IBL irradiance.\n     * Prefiltering will be invoked at the end of next rendering pass.\n     * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\n     * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\n     * @param texture Texture to filter\n     * @returns Promise called when prefiltering is done\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    async prefilter(texture) {\n        if (!this._engine._features.allowTexturePrefiltering) {\n            throw new Error(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n        }\n        if (this.useCdf) {\n            this._cdfGenerator = new IblCdfGenerator(this._engine);\n            this._cdfGenerator.iblSource = texture;\n            await this._cdfGenerator.renderWhenReady();\n        }\n        this._effectRenderer = new EffectRenderer(this._engine);\n        this._effectWrapper = this._createEffect(texture);\n        await this._effectWrapper.effect.whenCompiledAsync();\n        const irradianceTexture = this._prefilterInternal(texture);\n        if (this.useCdf) {\n            // eslint-disable-next-line github/no-then\n            await this._cdfGenerator.findDominantDirection().then((dir) => {\n                irradianceTexture._dominantDirection = dir;\n            });\n        }\n        this._effectRenderer.dispose();\n        this._effectWrapper.dispose();\n        this._cdfGenerator?.dispose();\n        return irradianceTexture;\n    }\n}\n//# sourceMappingURL=hdrIrradianceFiltering.js.map","import { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { Constants } from \"../../Engines/constants\";\nimport { GetCubeMapTextureData } from \"../../Misc/HighDynamicRange/hdr\";\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\nimport { RegisterClass } from \"../../Misc/typeStore\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Tools } from \"../../Misc/tools\";\nimport { ToGammaSpace } from \"../../Maths/math.constants\";\nimport { HDRFiltering } from \"../../Materials/Textures/Filtering/hdrFiltering\";\nimport { HDRIrradianceFiltering } from \"../../Materials/Textures/Filtering/hdrIrradianceFiltering\";\nimport { ToHalfFloat } from \"../../Misc/textureTools\";\nimport \"../../Materials/Textures/baseTexture.polynomial\";\n/**\n * This represents a texture coming from an HDR input.\n *\n * The only supported format is currently panorama picture stored in RGBE format.\n * Example of such files can be found on Poly Haven: https://polyhaven.com/hdris\n */\nexport class HDRCubeTexture extends BaseTexture {\n    /**\n     * Sets whether or not the texture is blocking during loading.\n     */\n    set isBlocking(value) {\n        this._isBlocking = value;\n    }\n    /**\n     * Gets whether or not the texture is blocking during loading.\n     */\n    get isBlocking() {\n        return this._isBlocking;\n    }\n    /**\n     * Sets texture matrix rotation angle around Y axis in radians.\n     */\n    set rotationY(value) {\n        this._rotationY = value;\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    }\n    /**\n     * Gets texture matrix rotation angle around Y axis radians.\n     */\n    get rotationY() {\n        return this._rotationY;\n    }\n    /**\n     * Gets or sets the size of the bounding box associated with the cube texture\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set boundingBoxSize(value) {\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n            return;\n        }\n        this._boundingBoxSize = value;\n        const scene = this.getScene();\n        if (scene) {\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\n        }\n    }\n    get boundingBoxSize() {\n        return this._boundingBoxSize;\n    }\n    /**\n     * Instantiates an HDRTexture from the following parameters.\n     *\n     * @param url The location of the HDR raw data (Panorama stored in RGBE format)\n     * @param sceneOrEngine The scene or engine the texture will be used in\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\n     * @param noMipmap Forces to not generate the mipmap if true\n     * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process\n     * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\n     * @param prefilterOnLoad Prefilters HDR texture to allow use of this texture as a PBR reflection texture.\n     * @param onLoad on success callback function\n     * @param onError on error callback function\n     * @param supersample Defines if texture must be supersampled (default: false)\n     * @param prefilterIrradianceOnLoad Prefilters HDR texture to allow use of this texture for irradiance lighting.\n     * @param prefilterUsingCdf Defines if the prefiltering should be done using a CDF instead of the default approach.\n     */\n    constructor(url, sceneOrEngine, size, noMipmap = false, generateHarmonics = true, gammaSpace = false, prefilterOnLoad = false, onLoad = null, onError = null, supersample = false, prefilterIrradianceOnLoad = false, prefilterUsingCdf = false) {\n        super(sceneOrEngine);\n        this._generateHarmonics = true;\n        this._onError = null;\n        this._isBlocking = true;\n        this._rotationY = 0;\n        /**\n         * Gets or sets the center of the bounding box associated with the cube texture\n         * It must define where the camera used to render the texture was set\n         */\n        this.boundingBoxPosition = Vector3.Zero();\n        /**\n         * Observable triggered once the texture has been loaded.\n         */\n        this.onLoadObservable = new Observable();\n        if (!url) {\n            return;\n        }\n        this._coordinatesMode = Texture.CUBIC_MODE;\n        this.name = url;\n        this.url = url;\n        this.hasAlpha = false;\n        this.isCube = true;\n        this._textureMatrix = Matrix.Identity();\n        this._prefilterOnLoad = prefilterOnLoad;\n        this._prefilterIrradianceOnLoad = prefilterIrradianceOnLoad;\n        this._prefilterUsingCdf = prefilterUsingCdf;\n        this._onLoad = () => {\n            this.onLoadObservable.notifyObservers(this);\n            if (onLoad) {\n                onLoad();\n            }\n        };\n        this._onError = onError;\n        this.gammaSpace = gammaSpace;\n        this._noMipmap = noMipmap;\n        this._size = size;\n        // CDF is very sensitive to lost precision due to downsampling. This can result in\n        // noticeable brightness differences with different resolutions. Enabling supersampling\n        // mitigates this.\n        this._supersample = supersample || prefilterUsingCdf;\n        this._generateHarmonics = generateHarmonics;\n        this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\n        if (!this._texture) {\n            if (!this.getScene()?.useDelayedTextureLoading) {\n                this._loadTexture();\n            }\n            else {\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\n            }\n        }\n        else {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => this._onLoad());\n            }\n            else {\n                this._texture.onLoadedObservable.add(this._onLoad);\n            }\n        }\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"HDRCubeTexture\"\n     */\n    getClassName() {\n        return \"HDRCubeTexture\";\n    }\n    /**\n     * Occurs when the file is raw .hdr file.\n     */\n    _loadTexture() {\n        const engine = this._getEngine();\n        const caps = engine.getCaps();\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n        if (caps.textureFloat && caps.textureFloatLinearFiltering) {\n            textureType = Constants.TEXTURETYPE_FLOAT;\n        }\n        else if (caps.textureHalfFloat && caps.textureHalfFloatLinearFiltering) {\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\n        }\n        const callback = (buffer) => {\n            this.lodGenerationOffset = 0.0;\n            this.lodGenerationScale = 0.8;\n            // Extract the raw linear data.\n            const data = GetCubeMapTextureData(buffer, this._size, this._supersample);\n            // Generate harmonics if needed.\n            if (this._generateHarmonics) {\n                const sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);\n                this.sphericalPolynomial = sphericalPolynomial;\n            }\n            const results = [];\n            let byteArray = null;\n            let shortArray = null;\n            // Push each faces.\n            for (let j = 0; j < 6; j++) {\n                // Create fallback array\n                if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\n                    shortArray = new Uint16Array(this._size * this._size * 3);\n                }\n                else if (textureType === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\n                    // 3 channels of 1 bytes per pixel in bytes.\n                    byteArray = new Uint8Array(this._size * this._size * 3);\n                }\n                const dataFace = data[HDRCubeTexture._FacesMapping[j]];\n                // If special cases.\n                if (this.gammaSpace || shortArray || byteArray) {\n                    for (let i = 0; i < this._size * this._size; i++) {\n                        // Put in gamma space if requested.\n                        if (this.gammaSpace) {\n                            dataFace[i * 3 + 0] = Math.pow(dataFace[i * 3 + 0], ToGammaSpace);\n                            dataFace[i * 3 + 1] = Math.pow(dataFace[i * 3 + 1], ToGammaSpace);\n                            dataFace[i * 3 + 2] = Math.pow(dataFace[i * 3 + 2], ToGammaSpace);\n                        }\n                        // Convert to half float texture for fallback.\n                        if (shortArray) {\n                            shortArray[i * 3 + 0] = ToHalfFloat(dataFace[i * 3 + 0]);\n                            shortArray[i * 3 + 1] = ToHalfFloat(dataFace[i * 3 + 1]);\n                            shortArray[i * 3 + 2] = ToHalfFloat(dataFace[i * 3 + 2]);\n                        }\n                        // Convert to int texture for fallback.\n                        if (byteArray) {\n                            let r = Math.max(dataFace[i * 3 + 0] * 255, 0);\n                            let g = Math.max(dataFace[i * 3 + 1] * 255, 0);\n                            let b = Math.max(dataFace[i * 3 + 2] * 255, 0);\n                            // May use luminance instead if the result is not accurate.\n                            const max = Math.max(Math.max(r, g), b);\n                            if (max > 255) {\n                                const scale = 255 / max;\n                                r *= scale;\n                                g *= scale;\n                                b *= scale;\n                            }\n                            byteArray[i * 3 + 0] = r;\n                            byteArray[i * 3 + 1] = g;\n                            byteArray[i * 3 + 2] = b;\n                        }\n                    }\n                }\n                if (shortArray) {\n                    results.push(shortArray);\n                }\n                else if (byteArray) {\n                    results.push(byteArray);\n                }\n                else {\n                    results.push(dataFace);\n                }\n            }\n            return results;\n        };\n        if (engine._features.allowTexturePrefiltering && (this._prefilterOnLoad || this._prefilterIrradianceOnLoad)) {\n            const previousOnLoad = this._onLoad;\n            const hdrFiltering = new HDRFiltering(engine);\n            this._onLoad = () => {\n                let irradiancePromise = Promise.resolve(null);\n                let radiancePromise = Promise.resolve();\n                if (this._prefilterIrradianceOnLoad) {\n                    const hdrIrradianceFiltering = new HDRIrradianceFiltering(engine, { useCdf: this._prefilterUsingCdf });\n                    irradiancePromise = hdrIrradianceFiltering.prefilter(this);\n                }\n                if (this._prefilterOnLoad) {\n                    radiancePromise = hdrFiltering.prefilter(this);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                Promise.all([irradiancePromise, radiancePromise]).then((results) => {\n                    const irradianceTexture = results[0];\n                    if (this._prefilterIrradianceOnLoad && irradianceTexture) {\n                        this.irradianceTexture = irradianceTexture;\n                        const scene = this.getScene();\n                        if (scene) {\n                            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\n                        }\n                    }\n                    if (previousOnLoad) {\n                        previousOnLoad();\n                    }\n                });\n            };\n        }\n        this._texture = engine.createRawCubeTextureFromUrl(this.url, this.getScene(), this._size, Constants.TEXTUREFORMAT_RGB, textureType, this._noMipmap, callback, null, this._onLoad, this._onError);\n    }\n    clone() {\n        const newTexture = new HDRCubeTexture(this.url, this.getScene() || this._getEngine(), this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);\n        // Base texture\n        newTexture.level = this.level;\n        newTexture.wrapU = this.wrapU;\n        newTexture.wrapV = this.wrapV;\n        newTexture.coordinatesIndex = this.coordinatesIndex;\n        newTexture.coordinatesMode = this.coordinatesMode;\n        return newTexture;\n    }\n    // Methods\n    delayLoad() {\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\n            return;\n        }\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\n        this._texture = this._getFromCache(this.url, this._noMipmap);\n        if (!this._texture) {\n            this._loadTexture();\n        }\n    }\n    /**\n     * Get the texture reflection matrix used to rotate/transform the reflection.\n     * @returns the reflection matrix\n     */\n    getReflectionTextureMatrix() {\n        return this._textureMatrix;\n    }\n    /**\n     * Set the texture reflection matrix used to rotate/transform the reflection.\n     * @param value Define the reflection matrix to set\n     */\n    setReflectionTextureMatrix(value) {\n        this._textureMatrix = value;\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\n            return;\n        }\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\n        }\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        this.onLoadObservable.clear();\n        super.dispose();\n    }\n    /**\n     * Parses a JSON representation of an HDR Texture in order to create the texture\n     * @param parsedTexture Define the JSON representation\n     * @param scene Define the scene the texture should be created in\n     * @param rootUrl Define the root url in case we need to load relative dependencies\n     * @returns the newly created texture after parsing\n     */\n    static Parse(parsedTexture, scene, rootUrl) {\n        let texture = null;\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n            texture = new HDRCubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.size, parsedTexture.noMipmap, parsedTexture.generateHarmonics, parsedTexture.useInGammaSpace);\n            texture.name = parsedTexture.name;\n            texture.hasAlpha = parsedTexture.hasAlpha;\n            texture.level = parsedTexture.level;\n            texture.coordinatesMode = parsedTexture.coordinatesMode;\n            texture.isBlocking = parsedTexture.isBlocking;\n        }\n        if (texture) {\n            if (parsedTexture.boundingBoxPosition) {\n                texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n            }\n            if (parsedTexture.boundingBoxSize) {\n                texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n            }\n            if (parsedTexture.rotationY) {\n                texture.rotationY = parsedTexture.rotationY;\n            }\n        }\n        return texture;\n    }\n    serialize() {\n        if (!this.name) {\n            return null;\n        }\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.hasAlpha = this.hasAlpha;\n        serializationObject.isCube = true;\n        serializationObject.level = this.level;\n        serializationObject.size = this._size;\n        serializationObject.coordinatesMode = this.coordinatesMode;\n        serializationObject.useInGammaSpace = this.gammaSpace;\n        serializationObject.generateHarmonics = this._generateHarmonics;\n        serializationObject.customType = \"BABYLON.HDRCubeTexture\";\n        serializationObject.noMipmap = this._noMipmap;\n        serializationObject.isBlocking = this._isBlocking;\n        serializationObject.rotationY = this._rotationY;\n        return serializationObject;\n    }\n}\nHDRCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\nRegisterClass(\"BABYLON.HDRCubeTexture\", HDRCubeTexture);\n//# sourceMappingURL=hdrCubeTexture.js.map"],"names":["HDRFiltering","constructor","engine","options","this","_lodGenerationOffset","_lodGenerationScale","quality","Constants","TEXTURE_FILTERING_QUALITY_OFFLINE","hdrScale","_engine","_createRenderTarget","size","textureType","TEXTURETYPE_UNSIGNED_BYTE","getCaps","textureHalfFloatRender","TEXTURETYPE_HALF_FLOAT","textureFloatRender","TEXTURETYPE_FLOAT","rtWrapper","createRenderTargetCubeTexture","format","TEXTUREFORMAT_RGBA","type","createMipMaps","generateMipMaps","generateDepthBuffer","generateStencilBuffer","samplingMode","TEXTURE_NEAREST_SAMPLINGMODE","label","updateTextureWrappingMode","texture","TEXTURE_CLAMP_ADDRESSMODE","updateTextureSamplingMode","TEXTURE_TRILINEAR_SAMPLINGMODE","_prefilterInternal","width","getSize","mipmapsCount","ILog2","effect","_effectWrapper","outputTexture","_effectRenderer","saveStates","setViewport","intTexture","getInternalTexture","applyEffectWrapper","directions","Vector3","setFloat","setFloat2","setTexture","face","setVector3","lod","bindFramebuffer","undefined","alpha","Math","pow","draw","restoreStates","restoreDefaultFramebuffer","_releaseTexture","_texture","_swapAndDie","gammaSpace","lodGenerationOffset","lodGenerationScale","_prefiltered","_createEffect","onCompiled","defines","push","isWebGPU","EffectWrapper","name","vertexShader","fragmentShader","samplerNames","uniformNames","useShaderStore","shaderLanguage","extraInitializationsAsync","async","Promise","all","import","isReady","prefilter","_features","allowTexturePrefiltering","Error","EffectRenderer","whenCompiledAsync","dispose","HDRIrradianceFiltering","useCdf","TEXTURE_BILINEAR_SAMPLINGMODE","irradianceSize","max","_cdfGenerator","getIcdfTexture","irradianceTexture","BaseTexture","getScene","displayName","samplers","IblCdfGenerator","iblSource","renderWhenReady","findDominantDirection","then","dir","_dominantDirection","HDRCubeTexture","isBlocking","value","_isBlocking","rotationY","_rotationY","setReflectionTextureMatrix","Matrix","RotationY","boundingBoxSize","_boundingBoxSize","equals","scene","markAllMaterialsAsDirty","MATERIAL_TextureDirtyFlag","url","sceneOrEngine","noMipmap","generateHarmonics","prefilterOnLoad","onLoad","onError","supersample","prefilterIrradianceOnLoad","prefilterUsingCdf","super","_generateHarmonics","_onError","boundingBoxPosition","Zero","onLoadObservable","Observable","_coordinatesMode","Texture","CUBIC_MODE","hasAlpha","isCube","_textureMatrix","Identity","_prefilterOnLoad","_prefilterIrradianceOnLoad","_prefilterUsingCdf","_onLoad","notifyObservers","_noMipmap","_size","_supersample","_getFromCache","Tools","SetImmediate","onLoadedObservable","add","useDelayedTextureLoading","delayLoadState","DELAYLOADSTATE_NOTLOADED","_loadTexture","getClassName","_getEngine","caps","textureFloat","textureFloatLinearFiltering","textureHalfFloat","textureHalfFloatLinearFiltering","previousOnLoad","hdrFiltering","irradiancePromise","resolve","radiancePromise","results","createRawCubeTextureFromUrl","TEXTUREFORMAT_RGB","buffer","data","GetCubeMapTextureData","sphericalPolynomial","CubeMapToSphericalPolynomialTools","ConvertCubeMapToSphericalPolynomial","byteArray","shortArray","j","Uint16Array","Uint8Array","dataFace","_FacesMapping","i","ToGammaSpace","ToHalfFloat","r","g","b","scale","clone","newTexture","level","wrapU","wrapV","coordinatesIndex","coordinatesMode","delayLoad","DELAYLOADSTATE_LOADED","getReflectionTextureMatrix","updateFlag","isIdentity","mat","getActiveTextures","indexOf","clear","Parse","parsedTexture","rootUrl","isRenderTarget","useInGammaSpace","FromArray","serialize","serializationObject","customType","RegisterClass"],"mappings":"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"}