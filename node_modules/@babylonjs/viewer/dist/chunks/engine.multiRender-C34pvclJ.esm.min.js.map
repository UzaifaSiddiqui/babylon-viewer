{"version":3,"file":"engine.multiRender-C34pvclJ.esm.min.js","sources":["../../../../../dev/core/dist/Engines/WebGPU/Extensions/engine.multiRender.js"],"sourcesContent":["import { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\nimport { Logger } from \"../../../Misc/logger\";\nimport { Constants } from \"../../constants\";\nimport { WebGPUEngine } from \"../../webgpuEngine\";\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n    if (onBeforeUnbind) {\n        onBeforeUnbind();\n    }\n    this._endCurrentRenderPass();\n    if (!disableGenerateMipMaps) {\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\n    }\n    this._currentRenderTarget = null;\n    this._mrtAttachments = [];\n    this._cacheRenderPipeline.setMRT([]);\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n};\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers) {\n    let generateMipMaps = false;\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let generateDepthTexture = false;\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\n    let textureCount = 1;\n    let samples = 1;\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\n    const defaultUseSRGBBuffer = false;\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\n    const defaultTarget = Constants.TEXTURE_2D;\n    let types = [];\n    let samplingModes = [];\n    let useSRGBBuffers = [];\n    let formats = [];\n    let targets = [];\n    let faceIndex = [];\n    let layerIndex = [];\n    let layers = [];\n    let labels = [];\n    let creationFlags = [];\n    let dontCreateTextures = false;\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n    if (options !== undefined) {\n        generateMipMaps = options.generateMipMaps ?? false;\n        generateDepthBuffer = options.generateDepthBuffer ?? true;\n        generateStencilBuffer = options.generateStencilBuffer ?? false;\n        generateDepthTexture = options.generateDepthTexture ?? false;\n        textureCount = options.textureCount ?? 1;\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\n        types = options.types || types;\n        samplingModes = options.samplingModes || samplingModes;\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\n        formats = options.formats || formats;\n        targets = options.targetTypes || targets;\n        faceIndex = options.faceIndex || faceIndex;\n        layerIndex = options.layerIndex || layerIndex;\n        layers = options.layerCounts || layers;\n        labels = options.labels || labels;\n        creationFlags = options.creationFlags || creationFlags;\n        samples = options.samples ?? samples;\n        dontCreateTextures = options.dontCreateTextures ?? false;\n    }\n    const width = size.width ?? size;\n    const height = size.height ?? size;\n    const textures = [];\n    const attachments = [];\n    const defaultAttachments = [];\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\n    rtWrapper._attachments = attachments;\n    rtWrapper._defaultAttachments = defaultAttachments;\n    let depthStencilTexture = null;\n    if ((generateDepthBuffer || generateStencilBuffer || generateDepthTexture) && !dontCreateTextures) {\n        if (!generateDepthTexture) {\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\n            // So, we will align with what the WebGL engine does\n            if (generateDepthBuffer && generateStencilBuffer) {\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH24_STENCIL8;\n            }\n            else if (generateDepthBuffer) {\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\n            }\n            else {\n                depthTextureFormat = Constants.TEXTUREFORMAT_STENCIL8;\n            }\n        }\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat, rtWrapper.label + \"-DepthStencil\");\n    }\n    const mipmapsCreationOnly = options !== undefined && typeof options === \"object\" && options.createMipMaps && !generateMipMaps;\n    for (let i = 0; i < textureCount; i++) {\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\n        let type = types[i] || defaultType;\n        const format = formats[i] || defaultFormat;\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\n        const target = targets[i] || defaultTarget;\n        const layerCount = layers[i] ?? 1;\n        const creationFlag = creationFlags[i];\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\n            type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n        }\n        attachments.push(i + 1);\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\n        if (target === -1 || dontCreateTextures) {\n            continue;\n        }\n        const texture = new InternalTexture(this, 6 /* InternalTextureSource.MultiRenderTarget */);\n        textures[i] = texture;\n        switch (target) {\n            case Constants.TEXTURE_CUBE_MAP:\n                texture.isCube = true;\n                break;\n            case Constants.TEXTURE_3D:\n                texture.is3D = true;\n                texture.baseDepth = texture.depth = layerCount;\n                break;\n            case Constants.TEXTURE_2D_ARRAY:\n                texture.is2DArray = true;\n                texture.baseDepth = texture.depth = layerCount;\n                break;\n        }\n        texture.baseWidth = width;\n        texture.baseHeight = height;\n        texture.width = width;\n        texture.height = height;\n        texture.isReady = true;\n        texture.samples = 1;\n        texture.generateMipMaps = generateMipMaps;\n        texture.samplingMode = samplingMode;\n        texture.type = type;\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        texture._useSRGBBuffer = useSRGBBuffer;\n        texture.format = format;\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\n        this._internalTexturesCache.push(texture);\n        if (mipmapsCreationOnly) {\n            // createGPUTextureForInternalTexture will only create a texture with mipmaps if generateMipMaps is true, as InternalTexture has no createMipMaps property, separate from generateMipMaps.\n            texture.generateMipMaps = true;\n        }\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, creationFlag, true);\n        if (mipmapsCreationOnly) {\n            texture.generateMipMaps = false;\n        }\n    }\n    if (depthStencilTexture) {\n        depthStencilTexture.incrementReferences();\n        textures[textureCount] = depthStencilTexture;\n        this._internalTexturesCache.push(depthStencilTexture);\n    }\n    rtWrapper.setTextures(textures);\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n    if (!dontCreateTextures) {\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples);\n    }\n    else {\n        rtWrapper._samples = samples;\n    }\n    return rtWrapper;\n};\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures.length === 0 || rtWrapper.textures[0].samples === samples) {\n        return samples;\n    }\n    const count = rtWrapper.textures.length;\n    if (count === 0) {\n        return 1;\n    }\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\n    for (let i = 0; i < count; ++i) {\n        const texture = rtWrapper.textures[i];\n        const gpuTextureWrapper = texture._hardwareTexture;\n        gpuTextureWrapper?.releaseMSAATexture(rtWrapper.getBaseArrayLayer(i));\n    }\n    // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\n    const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\n    for (let i = 0; i < count; ++i) {\n        const texture = rtWrapper.textures[i];\n        this._textureHelper.createMSAATexture(texture, samples, false, rtWrapper.getBaseArrayLayer(i));\n        texture.samples = samples;\n    }\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\n    if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\n        rtWrapper._depthStencilTexture.samples = samples;\n    }\n    rtWrapper._samples = samples;\n    return samples;\n};\nWebGPUEngine.prototype.generateMipMapsMultiFramebuffer = function (texture) {\n    const rtWrapper = texture;\n    if (!rtWrapper.isMulti) {\n        return;\n    }\n    const attachments = rtWrapper._attachments;\n    const count = attachments.length;\n    for (let i = 0; i < count; i++) {\n        const texture = rtWrapper.textures[i];\n        if (texture.generateMipMaps && !texture.isCube && !texture.is3D) {\n            this._generateMipmaps(texture);\n        }\n    }\n};\nWebGPUEngine.prototype.resolveMultiFramebuffer = function (_texture) {\n    throw new Error(\"resolveMultiFramebuffer is not yet implemented in WebGPU!\");\n};\nWebGPUEngine.prototype.bindAttachments = function (attachments) {\n    if (attachments.length === 0 || !this._currentRenderTarget) {\n        return;\n    }\n    this._mrtAttachments = attachments;\n    if (this._currentRenderPass) {\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\n    }\n    else {\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\n    }\n};\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus) {\n    const result = [];\n    for (let i = 0; i < textureStatus.length; i++) {\n        if (textureStatus[i]) {\n            result.push(i + 1);\n        }\n        else {\n            result.push(0);\n        }\n    }\n    return result;\n};\nWebGPUEngine.prototype.restoreSingleAttachment = function () {\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\n};\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\n};\n//# sourceMappingURL=engine.multiRender.js.map"],"names":["WebGPUEngine","prototype","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","this","_endCurrentRenderPass","generateMipMapsMultiFramebuffer","_currentRenderTarget","_mrtAttachments","_cacheRenderPipeline","setMRT","setMRTAttachments","createMultipleRenderTarget","size","options","initializeBuffers","generateMipMaps","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","Constants","TEXTUREFORMAT_DEPTH16","textureCount","samples","defaultType","TEXTURETYPE_UNSIGNED_BYTE","defaultSamplingMode","TEXTURE_TRILINEAR_SAMPLINGMODE","defaultFormat","TEXTUREFORMAT_RGBA","defaultTarget","TEXTURE_2D","types","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","labels","creationFlags","dontCreateTextures","_createHardwareRenderTargetWrapper","undefined","targetTypes","layerCounts","width","height","textures","attachments","defaultAttachments","label","_generateDepthBuffer","_generateStencilBuffer","_attachments","_defaultAttachments","depthStencilTexture","TEXTUREFORMAT_DEPTH24_STENCIL8","TEXTUREFORMAT_DEPTH32_FLOAT","TEXTUREFORMAT_STENCIL8","createDepthStencilTexture","mipmapsCreationOnly","createMipMaps","i","samplingMode","type","format","useSRGBBuffer","_caps","supportSRGBBuffers","target","layerCount","creationFlag","TEXTURETYPE_FLOAT","textureFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","textureHalfFloatLinearFiltering","TEXTURE_NEAREST_SAMPLINGMODE","textureFloat","Logger","Warn","push","texture","InternalTexture","TEXTURE_CUBE_MAP","isCube","TEXTURE_3D","is3D","baseDepth","depth","TEXTURE_2D_ARRAY","is2DArray","baseWidth","baseHeight","isReady","_cachedWrapU","TEXTURE_CLAMP_ADDRESSMODE","_cachedWrapV","_useSRGBBuffer","_internalTexturesCache","_textureHelper","createGPUTextureForInternalTexture","incrementReferences","setTextures","setLayerAndFaceIndices","_samples","updateMultipleRenderTargetTextureSampleCount","length","count","Math","min","getCaps","maxMSAASamples","gpuTextureWrapper","_hardwareTexture","releaseMSAATexture","getBaseArrayLayer","lastTextureIsDepthTexture","_depthStencilTexture","createMSAATexture","isMulti","_generateMipmaps","resolveMultiFramebuffer","_texture","Error","bindAttachments","_currentRenderPass","buildTextureLayout","textureStatus","result","restoreSingleAttachment","restoreSingleAttachmentForRenderTarget"],"mappings":"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"}