function t(t){return Math.floor(t/8)}function e(t){return 1<<t%8}class o{constructor(t){this.size=t,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(o){if(o>=this.size)throw new RangeError("Bit index out of range");const r=t(o),n=e(o);return 0!==(this._byteArray[r]&n)}set(o,r){if(o>=this.size)throw new RangeError("Bit index out of range");const n=t(o),s=e(o);r?this._byteArray[n]|=s:this._byteArray[n]&=~s}}function r(t){const e=[],r=t.length/3;for(let o=0;o<r;o++)e.push([t[3*o],t[3*o+1],t[3*o+2]]);const n=new Map;for(let t=0;t<e.length;t++){const o=e[t];for(const e of o){let o=n.get(e);o||n.set(e,o=[]),o.push(t)}}const s=new o(r),i=[],f=t=>{const o=[t];for(;o.length>0;){const t=o.pop();if(!s.get(t)){s.set(t,!0),i.push(e[t]);for(const r of e[t]){const t=n.get(r);if(!t)return;for(const e of t)s.get(e)||o.push(e)}}}};for(let t=0;t<r;t++)s.get(t)||f(t);let c=0;for(const e of i)t[c++]=e[0],t[c++]=e[1],t[c++]=e[2]}export{r as OptimizeIndices};
//# sourceMappingURL=mesh.vertexData.functions-D0Kx5Kh7.esm.min.js.map
