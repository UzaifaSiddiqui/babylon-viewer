import{aD as e,V as t,M as o,b as n,Q as r,aE as s,aF as i}from"./index-VvGulz6u.esm.min.js";import{A as a}from"./assetContainer-Da0Xx6Do.esm.min.js";import{B as f}from"./bone-DPw1oOFK.esm.min.js";import{S as l}from"./skeleton-BDCw4yVL.esm.min.js";import"./rawTexture-B-F8SA5B.esm.min.js";const c="Xposition",p="Yposition",m="Zposition",h="Xrotation",u="Yrotation",d="Zrotation";class E{constructor(t){this.loopMode=e.ANIMATIONLOOPMODE_CYCLE,this.list=[],this.root=w(),this.numFrames=0,this.frameRate=0,this.skeleton=t}}function w(){return{name:"",type:"",offset:new t,channels:[],children:[],frames:[],parent:null}}function g(t,n,r){const s=function(e){const t=e.offset.x,n=e.offset.y,r=e.offset.z;return o.Translation(t,n,r)}(t),i=new f(t.name,r.skeleton,n,s),a=function(t,o){if(0===t.frames.length)return[];const n=[],r=t.channels.some((e=>e===c||e===p||e===m)),s=t.channels.some((e=>e===h||e===u||e===d)),i=new e(`${t.name}_pos`,"position",o.frameRate,e.ANIMATIONTYPE_VECTOR3,o.loopMode),a=new e(`${t.name}_rot`,"rotationQuaternion",o.frameRate,e.ANIMATIONTYPE_QUATERNION,o.loopMode),f=[],l=[];for(let e=0;e<t.frames.length;e++){const o=t.frames[e];r&&o.position&&f.push({frame:o.frame,value:o.position.clone()}),s&&l.push({frame:o.frame,value:o.rotation.clone()})}return f.length>0&&(i.setKeys(f),n.push(i)),l.length>0&&(a.setKeys(l),n.push(a)),n}(t,r);for(const e of a)e.getKeys()&&e.getKeys().length>0&&i.animations.push(e);for(const e of t.children)g(e,i,r)}function N(e,s,i,a){if("ENDSITE"===i.type)return;const f={frame:0,position:new t,rotation:new r};f.frame=s,f.position=new t,f.rotation=new r,i.frames.push(f);let l=o.Identity();for(let t=0;t<i.channels.length;++t){const r=i.channels[t],s=e[a.i++];if(!s)continue;const E=parseFloat(s.trim());if(r.endsWith("position"))switch(r){case c:f.position.x=E;break;case p:f.position.y=E;break;case m:f.position.z=E}else if(r.endsWith("rotation")){const e=n.ToRadians(E);let t;switch(r){case h:t=o.RotationX(e);break;case u:t=o.RotationY(e);break;case d:t=o.RotationZ(e)}l=t.multiply(l)}}r.FromRotationMatrixToRef(l,f.rotation);for(const t of i.children)N(e,s,t,a)}function y(e,o,n,r){const s=w();s.parent=n,r.list.push(s);let i=o.trim().split(/\s+/);if("END"===i[0].toUpperCase()&&"SITE"===i[1].toUpperCase()?(s.type="ENDSITE",s.name="ENDSITE"):(s.name=i[1],s.type=i[0].toUpperCase()),"{"!=e.shift()?.trim())throw new Error("Expected opening { after type & name");const a=e.shift()?.trim().split(/\s+/);if(!a)throw new Error("Unexpected end of file: missing OFFSET");if(i=a,"OFFSET"!=i[0].toUpperCase())throw new Error("Expected OFFSET, but got: "+i[0]);if(4!=i.length)throw new Error("OFFSET: Invalid number of values");const f=new t(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));if(isNaN(f.x)||isNaN(f.y)||isNaN(f.z))throw new Error("OFFSET: Invalid values");if(s.offset=f,"ENDSITE"!=s.type){if(i=e.shift()?.trim().split(/\s+/),!i)throw new Error("Unexpected end of file: missing CHANNELS");if("CHANNELS"!=i[0].toUpperCase())throw new Error("Expected CHANNELS definition");const t=parseInt(i[1]);s.channels=i.splice(2,t),s.children=[]}for(;e.length>0;){const t=e.shift()?.trim();if("}"===t)return s;t&&s.children.push(y(e,t,s,r))}throw new Error("Unexpected end of file: missing closing brace")}function I(e,t,o,n){const r=e.split("\n"),{loopMode:s}=n;t._blockEntityCollection=!!o;const i=new l("","",t);i._parentContainer=o,t._blockEntityCollection=!1;const a=new E(i);a.loopMode=s;const f=r.shift();if(!f||"HIERARCHY"!==f.trim().toUpperCase())throw new Error("HIERARCHY expected");const c=r.shift();if(!c)throw new Error("Unexpected end of file after HIERARCHY");const p=y(r,c.trim(),null,a),m=r.shift();if(!m||"MOTION"!==m.trim().toUpperCase())throw new Error("MOTION expected");const h=r.shift();if(!h)throw new Error("Unexpected end of file before frame count");const u=h.trim().split(/[\s]+/);if(u.length<2)throw new Error("Invalid frame count line");const d=parseInt(u[1]);if(isNaN(d))throw new Error("Failed to read number of frames.");a.numFrames=d;const w=r.shift();if(!w)throw new Error("Unexpected end of file before frame time");const I=w.trim().split(/[\s]+/);if(I.length<3)throw new Error("Invalid frame time line");const O=parseFloat(I[2]);if(isNaN(O))throw new Error("Failed to read frame time.");a.frameRate=O;for(let e=0;e<d;++e){const t=r.shift();if(!t)continue;N(t.trim().split(/[\s]+/)||[],e,p,{i:0})}return a.root=p,g(a.root,null,a),a.skeleton.returnToRest(),a.skeleton}class O{constructor(e){this.name=s.name,this.extensions=s.extensions,this._loadingOptions={...O._DefaultLoadingOptions,...e??{}}}static get _DefaultLoadingOptions(){return{loopMode:e.ANIMATIONLOOPMODE_CYCLE}}createPlugin(e){return new O(e[s.name])}canDirectLoad(){return!0}importMeshAsync(e,t,o){if("string"!=typeof o)return Promise.reject("BVH loader expects string data.");try{const e=I(o,t,null,this._loadingOptions);return Promise.resolve({meshes:[],particleSystems:[],skeletons:[e],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})}catch(e){return Promise.reject(e)}}loadAsync(e,t){return"string"!=typeof t?Promise.reject("BVH loader expects string data."):this.importMeshAsync(null,e,t).then((()=>{}))}loadAssetContainerAsync(e,t){if("string"!=typeof t)return Promise.reject("BVH loader expects string data.");const o=new a(e);try{const n=I(t,e,o,this._loadingOptions);return o.skeletons.push(n),Promise.resolve(o)}catch(e){return Promise.reject(e)}}}i(new O);export{O as BVHFileLoader};
//# sourceMappingURL=bvhFileLoader-B6csIH5P.esm.min.js.map
