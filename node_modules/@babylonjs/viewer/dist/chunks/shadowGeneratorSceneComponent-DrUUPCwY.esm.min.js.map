{"version":3,"file":"shadowGeneratorSceneComponent-DrUUPCwY.esm.min.js","sources":["../../../../../dev/core/dist/Shaders/depth.fragment.js","../../../../../dev/core/dist/Shaders/ShadersInclude/pointCloudVertexDeclaration.js","../../../../../dev/core/dist/Shaders/depth.vertex.js","../../../../../dev/core/dist/Misc/thinMinMaxReducer.js","../../../../../dev/core/dist/Rendering/depthRenderer.js","../../../../../dev/core/dist/Shaders/minmaxRedux.fragment.js","../../../../../dev/core/dist/ShadersWGSL/minmaxRedux.fragment.js","../../../../../dev/core/dist/Misc/minMaxReducer.js","../../../../../dev/core/dist/Misc/depthReducer.js","../../../../../dev/core/dist/Lights/Shadows/cascadedShadowGenerator.js","../../../../../dev/core/dist/Lights/Shadows/shadowGeneratorSceneComponent.js"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/packingFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nconst name = \"depthPixelShader\";\nconst shader = `#ifdef ALPHATEST\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\n#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const depthPixelShader = { name, shader };\n//# sourceMappingURL=depth.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"pointCloudVertexDeclaration\";\nconst shader = `#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const pointCloudVertexDeclaration = { name, shader };\n//# sourceMappingURL=pointCloudVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/pointCloudVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/pointCloudVertex\";\nconst name = \"depthVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;varying vec4 vViewPos;\n#endif\n#include<pointCloudVertexDeclaration>\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef UV2\nvec2 uv2Updated=uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n#include<pointCloudVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const depthVertexShader = { name, shader };\n//# sourceMappingURL=depth.vertex.js.map","import { Observable } from \"./observable\";\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\nimport { Engine } from \"core/Engines/engine\";\n/**\n * @internal\n */\nexport var DepthTextureType;\n(function (DepthTextureType) {\n    DepthTextureType[DepthTextureType[\"NormalizedViewDepth\"] = 0] = \"NormalizedViewDepth\";\n    DepthTextureType[DepthTextureType[\"ViewDepth\"] = 1] = \"ViewDepth\";\n    DepthTextureType[DepthTextureType[\"ScreenDepth\"] = 2] = \"ScreenDepth\";\n})(DepthTextureType || (DepthTextureType = {}));\n/**\n * @internal\n */\nexport class ThinMinMaxReducerPostProcess extends EffectWrapper {\n    _gatherImports(useWebGPU, list) {\n        if (useWebGPU) {\n            this._webGPUReady = true;\n            list.push(import(\"../ShadersWGSL/minmaxRedux.fragment\"));\n        }\n        else {\n            list.push(import(\"../Shaders/minmaxRedux.fragment\"));\n        }\n    }\n    constructor(name, engine = null, defines = \"\", options) {\n        super({\n            ...options,\n            name,\n            engine: engine || Engine.LastCreatedEngine,\n            useShaderStore: true,\n            useAsPostProcess: true,\n            fragmentShader: ThinMinMaxReducerPostProcess.FragmentUrl,\n            uniforms: ThinMinMaxReducerPostProcess.Uniforms,\n            defines,\n        });\n        this.textureWidth = 0;\n        this.textureHeight = 0;\n    }\n    bind(noDefaultBindings = false) {\n        super.bind(noDefaultBindings);\n        const effect = this.drawWrapper.effect;\n        if (this.textureWidth === 1 || this.textureHeight === 1) {\n            effect.setInt2(\"texSize\", this.textureWidth, this.textureHeight);\n        }\n        else {\n            effect.setFloat2(\"texSize\", this.textureWidth, this.textureHeight);\n        }\n    }\n}\nThinMinMaxReducerPostProcess.FragmentUrl = \"minmaxRedux\";\nThinMinMaxReducerPostProcess.Uniforms = [\"texSize\"];\nconst BufferFloat = new Float32Array(4 * 1 * 1);\nconst BufferUint8 = new Uint8Array(4 * 1 * 1);\nconst MinMax = { min: 0, max: 0 };\n/**\n * @internal\n */\nexport class ThinMinMaxReducer {\n    get depthRedux() {\n        return this._depthRedux;\n    }\n    set depthRedux(value) {\n        if (this._depthRedux === value) {\n            return;\n        }\n        this._depthRedux = value;\n        this._recreatePostProcesses();\n    }\n    get textureWidth() {\n        return this._textureWidth;\n    }\n    get textureHeight() {\n        return this._textureHeight;\n    }\n    constructor(scene, depthRedux = true) {\n        this.onAfterReductionPerformed = new Observable();\n        this._textureWidth = 0;\n        this._textureHeight = 0;\n        this._scene = scene;\n        this._depthRedux = depthRedux;\n        this.reductionSteps = [];\n    }\n    setTextureDimensions(width, height, depthTextureType = 0 /* DepthTextureType.NormalizedViewDepth */) {\n        if (width === this._textureWidth && height === this._textureHeight && depthTextureType === this._depthTextureType) {\n            return false;\n        }\n        this._textureWidth = width;\n        this._textureHeight = height;\n        this._depthTextureType = depthTextureType;\n        this._recreatePostProcesses();\n        return true;\n    }\n    readMinMax(texture) {\n        // Note that we should normally await the call to _readTexturePixels!\n        // But because WebGL does the read synchronously, we know the values will be updated without waiting for the promise to be resolved, which will let us get the updated values\n        // in the current frame, whereas in WebGPU, the read is asynchronous and we should normally wait for the promise to be resolved to get the updated values.\n        // However, it's safe to avoid waiting for the promise to be resolved in WebGPU as well, because we will simply use the current values until \"buffer\" is updated later on.\n        // Note that it means we can suffer some rendering artifacts in WebGPU because we may use previous min/max values for the current frame.\n        const isFloat = texture.type === Engine.TEXTURETYPE_FLOAT || texture.type === Engine.TEXTURETYPE_HALF_FLOAT;\n        const buffer = isFloat ? BufferFloat : BufferUint8;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._scene.getEngine()._readTexturePixels(texture, 1, 1, -1, 0, buffer, false);\n        MinMax.min = buffer[0];\n        MinMax.max = buffer[1];\n        if (!isFloat) {\n            MinMax.min = MinMax.min / 255.0;\n            MinMax.max = MinMax.max / 255.0;\n        }\n        if (MinMax.min >= MinMax.max) {\n            MinMax.min = 0;\n            MinMax.max = 1;\n        }\n        this.onAfterReductionPerformed.notifyObservers(MinMax);\n    }\n    dispose(disposeAll = true) {\n        if (disposeAll) {\n            this.onAfterReductionPerformed.clear();\n            this._textureWidth = 0;\n            this._textureHeight = 0;\n        }\n        for (let i = 0; i < this.reductionSteps.length; ++i) {\n            this.reductionSteps[i].dispose();\n        }\n        this.reductionSteps.length = 0;\n    }\n    _recreatePostProcesses() {\n        this.dispose(false);\n        const scene = this._scene;\n        let w = this.textureWidth, h = this.textureHeight;\n        const reductionInitial = new ThinMinMaxReducerPostProcess(\"Initial reduction phase\", scene.getEngine(), \"#define INITIAL\" + (this._depthRedux ? \"\\n#define DEPTH_REDUX\" : \"\") + (this._depthTextureType === 1 /* DepthTextureType.ViewDepth */ ? \"\\n#define VIEW_DEPTH\" : \"\"));\n        reductionInitial.textureWidth = w;\n        reductionInitial.textureHeight = h;\n        this.reductionSteps.push(reductionInitial);\n        let index = 1;\n        // create the additional steps\n        while (w > 1 || h > 1) {\n            w = Math.max(Math.round(w / 2), 1);\n            h = Math.max(Math.round(h / 2), 1);\n            const reduction = new ThinMinMaxReducerPostProcess(\"Reduction phase \" + index, scene.getEngine(), \"#define \" + (w == 1 && h == 1 ? \"LAST\" : w == 1 || h == 1 ? \"ONEBEFORELAST\" : \"MAIN\"));\n            reduction.textureWidth = w;\n            reduction.textureHeight = h;\n            this.reductionSteps.push(reduction);\n            index++;\n        }\n    }\n}\n//# sourceMappingURL=thinMinMaxReducer.js.map","import { Color4 } from \"../Maths/math.color\";\nimport { VertexBuffer } from \"../Buffers/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { Camera } from \"../Cameras/camera\";\nimport { Constants } from \"../Engines/constants\";\nimport \"../Shaders/depth.fragment\";\nimport \"../Shaders/depth.vertex\";\nimport { _WarnImport } from \"../Misc/devTools\";\nimport { AddClipPlaneUniforms, BindClipPlane, PrepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\nexport class DepthRenderer {\n    /**\n     * Gets the shader language used in this material.\n     */\n    get shaderLanguage() {\n        return this._shaderLanguage;\n    }\n    /**\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n     * @param mesh mesh or array of meshes\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n     */\n    setMaterialForRendering(mesh, material) {\n        this._depthMap.setMaterialForRendering(mesh, material);\n    }\n    /**\n     * Instantiates a depth renderer\n     * @param scene The scene the renderer belongs to\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\n     * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\n     * @param name Name of the render target (default: DepthRenderer)\n     */\n    constructor(scene, type = Constants.TEXTURETYPE_FLOAT, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name) {\n        /** Shader language used by the material */\n        this._shaderLanguage = 0 /* ShaderLanguage.GLSL */;\n        /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n        this.enabled = true;\n        /** Force writing the transparent objects into the depth map */\n        this.forceDepthWriteTransparentMeshes = false;\n        /**\n         * Specifies that the depth renderer will only be used within\n         * the camera it is created for.\n         * This can help forcing its rendering during the camera processing.\n         */\n        this.useOnlyInActiveCamera = false;\n        /** If true, reverse the culling of materials before writing to the depth texture.\n         * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\n         */\n        this.reverseCulling = false;\n        this._shadersLoaded = false;\n        this._scene = scene;\n        this._storeNonLinearDepth = storeNonLinearDepth;\n        this._storeCameraSpaceZ = storeCameraSpaceZ;\n        this.isPacked = type === Constants.TEXTURETYPE_UNSIGNED_BYTE;\n        if (this.isPacked) {\n            this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n        }\n        else {\n            this.clearColor = new Color4(storeCameraSpaceZ ? 0.0 : 1.0, 0.0, 0.0, 1.0);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._initShaderSourceAsync();\n        DepthRenderer._SceneComponentInitialization(this._scene);\n        const engine = scene.getEngine();\n        this._camera = camera;\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n            if (type === Constants.TEXTURETYPE_FLOAT && !engine._caps.textureFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n            if (type === Constants.TEXTURETYPE_HALF_FLOAT && !engine._caps.textureHalfFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n        }\n        // Render target\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_R;\n        this._depthMap = new RenderTargetTexture(name ?? \"DepthRenderer\", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.refreshRate = 1;\n        this._depthMap.renderParticles = false;\n        this._depthMap.renderList = null;\n        this._depthMap.noPrePassRenderer = true;\n        // Camera to get depth map from to support multiple concurrent cameras\n        this._depthMap.activeCamera = this._camera;\n        this._depthMap.ignoreCameraViewport = true;\n        this._depthMap.useCameraPostProcesses = false;\n        // set default depth value to 1.0 (far away)\n        this._depthMap.onClearObservable.add((engine) => {\n            engine.clear(this.clearColor, true, true, true);\n        });\n        this._depthMap.onBeforeBindObservable.add(() => {\n            engine._debugPushGroup?.(\"depth renderer\", 1);\n        });\n        this._depthMap.onAfterUnbindObservable.add(() => {\n            engine._debugPopGroup?.(1);\n        });\n        this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\n                    const subMesh = mesh.subMeshes[i];\n                    const renderingMesh = subMesh.getRenderingMesh();\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        // Custom render function\n        const renderSubMesh = (subMesh) => {\n            const renderingMesh = subMesh.getRenderingMesh();\n            const effectiveMesh = subMesh.getEffectiveMesh();\n            const scene = this._scene;\n            const engine = scene.getEngine();\n            const material = subMesh.getMaterial();\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n                return;\n            }\n            // Culling\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n            let sideOrientation = material._getEffectiveOrientation(renderingMesh);\n            if (detNeg) {\n                sideOrientation =\n                    sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation\n                        ? Constants.MATERIAL_CounterClockWiseSideOrientation\n                        : Constants.MATERIAL_ClockWiseSideOrientation;\n            }\n            const reverseSideOrientation = sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\n            // Managing instances\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n            if (batch.mustReturn) {\n                return;\n            }\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n            const camera = this._camera || scene.activeCamera;\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n                subMesh._renderId = scene.getRenderId();\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n                let drawWrapper = subMesh._getDrawWrapper();\n                if (!drawWrapper && renderingMaterial) {\n                    drawWrapper = renderingMaterial._getDrawWrapper();\n                }\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n                if (!drawWrapper) {\n                    return;\n                }\n                const effect = drawWrapper.effect;\n                engine.enableEffect(drawWrapper);\n                if (!hardwareInstancedRendering) {\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\n                }\n                if (!renderingMaterial) {\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n                    if (this._storeCameraSpaceZ) {\n                        effect.setMatrix(\"view\", scene.getViewMatrix());\n                    }\n                }\n                else {\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n                }\n                let minZ, maxZ;\n                if (cameraIsOrtho) {\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                }\n                else {\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n                }\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n                if (!renderingMaterial) {\n                    // Alpha test\n                    if (material.needAlphaTestingForMesh(effectiveMesh)) {\n                        const alphaTexture = material.getAlphaTestTexture();\n                        if (alphaTexture) {\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                        }\n                    }\n                    // Bones\n                    BindBonesParameters(renderingMesh, effect);\n                    // Clip planes\n                    BindClipPlane(effect, material, scene);\n                    // Morph targets\n                    BindMorphTargetParameters(renderingMesh, effect);\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                        renderingMesh.morphTargetManager._bind(effect);\n                    }\n                    // Baked vertex animations\n                    const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;\n                    if (bvaManager && bvaManager.isEnabled) {\n                        bvaManager.bind(effect, hardwareInstancedRendering);\n                    }\n                    // Points cloud rendering\n                    if (material.pointsCloud) {\n                        effect.setFloat(\"pointSize\", material.pointSize);\n                    }\n                }\n                // Draw\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n            }\n        };\n        this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n            let index;\n            if (depthOnlySubMeshes.length) {\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\n                }\n            }\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                renderSubMesh(opaqueSubMeshes.data[index]);\n            }\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                renderSubMesh(alphaTestSubMeshes.data[index]);\n            }\n            if (this.forceDepthWriteTransparentMeshes) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            }\n            else {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n                }\n            }\n        };\n    }\n    async _initShaderSourceAsync(forceGLSL = false) {\n        const engine = this._scene.getEngine();\n        if (engine.isWebGPU && !forceGLSL && !DepthRenderer.ForceGLSL) {\n            this._shaderLanguage = 1 /* ShaderLanguage.WGSL */;\n            await Promise.all([import(\"../ShadersWGSL/depth.vertex\"), import(\"../ShadersWGSL/depth.fragment\")]);\n        }\n        else {\n            await Promise.all([import(\"../Shaders/depth.vertex\"), import(\"../Shaders/depth.fragment\")]);\n        }\n        this._shadersLoaded = true;\n    }\n    /**\n     * Creates the depth rendering effect and checks if the effect is ready.\n     * @param subMesh The submesh to be used to render the depth map of\n     * @param useInstances If multiple world instances should be used\n     * @returns if the depth renderer is ready to render the depth map\n     */\n    isReady(subMesh, useInstances) {\n        if (!this._shadersLoaded) {\n            return false;\n        }\n        const engine = this._scene.getEngine();\n        const mesh = subMesh.getMesh();\n        const scene = mesh.getScene();\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n        if (renderingMaterial) {\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n        }\n        const material = subMesh.getMaterial();\n        if (!material || material.disableDepthWrite) {\n            return false;\n        }\n        const defines = [];\n        const attribs = [VertexBuffer.PositionKind];\n        let uv1 = false;\n        let uv2 = false;\n        const color = false;\n        // Alpha test\n        if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {\n            defines.push(\"#define ALPHATEST\");\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                attribs.push(VertexBuffer.UVKind);\n                defines.push(\"#define UV1\");\n                uv1 = true;\n            }\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                attribs.push(VertexBuffer.UV2Kind);\n                defines.push(\"#define UV2\");\n                uv2 = true;\n            }\n        }\n        // Bones\n        const fallbacks = new EffectFallbacks();\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            if (mesh.numBoneInfluencers > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n            }\n            const skeleton = mesh.skeleton;\n            if (skeleton.isUsingTextureForMatrices) {\n                defines.push(\"#define BONETEXTURE\");\n            }\n            else {\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n            }\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        const numMorphInfluencers = mesh.morphTargetManager\n            ? PrepareDefinesAndAttributesForMorphTargets(mesh.morphTargetManager, defines, attribs, mesh, true, // usePositionMorph\n            false, // useNormalMorph\n            false, // useTangentMorph\n            uv1, // useUVMorph\n            uv2, // useUV2Morph\n            color // useColorMorph\n            )\n            : 0;\n        // Points cloud rendering\n        if (material.pointsCloud) {\n            defines.push(\"#define POINTSIZE\");\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            PushAttributesForInstances(attribs);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // Baked vertex animations\n        const bvaManager = mesh.bakedVertexAnimationManager;\n        if (bvaManager && bvaManager.isEnabled) {\n            defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\n            if (useInstances) {\n                attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n            }\n        }\n        // None linear depth\n        if (this._storeNonLinearDepth) {\n            defines.push(\"#define NONLINEARDEPTH\");\n        }\n        // Store camera space Z coordinate instead of NDC Z\n        if (this._storeCameraSpaceZ) {\n            defines.push(\"#define STORE_CAMERASPACE_Z\");\n        }\n        // Float Mode\n        if (this.isPacked) {\n            defines.push(\"#define PACKED\");\n        }\n        // Clip planes\n        PrepareStringDefinesForClipPlanes(material, scene, defines);\n        // Get correct effect\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n        const cachedDefines = drawWrapper.defines;\n        const join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            const uniforms = [\n                \"world\",\n                \"mBones\",\n                \"boneTextureWidth\",\n                \"pointSize\",\n                \"viewProjection\",\n                \"view\",\n                \"diffuseMatrix\",\n                \"depthValues\",\n                \"morphTargetInfluences\",\n                \"morphTargetCount\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n                \"bakedVertexAnimationSettings\",\n                \"bakedVertexAnimationTextureSizeInverted\",\n                \"bakedVertexAnimationTime\",\n                \"bakedVertexAnimationTexture\",\n            ];\n            const samplers = [\"diffuseSampler\", \"morphTargets\", \"boneSampler\", \"bakedVertexAnimationTexture\"];\n            AddClipPlaneUniforms(uniforms);\n            drawWrapper.setEffect(engine.createEffect(\"depth\", {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: [],\n                samplers: samplers,\n                defines: join,\n                fallbacks: fallbacks,\n                onCompiled: null,\n                onError: null,\n                indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\n                shaderLanguage: this._shaderLanguage,\n            }, engine), join);\n        }\n        return drawWrapper.effect.isReady();\n    }\n    /**\n     * Gets the texture which the depth map will be written to.\n     * @returns The depth map texture\n     */\n    getDepthMap() {\n        return this._depthMap;\n    }\n    /**\n     * Disposes of the depth renderer.\n     */\n    dispose() {\n        const keysToDelete = [];\n        for (const key in this._scene._depthRenderer) {\n            const depthRenderer = this._scene._depthRenderer[key];\n            if (depthRenderer === this) {\n                keysToDelete.push(key);\n            }\n        }\n        if (keysToDelete.length > 0) {\n            this._depthMap.dispose();\n            for (const key of keysToDelete) {\n                delete this._scene._depthRenderer[key];\n            }\n        }\n    }\n}\n/**\n * Force all the depth renderer to compile to glsl even on WebGPU engines.\n * False by default. This is mostly meant for backward compatibility.\n */\nDepthRenderer.ForceGLSL = false;\n/**\n * @internal\n */\nDepthRenderer._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"DepthRendererSceneComponent\");\n};\n//# sourceMappingURL=depthRenderer.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nconst name = \"minmaxReduxPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(textureSampler,coord,0).r;float f2=texelFetch(textureSampler,coord+ivec2(1,0),0).r;float f3=texelFetch(textureSampler,coord+ivec2(1,1),0).r;float f4=texelFetch(textureSampler,coord+ivec2(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nfloat minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\nvoid main(void)\n{glFragColor=vec4(0.);if (true) { \ndiscard;}}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const minmaxReduxPixelShader = { name, shader };\n//# sourceMappingURL=minmaxRedux.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nconst name = \"minmaxReduxPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSampler: texture_2d<f32>;\n#if defined(INITIAL)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).r;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).r;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).r;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nvar minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nlet maxz=max(max(max(f1,f2),f3),f4);\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(f1,f2),f3),f4);\n#endif\nfragmentOutputs.color=vec4f(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).rg;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).rg;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).rg;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform texSize: vec2i;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*vec2f(uniforms.texSize-1));let f1=textureLoad(textureSampler,coord % uniforms.texSize,0).rg;let f2=textureLoad(textureSampler,(coord+vec2i(1,0)) % uniforms.texSize,0).rg;let f3=textureLoad(textureSampler,(coord+vec2i(1,1)) % uniforms.texSize,0).rg;let f4=textureLoad(textureSampler,(coord+vec2i(0,1)) % uniforms.texSize,0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(0.);if (true) { \ndiscard;}}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const minmaxReduxPixelShaderWGSL = { name, shader };\n//# sourceMappingURL=minmaxRedux.fragment.js.map","import { Constants } from \"../Engines/constants\";\nimport { PostProcess } from \"../PostProcesses/postProcess\";\nimport { PostProcessManager } from \"../PostProcesses/postProcessManager\";\nimport { ThinMinMaxReducer, ThinMinMaxReducerPostProcess } from \"./thinMinMaxReducer\";\nimport \"../Shaders/minmaxRedux.fragment\";\nimport \"../ShadersWGSL/minmaxRedux.fragment\";\n/**\n * This class computes a min/max reduction from a texture: it means it computes the minimum\n * and maximum values from all values of the texture.\n * It is performed on the GPU for better performances, thanks to a succession of post processes.\n * The source values are read from the red channel of the texture.\n */\nexport class MinMaxReducer {\n    /**\n     * Observable triggered when the computation has been performed\n     */\n    get onAfterReductionPerformed() {\n        return this._thinMinMaxReducer.onAfterReductionPerformed;\n    }\n    /**\n     * Creates a min/max reducer\n     * @param camera The camera to use for the post processes\n     */\n    constructor(camera) {\n        this._onAfterUnbindObserver = null;\n        this._forceFullscreenViewport = true;\n        this._activated = false;\n        this._camera = camera;\n        this._postProcessManager = new PostProcessManager(camera.getScene());\n        this._thinMinMaxReducer = new ThinMinMaxReducer(camera.getScene());\n        this._reductionSteps = [];\n        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {\n            this._postProcessManager._rebuild();\n        });\n    }\n    /**\n     * Gets the texture used to read the values from.\n     */\n    get sourceTexture() {\n        return this._sourceTexture;\n    }\n    /**\n     * Sets the source texture to read the values from.\n     * One must indicate if the texture is a depth texture or not through the depthRedux parameter\n     * because in such textures '1' value must not be taken into account to compute the maximum\n     * as this value is used to clear the texture.\n     * Note that the computation is not activated by calling this function, you must call activate() for that!\n     * @param sourceTexture The texture to read the values from. The values should be in the red channel.\n     * @param depthRedux Indicates if the texture is a depth texture or not\n     * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\n     */\n    setSourceTexture(sourceTexture, depthRedux, type = Constants.TEXTURETYPE_HALF_FLOAT, forceFullscreenViewport = true) {\n        if (sourceTexture === this._sourceTexture) {\n            return;\n        }\n        this._thinMinMaxReducer.depthRedux = depthRedux;\n        this.deactivate();\n        this._sourceTexture = sourceTexture;\n        this._forceFullscreenViewport = forceFullscreenViewport;\n        if (this._thinMinMaxReducer.setTextureDimensions(sourceTexture.getRenderWidth(), sourceTexture.getRenderHeight())) {\n            this._disposePostProcesses();\n            const reductionSteps = this._thinMinMaxReducer.reductionSteps;\n            for (let i = 0; i < reductionSteps.length; ++i) {\n                const reductionStep = reductionSteps[i];\n                const postProcess = new PostProcess(reductionStep.name, ThinMinMaxReducerPostProcess.FragmentUrl, {\n                    effectWrapper: reductionStep,\n                    samplingMode: Constants.TEXTURE_NEAREST_NEAREST,\n                    engine: this._camera.getScene().getEngine(),\n                    textureType: type,\n                    textureFormat: Constants.TEXTUREFORMAT_RG,\n                    size: { width: reductionStep.textureWidth, height: reductionStep.textureHeight },\n                });\n                this._reductionSteps.push(postProcess);\n                postProcess.autoClear = false;\n                postProcess.forceFullscreenViewport = forceFullscreenViewport;\n                if (i === 0) {\n                    postProcess.externalTextureSamplerBinding = true;\n                    postProcess.onApplyObservable.add((effect) => {\n                        effect.setTexture(\"textureSampler\", this._sourceTexture);\n                    });\n                }\n                if (i === reductionSteps.length - 1) {\n                    this._reductionSteps[i - 1].onAfterRenderObservable.add(() => {\n                        this._thinMinMaxReducer.readMinMax(postProcess.inputTexture.texture);\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Defines the refresh rate of the computation.\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n     */\n    get refreshRate() {\n        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;\n    }\n    set refreshRate(value) {\n        if (this._sourceTexture) {\n            this._sourceTexture.refreshRate = value;\n        }\n    }\n    /**\n     * Gets the activation status of the reducer\n     */\n    get activated() {\n        return this._activated;\n    }\n    /**\n     * Activates the reduction computation.\n     * When activated, the observers registered in onAfterReductionPerformed are\n     * called after the computation is performed\n     */\n    activate() {\n        if (this._onAfterUnbindObserver || !this._sourceTexture) {\n            return;\n        }\n        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {\n            const engine = this._camera.getScene().getEngine();\n            engine._debugPushGroup?.(`min max reduction`, 1);\n            this._reductionSteps[0].activate(this._camera);\n            this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport, 0, 0, true, this._reductionSteps.length - 1);\n            engine.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length - 1].inputTexture, false);\n            engine._debugPopGroup?.(1);\n        });\n        this._activated = true;\n    }\n    /**\n     * Deactivates the reduction computation.\n     */\n    deactivate() {\n        if (!this._onAfterUnbindObserver || !this._sourceTexture) {\n            return;\n        }\n        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n        this._onAfterUnbindObserver = null;\n        this._activated = false;\n    }\n    /**\n     * Disposes the min/max reducer\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\n     */\n    dispose(disposeAll = true) {\n        if (!disposeAll) {\n            return;\n        }\n        this.onAfterReductionPerformed.clear();\n        this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n        this._onContextRestoredObserver = undefined;\n        this._disposePostProcesses();\n        this._postProcessManager.dispose();\n        this._postProcessManager = undefined;\n        this._thinMinMaxReducer.dispose();\n        this._thinMinMaxReducer = undefined;\n        this._sourceTexture = null;\n    }\n    _disposePostProcesses() {\n        for (let i = 0; i < this._reductionSteps.length; ++i) {\n            this._reductionSteps[i].dispose();\n        }\n        this._reductionSteps.length = 0;\n    }\n}\n//# sourceMappingURL=minMaxReducer.js.map","import { Constants } from \"../Engines/constants\";\nimport { DepthRenderer } from \"../Rendering/depthRenderer\";\nimport { MinMaxReducer } from \"./minMaxReducer\";\n/**\n * This class is a small wrapper around the MinMaxReducer class to compute the min/max values of a depth texture\n */\nexport class DepthReducer extends MinMaxReducer {\n    /**\n     * Gets the depth renderer used for the computation.\n     * Note that the result is null if you provide your own renderer when calling setDepthRenderer.\n     */\n    get depthRenderer() {\n        return this._depthRenderer;\n    }\n    /**\n     * Creates a depth reducer\n     * @param camera The camera used to render the depth texture\n     */\n    constructor(camera) {\n        super(camera);\n    }\n    /**\n     * Sets the depth renderer to use to generate the depth map\n     * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically\n     * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\n     */\n    setDepthRenderer(depthRenderer = null, type = Constants.TEXTURETYPE_HALF_FLOAT, forceFullscreenViewport = true) {\n        const scene = this._camera.getScene();\n        if (this._depthRenderer) {\n            delete scene._depthRenderer[this._depthRendererId];\n            this._depthRenderer.dispose();\n            this._depthRenderer = null;\n        }\n        if (depthRenderer === null) {\n            if (!scene._depthRenderer) {\n                scene._depthRenderer = {};\n            }\n            this._depthRendererId = \"minmax_\" + this._camera.id;\n            depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, false, `DepthRenderer ${this._depthRendererId}`);\n            depthRenderer.enabled = false;\n            scene._depthRenderer[this._depthRendererId] = depthRenderer;\n        }\n        super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);\n    }\n    /**\n     * @internal\n     */\n    setSourceTexture(sourceTexture, depthRedux, type = Constants.TEXTURETYPE_HALF_FLOAT, forceFullscreenViewport = true) {\n        super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);\n    }\n    /**\n     * Activates the reduction computation.\n     * When activated, the observers registered in onAfterReductionPerformed are\n     * called after the computation is performed\n     */\n    activate() {\n        if (this._depthRenderer) {\n            this._depthRenderer.enabled = true;\n        }\n        super.activate();\n    }\n    /**\n     * Deactivates the reduction computation.\n     */\n    deactivate() {\n        super.deactivate();\n        if (this._depthRenderer) {\n            this._depthRenderer.enabled = false;\n        }\n    }\n    /**\n     * Disposes the depth reducer\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\n     */\n    dispose(disposeAll = true) {\n        super.dispose(disposeAll);\n        if (this._depthRenderer && disposeAll) {\n            this._depthRenderer.dispose();\n            this._depthRenderer = null;\n        }\n    }\n}\n//# sourceMappingURL=depthReducer.js.map","import { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\nimport { Constants } from \"../../Engines/constants\";\nimport { _WarnImport } from \"../../Misc/devTools\";\nimport { ShadowGenerator } from \"./shadowGenerator\";\nimport { BoundingInfo } from \"../../Culling/boundingInfo\";\nimport { DepthReducer } from \"../../Misc/depthReducer\";\nimport { Logger } from \"../../Misc/logger\";\nimport { EngineStore } from \"../../Engines/engineStore\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst UpDir = Vector3.Up();\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst ZeroVec = Vector3.Zero();\nconst Tmpv1 = new Vector3();\nconst Tmpv2 = new Vector3();\nconst TmpMatrix = new Matrix();\n/**\n * A CSM implementation allowing casting shadows on large scenes.\n * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/\n */\nexport class CascadedShadowGenerator extends ShadowGenerator {\n    _validateFilter(filter) {\n        if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {\n            return filter;\n        }\n        Logger.Error('Unsupported filter \"' + filter + '\"!');\n        return ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets or set the number of cascades used by the CSM.\n     */\n    get numCascades() {\n        return this._numCascades;\n    }\n    set numCascades(value) {\n        value = Math.min(Math.max(value, CascadedShadowGenerator.MIN_CASCADES_COUNT), CascadedShadowGenerator.MAX_CASCADES_COUNT);\n        if (value === this._numCascades) {\n            return;\n        }\n        this._numCascades = value;\n        this.recreateShadowMap();\n        this._recreateSceneUBOs();\n    }\n    /**\n     * Enables or disables the shadow casters bounding info computation.\n     * If your shadow casters don't move, you can disable this feature.\n     * If it is enabled, the bounding box computation is done every frame.\n     */\n    get freezeShadowCastersBoundingInfo() {\n        return this._freezeShadowCastersBoundingInfo;\n    }\n    set freezeShadowCastersBoundingInfo(freeze) {\n        if (this._freezeShadowCastersBoundingInfoObservable && freeze) {\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n            this._freezeShadowCastersBoundingInfoObservable = null;\n        }\n        if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {\n            this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(() => this._computeShadowCastersBoundingInfo());\n        }\n        this._freezeShadowCastersBoundingInfo = freeze;\n        if (freeze) {\n            this._computeShadowCastersBoundingInfo();\n        }\n    }\n    _computeShadowCastersBoundingInfo() {\n        this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._scbiMax.copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        if (this._shadowMap && this._shadowMap.renderList) {\n            const renderList = this._shadowMap.renderList;\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n                const mesh = renderList[meshIndex];\n                if (!mesh) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\n            }\n        }\n        this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);\n    }\n    /**\n     * Gets or sets the shadow casters bounding info.\n     * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo\n     * so that the system won't overwrite the bounds you provide\n     */\n    get shadowCastersBoundingInfo() {\n        return this._shadowCastersBoundingInfo;\n    }\n    set shadowCastersBoundingInfo(boundingInfo) {\n        this._shadowCastersBoundingInfo = boundingInfo;\n    }\n    /**\n     * Sets the minimal and maximal distances to use when computing the cascade breaks.\n     *\n     * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.\n     * If you don't know these values, simply leave them to their defaults and don't call this function.\n     * @param min minimal distance for the breaks (default to 0.)\n     * @param max maximal distance for the breaks (default to 1.)\n     */\n    setMinMaxDistance(min, max) {\n        if (this._minDistance === min && this._maxDistance === max) {\n            return;\n        }\n        if (min > max) {\n            min = 0;\n            max = 1;\n        }\n        if (min < 0) {\n            min = 0;\n        }\n        if (max > 1) {\n            max = 1;\n        }\n        this._minDistance = min;\n        this._maxDistance = max;\n        this._breaksAreDirty = true;\n    }\n    /** Gets the minimal distance used in the cascade break computation */\n    get minDistance() {\n        return this._minDistance;\n    }\n    /** Gets the maximal distance used in the cascade break computation */\n    get maxDistance() {\n        return this._maxDistance;\n    }\n    /**\n     * Gets the class name of that object\n     * @returns \"CascadedShadowGenerator\"\n     */\n    getClassName() {\n        return CascadedShadowGenerator.CLASSNAME;\n    }\n    /**\n     * Gets a cascade minimum extents\n     * @param cascadeIndex index of the cascade\n     * @returns the minimum cascade extents\n     */\n    getCascadeMinExtents(cascadeIndex) {\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;\n    }\n    /**\n     * Gets a cascade maximum extents\n     * @param cascadeIndex index of the cascade\n     * @returns the maximum cascade extents\n     */\n    getCascadeMaxExtents(cascadeIndex) {\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;\n    }\n    /**\n     * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.\n     * It defaults to camera.maxZ\n     */\n    get shadowMaxZ() {\n        if (!this._getCamera()) {\n            return 0;\n        }\n        return this._shadowMaxZ;\n    }\n    /**\n     * Sets the shadow max z distance.\n     */\n    set shadowMaxZ(value) {\n        const camera = this._getCamera();\n        if (!camera) {\n            this._shadowMaxZ = value;\n            return;\n        }\n        if (this._shadowMaxZ === value || value < camera.minZ || (value > camera.maxZ && camera.maxZ !== 0)) {\n            return;\n        }\n        this._shadowMaxZ = value;\n        this._light._markMeshesAsLightDirty();\n        this._breaksAreDirty = true;\n    }\n    /**\n     * Gets or sets the debug flag.\n     * When enabled, the cascades are materialized by different colors on the screen.\n     */\n    get debug() {\n        return this._debug;\n    }\n    set debug(dbg) {\n        this._debug = dbg;\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets or sets the depth clamping value.\n     *\n     * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted\n     * to account for the shadow casters far away.\n     *\n     * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.\n     */\n    get depthClamp() {\n        return this._depthClamp;\n    }\n    set depthClamp(value) {\n        this._depthClamp = value;\n    }\n    /**\n     * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).\n     * It defaults to 0.1 (10% blending).\n     */\n    get cascadeBlendPercentage() {\n        return this._cascadeBlendPercentage;\n    }\n    set cascadeBlendPercentage(value) {\n        this._cascadeBlendPercentage = value;\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets or set the lambda parameter.\n     * This parameter is used to split the camera frustum and create the cascades.\n     * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.\n     * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.\n     */\n    get lambda() {\n        return this._lambda;\n    }\n    set lambda(value) {\n        const lambda = Math.min(Math.max(value, 0), 1);\n        if (this._lambda == lambda) {\n            return;\n        }\n        this._lambda = lambda;\n        this._breaksAreDirty = true;\n    }\n    /**\n     * Gets the view matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the view matrix from\n     * @returns the cascade view matrix\n     */\n    getCascadeViewMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;\n    }\n    /**\n     * Gets the projection matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the projection matrix from\n     * @returns the cascade projection matrix\n     */\n    getCascadeProjectionMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;\n    }\n    /**\n     * Gets the transformation matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the transformation matrix from\n     * @returns the cascade transformation matrix\n     */\n    getCascadeTransformMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;\n    }\n    /**\n     * Sets the depth renderer to use when autoCalcDepthBounds is enabled.\n     *\n     * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.\n     *\n     * You should call this function if you already have a depth renderer enabled in your scene, to avoid\n     * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!\n     * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created\n     */\n    setDepthRenderer(depthRenderer) {\n        this._depthRenderer = depthRenderer;\n        if (this._depthReducer) {\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\n        }\n    }\n    /**\n     * Gets or sets the autoCalcDepthBounds property.\n     *\n     * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one\n     * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the\n     * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.\n     * It can greatly enhance the shadow quality, at the expense of more GPU works.\n     * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.\n     */\n    get autoCalcDepthBounds() {\n        return this._autoCalcDepthBounds;\n    }\n    set autoCalcDepthBounds(value) {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        this._autoCalcDepthBounds = value;\n        if (!value) {\n            if (this._depthReducer) {\n                this._depthReducer.deactivate();\n            }\n            this.setMinMaxDistance(0, 1);\n            return;\n        }\n        if (!this._depthReducer) {\n            this._depthReducer = new DepthReducer(camera);\n            this._depthReducer.onAfterReductionPerformed.add((minmax) => {\n                let min = minmax.min, max = minmax.max;\n                if (min >= max) {\n                    min = 0;\n                    max = 1;\n                }\n                if (min != this._minDistance || max != this._maxDistance) {\n                    this.setMinMaxDistance(min, max);\n                }\n            });\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\n        }\n        this._depthReducer.activate();\n    }\n    /**\n     * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n     * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible\n     * for setting the refresh rate on the renderer yourself!\n     */\n    get autoCalcDepthBoundsRefreshRate() {\n        return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate ?? -1;\n    }\n    set autoCalcDepthBoundsRefreshRate(value) {\n        if (this._depthReducer?.depthRenderer) {\n            this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;\n        }\n    }\n    /**\n     * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.\n     * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if\n     * you change the camera near/far planes!\n     */\n    splitFrustum() {\n        this._breaksAreDirty = true;\n    }\n    _splitFrustum() {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const near = camera.minZ, far = camera.maxZ || this._shadowMaxZ, // account for infinite far plane (ie. maxZ = 0)\n        cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;\n        const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;\n        const range = maxZ - minZ, ratio = maxZ / minZ;\n        for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {\n            const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;\n            const d = this._lambda * (log - uniform) + uniform;\n            this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;\n            this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;\n            this._viewSpaceFrustumsZ[cascadeIndex] = d;\n            this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;\n        }\n        this._breaksAreDirty = false;\n    }\n    _computeMatrices() {\n        const scene = this._scene;\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\n        }\n        this._cachedDirection.copyFrom(this._lightDirection);\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n            this._computeFrustumInWorldSpace(cascadeIndex);\n            this._computeCascadeFrustum(cascadeIndex);\n            this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], Tmpv1); // tmpv1 = cascadeExtents\n            // Get position of the shadow camera\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);\n            // Come up with a new orthographic camera for the shadow caster\n            Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);\n            // Z extents of the current cascade, in cascade view coordinate system\n            let viewMinZ = 0, viewMaxZ = Tmpv1.z;\n            // Try to tighten minZ and maxZ based on the bounding box of the shadow casters\n            const boundingInfo = this._shadowCastersBoundingInfo;\n            boundingInfo.update(this._viewMatrices[cascadeIndex]);\n            // Note that after the call to update, the boundingInfo properties that are identified as \"world\" coordinates are in fact view coordinates for the current cascade!\n            // This is because the boundingInfo properties that are identifed as \"local\" are in fact world coordinates (see _computeShadowCastersBoundingInfo()), and we multiply them by the current cascade view matrix when we call update.\n            const castersViewMinZ = boundingInfo.boundingBox.minimumWorld.z;\n            const castersViewMaxZ = boundingInfo.boundingBox.maximumWorld.z;\n            if (castersViewMinZ > viewMaxZ) {\n                // Do nothing, keep the current z extents.\n                // All the casters are too far from the light to have an impact on the current cascade.\n                // Possible optimization: skip the rendering of the shadow map for this cascade, as all the casters will be clipped by the GPU anyway.\n            }\n            else {\n                if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {\n                    // If we don't use depth clamping, we must define minZ so that all shadow casters are in the cascade frustum\n                    viewMinZ = Math.min(viewMinZ, castersViewMinZ);\n                    if (this.filter !== ShadowGenerator.FILTER_PCSS) {\n                        // We do not need the actual distance between the currently shaded pixel and the occluder when generating shadows, so we can lower the far plane to increase the accuracy of the shadow map.\n                        viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);\n                    }\n                }\n                else {\n                    // If we use depth clamping (but not PCSS!), we can adjust minZ/maxZ to reduce the range [minZ, maxZ] (and obtain additional precision in the shadow map)\n                    viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);\n                    // Thanks to depth clamping, casters won't be Z clipped even if they fall outside the [-1,1] range, so we can move the near plane to 0 if castersViewMinZ < 0.\n                    // We will generate negative Z values in the shadow map, but that's okay (they will be clamped to the 0..1 range anyway), except in PCSS case\n                    // where we need the actual distance between the currently shader pixel and the occluder: that's why we don't use depth clamping in PCSS case.\n                    viewMinZ = Math.max(viewMinZ, castersViewMinZ);\n                    // If all the casters are behind the near plane of the cascade, minZ = 0 due to the previous line, and maxZ < 0 at this point.\n                    // We need to make sure that maxZ > minZ, so in this case we set maxZ a little higher than minZ. As we are using depth clamping, the casters won't be Z clipped, so we just need to make sure that we have a valid Z range for the cascade.\n                    // Having a 0 range is not ok, due to undefined behavior in the calculation in this case.\n                    viewMaxZ = Math.max(viewMinZ + 1.0, viewMaxZ);\n                }\n            }\n            Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? viewMaxZ : viewMinZ, useReverseDepthBuffer ? viewMinZ : viewMaxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);\n            this._cascadeMinExtents[cascadeIndex].z = viewMinZ;\n            this._cascadeMaxExtents[cascadeIndex].z = viewMaxZ;\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n            // Create the rounding matrix, by projecting the world-space origin and determining\n            // the fractional offset in texel space\n            Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], Tmpv1); // tmpv1 = shadowOrigin\n            Tmpv1.scaleInPlace(this._mapSize / 2);\n            Tmpv2.copyFromFloats(Math.round(Tmpv1.x), Math.round(Tmpv1.y), Math.round(Tmpv1.z)); // tmpv2 = roundedOrigin\n            Tmpv2.subtractInPlace(Tmpv1).scaleInPlace(2 / this._mapSize); // tmpv2 = roundOffset\n            Matrix.TranslationToRef(Tmpv2.x, Tmpv2.y, 0.0, TmpMatrix);\n            this._projectionMatrices[cascadeIndex].multiplyToRef(TmpMatrix, this._projectionMatrices[cascadeIndex]);\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n            this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);\n        }\n    }\n    // Get the 8 points of the view frustum in world space\n    _computeFrustumInWorldSpace(cascadeIndex) {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;\n        const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;\n        camera.getViewMatrix(); // make sure the transformation matrix we get when calling 'getTransformationMatrix()' is calculated with an up to date view matrix\n        const cameraInfiniteFarPlane = camera.maxZ === 0;\n        const saveCameraMaxZ = camera.maxZ;\n        if (cameraInfiniteFarPlane) {\n            camera.maxZ = this._shadowMaxZ;\n            camera.getProjectionMatrix(true);\n        }\n        const invViewProj = Matrix.Invert(camera.getTransformationMatrix());\n        if (cameraInfiniteFarPlane) {\n            camera.maxZ = saveCameraMaxZ;\n            camera.getProjectionMatrix(true);\n        }\n        const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++cornerIndex) {\n            Tmpv1.copyFrom(CascadedShadowGenerator._FrustumCornersNdcSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator._FrustumCornersNdcSpace.length]);\n            if (isNDCHalfZRange && Tmpv1.z === -1) {\n                Tmpv1.z = 0;\n            }\n            Vector3.TransformCoordinatesToRef(Tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n        }\n        // Get the corners of the current cascade slice of the view frustum\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNdcSpace.length / 2; ++cornerIndex) {\n            Tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n            Tmpv2.copyFrom(Tmpv1).scaleInPlace(prevSplitDist); // near corner ray\n            Tmpv1.scaleInPlace(splitDist); // far corner ray\n            Tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(Tmpv1);\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(Tmpv2);\n        }\n    }\n    _computeCascadeFrustum(cascadeIndex) {\n        this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cascadeMaxExtents[cascadeIndex].copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        // Calculate the centroid of the view frustum slice\n        for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n            this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n        }\n        this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);\n        if (this.stabilizeCascades) {\n            // Calculate the radius of a bounding sphere surrounding the frustum corners\n            let sphereRadius = 0;\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n                const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], Tmpv1).length();\n                sphereRadius = Math.max(sphereRadius, dist);\n            }\n            sphereRadius = Math.ceil(sphereRadius * 16) / 16;\n            this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);\n            this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);\n        }\n        else {\n            // Create a temporary view matrix for the light\n            const lightCameraPos = this._frustumCenter[cascadeIndex];\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, Tmpv1); // tmpv1 = look at\n            Matrix.LookAtLHToRef(lightCameraPos, Tmpv1, UpDir, TmpMatrix); // matrix = lightView\n            // Calculate an AABB around the frustum corners\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n                Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], TmpMatrix, Tmpv1);\n                this._cascadeMinExtents[cascadeIndex].minimizeInPlace(Tmpv1);\n                this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(Tmpv1);\n            }\n        }\n    }\n    _recreateSceneUBOs() {\n        this._disposeSceneUBOs();\n        if (this._sceneUBOs) {\n            for (let i = 0; i < this._numCascades; ++i) {\n                this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light \"${this._light.name}\" cascade #${i})`));\n            }\n        }\n    }\n    /**\n     *  Support test.\n     */\n    static get IsSupported() {\n        const engine = EngineStore.LastCreatedEngine;\n        if (!engine) {\n            return false;\n        }\n        return engine._features.supportCSM;\n    }\n    /**\n     * Creates a Cascaded Shadow Generator object.\n     * A ShadowGenerator is the required tool to use the shadows.\n     * Each directional light casting shadows needs to use its own ShadowGenerator.\n     * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\n     * @param light The directional light object generating the shadows.\n     * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\n     * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: true)\n     */\n    constructor(mapSize, light, usefulFloatFirst, camera, useRedTextureType = true) {\n        if (!CascadedShadowGenerator.IsSupported) {\n            Logger.Error(\"CascadedShadowMap is not supported by the current engine.\");\n            return;\n        }\n        super(mapSize, light, usefulFloatFirst, camera, useRedTextureType);\n        this.usePercentageCloserFiltering = true;\n    }\n    _initializeGenerator() {\n        this.penumbraDarkness = this.penumbraDarkness ?? 1.0;\n        this._numCascades = this._numCascades ?? CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;\n        this.stabilizeCascades = this.stabilizeCascades ?? false;\n        this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null;\n        this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? false;\n        this._scbiMin = this._scbiMin ?? new Vector3(0, 0, 0);\n        this._scbiMax = this._scbiMax ?? new Vector3(0, 0, 0);\n        this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n        this._breaksAreDirty = this._breaksAreDirty ?? true;\n        this._minDistance = this._minDistance ?? 0;\n        this._maxDistance = this._maxDistance ?? 1;\n        this._currentLayer = this._currentLayer ?? 0;\n        this._shadowMaxZ = this._shadowMaxZ ?? this._getCamera()?.maxZ ?? 10000;\n        this._debug = this._debug ?? false;\n        this._depthClamp = this._depthClamp ?? true;\n        this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? 0.1;\n        this._lambda = this._lambda ?? 0.5;\n        this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? false;\n        this._recreateSceneUBOs();\n        super._initializeGenerator();\n    }\n    _createTargetRenderTexture() {\n        const engine = this._scene.getEngine();\n        const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };\n        this._shadowMap = new RenderTargetTexture(this._light.name + \"_CSMShadowMap\", size, this._scene, false, true, this._textureType, false, undefined, false, false, undefined, this._useRedTextureType ? Constants.TEXTUREFORMAT_RED : Constants.TEXTUREFORMAT_RGBA);\n        this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? Constants.GREATER : Constants.LESS, true, undefined, undefined, undefined, `DepthStencilForCSMShadowGenerator-${this._light.name}`);\n        this._shadowMap.noPrePassRenderer = true;\n    }\n    _initializeShadowMap() {\n        super._initializeShadowMap();\n        if (this._shadowMap === null) {\n            return;\n        }\n        this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);\n        this._viewSpaceFrustumsZ = new Array(this._numCascades);\n        this._frustumLengths = new Array(this._numCascades);\n        this._lightSizeUVCorrection = new Array(this._numCascades * 2);\n        this._depthCorrection = new Array(this._numCascades);\n        this._cascades = [];\n        this._viewMatrices = [];\n        this._projectionMatrices = [];\n        this._transformMatrices = [];\n        this._cascadeMinExtents = [];\n        this._cascadeMaxExtents = [];\n        this._frustumCenter = [];\n        this._shadowCameraPos = [];\n        this._frustumCornersWorldSpace = [];\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n            this._cascades[cascadeIndex] = {\n                prevBreakDistance: 0,\n                breakDistance: 0,\n            };\n            this._viewMatrices[cascadeIndex] = Matrix.Zero();\n            this._projectionMatrices[cascadeIndex] = Matrix.Zero();\n            this._transformMatrices[cascadeIndex] = Matrix.Zero();\n            this._cascadeMinExtents[cascadeIndex] = new Vector3();\n            this._cascadeMaxExtents[cascadeIndex] = new Vector3();\n            this._frustumCenter[cascadeIndex] = new Vector3();\n            this._shadowCameraPos[cascadeIndex] = new Vector3();\n            this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator._FrustumCornersNdcSpace.length);\n            for (let i = 0; i < CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++i) {\n                this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();\n            }\n        }\n        const engine = this._scene.getEngine();\n        this._shadowMap.onBeforeBindObservable.clear();\n        this._shadowMap.onBeforeRenderObservable.clear();\n        this._shadowMap.onBeforeRenderObservable.add((layer) => {\n            if (this._sceneUBOs) {\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);\n            }\n            this._currentLayer = layer;\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.setColorWrite(false);\n            }\n            this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));\n            if (this._useUBO) {\n                this._scene.getSceneUniformBuffer().unbindEffect();\n                this._scene.finalizeSceneUbo();\n            }\n        });\n        this._shadowMap.onBeforeBindObservable.add(() => {\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\n            engine._debugPushGroup?.(`cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\n            if (this._breaksAreDirty) {\n                this._splitFrustum();\n            }\n            this._computeMatrices();\n        });\n        this._splitFrustum();\n    }\n    _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {\n        effect.setMatrix(\"viewProjection\", this.getCascadeTransformMatrix(this._currentLayer));\n    }\n    _isReadyCustomDefines(defines) {\n        defines.push(\"#define SM_DEPTHCLAMP \" + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? \"1\" : \"0\"));\n    }\n    /**\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\n     * @param defines Defines of the material we want to update\n     * @param lightIndex Index of the light in the enabled light list of the material\n     */\n    prepareDefines(defines, lightIndex) {\n        super.prepareDefines(defines, lightIndex);\n        const scene = this._scene;\n        const light = this._light;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        defines[\"SHADOWCSM\" + lightIndex] = true;\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = this.debug;\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = this.numCascades;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = scene.useRightHandedSystem;\n        const camera = this._getCamera();\n        if (camera && this._shadowMaxZ <= (camera.maxZ || this._shadowMaxZ)) {\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = true;\n        }\n        if (this.cascadeBlendPercentage === 0) {\n            defines[\"SHADOWCSMNOBLEND\" + lightIndex] = true;\n        }\n    }\n    /**\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\n     * defined in the generator but impacting the effect).\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\n     * @param effect The effect we are binfing the information for\n     */\n    bindShadowLight(lightIndex, effect) {\n        const light = this._light;\n        const scene = this._scene;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return;\n        }\n        const width = shadowMap.getSize().width;\n        effect.setMatrices(\"lightMatrix\" + lightIndex, this._transformMatricesAsArray);\n        effect.setArray(\"viewFrustumZ\" + lightIndex, this._viewSpaceFrustumsZ);\n        effect.setFloat(\"cascadeBlendFactor\" + lightIndex, this.cascadeBlendPercentage === 0 ? 10000 : 1 / this.cascadeBlendPercentage);\n        effect.setArray(\"frustumLengths\" + lightIndex, this._frustumLengths);\n        // Only PCF uses depth stencil texture.\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\n            effect.setDepthStencilTexture(\"shadowTexture\" + lightIndex, shadowMap);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else if (this._filter === ShadowGenerator.FILTER_PCSS) {\n            for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 0] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x); // x correction\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 1] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y); // y correction\n                this._depthCorrection[cascadeIndex] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);\n            }\n            effect.setDepthStencilTexture(\"shadowTexture\" + lightIndex, shadowMap);\n            effect.setTexture(\"depthTexture\" + lightIndex, shadowMap);\n            effect.setArray2(\"lightSizeUVCorrection\" + lightIndex, this._lightSizeUVCorrection);\n            effect.setArray(\"depthCorrection\" + lightIndex, this._depthCorrection);\n            effect.setFloat(\"penumbraDarkness\" + lightIndex, this.penumbraDarkness);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else {\n            effect.setTexture(\"shadowTexture\" + lightIndex, shadowMap);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n        }\n        light._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);\n    }\n    /**\n     * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.\n     * (eq to view projection * shadow projection matrices)\n     * @returns The transform matrix used to create the shadow map\n     */\n    getTransformMatrix() {\n        return this.getCascadeTransformMatrix(0);\n    }\n    /**\n     * Disposes the ShadowGenerator.\n     * Returns nothing.\n     */\n    dispose() {\n        super.dispose();\n        if (this._freezeShadowCastersBoundingInfoObservable) {\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n            this._freezeShadowCastersBoundingInfoObservable = null;\n        }\n        if (this._depthReducer) {\n            this._depthReducer.dispose();\n            this._depthReducer = null;\n        }\n    }\n    /**\n     * Serializes the shadow generator setup to a json object.\n     * @returns The serialized JSON object\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return serializationObject;\n        }\n        serializationObject.numCascades = this._numCascades;\n        serializationObject.debug = this._debug;\n        serializationObject.stabilizeCascades = this.stabilizeCascades;\n        serializationObject.lambda = this._lambda;\n        serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;\n        serializationObject.depthClamp = this._depthClamp;\n        serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;\n        serializationObject.shadowMaxZ = this._shadowMaxZ;\n        serializationObject.penumbraDarkness = this.penumbraDarkness;\n        serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;\n        serializationObject.minDistance = this.minDistance;\n        serializationObject.maxDistance = this.maxDistance;\n        serializationObject.renderList = [];\n        if (shadowMap.renderList) {\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\n                const mesh = shadowMap.renderList[meshIndex];\n                serializationObject.renderList.push(mesh.id);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\n     * @param parsedShadowGenerator The JSON object to parse\n     * @param scene The scene to create the shadow map for\n     * @returns The parsed shadow generator\n     */\n    static Parse(parsedShadowGenerator, scene) {\n        const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new CascadedShadowGenerator(mapSize, light, undefined, camera));\n        if (parsedShadowGenerator.numCascades !== undefined) {\n            shadowGenerator.numCascades = parsedShadowGenerator.numCascades;\n        }\n        if (parsedShadowGenerator.debug !== undefined) {\n            shadowGenerator.debug = parsedShadowGenerator.debug;\n        }\n        if (parsedShadowGenerator.stabilizeCascades !== undefined) {\n            shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;\n        }\n        if (parsedShadowGenerator.lambda !== undefined) {\n            shadowGenerator.lambda = parsedShadowGenerator.lambda;\n        }\n        if (parsedShadowGenerator.cascadeBlendPercentage !== undefined) {\n            shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;\n        }\n        if (parsedShadowGenerator.depthClamp !== undefined) {\n            shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;\n        }\n        if (parsedShadowGenerator.autoCalcDepthBounds !== undefined) {\n            shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;\n        }\n        if (parsedShadowGenerator.shadowMaxZ !== undefined) {\n            shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;\n        }\n        if (parsedShadowGenerator.penumbraDarkness !== undefined) {\n            shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;\n        }\n        if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== undefined) {\n            shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;\n        }\n        if (parsedShadowGenerator.minDistance !== undefined && parsedShadowGenerator.maxDistance !== undefined) {\n            shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);\n        }\n        return shadowGenerator;\n    }\n}\nCascadedShadowGenerator._FrustumCornersNdcSpace = [\n    new Vector3(-1.0, +1.0, -1.0),\n    new Vector3(+1.0, +1.0, -1.0),\n    new Vector3(+1.0, -1.0, -1.0),\n    new Vector3(-1.0, -1.0, -1.0),\n    new Vector3(-1.0, +1.0, +1.0),\n    new Vector3(+1.0, +1.0, +1.0),\n    new Vector3(+1.0, -1.0, +1.0),\n    new Vector3(-1.0, -1.0, +1.0),\n];\n/**\n * Name of the CSM class\n */\nCascadedShadowGenerator.CLASSNAME = \"CascadedShadowGenerator\";\n/**\n * Defines the default number of cascades used by the CSM.\n */\nCascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;\n/**\n * Defines the minimum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MIN_CASCADES_COUNT = 2;\n/**\n * Defines the maximum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MAX_CASCADES_COUNT = 4;\n/**\n * @internal\n */\nCascadedShadowGenerator._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"ShadowGeneratorSceneComponent\");\n};\n//# sourceMappingURL=cascadedShadowGenerator.js.map","import { ShadowGenerator } from \"./shadowGenerator\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\nimport { SceneComponentConstants } from \"../../sceneComponent\";\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\n// Adds the parser to the scene parsers.\nAddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {\n    // Shadows\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            else {\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            // SG would be available on their associated lights\n        }\n    }\n});\n/**\n * Defines the shadow generator component responsible to manage any shadow generators\n * in a given scene.\n */\nexport class ShadowGeneratorSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing To Do Here.\n    }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        // Shadows\n        serializationObject.shadowGenerators = [];\n        const lights = this.scene.lights;\n        for (const light of lights) {\n            if (light.doNotSerialize) {\n                continue;\n            }\n            const shadowGenerators = light.getShadowGenerators();\n            if (shadowGenerators) {\n                const iterator = shadowGenerators.values();\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                    const shadowGenerator = key.value;\n                    if (shadowGenerator.doNotSerialize) {\n                        continue;\n                    }\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     * @param container the container holding the elements\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addFromContainer(container) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     * @param container contains the elements to remove\n     * @param dispose if the removed element should be disposed (default: false)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    removeFromContainer(container, dispose) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    dispose() {\n        // Nothing To Do Here.\n    }\n    _gatherRenderTargets(renderTargets) {\n        // Shadows\n        const scene = this.scene;\n        if (this.scene.shadowsEnabled) {\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n                const light = scene.lights[lightIndex];\n                const shadowGenerators = light.getShadowGenerators();\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\n                    const iterator = shadowGenerators.values();\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                        const shadowGenerator = key.value;\n                        const shadowMap = shadowGenerator.getShadowMap();\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\n                            renderTargets.push(shadowMap);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nShadowGenerator._SceneComponentInitialization = (scene) => {\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n    if (!component) {\n        component = new ShadowGeneratorSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=shadowGeneratorSceneComponent.js.map"],"names":["name","shader","ShaderStore","ShadersStore","depthPixelShader","IncludesShadersStore","depthVertexShader","DepthTextureType","DepthRenderer","shaderLanguage","this","_shaderLanguage","setMaterialForRendering","mesh","material","_depthMap","constructor","scene","type","Constants","TEXTURETYPE_FLOAT","camera","storeNonLinearDepth","samplingMode","Texture","TRILINEAR_SAMPLINGMODE","storeCameraSpaceZ","enabled","forceDepthWriteTransparentMeshes","useOnlyInActiveCamera","reverseCulling","_shadersLoaded","_scene","_storeNonLinearDepth","_storeCameraSpaceZ","isPacked","TEXTURETYPE_UNSIGNED_BYTE","clearColor","Color4","_initShaderSourceAsync","_SceneComponentInitialization","engine","getEngine","_camera","NEAREST_SAMPLINGMODE","_caps","textureFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","textureHalfFloatLinearFiltering","format","_features","supportExtendedTextureFormats","TEXTUREFORMAT_RGBA","TEXTUREFORMAT_R","RenderTargetTexture","width","getRenderWidth","height","getRenderHeight","undefined","wrapU","CLAMP_ADDRESSMODE","wrapV","refreshRate","renderParticles","renderList","noPrePassRenderer","activeCamera","ignoreCameraViewport","useCameraPostProcesses","onClearObservable","add","clear","onBeforeBindObservable","_debugPushGroup","onAfterUnbindObservable","_debugPopGroup","customIsReadyFunction","preWarm","subMeshes","i","length","subMesh","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","hasThinInstances","isReady","renderSubMesh","effectiveMesh","getEffectiveMesh","getMaterial","_internalAbstractMeshDataInfo","_isActiveIntermediate","infiniteDistance","disableDepthWrite","verticesCount","_renderId","getRenderId","detNeg","_getWorldMatrixDeterminant","sideOrientation","_getEffectiveOrientation","MATERIAL_ClockWiseSideOrientation","MATERIAL_CounterClockWiseSideOrientation","reverseSideOrientation","setState","backFaceCulling","cullBackFaces","mustReturn","renderingMaterial","_materialForRenderPass","currentRenderPassId","drawWrapper","_getDrawWrapper","cameraIsOrtho","mode","Camera","ORTHOGRAPHIC_CAMERA","effect","minZ","maxZ","enableEffect","_bind","fillMode","bindForSubMesh","getWorldMatrix","setMatrix","getTransformMatrix","getViewMatrix","useReverseDepthBuffer","isNDCHalfZRange","setFloat2","needAlphaTestingForMesh","alphaTexture","getAlphaTestTexture","setTexture","getTextureMatrix","BindBonesParameters","BindClipPlane","BindMorphTargetParameters","morphTargetManager","isUsingTextureForTargets","bvaManager","getMesh","bakedVertexAnimationManager","isEnabled","bind","pointsCloud","setFloat","pointSize","_processRendering","isInstance","world","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","index","data","forceGLSL","isWebGPU","ForceGLSL","Promise","all","resolve","then","depth_vertex","depth_fragment","import","useInstances","getScene","isReadyForSubMesh","defines","attribs","VertexBuffer","PositionKind","uv1","uv2","push","isVerticesDataPresent","UVKind","UV2Kind","fallbacks","EffectFallbacks","useBones","computeBonesUsingShaders","skeleton","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","addCPUSkinningFallback","isUsingTextureForMatrices","bones","numMorphInfluencers","PrepareDefinesAndAttributesForMorphTargets","PushAttributesForInstances","PrepareStringDefinesForClipPlanes","cachedDefines","join","uniforms","samplers","AddClipPlaneUniforms","setEffect","createEffect","attributes","uniformsNames","uniformBuffersNames","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","getDepthMap","dispose","keysToDelete","key","_depthRenderer","_","_WarnImport","ThinMinMaxReducerPostProcess","EffectWrapper","_gatherImports","useWebGPU","list","_webGPUReady","options","super","Engine","LastCreatedEngine","useShaderStore","useAsPostProcess","fragmentShader","FragmentUrl","Uniforms","textureWidth","textureHeight","noDefaultBindings","setInt2","BufferFloat","Float32Array","BufferUint8","Uint8Array","MinMax","min","max","ThinMinMaxReducer","depthRedux","_depthRedux","value","_recreatePostProcesses","_textureWidth","_textureHeight","onAfterReductionPerformed","Observable","reductionSteps","setTextureDimensions","depthTextureType","_depthTextureType","readMinMax","texture","isFloat","buffer","_readTexturePixels","notifyObservers","disposeAll","w","h","reductionInitial","Math","round","reduction","minmaxReduxPixelShader","ShadersStoreWGSL","minmaxReduxPixelShaderWGSL","MinMaxReducer","_thinMinMaxReducer","_onAfterUnbindObserver","_forceFullscreenViewport","_activated","_postProcessManager","PostProcessManager","_reductionSteps","_onContextRestoredObserver","onContextRestoredObservable","_rebuild","sourceTexture","_sourceTexture","setSourceTexture","forceFullscreenViewport","deactivate","_disposePostProcesses","reductionStep","postProcess","PostProcess","effectWrapper","TEXTURE_NEAREST_NEAREST","textureType","textureFormat","TEXTUREFORMAT_RG","size","autoClear","externalTextureSamplerBinding","onApplyObservable","onAfterRenderObservable","inputTexture","activated","activate","directRender","unBindFramebuffer","remove","DepthReducer","depthRenderer","setDepthRenderer","_depthRendererId","id","TEXTURE_NEAREST_SAMPLINGMODE","UpDir","Vector3","Up","ZeroVec","Zero","Tmpv1","Tmpv2","TmpMatrix","Matrix","CascadedShadowGenerator","ShadowGenerator","_validateFilter","filter","FILTER_NONE","FILTER_PCF","FILTER_PCSS","Logger","Error","numCascades","_numCascades","MIN_CASCADES_COUNT","MAX_CASCADES_COUNT","recreateShadowMap","_recreateSceneUBOs","freezeShadowCastersBoundingInfo","_freezeShadowCastersBoundingInfo","freeze","_freezeShadowCastersBoundingInfoObservable","onBeforeRenderObservable","_computeShadowCastersBoundingInfo","_scbiMin","copyFromFloats","Number","MAX_VALUE","_scbiMax","_shadowMap","meshIndex","boundingBox","getBoundingInfo","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","_shadowCastersBoundingInfo","reConstruct","shadowCastersBoundingInfo","boundingInfo","setMinMaxDistance","_minDistance","_maxDistance","_breaksAreDirty","minDistance","maxDistance","getClassName","CLASSNAME","getCascadeMinExtents","cascadeIndex","_cascadeMinExtents","getCascadeMaxExtents","_cascadeMaxExtents","shadowMaxZ","_getCamera","_shadowMaxZ","_light","_markMeshesAsLightDirty","debug","_debug","dbg","depthClamp","_depthClamp","cascadeBlendPercentage","_cascadeBlendPercentage","lambda","_lambda","getCascadeViewMatrix","cascadeNum","_viewMatrices","getCascadeProjectionMatrix","_projectionMatrices","getCascadeTransformMatrix","_transformMatrices","_depthReducer","autoCalcDepthBounds","_autoCalcDepthBounds","minmax","autoCalcDepthBoundsRefreshRate","splitFrustum","_splitFrustum","near","far","cameraRange","range","ratio","_cascades","p","log","uniform","d","prevBreakDistance","breakDistance","_viewSpaceFrustumsZ","_frustumLengths","_computeMatrices","NormalizeToRef","getShadowDirection","_lightDirection","abs","Dot","z","_cachedDirection","copyFrom","_computeFrustumInWorldSpace","_computeCascadeFrustum","subtractToRef","_frustumCenter","addToRef","scale","_shadowCameraPos","LookAtLHToRef","viewMinZ","viewMaxZ","update","castersViewMinZ","castersViewMaxZ","OrthoOffCenterLHToRef","x","y","multiplyToRef","TransformCoordinatesToRef","scaleInPlace","_mapSize","subtractInPlace","TranslationToRef","copyToArray","_transformMatricesAsArray","prevSplitDist","splitDist","cameraInfiniteFarPlane","saveCameraMaxZ","getProjectionMatrix","invViewProj","Invert","getTransformationMatrix","cornerIndexOffset","cornerIndex","_FrustumCornersNdcSpace","_frustumCornersWorldSpace","addInPlace","stabilizeCascades","sphereRadius","dist","ceil","lightCameraPos","_disposeSceneUBOs","_sceneUBOs","createSceneUniformBuffer","IsSupported","EngineStore","supportCSM","mapSize","light","usefulFloatFirst","useRedTextureType","usePercentageCloserFiltering","_initializeGenerator","penumbraDarkness","DEFAULT_CASCADES_COUNT","BoundingInfo","_currentLayer","_createTargetRenderTexture","layers","_textureType","_useRedTextureType","TEXTUREFORMAT_RED","createDepthStencilTexture","GREATER","LESS","_initializeShadowMap","Array","_lightSizeUVCorrection","_depthCorrection","layer","setSceneUniformBuffer","_filter","setColorWrite","setTransformMatrix","_useUBO","getSceneUniformBuffer","unbindEffect","finalizeSceneUbo","_currentSceneUBO","_bindCustomEffectForRenderSubMeshForShadowMap","_isReadyCustomDefines","prepareDefines","lightIndex","shadowsEnabled","shadowEnabled","useRightHandedSystem","bindShadowLight","shadowMap","getShadowMap","getSize","setMatrices","setArray","setDepthStencilTexture","_uniformBuffer","updateFloat4","getDarkness","frustumEdgeFalloff","setArray2","_contactHardeningLightSizeUVRatio","updateFloat2","getLight","getDepthMinZ","getDepthMaxZ","serialize","serializationObject","Parse","parsedShadowGenerator","shadowGenerator","ShadowGeneratorSceneComponent","SceneComponentConstants","NAME_SHADOWGENERATOR","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","shadowGenerators","lights","doNotSerialize","getShadowGenerators","iterator","values","next","done","addFromContainer","container","removeFromContainer","renderTargets","textures","indexOf","component","_getComponent","_addComponent"],"mappings":"ooBAKA,MAAMA,EAAO,mBACPC,EAAS,q0BA0CVC,EAAYC,aAAaH,KAC1BE,EAAYC,aAAaH,GAAQC,GAG9B,MAAMG,EAAmB,CAAAJ,KAAEA,EAAIC,OAAEA,4DClDxC,MAAMD,EAAO,8BAMRE,EAAYG,qBAAqBL,KAClCE,EAAYG,qBAAqBL,GANtB,wDCaf,MAAMA,EAAO,oBACPC,EAAS,skDA4DVC,EAAYC,aAAaH,KAC1BE,EAAYC,aAAaH,GAAQC,GAG9B,MAAMK,EAAoB,CAAAN,KAAEA,EAAIC,OAAEA,OC3E9BM,wDCUJ,MAAMC,EAIT,kBAAIC,GACA,OAAOC,KAAKC,eACpB,CAMI,uBAAAC,CAAwBC,EAAMC,GAC1BJ,KAAKK,UAAUH,wBAAwBC,EAAMC,EACrD,CAWI,WAAAE,CAAYC,EAAOC,EAAOC,EAAUC,kBAAmBC,EAAS,KAAMC,GAAsB,EAAOC,EAAeC,EAAQC,uBAAwBC,GAAoB,EAAO1B,GAEzKU,KAAKC,gBAAkB,EAEvBD,KAAKiB,SAAU,EAEfjB,KAAKkB,kCAAmC,EAMxClB,KAAKmB,uBAAwB,EAI7BnB,KAAKoB,gBAAiB,EACtBpB,KAAKqB,gBAAiB,EACtBrB,KAAKsB,OAASf,EACdP,KAAKuB,qBAAuBX,EAC5BZ,KAAKwB,mBAAqBR,EAC1BhB,KAAKyB,SAAWjB,IAASC,EAAUiB,0BAC/B1B,KAAKyB,SACLzB,KAAK2B,WAAa,IAAIC,EAAO,EAAK,EAAK,EAAK,GAG5C5B,KAAK2B,WAAa,IAAIC,EAAOZ,EAAoB,EAAM,EAAK,EAAK,EAAK,GAG1EhB,KAAK6B,yBACL/B,EAAcgC,8BAA8B9B,KAAKsB,QACjD,MAAMS,EAASxB,EAAMyB,YACrBhC,KAAKiC,QAAUtB,EACXE,IAAiBC,EAAQoB,uBACrB1B,IAASC,EAAUC,mBAAsBqB,EAAOI,MAAMC,8BACtDvB,EAAeC,EAAQoB,sBAEvB1B,IAASC,EAAU4B,wBAA2BN,EAAOI,MAAMG,kCAC3DzB,EAAeC,EAAQoB,uBAI/B,MAAMK,EAASvC,KAAKyB,WAAaM,EAAOS,UAAUC,8BAAgChC,EAAUiC,mBAAqBjC,EAAUkC,gBAC3H3C,KAAKK,UAAY,IAAIuC,EAAoBtD,GAAQ,gBAAiB,CAAEuD,MAAOd,EAAOe,iBAAkBC,OAAQhB,EAAOiB,mBAAqBhD,KAAKsB,QAAQ,GAAO,EAAMd,GAAM,EAAOK,OAAcoC,OAAWA,OAAWA,EAAWV,GAC9NvC,KAAKK,UAAU6C,MAAQpC,EAAQqC,kBAC/BnD,KAAKK,UAAU+C,MAAQtC,EAAQqC,kBAC/BnD,KAAKK,UAAUgD,YAAc,EAC7BrD,KAAKK,UAAUiD,iBAAkB,EACjCtD,KAAKK,UAAUkD,WAAa,KAC5BvD,KAAKK,UAAUmD,mBAAoB,EAEnCxD,KAAKK,UAAUoD,aAAezD,KAAKiC,QACnCjC,KAAKK,UAAUqD,sBAAuB,EACtC1D,KAAKK,UAAUsD,wBAAyB,EAExC3D,KAAKK,UAAUuD,kBAAkBC,KAAK9B,IAClCA,EAAO+B,MAAM9D,KAAK2B,YAAY,GAAM,GAAM,MAE9C3B,KAAKK,UAAU0D,uBAAuBF,KAAI,KACtC9B,EAAOiC,kBAAkB,iBAAkB,MAE/ChE,KAAKK,UAAU4D,wBAAwBJ,KAAI,KACvC9B,EAAOmC,iBAAiB,MAE5BlE,KAAKK,UAAU8D,sBAAwB,CAAChE,EAAMkD,EAAae,KACvD,IAAKA,GAA2B,IAAhBf,IAAsBlD,EAAKkE,UACvC,IAAK,IAAIC,EAAI,EAAGA,EAAInE,EAAKkE,UAAUE,SAAUD,EAAG,CAC5C,MAAME,EAAUrE,EAAKkE,UAAUC,GACzBG,EAAgBD,EAAQE,mBACxBC,EAAQF,EAAcG,wBAAwBJ,EAAQK,MAAOL,EAAQM,sBACrEC,EAA6BhD,EAAOiD,UAAUC,kBACN,OAAxCN,EAAMO,iBAAiBV,EAAQK,WAAyD5B,IAAxC0B,EAAMO,iBAAiBV,EAAQK,MAAuBJ,EAAcU,kBAC1H,IAAKnF,KAAKoF,QAAQZ,EAASO,GACvB,OAAO,CAE/B,CAEY,OAAO,GAGX,MAAMM,EAAiBb,IACnB,MAAMC,EAAgBD,EAAQE,mBACxBY,EAAgBd,EAAQe,mBACxBhF,EAAQP,KAAKsB,OACbS,EAASxB,EAAMyB,YACf5B,EAAWoE,EAAQgB,cAEzB,GADAF,EAAcG,8BAA8BC,uBAAwB,GAC/DtF,GAAYkF,EAAcK,kBAAoBvF,EAASwF,mBAA+C,IAA1BpB,EAAQqB,eAAuBrB,EAAQsB,YAAcvF,EAAMwF,cACxI,OAGJ,MAAMC,EAASV,EAAcW,6BAA+B,EAC5D,IAAIC,EAAkB9F,EAAS+F,yBAAyB1B,GACpDuB,IACAE,EACIA,IAAoBzF,EAAU2F,kCACxB3F,EAAU4F,yCACV5F,EAAU2F,mCAExB,MAAME,EAAyBJ,IAAoBzF,EAAU2F,kCAC7DrE,EAAOwE,SAASnG,EAASoG,gBAAiB,GAAG,EAAOF,EAAwBtG,KAAKoB,gBAAkBhB,EAASqG,cAAgBrG,EAASqG,eAErI,MAAM9B,EAAQF,EAAcG,wBAAwBJ,EAAQK,MAAOL,EAAQM,sBAC3E,GAAIH,EAAM+B,WACN,OAEJ,MAAM3B,EAA6BhD,EAAOiD,UAAUC,kBACN,OAAxCN,EAAMO,iBAAiBV,EAAQK,WAAyD5B,IAAxC0B,EAAMO,iBAAiBV,EAAQK,MAAuBJ,EAAcU,kBACpHxE,EAASX,KAAKiC,SAAW1B,EAAMkD,aACrC,GAAIzD,KAAKoF,QAAQZ,EAASO,IAA+BpE,EAAQ,CAC7D6D,EAAQsB,UAAYvF,EAAMwF,cAC1B,MAAMY,EAAoBrB,EAAcG,8BAA8BmB,yBAAyB7E,EAAO8E,qBACtG,IAAIC,EAActC,EAAQuC,mBACrBD,GAAeH,IAChBG,EAAcH,EAAkBI,mBAEpC,MAAMC,EAAgBrG,EAAOsG,OAASC,EAAOC,oBAC7C,IAAKL,EACD,OAEJ,MAAMM,EAASN,EAAYM,OAe3B,IAAIC,EAAMC,EAUV,GAxBAvF,EAAOwF,aAAaT,GACf/B,GACDN,EAAc+C,MAAMhD,EAAS4C,EAAQhH,EAASqH,UAE7Cd,EAQDA,EAAkBe,eAAepC,EAAcqC,iBAAkBrC,EAAed,IAPhF4C,EAAOQ,UAAU,iBAAkBrH,EAAMsH,sBACzCT,EAAOQ,UAAU,QAAStC,EAAcqC,kBACpC3H,KAAKwB,oBACL4F,EAAOQ,UAAU,OAAQrH,EAAMuH,kBAOnCd,GACAK,GAAQtF,EAAOgG,uBAAyBhG,EAAOiG,gBAAkB,EAAI,EACrEV,EAAOvF,EAAOgG,uBAAyBhG,EAAOiG,gBAAkB,EAAI,IAGpEX,EAAOtF,EAAOgG,uBAAyBhG,EAAOiG,gBAAkBrH,EAAO0G,KAAOtF,EAAOiG,gBAAkB,EAAIrH,EAAO0G,KAClHC,EAAOvF,EAAOgG,uBAAyBhG,EAAOiG,gBAAkB,EAAIrH,EAAO2G,MAE/EF,EAAOa,UAAU,cAAeZ,EAAMA,EAAOC,IACxCX,EAAmB,CAEpB,GAAIvG,EAAS8H,wBAAwB5C,GAAgB,CACjD,MAAM6C,EAAe/H,EAASgI,sBAC1BD,IACAf,EAAOiB,WAAW,iBAAkBF,GACpCf,EAAOQ,UAAU,gBAAiBO,EAAaG,oBAE3E,CAEoBC,EAAoB9D,EAAe2C,GAEnCoB,EAAcpB,EAAQhH,EAAUG,GAEhCkI,EAA0BhE,EAAe2C,GACrC3C,EAAciE,oBAAsBjE,EAAciE,mBAAmBC,0BACrElE,EAAciE,mBAAmBlB,MAAMJ,GAG3C,MAAMwB,EAAapE,EAAQqE,UAAUC,4BACjCF,GAAcA,EAAWG,WACzBH,EAAWI,KAAK5B,EAAQrC,GAGxB3E,EAAS6I,aACT7B,EAAO8B,SAAS,YAAa9I,EAAS+I,UAE9D,CAEgB1E,EAAc2E,kBAAkB9D,EAAed,EAAS4C,EAAQhH,EAASqH,SAAU9C,EAAOI,GAA4B,CAACsE,EAAYC,IAAUlC,EAAOQ,UAAU,QAAS0B,IACvL,GAEQtJ,KAAKK,UAAUkJ,qBAAuB,CAACC,EAAiBC,EAAoBC,EAAsBC,KAC9F,IAAIC,EACJ,GAAID,EAAmBpF,OACnB,IAAKqF,EAAQ,EAAGA,EAAQD,EAAmBpF,OAAQqF,IAC/CvE,EAAcsE,EAAmBE,KAAKD,IAG9C,IAAKA,EAAQ,EAAGA,EAAQJ,EAAgBjF,OAAQqF,IAC5CvE,EAAcmE,EAAgBK,KAAKD,IAEvC,IAAKA,EAAQ,EAAGA,EAAQH,EAAmBlF,OAAQqF,IAC/CvE,EAAcoE,EAAmBI,KAAKD,IAE1C,GAAI5J,KAAKkB,iCACL,IAAK0I,EAAQ,EAAGA,EAAQF,EAAqBnF,OAAQqF,IACjDvE,EAAcqE,EAAqBG,KAAKD,SAI5C,IAAKA,EAAQ,EAAGA,EAAQF,EAAqBnF,OAAQqF,IACjDF,EAAqBG,KAAKD,GAAOrE,mBAAmBE,8BAA8BC,uBAAwB,EAI9H,CACI,4BAAM7D,CAAuBiI,GAAY,IACtB9J,KAAKsB,OAAOU,YAChB+H,UAAaD,GAAchK,EAAckK,gBAK1CC,QAAQC,IAAI,CAACD,QAAiCE,UAAAC,MAAA,WAAA,OAAAC,CAAA,IAAEJ,QAAmCE,UAAAC,MAAA,WAAA,OAAAE,CAAA,OAJzFtK,KAAKC,gBAAkB,QACjBgK,QAAQC,IAAI,CAACK,OAAO,sCAAgCA,OAAO,2CAKrEvK,KAAKqB,gBAAiB,CAC9B,CAOI,OAAA+D,CAAQZ,EAASgG,GACb,IAAKxK,KAAKqB,eACN,OAAO,EAEX,MAAMU,EAAS/B,KAAKsB,OAAOU,YACrB7B,EAAOqE,EAAQqE,UACftI,EAAQJ,EAAKsK,WACb9D,EAAoBxG,EAAKsF,8BAA8BmB,yBAAyB7E,EAAO8E,qBAC7F,GAAIF,EACA,OAAOA,EAAkB+D,kBAAkBvK,EAAMqE,EAASgG,GAE9D,MAAMpK,EAAWoE,EAAQgB,cACzB,IAAKpF,GAAYA,EAASwF,kBACtB,OAAO,EAEX,MAAM+E,EAAU,GACVC,EAAU,CAACC,EAAaC,cAC9B,IAAIC,GAAM,EACNC,GAAM,EAGN5K,EAAS8H,wBAAwB/H,IAASC,EAASgI,wBACnDuC,EAAQM,KAAK,qBACT9K,EAAK+K,sBAAsBL,EAAaM,UACxCP,EAAQK,KAAKJ,EAAaM,QAC1BR,EAAQM,KAAK,eACbF,GAAM,GAEN5K,EAAK+K,sBAAsBL,EAAaO,WACxCR,EAAQK,KAAKJ,EAAaO,SAC1BT,EAAQM,KAAK,eACbD,GAAM,IAId,MAAMK,EAAY,IAAIC,EACtB,GAAInL,EAAKoL,UAAYpL,EAAKqL,0BAA4BrL,EAAKsL,SAAU,CACjEb,EAAQK,KAAKJ,EAAaa,qBAC1Bd,EAAQK,KAAKJ,EAAac,qBACtBxL,EAAKyL,mBAAqB,IAC1BhB,EAAQK,KAAKJ,EAAagB,0BAC1BjB,EAAQK,KAAKJ,EAAaiB,2BAE9BnB,EAAQM,KAAK,gCAAkC9K,EAAKyL,oBAChDzL,EAAKyL,mBAAqB,GAC1BP,EAAUU,uBAAuB,EAAG5L,GAExC,MAAMsL,EAAWtL,EAAKsL,SAClBA,EAASO,0BACTrB,EAAQM,KAAK,uBAGbN,EAAQM,KAAK,yBAA2BQ,EAASQ,MAAM1H,OAAS,GAEhF,MAEYoG,EAAQM,KAAK,kCAGjB,MAAMiB,EAAsB/L,EAAKuI,mBAC3ByD,EAA2ChM,EAAKuI,mBAAoBiC,EAASC,EAASzK,GAAM,GAC9F,GACA,EACA4K,EACAC,GA7CU,GAgDR,EAEF5K,EAAS6I,aACT0B,EAAQM,KAAK,qBAGbT,IACAG,EAAQM,KAAK,qBACbmB,EAA2BxB,GACvBpG,EAAQE,mBAAmBS,kBAC3BwF,EAAQM,KAAK,2BAIrB,MAAMrC,EAAazI,EAAK2I,4BACpBF,GAAcA,EAAWG,YACzB4B,EAAQM,KAAK,0CACTT,GACAI,EAAQK,KAAK,0CAIjBjL,KAAKuB,sBACLoJ,EAAQM,KAAK,0BAGbjL,KAAKwB,oBACLmJ,EAAQM,KAAK,+BAGbjL,KAAKyB,UACLkJ,EAAQM,KAAK,kBAGjBoB,EAAkCjM,EAAUG,EAAOoK,GAEnD,MAAM7D,EAActC,EAAQuC,qBAAgB9D,GAAW,GACjDqJ,EAAgBxF,EAAY6D,QAC5B4B,EAAO5B,EAAQ4B,KAAK,MAC1B,GAAID,IAAkBC,EAAM,CACxB,MAAMC,EAAW,CACb,QACA,SACA,mBACA,YACA,iBACA,OACA,gBACA,cACA,wBACA,mBACA,yBACA,4BACA,+BACA,0CACA,2BACA,+BAEEC,EAAW,CAAC,iBAAkB,eAAgB,cAAe,+BACnEC,EAAqBF,GACrB1F,EAAY6F,UAAU5K,EAAO6K,aAAa,QAAS,CAC/CC,WAAYjC,EACZkC,cAAeN,EACfO,oBAAqB,GACrBN,SAAUA,EACV9B,QAAS4B,EACTlB,UAAWA,EACX2B,WAAY,KACZC,QAAS,KACTC,gBAAiB,CAAEC,4BAA6BjB,GAChDnM,eAAgBC,KAAKC,iBACtB8B,GAASwK,EACxB,CACQ,OAAOzF,EAAYM,OAAOhC,SAClC,CAKI,WAAAgI,GACI,OAAOpN,KAAKK,SACpB,CAII,OAAAgN,GACI,MAAMC,EAAe,GACrB,IAAK,MAAMC,KAAOvN,KAAKsB,OAAOkM,eAAgB,CACpBxN,KAAKsB,OAAOkM,eAAeD,KAC3BvN,MAClBsN,EAAarC,KAAKsC,EAElC,CACQ,GAAID,EAAa/I,OAAS,EAAG,CACzBvE,KAAKK,UAAUgN,UACf,IAAK,MAAME,KAAOD,SACPtN,KAAKsB,OAAOkM,eAAeD,EAElD,CACA,EAMAzN,EAAckK,WAAY,EAI1BlK,EAAcgC,8BAAiC2L,IAC3C,MAAMC,EAAY,gCD9atB,SAAW7N,GACPA,EAAiBA,EAAsC,oBAAI,GAAK,sBAChEA,EAAiBA,EAA4B,UAAI,GAAK,YACtDA,EAAiBA,EAA8B,YAAI,GAAK,aAC3D,CAJD,CAIGA,IAAqBA,EAAmB,CAAA,IAIpC,MAAM8N,UAAqCC,EAC9C,cAAAC,CAAeC,EAAWC,GAClBD,GACA9N,KAAKgO,cAAe,EACpBD,EAAK9C,KAAKhB,iDAGV8D,EAAK9C,KAAKhB,+CAEtB,CACI,WAAA3J,CAAYhB,EAAMyC,EAAS,KAAM4I,EAAU,GAAIsD,GAC3CC,MAAM,IACCD,EACH3O,OACAyC,OAAQA,GAAUoM,EAAOC,kBACzBC,gBAAgB,EAChBC,kBAAkB,EAClBC,eAAgBZ,EAA6Ba,YAC7ChC,SAAUmB,EAA6Bc,SACvC9D,YAEJ3K,KAAK0O,aAAe,EACpB1O,KAAK2O,cAAgB,CAC7B,CACI,IAAA3F,CAAK4F,GAAoB,GACrBV,MAAMlF,KAAK4F,GACX,MAAMxH,EAASpH,KAAK8G,YAAYM,OACN,IAAtBpH,KAAK0O,cAA6C,IAAvB1O,KAAK2O,cAChCvH,EAAOyH,QAAQ,UAAW7O,KAAK0O,aAAc1O,KAAK2O,eAGlDvH,EAAOa,UAAU,UAAWjI,KAAK0O,aAAc1O,KAAK2O,cAEhE,EAEAhB,EAA6Ba,YAAc,cAC3Cb,EAA6Bc,SAAW,CAAC,WACzC,MAAMK,EAAc,IAAIC,aAAa,GAC/BC,EAAc,IAAIC,WAAW,GAC7BC,EAAS,CAAEC,IAAK,EAAGC,IAAK,GAIvB,MAAMC,EACT,cAAIC,GACA,OAAOtP,KAAKuP,WACpB,CACI,cAAID,CAAWE,GACPxP,KAAKuP,cAAgBC,IAGzBxP,KAAKuP,YAAcC,EACnBxP,KAAKyP,yBACb,CACI,gBAAIf,GACA,OAAO1O,KAAK0P,aACpB,CACI,iBAAIf,GACA,OAAO3O,KAAK2P,cACpB,CACI,WAAArP,CAAYC,EAAO+O,GAAa,GAC5BtP,KAAK4P,0BAA4B,IAAIC,EACrC7P,KAAK0P,cAAgB,EACrB1P,KAAK2P,eAAiB,EACtB3P,KAAKsB,OAASf,EACdP,KAAKuP,YAAcD,EACnBtP,KAAK8P,eAAiB,EAC9B,CACI,oBAAAC,CAAqBlN,EAAOE,EAAQiN,EAAmB,GACnD,OAAInN,IAAU7C,KAAK0P,eAAiB3M,IAAW/C,KAAK2P,gBAAkBK,IAAqBhQ,KAAKiQ,qBAGhGjQ,KAAK0P,cAAgB7M,EACrB7C,KAAK2P,eAAiB5M,EACtB/C,KAAKiQ,kBAAoBD,EACzBhQ,KAAKyP,0BACE,EACf,CACI,UAAAS,CAAWC,GAMP,MAAMC,EAAUD,EAAQ3P,OAAS2N,EAAOzN,mBAAqByP,EAAQ3P,OAAS2N,EAAO9L,uBAC/EgO,EAASD,EAAUtB,EAAcE,EAEvChP,KAAKsB,OAAOU,YAAYsO,mBAAmBH,EAAS,EAAG,GAAK,EAAE,EAAGE,GAAQ,GACzEnB,EAAOC,IAAMkB,EAAO,GACpBnB,EAAOE,IAAMiB,EAAO,GACfD,IACDlB,EAAOC,IAAMD,EAAOC,IAAM,IAC1BD,EAAOE,IAAMF,EAAOE,IAAM,KAE1BF,EAAOC,KAAOD,EAAOE,MACrBF,EAAOC,IAAM,EACbD,EAAOE,IAAM,GAEjBpP,KAAK4P,0BAA0BW,gBAAgBrB,EACvD,CACI,OAAA7B,CAAQmD,GAAa,GACbA,IACAxQ,KAAK4P,0BAA0B9L,QAC/B9D,KAAK0P,cAAgB,EACrB1P,KAAK2P,eAAiB,GAE1B,IAAK,IAAIrL,EAAI,EAAGA,EAAItE,KAAK8P,eAAevL,SAAUD,EAC9CtE,KAAK8P,eAAexL,GAAG+I,UAE3BrN,KAAK8P,eAAevL,OAAS,CACrC,CACI,sBAAAkL,GACIzP,KAAKqN,SAAQ,GACb,MAAM9M,EAAQP,KAAKsB,OACnB,IAAImP,EAAIzQ,KAAK0O,aAAcgC,EAAI1Q,KAAK2O,cACpC,MAAMgC,EAAmB,IAAIhD,EAA6B,0BAA2BpN,EAAMyB,YAAa,mBAAqBhC,KAAKuP,YAAc,wBAA0B,KAAkC,IAA3BvP,KAAKiQ,kBAA2D,uBAAyB,KAC1QU,EAAiBjC,aAAe+B,EAChCE,EAAiBhC,cAAgB+B,EACjC1Q,KAAK8P,eAAe7E,KAAK0F,GACzB,IAAI/G,EAAQ,EAEZ,KAAO6G,EAAI,GAAKC,EAAI,GAAG,CACnBD,EAAIG,KAAKxB,IAAIwB,KAAKC,MAAMJ,EAAI,GAAI,GAChCC,EAAIE,KAAKxB,IAAIwB,KAAKC,MAAMH,EAAI,GAAI,GAChC,MAAMI,EAAY,IAAInD,EAA6B,mBAAqB/D,EAAOrJ,EAAMyB,YAAa,YAAmB,GAALyO,GAAe,GAALC,EAAS,OAAc,GAALD,GAAe,GAALC,EAAS,gBAAkB,SACjLI,EAAUpC,aAAe+B,EACzBK,EAAUnC,cAAgB+B,EAC1B1Q,KAAK8P,eAAe7E,KAAK6F,GACzBlH,GACZ,CACA,EE/IA,MAAMtK,EAAO,yBACPC,EAAS,w4DA+BVC,EAAYC,aAAaH,KAC1BE,EAAYC,aAAaH,GAAQC,GAG9B,MAAMwR,EAAyB,CAAAzR,KAAEA,EAAIC,OAAEA,kECpC9C,MAAMD,EAAO,yBACPC,EAAS,mrEA+BVC,EAAYwR,iBAAiB1R,KAC9BE,EAAYwR,iBAAiB1R,GAAQC,GAGlC,MAAM0R,EAA6B,CAAE3R,OAAMC,6EC1B3C,MAAM2R,EAIT,6BAAItB,GACA,OAAO5P,KAAKmR,mBAAmBvB,yBACvC,CAKI,WAAAtP,CAAYK,GACRX,KAAKoR,uBAAyB,KAC9BpR,KAAKqR,0BAA2B,EAChCrR,KAAKsR,YAAa,EAClBtR,KAAKiC,QAAUtB,EACfX,KAAKuR,oBAAsB,IAAIC,EAAmB7Q,EAAO8J,YACzDzK,KAAKmR,mBAAqB,IAAI9B,EAAkB1O,EAAO8J,YACvDzK,KAAKyR,gBAAkB,GACvBzR,KAAK0R,2BAA6B/Q,EAAOqB,YAAY2P,4BAA4B9N,KAAI,KACjF7D,KAAKuR,oBAAoBK,aAErC,CAII,iBAAIC,GACA,OAAO7R,KAAK8R,cACpB,CAYI,gBAAAC,CAAiBF,EAAevC,EAAY9O,EAAOC,EAAU4B,uBAAwB2P,GAA0B,GAC3G,GAAIH,IAAkB7R,KAAK8R,iBAG3B9R,KAAKmR,mBAAmB7B,WAAaA,EACrCtP,KAAKiS,aACLjS,KAAK8R,eAAiBD,EACtB7R,KAAKqR,yBAA2BW,EAC5BhS,KAAKmR,mBAAmBpB,qBAAqB8B,EAAc/O,iBAAkB+O,EAAc7O,oBAAoB,CAC/GhD,KAAKkS,wBACL,MAAMpC,EAAiB9P,KAAKmR,mBAAmBrB,eAC/C,IAAK,IAAIxL,EAAI,EAAGA,EAAIwL,EAAevL,SAAUD,EAAG,CAC5C,MAAM6N,EAAgBrC,EAAexL,GAC/B8N,EAAc,IAAIC,EAAYF,EAAc7S,KAAMqO,EAA6Ba,YAAa,CAC9F8D,cAAeH,EACftR,aAAcJ,EAAU8R,wBACxBxQ,OAAQ/B,KAAKiC,QAAQwI,WAAWzI,YAChCwQ,YAAahS,EACbiS,cAAehS,EAAUiS,iBACzBC,KAAM,CAAE9P,MAAOsP,EAAczD,aAAc3L,OAAQoP,EAAcxD,iBAErE3O,KAAKyR,gBAAgBxG,KAAKmH,GAC1BA,EAAYQ,WAAY,EACxBR,EAAYJ,wBAA0BA,EAC5B,IAAN1N,IACA8N,EAAYS,+BAAgC,EAC5CT,EAAYU,kBAAkBjP,KAAKuD,IAC/BA,EAAOiB,WAAW,iBAAkBrI,KAAK8R,oBAG7CxN,IAAMwL,EAAevL,OAAS,GAC9BvE,KAAKyR,gBAAgBnN,EAAI,GAAGyO,wBAAwBlP,KAAI,KACpD7D,KAAKmR,mBAAmBjB,WAAWkC,EAAYY,aAAa7C,WAGpF,CACA,CACA,CAKI,eAAI9M,GACA,OAAOrD,KAAK8R,eAAiB9R,KAAK8R,eAAezO,aAAgB,CACzE,CACI,eAAIA,CAAYmM,GACRxP,KAAK8R,iBACL9R,KAAK8R,eAAezO,YAAcmM,EAE9C,CAII,aAAIyD,GACA,OAAOjT,KAAKsR,UACpB,CAMI,QAAA4B,IACQlT,KAAKoR,wBAA2BpR,KAAK8R,iBAGzC9R,KAAKoR,uBAAyBpR,KAAK8R,eAAe7N,wBAAwBJ,KAAI,KAC1E,MAAM9B,EAAS/B,KAAKiC,QAAQwI,WAAWzI,YACvCD,EAAOiC,kBAAkB,oBAAqB,GAC9ChE,KAAKyR,gBAAgB,GAAGyB,SAASlT,KAAKiC,SACtCjC,KAAKuR,oBAAoB4B,aAAanT,KAAKyR,gBAAiBzR,KAAKyR,gBAAgB,GAAGuB,aAAchT,KAAKqR,yBAA0B,EAAG,GAAG,EAAMrR,KAAKyR,gBAAgBlN,OAAS,GAC3KxC,EAAOqR,kBAAkBpT,KAAKyR,gBAAgBzR,KAAKyR,gBAAgBlN,OAAS,GAAGyO,cAAc,GAC7FjR,EAAOmC,iBAAiB,MAE5BlE,KAAKsR,YAAa,EAC1B,CAII,UAAAW,GACSjS,KAAKoR,wBAA2BpR,KAAK8R,iBAG1C9R,KAAK8R,eAAe7N,wBAAwBoP,OAAOrT,KAAKoR,wBACxDpR,KAAKoR,uBAAyB,KAC9BpR,KAAKsR,YAAa,EAC1B,CAKI,OAAAjE,CAAQmD,GAAa,GACZA,IAGLxQ,KAAK4P,0BAA0B9L,QAC/B9D,KAAKiC,QAAQD,YAAY2P,4BAA4B0B,OAAOrT,KAAK0R,4BACjE1R,KAAK0R,gCAA6BzO,EAClCjD,KAAKkS,wBACLlS,KAAKuR,oBAAoBlE,UACzBrN,KAAKuR,yBAAsBtO,EAC3BjD,KAAKmR,mBAAmB9D,UACxBrN,KAAKmR,wBAAqBlO,EAC1BjD,KAAK8R,eAAiB,KAC9B,CACI,qBAAAI,GACI,IAAK,IAAI5N,EAAI,EAAGA,EAAItE,KAAKyR,gBAAgBlN,SAAUD,EAC/CtE,KAAKyR,gBAAgBnN,GAAG+I,UAE5BrN,KAAKyR,gBAAgBlN,OAAS,CACtC,EC3JO,MAAM+O,UAAqBpC,EAK9B,iBAAIqC,GACA,OAAOvT,KAAKwN,cACpB,CAKI,WAAAlN,CAAYK,GACRuN,MAAMvN,EACd,CAOI,gBAAA6S,CAAiBD,EAAgB,KAAM/S,EAAOC,EAAU4B,uBAAwB2P,GAA0B,GACtG,MAAMzR,EAAQP,KAAKiC,QAAQwI,WACvBzK,KAAKwN,wBACEjN,EAAMiN,eAAexN,KAAKyT,kBACjCzT,KAAKwN,eAAeH,UACpBrN,KAAKwN,eAAiB,MAEJ,OAAlB+F,IACKhT,EAAMiN,iBACPjN,EAAMiN,eAAiB,CAAE,GAE7BxN,KAAKyT,iBAAmB,UAAYzT,KAAKiC,QAAQyR,IACjDH,EAAgBvT,KAAKwN,eAAiB,IAAI1N,EAAcS,EAAOC,EAAMR,KAAKiC,SAAS,EAAOxB,EAAUkT,8BAA8B,EAAO,iBAAiB3T,KAAKyT,qBACjJxS,SAAU,EACxBV,EAAMiN,eAAexN,KAAKyT,kBAAoBF,GAElDrF,MAAM6D,iBAAiBwB,EAAcnG,eAAe,EAAM5M,EAAMwR,EACxE,CAII,gBAAAD,CAAiBF,EAAevC,EAAY9O,EAAOC,EAAU4B,uBAAwB2P,GAA0B,GAC3G9D,MAAM6D,iBAAiBF,EAAevC,EAAY9O,EAAMwR,EAChE,CAMI,QAAAkB,GACQlT,KAAKwN,iBACLxN,KAAKwN,eAAevM,SAAU,GAElCiN,MAAMgF,UACd,CAII,UAAAjB,GACI/D,MAAM+D,aACFjS,KAAKwN,iBACLxN,KAAKwN,eAAevM,SAAU,EAE1C,CAKI,OAAAoM,CAAQmD,GAAa,GACjBtC,MAAMb,QAAQmD,GACVxQ,KAAKwN,gBAAkBgD,IACvBxQ,KAAKwN,eAAeH,UACpBrN,KAAKwN,eAAiB,KAElC,ECvEA,MAAMoG,GAAQC,EAAQC,KAEhBC,GAAUF,EAAQG,OAClBC,GAAQ,IAAIJ,EACZK,GAAQ,IAAIL,EACZM,GAAY,IAAIC,EAMf,MAAMC,WAAgCC,EACzC,eAAAC,CAAgBC,GACZ,OAAIA,IAAWF,EAAgBG,aAAeD,IAAWF,EAAgBI,YAAcF,IAAWF,EAAgBK,YACvGH,GAEXI,EAAOC,MAAM,uBAAyBL,EAAS,MACxCF,EAAgBG,YAC/B,CAII,eAAIK,GACA,OAAO9U,KAAK+U,YACpB,CACI,eAAID,CAAYtF,IACZA,EAAQoB,KAAKzB,IAAIyB,KAAKxB,IAAII,EAAO6E,GAAwBW,oBAAqBX,GAAwBY,uBACxFjV,KAAK+U,eAGnB/U,KAAK+U,aAAevF,EACpBxP,KAAKkV,oBACLlV,KAAKmV,qBACb,CAMI,mCAAIC,GACA,OAAOpV,KAAKqV,gCACpB,CACI,mCAAID,CAAgCE,GAC5BtV,KAAKuV,4CAA8CD,IACnDtV,KAAKsB,OAAOkU,yBAAyBnC,OAAOrT,KAAKuV,4CACjDvV,KAAKuV,2CAA6C,MAEjDvV,KAAKuV,4CAA+CD,IACrDtV,KAAKuV,2CAA6CvV,KAAKsB,OAAOkU,yBAAyB3R,KAAI,IAAM7D,KAAKyV,uCAE1GzV,KAAKqV,iCAAmCC,EACpCA,GACAtV,KAAKyV,mCAEjB,CACI,iCAAAA,GAGI,GAFAzV,KAAK0V,SAASC,eAAeC,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WACxE7V,KAAK8V,SAASH,gBAAgBC,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WACvE7V,KAAK+V,YAAc/V,KAAK+V,WAAWxS,WAAY,CAC/C,MAAMA,EAAavD,KAAK+V,WAAWxS,WACnC,IAAK,IAAIyS,EAAY,EAAGA,EAAYzS,EAAWgB,OAAQyR,IAAa,CAChE,MAAM7V,EAAOoD,EAAWyS,GACxB,IAAK7V,EACD,SAEJ,MAA6C8V,EAAxB9V,EAAK+V,kBAA8CD,YACxEjW,KAAK0V,SAASS,gBAAgBF,EAAYG,cAC1CpW,KAAK8V,SAASO,gBAAgBJ,EAAYK,aAC1D,CACA,CACQtW,KAAKuW,2BAA2BC,YAAYxW,KAAK0V,SAAU1V,KAAK8V,SACxE,CAMI,6BAAIW,GACA,OAAOzW,KAAKuW,0BACpB,CACI,6BAAIE,CAA0BC,GAC1B1W,KAAKuW,2BAA6BG,CAC1C,CASI,iBAAAC,CAAkBxH,EAAKC,GACfpP,KAAK4W,eAAiBzH,GAAOnP,KAAK6W,eAAiBzH,IAGnDD,EAAMC,IACND,EAAM,EACNC,EAAM,GAEND,EAAM,IACNA,EAAM,GAENC,EAAM,IACNA,EAAM,GAEVpP,KAAK4W,aAAezH,EACpBnP,KAAK6W,aAAezH,EACpBpP,KAAK8W,iBAAkB,EAC/B,CAEI,eAAIC,GACA,OAAO/W,KAAK4W,YACpB,CAEI,eAAII,GACA,OAAOhX,KAAK6W,YACpB,CAKI,YAAAI,GACI,OAAO5C,GAAwB6C,SACvC,CAMI,oBAAAC,CAAqBC,GACjB,OAAOA,GAAgB,GAAKA,EAAepX,KAAK+U,aAAe/U,KAAKqX,mBAAmBD,GAAgB,IAC/G,CAMI,oBAAAE,CAAqBF,GACjB,OAAOA,GAAgB,GAAKA,EAAepX,KAAK+U,aAAe/U,KAAKuX,mBAAmBH,GAAgB,IAC/G,CAKI,cAAII,GACA,OAAKxX,KAAKyX,aAGHzX,KAAK0X,YAFD,CAGnB,CAII,cAAIF,CAAWhI,GACX,MAAM7O,EAASX,KAAKyX,aACf9W,EAIDX,KAAK0X,cAAgBlI,GAASA,EAAQ7O,EAAO0G,MAASmI,EAAQ7O,EAAO2G,MAAwB,IAAhB3G,EAAO2G,OAGxFtH,KAAK0X,YAAclI,EACnBxP,KAAK2X,OAAOC,0BACZ5X,KAAK8W,iBAAkB,GARnB9W,KAAK0X,YAAclI,CAS/B,CAKI,SAAIqI,GACA,OAAO7X,KAAK8X,MACpB,CACI,SAAID,CAAME,GACN/X,KAAK8X,OAASC,EACd/X,KAAK2X,OAAOC,yBACpB,CASI,cAAII,GACA,OAAOhY,KAAKiY,WACpB,CACI,cAAID,CAAWxI,GACXxP,KAAKiY,YAAczI,CAC3B,CAKI,0BAAI0I,GACA,OAAOlY,KAAKmY,uBACpB,CACI,0BAAID,CAAuB1I,GACvBxP,KAAKmY,wBAA0B3I,EAC/BxP,KAAK2X,OAAOC,yBACpB,CAOI,UAAIQ,GACA,OAAOpY,KAAKqY,OACpB,CACI,UAAID,CAAO5I,GACP,MAAM4I,EAASxH,KAAKzB,IAAIyB,KAAKxB,IAAII,EAAO,GAAI,GACxCxP,KAAKqY,SAAWD,IAGpBpY,KAAKqY,QAAUD,EACfpY,KAAK8W,iBAAkB,EAC/B,CAMI,oBAAAwB,CAAqBC,GACjB,OAAOA,GAAc,GAAKA,EAAavY,KAAK+U,aAAe/U,KAAKwY,cAAcD,GAAc,IACpG,CAMI,0BAAAE,CAA2BF,GACvB,OAAOA,GAAc,GAAKA,EAAavY,KAAK+U,aAAe/U,KAAK0Y,oBAAoBH,GAAc,IAC1G,CAMI,yBAAAI,CAA0BJ,GACtB,OAAOA,GAAc,GAAKA,EAAavY,KAAK+U,aAAe/U,KAAK4Y,mBAAmBL,GAAc,IACzG,CAUI,gBAAA/E,CAAiBD,GACbvT,KAAKwN,eAAiB+F,EAClBvT,KAAK6Y,eACL7Y,KAAK6Y,cAAcrF,iBAAiBxT,KAAKwN,eAErD,CAUI,uBAAIsL,GACA,OAAO9Y,KAAK+Y,oBACpB,CACI,uBAAID,CAAoBtJ,GACpB,MAAM7O,EAASX,KAAKyX,aACpB,GAAK9W,EAAL,CAIA,GADAX,KAAK+Y,qBAAuBvJ,GACvBA,EAKD,OAJIxP,KAAK6Y,eACL7Y,KAAK6Y,cAAc5G,kBAEvBjS,KAAK2W,kBAAkB,EAAG,GAGzB3W,KAAK6Y,gBACN7Y,KAAK6Y,cAAgB,IAAIvF,EAAa3S,GACtCX,KAAK6Y,cAAcjJ,0BAA0B/L,KAAKmV,IAC9C,IAAI7J,EAAM6J,EAAO7J,IAAKC,EAAM4J,EAAO5J,IAC/BD,GAAOC,IACPD,EAAM,EACNC,EAAM,GAEND,GAAOnP,KAAK4W,cAAgBxH,GAAOpP,KAAK6W,cACxC7W,KAAK2W,kBAAkBxH,EAAKC,MAGpCpP,KAAK6Y,cAAcrF,iBAAiBxT,KAAKwN,iBAE7CxN,KAAK6Y,cAAc3F,UAvB3B,CAwBA,CAOI,kCAAI+F,GACA,OAAOjZ,KAAK6Y,eAAetF,eAAenG,cAAc/J,cAAiB,CACjF,CACI,kCAAI4V,CAA+BzJ,GAC3BxP,KAAK6Y,eAAetF,gBACpBvT,KAAK6Y,cAActF,cAAcnG,cAAc/J,YAAcmM,EAEzE,CAMI,YAAA0J,GACIlZ,KAAK8W,iBAAkB,CAC/B,CACI,aAAAqC,GACI,MAAMxY,EAASX,KAAKyX,aACpB,IAAK9W,EACD,OAEJ,MAAMyY,EAAOzY,EAAO0G,KAAMgS,EAAM1Y,EAAO2G,MAAQtH,KAAK0X,YACpD4B,EAAcD,EAAMD,EAAMrC,EAAc/W,KAAK4W,aACvCvP,EAAO+R,EAAOrC,EAAcuC,EAAahS,EAAO8R,GADmBpZ,KAAK0X,YAAc2B,GAAOrZ,KAAK0X,aAAe0B,EAAOxI,KAAKzB,KAAKnP,KAAK0X,YAAc0B,IAASC,EAAMD,GAAOpZ,KAAK6W,cAAgB7W,KAAK6W,cAChIyC,EACrEC,EAAQjS,EAAOD,EAAMmS,EAAQlS,EAAOD,EAC1C,IAAK,IAAI+P,EAAe,EAAGA,EAAepX,KAAKyZ,UAAUlV,SAAU6S,EAAc,CAC7E,MAAMsC,GAAKtC,EAAe,GAAKpX,KAAK+U,aAAc4E,EAAMtS,EAAOmS,GAASE,EAAGE,EAAUvS,EAAOkS,EAAQG,EAC9FG,EAAI7Z,KAAKqY,SAAWsB,EAAMC,GAAWA,EAC3C5Z,KAAKyZ,UAAUrC,GAAc0C,kBAAqC,IAAjB1C,EAAqBL,EAAc/W,KAAKyZ,UAAUrC,EAAe,GAAG2C,cACrH/Z,KAAKyZ,UAAUrC,GAAc2C,eAAiBF,EAAIT,GAAQE,EAC1DtZ,KAAKga,oBAAoB5C,GAAgByC,EACzC7Z,KAAKia,gBAAgB7C,IAAiBpX,KAAKyZ,UAAUrC,GAAc2C,cAAgB/Z,KAAKyZ,UAAUrC,GAAc0C,mBAAqBR,CACjJ,CACQtZ,KAAK8W,iBAAkB,CAC/B,CACI,gBAAAoD,GACI,MAAM3Z,EAAQP,KAAKsB,OAEnB,IADetB,KAAKyX,aAEhB,OAEJ5D,EAAQsG,eAAena,KAAK2X,OAAOyC,mBAAmB,GAAIpa,KAAKqa,iBACG,IAA9DzJ,KAAK0J,IAAIzG,EAAQ0G,IAAIva,KAAKqa,gBAAiBxG,EAAQC,SACnD9T,KAAKqa,gBAAgBG,EAAI,OAE7Bxa,KAAKya,iBAAiBC,SAAS1a,KAAKqa,iBACpC,MAAMtS,EAAwBxH,EAAMyB,YAAY+F,sBAChD,IAAK,IAAIqP,EAAe,EAAGA,EAAepX,KAAK+U,eAAgBqC,EAAc,CACzEpX,KAAK2a,4BAA4BvD,GACjCpX,KAAK4a,uBAAuBxD,GAC5BpX,KAAKuX,mBAAmBH,GAAcyD,cAAc7a,KAAKqX,mBAAmBD,GAAenD,IAE3FjU,KAAK8a,eAAe1D,GAAc2D,SAAS/a,KAAKqa,gBAAgBW,MAAMhb,KAAKqX,mBAAmBD,GAAcoD,GAAIxa,KAAKib,iBAAiB7D,IAEtIhD,EAAO8G,cAAclb,KAAKib,iBAAiB7D,GAAepX,KAAK8a,eAAe1D,GAAexD,GAAO5T,KAAKwY,cAAcpB,IAEvH,IAAI+D,EAAW,EAAGC,EAAWnH,GAAMuG,EAEnC,MAAM9D,EAAe1W,KAAKuW,2BAC1BG,EAAa2E,OAAOrb,KAAKwY,cAAcpB,IAGvC,MAAMkE,EAAkB5E,EAAaT,YAAYG,aAAaoE,EACxDe,EAAkB7E,EAAaT,YAAYK,aAAakE,EAC1Dc,EAAkBF,IAMbpb,KAAKiY,aAAejY,KAAKwU,SAAWF,EAAgBK,aAUrDyG,EAAWxK,KAAKzB,IAAIiM,EAAUG,GAI9BJ,EAAWvK,KAAKxB,IAAI+L,EAAUG,GAI9BF,EAAWxK,KAAKxB,IAAI+L,EAAW,EAAKC,KAhBpCD,EAAWvK,KAAKzB,IAAIgM,EAAUG,GAC1Btb,KAAKwU,SAAWF,EAAgBK,cAEhCyG,EAAWxK,KAAKzB,IAAIiM,EAAUG,MAgB1CnH,EAAOoH,sBAAsBxb,KAAKqX,mBAAmBD,GAAcqE,EAAGzb,KAAKuX,mBAAmBH,GAAcqE,EAAGzb,KAAKqX,mBAAmBD,GAAcsE,EAAG1b,KAAKuX,mBAAmBH,GAAcsE,EAAG3T,EAAwBqT,EAAWD,EAAUpT,EAAwBoT,EAAWC,EAAUpb,KAAK0Y,oBAAoBtB,GAAe7W,EAAMyB,YAAYgG,iBACrVhI,KAAKqX,mBAAmBD,GAAcoD,EAAIW,EAC1Cnb,KAAKuX,mBAAmBH,GAAcoD,EAAIY,EAC1Cpb,KAAKwY,cAAcpB,GAAcuE,cAAc3b,KAAK0Y,oBAAoBtB,GAAepX,KAAK4Y,mBAAmBxB,IAG/GvD,EAAQ+H,0BAA0B7H,GAAS/T,KAAK4Y,mBAAmBxB,GAAenD,IAClFA,GAAM4H,aAAa7b,KAAK8b,SAAW,GACnC5H,GAAMyB,eAAe/E,KAAKC,MAAMoD,GAAMwH,GAAI7K,KAAKC,MAAMoD,GAAMyH,GAAI9K,KAAKC,MAAMoD,GAAMuG,IAChFtG,GAAM6H,gBAAgB9H,IAAO4H,aAAa,EAAI7b,KAAK8b,UACnD1H,EAAO4H,iBAAiB9H,GAAMuH,EAAGvH,GAAMwH,EAAG,EAAKvH,IAC/CnU,KAAK0Y,oBAAoBtB,GAAcuE,cAAcxH,GAAWnU,KAAK0Y,oBAAoBtB,IACzFpX,KAAKwY,cAAcpB,GAAcuE,cAAc3b,KAAK0Y,oBAAoBtB,GAAepX,KAAK4Y,mBAAmBxB,IAC/GpX,KAAK4Y,mBAAmBxB,GAAc6E,YAAYjc,KAAKkc,0BAA0C,GAAf9E,EAC9F,CACA,CAEI,2BAAAuD,CAA4BvD,GACxB,MAAMzW,EAASX,KAAKyX,aACpB,IAAK9W,EACD,OAEJ,MAAMwb,EAAgBnc,KAAKyZ,UAAUrC,GAAc0C,kBAAmBsC,EAAYpc,KAAKyZ,UAAUrC,GAAc2C,cACzG/R,EAAkBhI,KAAKsB,OAAOU,YAAYgG,gBAChDrH,EAAOmH,gBACP,MAAMuU,EAAyC,IAAhB1b,EAAO2G,KAChCgV,EAAiB3b,EAAO2G,KAC1B+U,IACA1b,EAAO2G,KAAOtH,KAAK0X,YACnB/W,EAAO4b,qBAAoB,IAE/B,MAAMC,EAAcpI,EAAOqI,OAAO9b,EAAO+b,2BACrCL,IACA1b,EAAO2G,KAAOgV,EACd3b,EAAO4b,qBAAoB,IAE/B,MAAMI,EAAoB3c,KAAKsB,OAAOU,YAAY+F,sBAAwB,EAAI,EAC9E,IAAK,IAAI6U,EAAc,EAAGA,EAAcvI,GAAwBwI,wBAAwBtY,SAAUqY,EAC9F3I,GAAMyG,SAASrG,GAAwBwI,yBAAyBD,EAAcD,GAAqBtI,GAAwBwI,wBAAwBtY,SAC/IyD,QAAmBiM,GAAMuG,IACzBvG,GAAMuG,EAAI,GAEd3G,EAAQ+H,0BAA0B3H,GAAOuI,EAAaxc,KAAK8c,0BAA0B1F,GAAcwF,IAGvG,IAAK,IAAIA,EAAc,EAAGA,EAAcvI,GAAwBwI,wBAAwBtY,OAAS,IAAKqY,EAClG3I,GAAMyG,SAAS1a,KAAK8c,0BAA0B1F,GAAcwF,EAAc,IAAIb,gBAAgB/b,KAAK8c,0BAA0B1F,GAAcwF,IAC3I1I,GAAMwG,SAASzG,IAAO4H,aAAaM,GACnClI,GAAM4H,aAAaO,GACnBnI,GAAM8I,WAAW/c,KAAK8c,0BAA0B1F,GAAcwF,IAC9D5c,KAAK8c,0BAA0B1F,GAAcwF,EAAc,GAAGlC,SAASzG,IACvEjU,KAAK8c,0BAA0B1F,GAAcwF,GAAaG,WAAW7I,GAEjF,CACI,sBAAA0G,CAAuBxD,GACnBpX,KAAKqX,mBAAmBD,GAAczB,eAAeC,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WAChG7V,KAAKuX,mBAAmBH,GAAczB,gBAAgBC,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WACnG7V,KAAK8a,eAAe1D,GAAczB,eAAe,EAAG,EAAG,GAEvD,GADe3V,KAAKyX,aACpB,CAIA,IAAK,IAAImF,EAAc,EAAGA,EAAc5c,KAAK8c,0BAA0B1F,GAAc7S,SAAUqY,EAC3F5c,KAAK8a,eAAe1D,GAAc2F,WAAW/c,KAAK8c,0BAA0B1F,GAAcwF,IAG9F,GADA5c,KAAK8a,eAAe1D,GAAcyE,aAAa,EAAI7b,KAAK8c,0BAA0B1F,GAAc7S,QAC5FvE,KAAKgd,kBAAmB,CAExB,IAAIC,EAAe,EACnB,IAAK,IAAIL,EAAc,EAAGA,EAAc5c,KAAK8c,0BAA0B1F,GAAc7S,SAAUqY,EAAa,CACxG,MAAMM,EAAOld,KAAK8c,0BAA0B1F,GAAcwF,GAAa/B,cAAc7a,KAAK8a,eAAe1D,GAAenD,IAAO1P,SAC/H0Y,EAAerM,KAAKxB,IAAI6N,EAAcC,EACtD,CACYD,EAAerM,KAAKuM,KAAoB,GAAfF,GAAqB,GAC9Cjd,KAAKuX,mBAAmBH,GAAczB,eAAesH,EAAcA,EAAcA,GACjFjd,KAAKqX,mBAAmBD,GAAczB,gBAAgBsH,GAAeA,GAAeA,EAChG,KACa,CAED,MAAMG,EAAiBpd,KAAK8a,eAAe1D,GAC3CpX,KAAK8a,eAAe1D,GAAc2D,SAAS/a,KAAKqa,gBAAiBpG,IACjEG,EAAO8G,cAAckC,EAAgBnJ,GAAOL,GAAOO,IAEnD,IAAK,IAAIyI,EAAc,EAAGA,EAAc5c,KAAK8c,0BAA0B1F,GAAc7S,SAAUqY,EAC3F/I,EAAQ+H,0BAA0B5b,KAAK8c,0BAA0B1F,GAAcwF,GAAczI,GAAWF,IACxGjU,KAAKqX,mBAAmBD,GAAcjB,gBAAgBlC,IACtDjU,KAAKuX,mBAAmBH,GAAcf,gBAAgBpC,GAEtE,CA5BA,CA6BA,CACI,kBAAAkB,GAEI,GADAnV,KAAKqd,oBACDrd,KAAKsd,WACL,IAAK,IAAIhZ,EAAI,EAAGA,EAAItE,KAAK+U,eAAgBzQ,EACrCtE,KAAKsd,WAAWrS,KAAKjL,KAAKsB,OAAOic,yBAAyB,0CAA0Cvd,KAAK2X,OAAOrY,kBAAkBgF,MAGlJ,CAII,sBAAWkZ,GACP,MAAMzb,EAAS0b,EAAYrP,kBAC3B,QAAKrM,GAGEA,EAAOS,UAAUkb,UAChC,CAYI,WAAApd,CAAYqd,EAASC,EAAOC,EAAkBld,EAAQmd,GAAoB,GACjEzJ,GAAwBmJ,aAI7BtP,MAAMyP,EAASC,EAAOC,EAAkBld,EAAQmd,GAChD9d,KAAK+d,8BAA+B,GAJhCnJ,EAAOC,MAAM,4DAKzB,CACI,oBAAAmJ,GACIhe,KAAKie,iBAAmBje,KAAKie,kBAAoB,EACjDje,KAAK+U,aAAe/U,KAAK+U,cAAgBV,GAAwB6J,uBACjEle,KAAKgd,kBAAoBhd,KAAKgd,oBAAqB,EACnDhd,KAAKuV,2CAA6CvV,KAAKuV,4CAA8C,KACrGvV,KAAKoV,gCAAkCpV,KAAKoV,kCAAmC,EAC/EpV,KAAK0V,SAAW1V,KAAK0V,UAAY,IAAI7B,EAAQ,EAAG,EAAG,GACnD7T,KAAK8V,SAAW9V,KAAK8V,UAAY,IAAIjC,EAAQ,EAAG,EAAG,GACnD7T,KAAKuW,2BAA6BvW,KAAKuW,4BAA8B,IAAI4H,EAAa,IAAItK,EAAQ,EAAG,EAAG,GAAI,IAAIA,EAAQ,EAAG,EAAG,IAC9H7T,KAAK8W,gBAAkB9W,KAAK8W,kBAAmB,EAC/C9W,KAAK4W,aAAe5W,KAAK4W,cAAgB,EACzC5W,KAAK6W,aAAe7W,KAAK6W,cAAgB,EACzC7W,KAAKoe,cAAgBpe,KAAKoe,eAAiB,EAC3Cpe,KAAK0X,YAAc1X,KAAK0X,aAAe1X,KAAKyX,cAAcnQ,MAAQ,IAClEtH,KAAK8X,OAAS9X,KAAK8X,SAAU,EAC7B9X,KAAKiY,YAAcjY,KAAKiY,cAAe,EACvCjY,KAAKmY,wBAA0BnY,KAAKmY,yBAA2B,GAC/DnY,KAAKqY,QAAUrY,KAAKqY,SAAW,GAC/BrY,KAAK+Y,qBAAuB/Y,KAAK+Y,uBAAwB,EACzD/Y,KAAKmV,qBACLjH,MAAM8P,sBACd,CACI,0BAAAK,GACI,MAAMtc,EAAS/B,KAAKsB,OAAOU,YACrB2Q,EAAO,CAAE9P,MAAO7C,KAAK8b,SAAU/Y,OAAQ/C,KAAK8b,SAAUwC,OAAQte,KAAK8U,aACzE9U,KAAK+V,WAAa,IAAInT,EAAoB5C,KAAK2X,OAAOrY,KAAO,gBAAiBqT,EAAM3S,KAAKsB,QAAQ,GAAO,EAAMtB,KAAKue,cAAc,OAAOtb,GAAW,GAAO,OAAOA,EAAWjD,KAAKwe,mBAAqB/d,EAAUge,kBAAoBhe,EAAUiC,oBAC9O1C,KAAK+V,WAAW2I,0BAA0B3c,EAAOgG,sBAAwBtH,EAAUke,QAAUle,EAAUme,MAAM,OAAM3b,OAAWA,OAAWA,EAAW,qCAAqCjD,KAAK2X,OAAOrY,QACrMU,KAAK+V,WAAWvS,mBAAoB,CAC5C,CACI,oBAAAqb,GAEI,GADA3Q,MAAM2Q,uBACkB,OAApB7e,KAAK+V,WACL,OAEJ/V,KAAKkc,0BAA4B,IAAInN,aAAiC,GAApB/O,KAAK+U,cACvD/U,KAAKga,oBAAsB,IAAI8E,MAAM9e,KAAK+U,cAC1C/U,KAAKia,gBAAkB,IAAI6E,MAAM9e,KAAK+U,cACtC/U,KAAK+e,uBAAyB,IAAID,MAA0B,EAApB9e,KAAK+U,cAC7C/U,KAAKgf,iBAAmB,IAAIF,MAAM9e,KAAK+U,cACvC/U,KAAKyZ,UAAY,GACjBzZ,KAAKwY,cAAgB,GACrBxY,KAAK0Y,oBAAsB,GAC3B1Y,KAAK4Y,mBAAqB,GAC1B5Y,KAAKqX,mBAAqB,GAC1BrX,KAAKuX,mBAAqB,GAC1BvX,KAAK8a,eAAiB,GACtB9a,KAAKib,iBAAmB,GACxBjb,KAAK8c,0BAA4B,GACjC,IAAK,IAAI1F,EAAe,EAAGA,EAAepX,KAAK+U,eAAgBqC,EAAc,CACzEpX,KAAKyZ,UAAUrC,GAAgB,CAC3B0C,kBAAmB,EACnBC,cAAe,GAEnB/Z,KAAKwY,cAAcpB,GAAgBhD,EAAOJ,OAC1ChU,KAAK0Y,oBAAoBtB,GAAgBhD,EAAOJ,OAChDhU,KAAK4Y,mBAAmBxB,GAAgBhD,EAAOJ,OAC/ChU,KAAKqX,mBAAmBD,GAAgB,IAAIvD,EAC5C7T,KAAKuX,mBAAmBH,GAAgB,IAAIvD,EAC5C7T,KAAK8a,eAAe1D,GAAgB,IAAIvD,EACxC7T,KAAKib,iBAAiB7D,GAAgB,IAAIvD,EAC1C7T,KAAK8c,0BAA0B1F,GAAgB,IAAI0H,MAAMzK,GAAwBwI,wBAAwBtY,QACzG,IAAK,IAAID,EAAI,EAAGA,EAAI+P,GAAwBwI,wBAAwBtY,SAAUD,EAC1EtE,KAAK8c,0BAA0B1F,GAAc9S,GAAK,IAAIuP,CAEtE,CACQ,MAAM9R,EAAS/B,KAAKsB,OAAOU,YAC3BhC,KAAK+V,WAAWhS,uBAAuBD,QACvC9D,KAAK+V,WAAWP,yBAAyB1R,QACzC9D,KAAK+V,WAAWP,yBAAyB3R,KAAKob,IACtCjf,KAAKsd,YACLtd,KAAKsB,OAAO4d,sBAAsBlf,KAAKsd,WAAW2B,IAEtDjf,KAAKoe,cAAgBa,EACjBjf,KAAKmf,UAAY7K,EAAgBI,YACjC3S,EAAOqd,eAAc,GAEzBpf,KAAKsB,OAAO+d,mBAAmBrf,KAAKsY,qBAAqB2G,GAAQjf,KAAKyY,2BAA2BwG,IAC7Fjf,KAAKsf,UACLtf,KAAKsB,OAAOie,wBAAwBC,eACpCxf,KAAKsB,OAAOme,uBAGpBzf,KAAK+V,WAAWhS,uBAAuBF,KAAI,KACvC7D,KAAK0f,iBAAmB1f,KAAKsB,OAAOie,wBACpCxd,EAAOiC,kBAAkB,8CAA8CjC,EAAO8E,sBAAuB,GACjG7G,KAAK8W,iBACL9W,KAAKmZ,gBAETnZ,KAAKka,sBAETla,KAAKmZ,eACb,CACI,6CAAAwG,CAA8Cnb,EAAS4C,GACnDA,EAAOQ,UAAU,iBAAkB5H,KAAK2Y,0BAA0B3Y,KAAKoe,eAC/E,CACI,qBAAAwB,CAAsBjV,GAClBA,EAAQM,KAAK,0BAA4BjL,KAAKiY,aAAejY,KAAKmf,UAAY7K,EAAgBK,YAAc,IAAM,KAC1H,CAMI,cAAAkL,CAAelV,EAASmV,GACpB5R,MAAM2R,eAAelV,EAASmV,GAC9B,MAAMvf,EAAQP,KAAKsB,OACbsc,EAAQ5d,KAAK2X,OACnB,IAAKpX,EAAMwf,iBAAmBnC,EAAMoC,cAChC,OAEJrV,EAAQ,YAAcmV,IAAc,EACpCnV,EAAQ,iBAAmBmV,GAAc9f,KAAK6X,MAC9ClN,EAAQ,wBAA0BmV,GAAc9f,KAAK8U,YACrDnK,EAAQ,wBAA0BmV,GAAcvf,EAAM0f,qBACtD,MAAMtf,EAASX,KAAKyX,aAChB9W,GAAUX,KAAK0X,cAAgB/W,EAAO2G,MAAQtH,KAAK0X,eACnD/M,EAAQ,yBAA2BmV,IAAc,GAEjB,IAAhC9f,KAAKkY,yBACLvN,EAAQ,mBAAqBmV,IAAc,EAEvD,CAOI,eAAAI,CAAgBJ,EAAY1Y,GACxB,MAAMwW,EAAQ5d,KAAK2X,OAEnB,IADc3X,KAAKsB,OACRye,iBAAmBnC,EAAMoC,cAChC,OAEJ,MAAMrf,EAASX,KAAKyX,aACpB,IAAK9W,EACD,OAEJ,MAAMwf,EAAYngB,KAAKogB,eACvB,IAAKD,EACD,OAEJ,MAAMtd,EAAQsd,EAAUE,UAAUxd,MAMlC,GALAuE,EAAOkZ,YAAY,cAAgBR,EAAY9f,KAAKkc,2BACpD9U,EAAOmZ,SAAS,eAAiBT,EAAY9f,KAAKga,qBAClD5S,EAAO8B,SAAS,qBAAuB4W,EAA4C,IAAhC9f,KAAKkY,uBAA+B,IAAQ,EAAIlY,KAAKkY,wBACxG9Q,EAAOmZ,SAAS,iBAAmBT,EAAY9f,KAAKia,iBAEhDja,KAAKmf,UAAY7K,EAAgBI,WACjCtN,EAAOoZ,uBAAuB,gBAAkBV,EAAYK,GAC5DvC,EAAM6C,eAAeC,aAAa,cAAe1gB,KAAK2gB,cAAe9d,EAAO,EAAIA,EAAO7C,KAAK4gB,mBAAoBd,QAE/G,GAAI9f,KAAKmf,UAAY7K,EAAgBK,YAAa,CACnD,IAAK,IAAIyC,EAAe,EAAGA,EAAepX,KAAK+U,eAAgBqC,EAC3DpX,KAAK+e,uBAAsC,EAAf3H,EAAmB,GAC1B,IAAjBA,EACM,GACCpX,KAAKuX,mBAAmB,GAAGkE,EAAIzb,KAAKqX,mBAAmB,GAAGoE,IAAMzb,KAAKuX,mBAAmBH,GAAcqE,EAAIzb,KAAKqX,mBAAmBD,GAAcqE,GAC3Jzb,KAAK+e,uBAAsC,EAAf3H,EAAmB,GAC1B,IAAjBA,EACM,GACCpX,KAAKuX,mBAAmB,GAAGmE,EAAI1b,KAAKqX,mBAAmB,GAAGqE,IAAM1b,KAAKuX,mBAAmBH,GAAcsE,EAAI1b,KAAKqX,mBAAmBD,GAAcsE,GAC3J1b,KAAKgf,iBAAiB5H,GACD,IAAjBA,EACM,GACCpX,KAAKuX,mBAAmBH,GAAcoD,EAAIxa,KAAKqX,mBAAmBD,GAAcoD,IAAMxa,KAAKuX,mBAAmB,GAAGiD,EAAIxa,KAAKqX,mBAAmB,GAAGmD,GAE/JpT,EAAOoZ,uBAAuB,gBAAkBV,EAAYK,GAC5D/Y,EAAOiB,WAAW,eAAiByX,EAAYK,GAC/C/Y,EAAOyZ,UAAU,wBAA0Bf,EAAY9f,KAAK+e,wBAC5D3X,EAAOmZ,SAAS,kBAAoBT,EAAY9f,KAAKgf,kBACrD5X,EAAO8B,SAAS,mBAAqB4W,EAAY9f,KAAKie,kBACtDL,EAAM6C,eAAeC,aAAa,cAAe1gB,KAAK2gB,cAAe,EAAI9d,EAAO7C,KAAK8gB,kCAAoCje,EAAO7C,KAAK4gB,mBAAoBd,EACrK,MAEY1Y,EAAOiB,WAAW,gBAAkByX,EAAYK,GAChDvC,EAAM6C,eAAeC,aAAa,cAAe1gB,KAAK2gB,cAAe9d,EAAO,EAAIA,EAAO7C,KAAK4gB,mBAAoBd,GAEpHlC,EAAM6C,eAAeM,aAAa,cAAe/gB,KAAKghB,WAAWC,aAAatgB,GAASX,KAAKghB,WAAWC,aAAatgB,GAAUX,KAAKghB,WAAWE,aAAavgB,GAASmf,EAC5K,CAMI,kBAAAjY,GACI,OAAO7H,KAAK2Y,0BAA0B,EAC9C,CAKI,OAAAtL,GACIa,MAAMb,UACFrN,KAAKuV,6CACLvV,KAAKsB,OAAOkU,yBAAyBnC,OAAOrT,KAAKuV,4CACjDvV,KAAKuV,2CAA6C,MAElDvV,KAAK6Y,gBACL7Y,KAAK6Y,cAAcxL,UACnBrN,KAAK6Y,cAAgB,KAEjC,CAKI,SAAAsI,GACI,MAAMC,EAAsBlT,MAAMiT,YAC5BhB,EAAYngB,KAAKogB,eACvB,IAAKD,EACD,OAAOiB,EAeX,GAbAA,EAAoBtM,YAAc9U,KAAK+U,aACvCqM,EAAoBvJ,MAAQ7X,KAAK8X,OACjCsJ,EAAoBpE,kBAAoBhd,KAAKgd,kBAC7CoE,EAAoBhJ,OAASpY,KAAKqY,QAClC+I,EAAoBlJ,uBAAyBlY,KAAKkY,uBAClDkJ,EAAoBpJ,WAAahY,KAAKiY,YACtCmJ,EAAoBtI,oBAAsB9Y,KAAK8Y,oBAC/CsI,EAAoB5J,WAAaxX,KAAK0X,YACtC0J,EAAoBnD,iBAAmBje,KAAKie,iBAC5CmD,EAAoBhM,gCAAkCpV,KAAKqV,iCAC3D+L,EAAoBrK,YAAc/W,KAAK+W,YACvCqK,EAAoBpK,YAAchX,KAAKgX,YACvCoK,EAAoB7d,WAAa,GAC7B4c,EAAU5c,WACV,IAAK,IAAIyS,EAAY,EAAGA,EAAYmK,EAAU5c,WAAWgB,OAAQyR,IAAa,CAC1E,MAAM7V,EAAOggB,EAAU5c,WAAWyS,GAClCoL,EAAoB7d,WAAW0H,KAAK9K,EAAKuT,GACzD,CAEQ,OAAO0N,CACf,CAOI,YAAOC,CAAMC,EAAuB/gB,GAChC,MAAMghB,EAAkBjN,EAAgB+M,MAAMC,EAAuB/gB,GAAO,CAACod,EAASC,EAAOjd,IAAW,IAAI0T,GAAwBsJ,EAASC,OAAO3a,EAAWtC,KAkC/J,YAjC0CsC,IAAtCqe,EAAsBxM,cACtByM,EAAgBzM,YAAcwM,EAAsBxM,kBAEpB7R,IAAhCqe,EAAsBzJ,QACtB0J,EAAgB1J,MAAQyJ,EAAsBzJ,YAEF5U,IAA5Cqe,EAAsBtE,oBACtBuE,EAAgBvE,kBAAoBsE,EAAsBtE,wBAEzB/Z,IAAjCqe,EAAsBlJ,SACtBmJ,EAAgBnJ,OAASkJ,EAAsBlJ,aAEEnV,IAAjDqe,EAAsBpJ,yBACtBqJ,EAAgBrJ,uBAAyBoJ,EAAsBpJ,6BAE1BjV,IAArCqe,EAAsBtJ,aACtBuJ,EAAgBvJ,WAAasJ,EAAsBtJ,iBAEL/U,IAA9Cqe,EAAsBxI,sBACtByI,EAAgBzI,oBAAsBwI,EAAsBxI,0BAEvB7V,IAArCqe,EAAsB9J,aACtB+J,EAAgB/J,WAAa8J,EAAsB9J,iBAERvU,IAA3Cqe,EAAsBrD,mBACtBsD,EAAgBtD,iBAAmBqD,EAAsBrD,uBAEChb,IAA1Dqe,EAAsBlM,kCACtBmM,EAAgBnM,gCAAkCkM,EAAsBlM,sCAElCnS,IAAtCqe,EAAsBvK,kBAAmE9T,IAAtCqe,EAAsBtK,aACzEuK,EAAgB5K,kBAAkB2K,EAAsBvK,YAAauK,EAAsBtK,aAExFuK,CACf,EAEAlN,GAAwBwI,wBAA0B,CAC9C,IAAIhJ,GAAQ,EAAM,MAClB,IAAIA,EAAQ,EAAM,MAClB,IAAIA,EAAQ,GAAU,MACtB,IAAIA,GAAQ,GAAU,MACtB,IAAIA,GAAQ,EAAM,EAAM,GACxB,IAAIA,EAAQ,EAAM,EAAM,GACxB,IAAIA,EAAQ,GAAU,EAAE,GACxB,IAAIA,GAAQ,GAAU,EAAE,IAK5BQ,GAAwB6C,UAAY,0BAIpC7C,GAAwB6J,uBAAyB,EAIjD7J,GAAwBW,mBAAqB,EAI7CX,GAAwBY,mBAAqB,EAI7CZ,GAAwBvS,8BAAiC2L,IACrD,MAAMC,EAAY,kCClzBf,MAAM8T,GAKT,WAAAlhB,CAAYC,GAIRP,KAAKV,KAAOmiB,EAAwBC,qBACpC1hB,KAAKO,MAAQA,CACrB,CAII,QAAAohB,GACI3hB,KAAKO,MAAMqhB,0BAA0BC,aAAaJ,EAAwBK,yCAA0C9hB,KAAMA,KAAK+hB,qBACvI,CAKI,OAAAC,GAEJ,CAKI,SAAAb,CAAUC,GAENA,EAAoBa,iBAAmB,GACvC,MAAMC,EAASliB,KAAKO,MAAM2hB,OAC1B,IAAK,MAAMtE,KAASsE,EAAQ,CACxB,GAAItE,EAAMuE,eACN,SAEJ,MAAMF,EAAmBrE,EAAMwE,sBAC/B,GAAIH,EAAkB,CAClB,MAAMI,EAAWJ,EAAiBK,SAClC,IAAK,IAAI/U,EAAM8U,EAASE,QAAqB,IAAbhV,EAAIiV,KAAejV,EAAM8U,EAASE,OAAQ,CACtE,MAAMhB,EAAkBhU,EAAIiC,MACxB+R,EAAgBY,gBAGpBf,EAAoBa,iBAAiBhX,KAAKsW,EAAgBJ,YAC9E,CACA,CACA,CACA,CAMI,gBAAAsB,CAAiBC,GAErB,CAOI,mBAAAC,CAAoBD,EAAWrV,GAEnC,CAKI,OAAAA,GAEJ,CACI,oBAAA0U,CAAqBa,GAEjB,MAAMriB,EAAQP,KAAKO,MACnB,GAAIP,KAAKO,MAAMwf,eACX,IAAK,IAAID,EAAa,EAAGA,EAAavf,EAAM2hB,OAAO3d,OAAQub,IAAc,CACrE,MAAMlC,EAAQrd,EAAM2hB,OAAOpC,GACrBmC,EAAmBrE,EAAMwE,sBAC/B,GAAIxE,EAAM7U,aAAe6U,EAAMoC,eAAiBiC,EAAkB,CAC9D,MAAMI,EAAWJ,EAAiBK,SAClC,IAAK,IAAI/U,EAAM8U,EAASE,QAAqB,IAAbhV,EAAIiV,KAAejV,EAAM8U,EAASE,OAAQ,CACtE,MACMpC,EADkB5S,EAAIiC,MACM4Q,gBACQ,IAAtC7f,EAAMsiB,SAASC,QAAQ3C,IACvByC,EAAc3X,KAAKkV,EAE/C,CACA,CACA,CAEA,EAEA7L,EAAgBxS,8BAAiCvB,IAC7C,IAAIwiB,EAAYxiB,EAAMyiB,cAAcvB,EAAwBC,sBACvDqB,IACDA,EAAY,IAAIvB,GAA8BjhB,GAC9CA,EAAM0iB,cAAcF"}