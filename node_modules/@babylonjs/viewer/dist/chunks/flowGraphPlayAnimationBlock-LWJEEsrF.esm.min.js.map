{"version":3,"file":"flowGraphPlayAnimationBlock-LWJEEsrF.esm.min.js","sources":["../../../../../dev/core/dist/FlowGraph/Blocks/Execution/Animation/flowGraphPlayAnimationBlock.js"],"sourcesContent":["import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\nimport { RichTypeAny, RichTypeNumber, RichTypeBoolean } from \"../../../flowGraphRichTypes\";\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\n/**\n * @experimental\n * A block that plays an animation on an animatable object.\n */\nexport class FlowGraphPlayAnimationBlock extends FlowGraphAsyncExecutionBlock {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(config, [\"animationLoop\", \"animationEnd\", \"animationGroupLoop\"]);\n        this.config = config;\n        this.speed = this.registerDataInput(\"speed\", RichTypeNumber);\n        this.loop = this.registerDataInput(\"loop\", RichTypeBoolean);\n        this.from = this.registerDataInput(\"from\", RichTypeNumber, 0);\n        this.to = this.registerDataInput(\"to\", RichTypeNumber);\n        this.currentFrame = this.registerDataOutput(\"currentFrame\", RichTypeNumber);\n        this.currentTime = this.registerDataOutput(\"currentTime\", RichTypeNumber);\n        this.currentAnimationGroup = this.registerDataOutput(\"currentAnimationGroup\", RichTypeAny);\n        this.animationGroup = this.registerDataInput(\"animationGroup\", RichTypeAny, config?.animationGroup);\n        this.animation = this.registerDataInput(\"animation\", RichTypeAny);\n        this.object = this.registerDataInput(\"object\", RichTypeAny);\n    }\n    /**\n     * @internal\n     * @param context\n     */\n    _preparePendingTasks(context) {\n        const ag = this.animationGroup.getValue(context);\n        const animation = this.animation.getValue(context);\n        if (!ag && !animation) {\n            return this._reportError(context, \"No animation or animation group provided\");\n        }\n        else {\n            // if an animation group was already created, dispose it and create a new one\n            const currentAnimationGroup = this.currentAnimationGroup.getValue(context);\n            if (currentAnimationGroup && currentAnimationGroup !== ag) {\n                currentAnimationGroup.dispose();\n            }\n            let animationGroupToUse = ag;\n            // check which animation to use. If no animationGroup was defined and an animation was provided, use the animation\n            if (animation && !animationGroupToUse) {\n                const target = this.object.getValue(context);\n                if (!target) {\n                    return this._reportError(context, \"No target object provided\");\n                }\n                const animationsArray = Array.isArray(animation) ? animation : [animation];\n                const name = animationsArray[0].name;\n                animationGroupToUse = new AnimationGroup(\"flowGraphAnimationGroup-\" + name + \"-\" + target.name, context.configuration.scene);\n                let isInterpolation = false;\n                const interpolationAnimations = context._getGlobalContextVariable(\"interpolationAnimations\", []);\n                for (const anim of animationsArray) {\n                    animationGroupToUse.addTargetedAnimation(anim, target);\n                    if (interpolationAnimations.indexOf(anim.uniqueId) !== -1) {\n                        isInterpolation = true;\n                    }\n                }\n                if (isInterpolation) {\n                    this._checkInterpolationDuplications(context, animationsArray, target);\n                }\n            }\n            // not accepting 0\n            const speed = this.speed.getValue(context) || 1;\n            const from = this.from.getValue(context) ?? 0;\n            // not accepting 0\n            const to = this.to.getValue(context) || animationGroupToUse.to;\n            const loop = !isFinite(to) || this.loop.getValue(context);\n            this.currentAnimationGroup.setValue(animationGroupToUse, context);\n            const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []);\n            // check if it already running\n            if (currentlyRunningAnimationGroups.indexOf(animationGroupToUse.uniqueId) !== -1) {\n                animationGroupToUse.stop();\n            }\n            try {\n                animationGroupToUse.start(loop, speed, from, to);\n                animationGroupToUse.onAnimationGroupEndObservable.add(() => this._onAnimationGroupEnd(context));\n                animationGroupToUse.onAnimationEndObservable.add(() => this._eventsSignalOutputs[\"animationEnd\"]._activateSignal(context));\n                animationGroupToUse.onAnimationLoopObservable.add(() => this._eventsSignalOutputs[\"animationLoop\"]._activateSignal(context));\n                animationGroupToUse.onAnimationGroupLoopObservable.add(() => this._eventsSignalOutputs[\"animationGroupLoop\"]._activateSignal(context));\n                currentlyRunningAnimationGroups.push(animationGroupToUse.uniqueId);\n                context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\n            }\n            catch (e) {\n                this._reportError(context, e);\n            }\n        }\n    }\n    _reportError(context, error) {\n        super._reportError(context, error);\n        this.currentFrame.setValue(-1, context);\n        this.currentTime.setValue(-1, context);\n    }\n    /**\n     * @internal\n     */\n    _executeOnTick(_context) {\n        const ag = this.currentAnimationGroup.getValue(_context);\n        if (ag) {\n            this.currentFrame.setValue(ag.getCurrentFrame(), _context);\n            this.currentTime.setValue(ag.animatables[0]?.elapsedTime ?? 0, _context);\n        }\n    }\n    _execute(context) {\n        this._startPendingTasks(context);\n    }\n    _onAnimationGroupEnd(context) {\n        this._removeFromCurrentlyRunning(context, this.currentAnimationGroup.getValue(context));\n        this._resetAfterCanceled(context);\n        this.done._activateSignal(context);\n    }\n    /**\n     * The idea behind this function is to check every running animation group and check if the targeted animations it uses are interpolation animations.\n     * If they are, we want to see that they don't collide with the current interpolation animations that are starting to play.\n     * If they do, we want to stop the already-running animation group.\n     * @internal\n     */\n    _checkInterpolationDuplications(context, animation, target) {\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []);\n        for (const uniqueId of currentlyRunningAnimationGroups) {\n            const ag = context.assetsContext.animationGroups.find((ag) => ag.uniqueId === uniqueId);\n            if (ag) {\n                for (const anim of ag.targetedAnimations) {\n                    for (const animToCheck of animation) {\n                        if (anim.animation.targetProperty === animToCheck.targetProperty && anim.target === target) {\n                            this._stopAnimationGroup(context, ag);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    _stopAnimationGroup(context, animationGroup) {\n        // stop, while skipping the on AnimationEndObservable to avoid the \"done\" signal\n        animationGroup.stop(true);\n        animationGroup.dispose();\n        this._removeFromCurrentlyRunning(context, animationGroup);\n    }\n    _removeFromCurrentlyRunning(context, animationGroup) {\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []);\n        const idx = currentlyRunningAnimationGroups.indexOf(animationGroup.uniqueId);\n        if (idx !== -1) {\n            currentlyRunningAnimationGroups.splice(idx, 1);\n            context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\n        }\n    }\n    /**\n     * @internal\n     * Stop any currently running animations.\n     */\n    _cancelPendingTasks(context) {\n        const ag = this.currentAnimationGroup.getValue(context);\n        if (ag) {\n            this._stopAnimationGroup(context, ag);\n        }\n    }\n    /**\n     * @returns class name of the block.\n     */\n    getClassName() {\n        return \"FlowGraphPlayAnimationBlock\" /* FlowGraphBlockNames.PlayAnimation */;\n    }\n}\nRegisterClass(\"FlowGraphPlayAnimationBlock\" /* FlowGraphBlockNames.PlayAnimation */, FlowGraphPlayAnimationBlock);\n//# sourceMappingURL=flowGraphPlayAnimationBlock.js.map"],"names":["FlowGraphPlayAnimationBlock","FlowGraphAsyncExecutionBlock","constructor","config","super","this","speed","registerDataInput","RichTypeNumber","loop","RichTypeBoolean","from","to","currentFrame","registerDataOutput","currentTime","currentAnimationGroup","RichTypeAny","animationGroup","animation","object","_preparePendingTasks","context","ag","getValue","_reportError","dispose","animationGroupToUse","target","animationsArray","Array","isArray","name","AnimationGroup","configuration","scene","isInterpolation","interpolationAnimations","_getGlobalContextVariable","anim","addTargetedAnimation","indexOf","uniqueId","_checkInterpolationDuplications","isFinite","setValue","currentlyRunningAnimationGroups","stop","start","onAnimationGroupEndObservable","add","_onAnimationGroupEnd","onAnimationEndObservable","_eventsSignalOutputs","_activateSignal","onAnimationLoopObservable","onAnimationGroupLoopObservable","push","_setGlobalContextVariable","e","error","_executeOnTick","_context","getCurrentFrame","animatables","elapsedTime","_execute","_startPendingTasks","_removeFromCurrentlyRunning","_resetAfterCanceled","done","assetsContext","animationGroups","find","targetedAnimations","animToCheck","targetProperty","_stopAnimationGroup","idx","splice","_cancelPendingTasks","getClassName","RegisterClass"],"mappings":"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"}