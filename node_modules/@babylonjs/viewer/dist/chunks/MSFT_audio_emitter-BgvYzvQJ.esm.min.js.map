{"version":3,"file":"MSFT_audio_emitter-BgvYzvQJ.esm.min.js","sources":["../../../../../dev/core/dist/Animations/animationEvent.js","../../../../../dev/core/dist/Audio/sound.js","../../../../../dev/core/dist/Audio/weightedsound.js","../../../../../dev/core/dist/Audio/soundTrack.js","../../../../../dev/core/dist/Audio/audioSceneComponent.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/MSFT_audio_emitter.js"],"sourcesContent":["/**\n * Composed of a frame, and an action function\n */\nexport class AnimationEvent {\n    /**\n     * Initializes the animation event\n     * @param frame The frame for which the event is triggered\n     * @param action The event to perform when triggered\n     * @param onlyOnce Specifies if the event should be triggered only once\n     */\n    constructor(\n    /** The frame for which the event is triggered **/\n    frame, \n    /** The event to perform when triggered **/\n    action, \n    /** Specifies if the event should be triggered only once**/\n    onlyOnce) {\n        this.frame = frame;\n        this.action = action;\n        this.onlyOnce = onlyOnce;\n        /**\n         * Specifies if the animation event is done\n         */\n        this.isDone = false;\n    }\n    /** @internal */\n    _clone() {\n        return new AnimationEvent(this.frame, this.action, this.onlyOnce);\n    }\n}\n//# sourceMappingURL=animationEvent.js.map","import { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { _WarnImport } from \"../Misc/devTools\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\nimport { _RetryWithInterval } from \"core/Misc/timingTools\";\n/**\n * Defines a sound that can be played in the application.\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\n */\nexport class Sound {\n    /**\n     * Does the sound loop after it finishes playing once.\n     */\n    get loop() {\n        return this._loop;\n    }\n    set loop(value) {\n        if (value === this._loop) {\n            return;\n        }\n        this._loop = value;\n        this.updateOptions({ loop: value });\n    }\n    /**\n     * Gets the current time for the sound.\n     */\n    get currentTime() {\n        if (this._htmlAudioElement) {\n            return this._htmlAudioElement.currentTime;\n        }\n        if (AbstractEngine.audioEngine?.audioContext && (this.isPlaying || this.isPaused)) {\n            // The `_currentTime` member is only updated when the sound is paused. Add the time since the last start\n            // to get the actual current time.\n            const timeSinceLastStart = this.isPaused ? 0 : AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;\n            return this._currentTime + timeSinceLastStart;\n        }\n        return 0;\n    }\n    /**\n     * Does this sound enables spatial sound.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    get spatialSound() {\n        return this._spatialSound;\n    }\n    /**\n     * Does this sound enables spatial sound.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    set spatialSound(newValue) {\n        if (newValue == this._spatialSound) {\n            return;\n        }\n        const wasPlaying = this.isPlaying;\n        this.pause();\n        if (newValue) {\n            this._spatialSound = newValue;\n            this._updateSpatialParameters();\n        }\n        else {\n            this._disableSpatialSound();\n        }\n        if (wasPlaying) {\n            this.play();\n        }\n    }\n    /**\n     * Create a sound and attach it to a scene\n     * @param name Name of your sound\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\n     * @param scene defines the scene the sound belongs to\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\n     */\n    constructor(name, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {\n        /**\n         * Does the sound autoplay once loaded.\n         */\n        this.autoplay = false;\n        this._loop = false;\n        /**\n         * Does the sound use a custom attenuation curve to simulate the falloff\n         * happening when the source gets further away from the camera.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\n         */\n        this.useCustomAttenuation = false;\n        /**\n         * Is this sound currently played.\n         */\n        this.isPlaying = false;\n        /**\n         * Is this sound currently paused.\n         */\n        this.isPaused = false;\n        /**\n         * Define the reference distance the sound should be heard perfectly.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n         */\n        this.refDistance = 1;\n        /**\n         * Define the roll off factor of spatial sounds.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n         */\n        this.rolloffFactor = 1;\n        /**\n         * Define the max distance the sound should be heard (intensity just became 0 at this point).\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n         */\n        this.maxDistance = 100;\n        /**\n         * Define the distance attenuation model the sound will follow.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n         */\n        this.distanceModel = \"linear\";\n        /**\n         * Gets or sets an object used to store user defined information for the sound.\n         */\n        this.metadata = null;\n        /**\n         * Observable event when the current playing sound finishes.\n         */\n        this.onEndedObservable = new Observable();\n        this._spatialSound = false;\n        this._panningModel = \"equalpower\";\n        this._playbackRate = 1;\n        this._streaming = false;\n        this._startTime = 0;\n        this._currentTime = 0;\n        this._position = Vector3.Zero();\n        this._localDirection = new Vector3(1, 0, 0);\n        this._volume = 1;\n        this._isReadyToPlay = false;\n        this._isDirectional = false;\n        // Used if you'd like to create a directional sound.\n        // If not set, the sound will be omnidirectional\n        this._coneInnerAngle = 360;\n        this._coneOuterAngle = 360;\n        this._coneOuterGain = 0;\n        this._isOutputConnected = false;\n        this._urlType = \"Unknown\";\n        this.name = name;\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this._scene = scene;\n        Sound._SceneComponentInitialization(scene);\n        this._readyToPlayCallback = readyToPlayCallback;\n        // Default custom attenuation function is a linear attenuation\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {\n            if (currentDistance < maxDistance) {\n                return currentVolume * (1 - currentDistance / maxDistance);\n            }\n            else {\n                return 0;\n            }\n        };\n        if (options) {\n            this.autoplay = options.autoplay || false;\n            this._loop = options.loop || false;\n            // if volume === 0, we need another way to check this option\n            if (options.volume !== undefined) {\n                this._volume = options.volume;\n            }\n            this._spatialSound = options.spatialSound ?? false;\n            this.maxDistance = options.maxDistance ?? 100;\n            this.useCustomAttenuation = options.useCustomAttenuation ?? false;\n            this.rolloffFactor = options.rolloffFactor || 1;\n            this.refDistance = options.refDistance || 1;\n            this.distanceModel = options.distanceModel || \"linear\";\n            this._playbackRate = options.playbackRate || 1;\n            this._streaming = options.streaming ?? false;\n            this._length = options.length;\n            this._offset = options.offset;\n        }\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\n            this._soundGain = AbstractEngine.audioEngine.audioContext.createGain();\n            this._soundGain.gain.value = this._volume;\n            this._inputAudioNode = this._soundGain;\n            this._outputAudioNode = this._soundGain;\n            if (this._spatialSound) {\n                this._createSpatialParameters();\n            }\n            this._scene.mainSoundTrack.addSound(this);\n            let validParameter = true;\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\n            if (urlOrArrayBuffer) {\n                try {\n                    if (typeof urlOrArrayBuffer === \"string\") {\n                        this._urlType = \"String\";\n                        this._url = urlOrArrayBuffer;\n                    }\n                    else if (urlOrArrayBuffer instanceof ArrayBuffer) {\n                        this._urlType = \"ArrayBuffer\";\n                    }\n                    else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\n                        this._urlType = \"MediaElement\";\n                    }\n                    else if (urlOrArrayBuffer instanceof MediaStream) {\n                        this._urlType = \"MediaStream\";\n                    }\n                    else if (urlOrArrayBuffer instanceof AudioBuffer) {\n                        this._urlType = \"AudioBuffer\";\n                    }\n                    else if (Array.isArray(urlOrArrayBuffer)) {\n                        this._urlType = \"Array\";\n                    }\n                    let urls = [];\n                    let codecSupportedFound = false;\n                    switch (this._urlType) {\n                        case \"MediaElement\":\n                            this._streaming = true;\n                            this._isReadyToPlay = true;\n                            this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\n                            if (this.autoplay) {\n                                this.play(0, this._offset, this._length);\n                            }\n                            if (this._readyToPlayCallback) {\n                                this._readyToPlayCallback();\n                            }\n                            break;\n                        case \"MediaStream\":\n                            this._streaming = true;\n                            this._isReadyToPlay = true;\n                            this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\n                            if (this.autoplay) {\n                                this.play(0, this._offset, this._length);\n                            }\n                            if (this._readyToPlayCallback) {\n                                this._readyToPlayCallback();\n                            }\n                            break;\n                        case \"ArrayBuffer\":\n                            if (urlOrArrayBuffer.byteLength > 0) {\n                                codecSupportedFound = true;\n                                this._soundLoaded(urlOrArrayBuffer);\n                            }\n                            break;\n                        case \"AudioBuffer\":\n                            this._audioBufferLoaded(urlOrArrayBuffer);\n                            break;\n                        case \"String\":\n                            urls.push(urlOrArrayBuffer);\n                        // eslint-disable-next-line no-fallthrough\n                        case \"Array\":\n                            if (urls.length === 0) {\n                                urls = urlOrArrayBuffer;\n                            }\n                            // If we found a supported format, we load it immediately and stop the loop\n                            for (let i = 0; i < urls.length; i++) {\n                                const url = urls[i];\n                                codecSupportedFound =\n                                    (options && options.skipCodecCheck) ||\n                                        (url.indexOf(\".mp3\", url.length - 4) !== -1 && AbstractEngine.audioEngine.isMP3supported) ||\n                                        (url.indexOf(\".ogg\", url.length - 4) !== -1 && AbstractEngine.audioEngine.isOGGsupported) ||\n                                        url.indexOf(\".wav\", url.length - 4) !== -1 ||\n                                        url.indexOf(\".m4a\", url.length - 4) !== -1 ||\n                                        url.indexOf(\".mp4\", url.length - 4) !== -1 ||\n                                        url.indexOf(\"blob:\") !== -1;\n                                if (codecSupportedFound) {\n                                    // Loading sound\n                                    if (!this._streaming) {\n                                        this._scene._loadFile(url, (data) => {\n                                            this._soundLoaded(data);\n                                        }, undefined, true, true, (exception) => {\n                                            if (exception) {\n                                                Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\n                                            }\n                                            Logger.Error(\"Sound creation aborted.\");\n                                            this._scene.mainSoundTrack.removeSound(this);\n                                        });\n                                    }\n                                    // Streaming sound using HTML5 Audio tag\n                                    else {\n                                        this._htmlAudioElement = new Audio(url);\n                                        this._htmlAudioElement.controls = false;\n                                        this._htmlAudioElement.loop = this.loop;\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\n                                        this._htmlAudioElement.preload = \"auto\";\n                                        this._htmlAudioElement.addEventListener(\"canplaythrough\", () => {\n                                            this._isReadyToPlay = true;\n                                            if (this.autoplay) {\n                                                this.play(0, this._offset, this._length);\n                                            }\n                                            if (this._readyToPlayCallback) {\n                                                this._readyToPlayCallback();\n                                            }\n                                        }, { once: true });\n                                        document.body.appendChild(this._htmlAudioElement);\n                                        this._htmlAudioElement.load();\n                                    }\n                                    break;\n                                }\n                            }\n                            break;\n                        default:\n                            validParameter = false;\n                            break;\n                    }\n                    if (!validParameter) {\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n                    }\n                    else {\n                        if (!codecSupportedFound) {\n                            this._isReadyToPlay = true;\n                            // Simulating a ready to play event to avoid breaking code path\n                            if (this._readyToPlayCallback) {\n                                setTimeout(() => {\n                                    if (this._readyToPlayCallback) {\n                                        this._readyToPlayCallback();\n                                    }\n                                }, 1000);\n                            }\n                        }\n                    }\n                }\n                catch (ex) {\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\n                    this._scene.mainSoundTrack.removeSound(this);\n                }\n            }\n        }\n        else {\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\n            this._scene.mainSoundTrack.addSound(this);\n            if (AbstractEngine.audioEngine && !AbstractEngine.audioEngine.WarnedWebAudioUnsupported) {\n                Logger.Error(\"Web Audio is not supported by your browser.\");\n                AbstractEngine.audioEngine.WarnedWebAudioUnsupported = true;\n            }\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\n            if (this._readyToPlayCallback) {\n                setTimeout(() => {\n                    if (this._readyToPlayCallback) {\n                        this._readyToPlayCallback();\n                    }\n                }, 1000);\n            }\n        }\n    }\n    /**\n     * Release the sound and its associated resources\n     */\n    dispose() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\n            if (this.isPlaying) {\n                this.stop();\n            }\n            this._isReadyToPlay = false;\n            if (this.soundTrackId === -1) {\n                this._scene.mainSoundTrack.removeSound(this);\n            }\n            else if (this._scene.soundTracks) {\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\n            }\n            if (this._soundGain) {\n                this._soundGain.disconnect();\n                this._soundGain = null;\n            }\n            if (this._soundPanner) {\n                this._soundPanner.disconnect();\n                this._soundPanner = null;\n            }\n            if (this._soundSource) {\n                this._soundSource.disconnect();\n                this._soundSource = null;\n            }\n            this._audioBuffer = null;\n            if (this._htmlAudioElement) {\n                this._htmlAudioElement.pause();\n                this._htmlAudioElement.src = \"\";\n                document.body.removeChild(this._htmlAudioElement);\n                this._htmlAudioElement = null;\n            }\n            if (this._streamingSource) {\n                this._streamingSource.disconnect();\n                this._streamingSource = null;\n            }\n            if (this._connectedTransformNode && this._registerFunc) {\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n                this._connectedTransformNode = null;\n            }\n            this._clearTimeoutsAndObservers();\n        }\n    }\n    /**\n     * Gets if the sounds is ready to be played or not.\n     * @returns true if ready, otherwise false\n     */\n    isReady() {\n        return this._isReadyToPlay;\n    }\n    /**\n     * Get the current class name.\n     * @returns current class name\n     */\n    getClassName() {\n        return \"Sound\";\n    }\n    _audioBufferLoaded(buffer) {\n        if (!AbstractEngine.audioEngine?.audioContext) {\n            return;\n        }\n        this._audioBuffer = buffer;\n        this._isReadyToPlay = true;\n        if (this.autoplay) {\n            this.play(0, this._offset, this._length);\n        }\n        if (this._readyToPlayCallback) {\n            this._readyToPlayCallback();\n        }\n    }\n    _soundLoaded(audioData) {\n        if (!AbstractEngine.audioEngine?.audioContext) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        AbstractEngine.audioEngine.audioContext.decodeAudioData(audioData, (buffer) => {\n            this._audioBufferLoaded(buffer);\n        }, (err) => {\n            Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\n        });\n    }\n    /**\n     * Sets the data of the sound from an audiobuffer\n     * @param audioBuffer The audioBuffer containing the data\n     */\n    setAudioBuffer(audioBuffer) {\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\n            this._audioBuffer = audioBuffer;\n            this._isReadyToPlay = true;\n        }\n    }\n    /**\n     * Updates the current sounds options such as maxdistance, loop...\n     * @param options A JSON object containing values named as the object properties\n     */\n    updateOptions(options) {\n        if (options) {\n            this.loop = options.loop ?? this.loop;\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\n            this.refDistance = options.refDistance ?? this.refDistance;\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\n            this._playbackRate = options.playbackRate ?? this._playbackRate;\n            this._length = options.length ?? undefined;\n            this.spatialSound = options.spatialSound ?? this._spatialSound;\n            this._setOffset(options.offset ?? undefined);\n            this.setVolume(options.volume ?? this._volume);\n            this._updateSpatialParameters();\n            if (this.isPlaying) {\n                if (this._streaming && this._htmlAudioElement) {\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\n                    if (this._htmlAudioElement.loop !== this.loop) {\n                        this._htmlAudioElement.loop = this.loop;\n                    }\n                }\n                else {\n                    if (this._soundSource) {\n                        this._soundSource.playbackRate.value = this._playbackRate;\n                        if (this._soundSource.loop !== this.loop) {\n                            this._soundSource.loop = this.loop;\n                        }\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\n                            this._soundSource.loopStart = this._offset;\n                        }\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\n                            this._soundSource.loopEnd = (this._offset | 0) + this._length;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    _createSpatialParameters() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\n            if (this._scene.headphone) {\n                this._panningModel = \"HRTF\";\n            }\n            this._soundPanner = this._soundPanner ?? AbstractEngine.audioEngine.audioContext.createPanner();\n            if (this._soundPanner && this._outputAudioNode) {\n                this._updateSpatialParameters();\n                this._soundPanner.connect(this._outputAudioNode);\n                this._inputAudioNode = this._soundPanner;\n            }\n        }\n    }\n    _disableSpatialSound() {\n        if (!this._spatialSound) {\n            return;\n        }\n        this._inputAudioNode = this._soundGain;\n        this._soundPanner?.disconnect();\n        this._soundPanner = null;\n        this._spatialSound = false;\n    }\n    _updateSpatialParameters() {\n        if (!this._spatialSound) {\n            return;\n        }\n        if (this._soundPanner) {\n            if (this.useCustomAttenuation) {\n                // Tricks to disable in a way embedded Web Audio attenuation\n                this._soundPanner.distanceModel = \"linear\";\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\n                this._soundPanner.refDistance = 1;\n                this._soundPanner.rolloffFactor = 1;\n                this._soundPanner.panningModel = this._panningModel;\n            }\n            else {\n                this._soundPanner.distanceModel = this.distanceModel;\n                this._soundPanner.maxDistance = this.maxDistance;\n                this._soundPanner.refDistance = this.refDistance;\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\n                this._soundPanner.panningModel = this._panningModel;\n            }\n        }\n        else {\n            this._createSpatialParameters();\n        }\n    }\n    /**\n     * Switch the panning model to HRTF:\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToHRTF() {\n        this._panningModel = \"HRTF\";\n        this._switchPanningModel();\n    }\n    /**\n     * Switch the panning model to Equal Power:\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToEqualPower() {\n        this._panningModel = \"equalpower\";\n        this._switchPanningModel();\n    }\n    _switchPanningModel() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\n            this._soundPanner.panningModel = this._panningModel;\n        }\n    }\n    /**\n     * Connect this sound to a sound track audio node like gain...\n     * @param soundTrackAudioNode the sound track audio node to connect to\n     */\n    connectToSoundTrackAudioNode(soundTrackAudioNode) {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\n            if (this._isOutputConnected) {\n                this._outputAudioNode.disconnect();\n            }\n            this._outputAudioNode.connect(soundTrackAudioNode);\n            this._isOutputConnected = true;\n        }\n    }\n    /**\n     * Transform this sound into a directional source\n     * @param coneInnerAngle Size of the inner cone in degree\n     * @param coneOuterAngle Size of the outer cone in degree\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\n     */\n    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n        if (coneOuterAngle < coneInnerAngle) {\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n            return;\n        }\n        this._coneInnerAngle = coneInnerAngle;\n        this._coneOuterAngle = coneOuterAngle;\n        this._coneOuterGain = coneOuterGain;\n        this._isDirectional = true;\n        if (this.isPlaying && this.loop) {\n            this.stop();\n            this.play(0, this._offset, this._length);\n        }\n    }\n    /**\n     * Gets or sets the inner angle for the directional cone.\n     */\n    get directionalConeInnerAngle() {\n        return this._coneInnerAngle;\n    }\n    /**\n     * Gets or sets the inner angle for the directional cone.\n     */\n    set directionalConeInnerAngle(value) {\n        if (value != this._coneInnerAngle) {\n            if (this._coneOuterAngle < value) {\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneInnerAngle = value;\n            if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\n                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n            }\n        }\n    }\n    /**\n     * Gets or sets the outer angle for the directional cone.\n     */\n    get directionalConeOuterAngle() {\n        return this._coneOuterAngle;\n    }\n    /**\n     * Gets or sets the outer angle for the directional cone.\n     */\n    set directionalConeOuterAngle(value) {\n        if (value != this._coneOuterAngle) {\n            if (value < this._coneInnerAngle) {\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneOuterAngle = value;\n            if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\n                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n            }\n        }\n    }\n    /**\n     * Sets the position of the emitter if spatial sound is enabled\n     * @param newPosition Defines the new position\n     */\n    setPosition(newPosition) {\n        if (newPosition.equals(this._position)) {\n            return;\n        }\n        this._position.copyFrom(newPosition);\n        if (AbstractEngine.audioEngine?.canUseWebAudio &&\n            this._spatialSound &&\n            this._soundPanner &&\n            !isNaN(this._position.x) &&\n            !isNaN(this._position.y) &&\n            !isNaN(this._position.z)) {\n            this._soundPanner.positionX.value = this._position.x;\n            this._soundPanner.positionY.value = this._position.y;\n            this._soundPanner.positionZ.value = this._position.z;\n        }\n    }\n    /**\n     * Sets the local direction of the emitter if spatial sound is enabled\n     * @param newLocalDirection Defines the new local direction\n     */\n    setLocalDirectionToMesh(newLocalDirection) {\n        this._localDirection = newLocalDirection;\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\n            this._updateDirection();\n        }\n    }\n    _updateDirection() {\n        if (!this._connectedTransformNode || !this._soundPanner) {\n            return;\n        }\n        const mat = this._connectedTransformNode.getWorldMatrix();\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\n        direction.normalize();\n        this._soundPanner.orientationX.value = direction.x;\n        this._soundPanner.orientationY.value = direction.y;\n        this._soundPanner.orientationZ.value = direction.z;\n    }\n    /** @internal */\n    updateDistanceFromListener() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\n            const distance = this._scene.audioListenerPositionProvider\n                ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length()\n                : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n        }\n    }\n    /**\n     * Sets a new custom attenuation function for the sound.\n     * @param callback Defines the function used for the attenuation\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\n     */\n    setAttenuationFunction(callback) {\n        this._customAttenuationFunction = callback;\n    }\n    /**\n     * Play the sound\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\n     * @param offset (optional) Start the sound at a specific time in seconds\n     * @param length (optional) Sound duration (in seconds)\n     */\n    play(time, offset, length) {\n        if (this._isReadyToPlay && this._scene.audioEnabled && AbstractEngine.audioEngine?.audioContext) {\n            try {\n                this._clearTimeoutsAndObservers();\n                let startTime = time ? AbstractEngine.audioEngine?.audioContext.currentTime + time : AbstractEngine.audioEngine?.audioContext.currentTime;\n                if (!this._soundSource || !this._streamingSource) {\n                    if (this._spatialSound && this._soundPanner) {\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n                            this._soundPanner.positionX.value = this._position.x;\n                            this._soundPanner.positionY.value = this._position.y;\n                            this._soundPanner.positionZ.value = this._position.z;\n                        }\n                        if (this._isDirectional) {\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\n                            if (this._connectedTransformNode) {\n                                this._updateDirection();\n                            }\n                            else {\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\n                            }\n                        }\n                    }\n                }\n                if (this._streaming) {\n                    if (!this._streamingSource && this._htmlAudioElement) {\n                        this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\n                        this._htmlAudioElement.onended = () => {\n                            this._onended();\n                        };\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\n                    }\n                    if (this._streamingSource) {\n                        this._streamingSource.disconnect();\n                        if (this._inputAudioNode) {\n                            this._streamingSource.connect(this._inputAudioNode);\n                        }\n                    }\n                    if (this._htmlAudioElement) {\n                        // required to manage properly the new suspended default state of Chrome\n                        // When the option 'streaming: true' is used, we need first to wait for\n                        // the audio engine to be unlocked by a user gesture before trying to play\n                        // an HTML Audio element\n                        const tryToPlay = () => {\n                            if (AbstractEngine.audioEngine?.unlocked) {\n                                if (!this._htmlAudioElement) {\n                                    return;\n                                }\n                                this._htmlAudioElement.currentTime = offset ?? 0;\n                                const playPromise = this._htmlAudioElement.play();\n                                // In browsers that don’t yet support this functionality,\n                                // playPromise won’t be defined.\n                                if (playPromise !== undefined) {\n                                    // eslint-disable-next-line github/no-then\n                                    playPromise.catch(() => {\n                                        // Automatic playback failed.\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\n                                        AbstractEngine.audioEngine?.lock();\n                                        if (this.loop || this.autoplay) {\n                                            this._audioUnlockedObserver = AbstractEngine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\n                                                tryToPlay();\n                                            });\n                                        }\n                                    });\n                                }\n                            }\n                            else {\n                                if (this.loop || this.autoplay) {\n                                    this._audioUnlockedObserver = AbstractEngine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\n                                        tryToPlay();\n                                    });\n                                }\n                            }\n                        };\n                        tryToPlay();\n                    }\n                }\n                else {\n                    const tryToPlay = () => {\n                        if (AbstractEngine.audioEngine?.audioContext) {\n                            length = length || this._length;\n                            if (offset !== undefined) {\n                                this._setOffset(offset);\n                            }\n                            if (this._soundSource) {\n                                const oldSource = this._soundSource;\n                                oldSource.onended = () => {\n                                    oldSource.disconnect();\n                                };\n                            }\n                            this._soundSource = AbstractEngine.audioEngine?.audioContext.createBufferSource();\n                            if (this._soundSource && this._inputAudioNode) {\n                                this._soundSource.buffer = this._audioBuffer;\n                                this._soundSource.connect(this._inputAudioNode);\n                                this._soundSource.loop = this.loop;\n                                if (offset !== undefined) {\n                                    this._soundSource.loopStart = offset;\n                                }\n                                if (length !== undefined) {\n                                    this._soundSource.loopEnd = (offset | 0) + length;\n                                }\n                                this._soundSource.playbackRate.value = this._playbackRate;\n                                this._soundSource.onended = () => {\n                                    this._onended();\n                                };\n                                startTime = time ? AbstractEngine.audioEngine?.audioContext.currentTime + time : AbstractEngine.audioEngine.audioContext.currentTime;\n                                const actualOffset = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource.buffer.duration;\n                                this._soundSource.start(startTime, actualOffset, this.loop ? undefined : length);\n                            }\n                        }\n                    };\n                    if (AbstractEngine.audioEngine?.audioContext.state === \"suspended\") {\n                        // Wait a bit for FF as context seems late to be ready.\n                        this._tryToPlayTimeout = setTimeout(() => {\n                            if (AbstractEngine.audioEngine?.audioContext.state === \"suspended\") {\n                                // Automatic playback failed.\n                                // Waiting for the audio engine to be unlocked by user click on unmute\n                                AbstractEngine.audioEngine.lock();\n                                if (this.loop || this.autoplay) {\n                                    this._audioUnlockedObserver = AbstractEngine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\n                                        tryToPlay();\n                                    });\n                                }\n                            }\n                            else {\n                                tryToPlay();\n                            }\n                        }, 500);\n                    }\n                    else {\n                        tryToPlay();\n                    }\n                }\n                this._startTime = startTime;\n                this.isPlaying = true;\n                this.isPaused = false;\n            }\n            catch (ex) {\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n            }\n        }\n    }\n    _onended() {\n        this.isPlaying = false;\n        this._startTime = 0;\n        this._currentTime = 0;\n        if (this.onended) {\n            this.onended();\n        }\n        this.onEndedObservable.notifyObservers(this);\n    }\n    /**\n     * Stop the sound\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\n     */\n    stop(time) {\n        if (this.isPlaying) {\n            this._clearTimeoutsAndObservers();\n            if (this._streaming) {\n                if (this._htmlAudioElement) {\n                    this._htmlAudioElement.pause();\n                    // Test needed for Firefox or it will generate an Invalid State Error\n                    if (this._htmlAudioElement.currentTime > 0) {\n                        this._htmlAudioElement.currentTime = 0;\n                    }\n                }\n                else {\n                    this._streamingSource?.disconnect();\n                }\n                this.isPlaying = false;\n            }\n            else if (AbstractEngine.audioEngine?.audioContext && this._soundSource) {\n                const stopTime = time ? AbstractEngine.audioEngine.audioContext.currentTime + time : undefined;\n                this._soundSource.onended = () => {\n                    this.isPlaying = false;\n                    this.isPaused = false;\n                    this._startTime = 0;\n                    this._currentTime = 0;\n                    if (this._soundSource) {\n                        this._soundSource.onended = () => void 0;\n                    }\n                    this._onended();\n                };\n                this._soundSource.stop(stopTime);\n            }\n            else {\n                this.isPlaying = false;\n            }\n        }\n        else if (this.isPaused) {\n            this.isPaused = false;\n            this._startTime = 0;\n            this._currentTime = 0;\n        }\n    }\n    /**\n     * Put the sound in pause\n     */\n    pause() {\n        if (this.isPlaying) {\n            this._clearTimeoutsAndObservers();\n            if (this._streaming) {\n                if (this._htmlAudioElement) {\n                    this._htmlAudioElement.pause();\n                }\n                else {\n                    this._streamingSource?.disconnect();\n                }\n                this.isPlaying = false;\n                this.isPaused = true;\n            }\n            else if (AbstractEngine.audioEngine?.audioContext && this._soundSource) {\n                this._soundSource.onended = () => void 0;\n                this._soundSource.stop();\n                this.isPlaying = false;\n                this.isPaused = true;\n                this._currentTime += AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;\n            }\n        }\n    }\n    /**\n     * Sets a dedicated volume for this sounds\n     * @param newVolume Define the new volume of the sound\n     * @param time Define time for gradual change to new volume\n     */\n    setVolume(newVolume, time) {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._soundGain) {\n            if (time && AbstractEngine.audioEngine.audioContext) {\n                this._soundGain.gain.cancelScheduledValues(AbstractEngine.audioEngine.audioContext.currentTime);\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, AbstractEngine.audioEngine.audioContext.currentTime);\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, AbstractEngine.audioEngine.audioContext.currentTime + time);\n            }\n            else {\n                this._soundGain.gain.value = newVolume;\n            }\n        }\n        this._volume = newVolume;\n    }\n    /**\n     * Set the sound play back rate\n     * @param newPlaybackRate Define the playback rate the sound should be played at\n     */\n    setPlaybackRate(newPlaybackRate) {\n        this._playbackRate = newPlaybackRate;\n        if (this.isPlaying) {\n            if (this._streaming && this._htmlAudioElement) {\n                this._htmlAudioElement.playbackRate = this._playbackRate;\n            }\n            else if (this._soundSource) {\n                this._soundSource.playbackRate.value = this._playbackRate;\n            }\n        }\n    }\n    /**\n     * Gets the sound play back rate.\n     * @returns the  play back rate of the sound\n     */\n    getPlaybackRate() {\n        return this._playbackRate;\n    }\n    /**\n     * Gets the volume of the sound.\n     * @returns the volume of the sound\n     */\n    getVolume() {\n        return this._volume;\n    }\n    /**\n     * Attach the sound to a dedicated mesh\n     * @param transformNode The transform node to connect the sound with\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\n     */\n    attachToMesh(transformNode) {\n        if (this._connectedTransformNode && this._registerFunc) {\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n            this._registerFunc = null;\n        }\n        this._connectedTransformNode = transformNode;\n        if (!this._spatialSound) {\n            this._spatialSound = true;\n            this._createSpatialParameters();\n            if (this.isPlaying && this.loop) {\n                this.stop();\n                this.play(0, this._offset, this._length);\n            }\n        }\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\n        this._registerFunc = (transformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\n    }\n    /**\n     * Detach the sound from the previously attached mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\n     */\n    detachFromMesh() {\n        if (this._connectedTransformNode && this._registerFunc) {\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n            this._registerFunc = null;\n            this._connectedTransformNode = null;\n        }\n    }\n    _onRegisterAfterWorldMatrixUpdate(node) {\n        if (!node.getBoundingInfo) {\n            this.setPosition(node.absolutePosition);\n        }\n        else {\n            const mesh = node;\n            const boundingInfo = mesh.getBoundingInfo();\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\n        }\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._isDirectional && this.isPlaying) {\n            this._updateDirection();\n        }\n    }\n    /**\n     * Clone the current sound in the scene.\n     * @returns the new sound clone\n     */\n    clone() {\n        if (!this._streaming) {\n            const setBufferAndRun = () => {\n                _RetryWithInterval(() => this._isReadyToPlay, () => {\n                    clonedSound._audioBuffer = this.getAudioBuffer();\n                    clonedSound._isReadyToPlay = true;\n                    if (clonedSound.autoplay) {\n                        clonedSound.play(0, this._offset, this._length);\n                    }\n                }, undefined, 300);\n            };\n            const currentOptions = {\n                autoplay: this.autoplay,\n                loop: this.loop,\n                volume: this._volume,\n                spatialSound: this._spatialSound,\n                maxDistance: this.maxDistance,\n                useCustomAttenuation: this.useCustomAttenuation,\n                rolloffFactor: this.rolloffFactor,\n                refDistance: this.refDistance,\n                distanceModel: this.distanceModel,\n            };\n            const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\n            if (this.useCustomAttenuation) {\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\n            }\n            clonedSound.setPosition(this._position);\n            clonedSound.setPlaybackRate(this._playbackRate);\n            setBufferAndRun();\n            return clonedSound;\n        }\n        // Can't clone a streaming sound\n        else {\n            return null;\n        }\n    }\n    /**\n     * Gets the current underlying audio buffer containing the data\n     * @returns the audio buffer\n     */\n    getAudioBuffer() {\n        return this._audioBuffer;\n    }\n    /**\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\n     * @returns the source node\n     */\n    getSoundSource() {\n        return this._soundSource;\n    }\n    /**\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\n     * @returns the gain node\n     */\n    getSoundGain() {\n        return this._soundGain;\n    }\n    /**\n     * Serializes the Sound in a JSON representation\n     * @returns the JSON representation of the sound\n     */\n    serialize() {\n        const serializationObject = {\n            name: this.name,\n            url: this._url,\n            autoplay: this.autoplay,\n            loop: this.loop,\n            volume: this._volume,\n            spatialSound: this._spatialSound,\n            maxDistance: this.maxDistance,\n            rolloffFactor: this.rolloffFactor,\n            refDistance: this.refDistance,\n            distanceModel: this.distanceModel,\n            playbackRate: this._playbackRate,\n            panningModel: this._panningModel,\n            soundTrackId: this.soundTrackId,\n            metadata: this.metadata,\n        };\n        if (this._spatialSound) {\n            if (this._connectedTransformNode) {\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\n            }\n            serializationObject.position = this._position.asArray();\n            serializationObject.refDistance = this.refDistance;\n            serializationObject.distanceModel = this.distanceModel;\n            serializationObject.isDirectional = this._isDirectional;\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\n            serializationObject.coneOuterGain = this._coneOuterGain;\n        }\n        return serializationObject;\n    }\n    /**\n     * Parse a JSON representation of a sound to instantiate in a given scene\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\n     * @param scene Define the scene the new parsed sound should be created in\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\n     * @returns the newly parsed sound\n     */\n    static Parse(parsedSound, scene, rootUrl, sourceSound) {\n        const soundName = parsedSound.name;\n        let soundUrl;\n        if (parsedSound.url) {\n            soundUrl = rootUrl + parsedSound.url;\n        }\n        else {\n            soundUrl = rootUrl + soundName;\n        }\n        const options = {\n            autoplay: parsedSound.autoplay,\n            loop: parsedSound.loop,\n            volume: parsedSound.volume,\n            spatialSound: parsedSound.spatialSound,\n            maxDistance: parsedSound.maxDistance,\n            rolloffFactor: parsedSound.rolloffFactor,\n            refDistance: parsedSound.refDistance,\n            distanceModel: parsedSound.distanceModel,\n            playbackRate: parsedSound.playbackRate,\n        };\n        let newSound;\n        if (!sourceSound) {\n            newSound = new Sound(soundName, soundUrl, scene, () => {\n                scene.removePendingData(newSound);\n            }, options);\n            scene.addPendingData(newSound);\n        }\n        else {\n            const setBufferAndRun = () => {\n                _RetryWithInterval(() => sourceSound._isReadyToPlay, () => {\n                    newSound._audioBuffer = sourceSound.getAudioBuffer();\n                    newSound._isReadyToPlay = true;\n                    if (newSound.autoplay) {\n                        newSound.play(0, newSound._offset, newSound._length);\n                    }\n                }, undefined, 300);\n            };\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n            setBufferAndRun();\n        }\n        if (parsedSound.position) {\n            const soundPosition = Vector3.FromArray(parsedSound.position);\n            newSound.setPosition(soundPosition);\n        }\n        if (parsedSound.isDirectional) {\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n            if (parsedSound.localDirectionToMesh) {\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\n            }\n        }\n        if (parsedSound.connectedMeshId) {\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\n            if (connectedMesh) {\n                newSound.attachToMesh(connectedMesh);\n            }\n        }\n        if (parsedSound.metadata) {\n            newSound.metadata = parsedSound.metadata;\n        }\n        return newSound;\n    }\n    _setOffset(value) {\n        if (this._offset === value) {\n            return;\n        }\n        if (this.isPaused) {\n            this.stop();\n            this.isPaused = false;\n        }\n        this._offset = value;\n    }\n    _clearTimeoutsAndObservers() {\n        if (this._tryToPlayTimeout) {\n            clearTimeout(this._tryToPlayTimeout);\n            this._tryToPlayTimeout = null;\n        }\n        if (this._audioUnlockedObserver) {\n            AbstractEngine.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);\n            this._audioUnlockedObserver = null;\n        }\n    }\n}\n/**\n * @internal\n */\nSound._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"AudioSceneComponent\");\n};\n// Register Class Name\nRegisterClass(\"BABYLON.Sound\", Sound);\n//# sourceMappingURL=sound.js.map","import { Logger } from \"../Misc/logger\";\n/**\n * Wraps one or more Sound objects and selects one with random weight for playback.\n */\nexport class WeightedSound {\n    /**\n     * Creates a new WeightedSound from the list of sounds given.\n     * @param loop When true a Sound will be selected and played when the current playing Sound completes.\n     * @param sounds Array of Sounds that will be selected from.\n     * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\n     */\n    constructor(loop, sounds, weights) {\n        /** When true a Sound will be selected and played when the current playing Sound completes. */\n        this.loop = false;\n        this._coneInnerAngle = 360;\n        this._coneOuterAngle = 360;\n        this._volume = 1;\n        /** A Sound is currently playing. */\n        this.isPlaying = false;\n        /** A Sound is currently paused. */\n        this.isPaused = false;\n        this._sounds = [];\n        this._weights = [];\n        if (sounds.length !== weights.length) {\n            throw new Error(\"Sounds length does not equal weights length\");\n        }\n        this.loop = loop;\n        this._weights = weights;\n        // Normalize the weights\n        let weightSum = 0;\n        for (const weight of weights) {\n            weightSum += weight;\n        }\n        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\n        for (let i = 0; i < this._weights.length; i++) {\n            this._weights[i] *= invWeightSum;\n        }\n        this._sounds = sounds;\n        for (const sound of this._sounds) {\n            sound.onEndedObservable.add(() => {\n                this._onended();\n            });\n        }\n    }\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    get directionalConeInnerAngle() {\n        return this._coneInnerAngle;\n    }\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    set directionalConeInnerAngle(value) {\n        if (value !== this._coneInnerAngle) {\n            if (this._coneOuterAngle < value) {\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneInnerAngle = value;\n            for (const sound of this._sounds) {\n                sound.directionalConeInnerAngle = value;\n            }\n        }\n    }\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    get directionalConeOuterAngle() {\n        return this._coneOuterAngle;\n    }\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    set directionalConeOuterAngle(value) {\n        if (value !== this._coneOuterAngle) {\n            if (value < this._coneInnerAngle) {\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneOuterAngle = value;\n            for (const sound of this._sounds) {\n                sound.directionalConeOuterAngle = value;\n            }\n        }\n    }\n    /**\n     * Playback volume.\n     */\n    get volume() {\n        return this._volume;\n    }\n    /**\n     * Playback volume.\n     */\n    set volume(value) {\n        if (value !== this._volume) {\n            for (const sound of this._sounds) {\n                sound.setVolume(value);\n            }\n        }\n    }\n    _onended() {\n        if (this._currentIndex !== undefined) {\n            this._sounds[this._currentIndex].autoplay = false;\n        }\n        if (this.loop && this.isPlaying) {\n            this.play();\n        }\n        else {\n            this.isPlaying = false;\n        }\n    }\n    /**\n     * Suspend playback\n     */\n    pause() {\n        if (this.isPlaying) {\n            this.isPaused = true;\n            if (this._currentIndex !== undefined) {\n                this._sounds[this._currentIndex].pause();\n            }\n        }\n    }\n    /**\n     * Stop playback\n     */\n    stop() {\n        this.isPlaying = false;\n        if (this._currentIndex !== undefined) {\n            this._sounds[this._currentIndex].stop();\n        }\n    }\n    /**\n     * Start playback.\n     * @param startOffset Position the clip head at a specific time in seconds.\n     */\n    play(startOffset) {\n        if (!this.isPaused) {\n            this.stop();\n            const randomValue = Math.random();\n            let total = 0;\n            for (let i = 0; i < this._weights.length; i++) {\n                total += this._weights[i];\n                if (randomValue <= total) {\n                    this._currentIndex = i;\n                    break;\n                }\n            }\n        }\n        const sound = this._sounds[this._currentIndex ?? 0];\n        if (sound.isReady()) {\n            sound.play(0, this.isPaused ? undefined : startOffset);\n        }\n        else {\n            sound.autoplay = true;\n        }\n        this.isPlaying = true;\n        this.isPaused = false;\n    }\n}\n//# sourceMappingURL=weightedsound.js.map","import { EngineStore } from \"../Engines/engineStore\";\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\n/**\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\n * It will be also used in a future release to apply effects on a specific track.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\n */\nexport class SoundTrack {\n    /**\n     * Creates a new sound track.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\n     * @param scene Define the scene the sound track belongs to\n     * @param options\n     */\n    constructor(scene, options = {}) {\n        /**\n         * The unique identifier of the sound track in the scene.\n         */\n        this.id = -1;\n        this._isInitialized = false;\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this._scene = scene;\n        this.soundCollection = [];\n        this._options = options;\n        if (!this._options.mainTrack && this._scene.soundTracks) {\n            this._scene.soundTracks.push(this);\n            this.id = this._scene.soundTracks.length - 1;\n        }\n    }\n    _initializeSoundTrackAudioGraph() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\n            this._outputAudioNode = AbstractEngine.audioEngine.audioContext.createGain();\n            this._outputAudioNode.connect(AbstractEngine.audioEngine.masterGain);\n            if (this._options) {\n                if (this._options.volume) {\n                    this._outputAudioNode.gain.value = this._options.volume;\n                }\n            }\n            this._isInitialized = true;\n        }\n    }\n    /**\n     * Release the sound track and its associated resources\n     */\n    dispose() {\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.canUseWebAudio) {\n            if (this._connectedAnalyser) {\n                this._connectedAnalyser.stopDebugCanvas();\n            }\n            while (this.soundCollection.length) {\n                this.soundCollection[0].dispose();\n            }\n            if (this._outputAudioNode) {\n                this._outputAudioNode.disconnect();\n            }\n            this._outputAudioNode = null;\n        }\n    }\n    /**\n     * Adds a sound to this sound track\n     * @param sound define the sound to add\n     * @ignoreNaming\n     */\n    addSound(sound) {\n        if (!this._isInitialized) {\n            this._initializeSoundTrackAudioGraph();\n        }\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\n            sound.connectToSoundTrackAudioNode(this._outputAudioNode);\n        }\n        if (sound.soundTrackId !== undefined) {\n            if (sound.soundTrackId === -1) {\n                this._scene.mainSoundTrack.removeSound(sound);\n            }\n            else if (this._scene.soundTracks) {\n                this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\n            }\n        }\n        this.soundCollection.push(sound);\n        sound.soundTrackId = this.id;\n    }\n    /**\n     * Removes a sound to this sound track\n     * @param sound define the sound to remove\n     * @ignoreNaming\n     */\n    removeSound(sound) {\n        const index = this.soundCollection.indexOf(sound);\n        if (index !== -1) {\n            this.soundCollection.splice(index, 1);\n        }\n    }\n    /**\n     * Set a global volume for the full sound track.\n     * @param newVolume Define the new volume of the sound track\n     */\n    setVolume(newVolume) {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\n            this._outputAudioNode.gain.value = newVolume;\n        }\n    }\n    /**\n     * Switch the panning model to HRTF:\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToHRTF() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\n            for (let i = 0; i < this.soundCollection.length; i++) {\n                this.soundCollection[i].switchPanningModelToHRTF();\n            }\n        }\n    }\n    /**\n     * Switch the panning model to Equal Power:\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToEqualPower() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\n            for (let i = 0; i < this.soundCollection.length; i++) {\n                this.soundCollection[i].switchPanningModelToEqualPower();\n            }\n        }\n    }\n    /**\n     * Connect the sound track to an audio analyser allowing some amazing\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\n     * @param analyser The analyser to connect to the engine\n     */\n    connectToAnalyser(analyser) {\n        if (this._connectedAnalyser) {\n            this._connectedAnalyser.stopDebugCanvas();\n        }\n        this._connectedAnalyser = analyser;\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\n            this._outputAudioNode.disconnect();\n            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, AbstractEngine.audioEngine.masterGain);\n        }\n    }\n}\n//# sourceMappingURL=soundTrack.js.map","import { Sound } from \"./sound\";\nimport { SoundTrack } from \"./soundTrack\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { Scene } from \"../scene\";\nimport \"./audioEngine\";\nimport { PrecisionDate } from \"../Misc/precisionDate\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\n// Adds the parser to the scene parsers.\nAddParser(SceneComponentConstants.NAME_AUDIO, (parsedData, scene, container, rootUrl) => {\n    // TODO: add sound\n    let loadedSounds = [];\n    let loadedSound;\n    container.sounds = container.sounds || [];\n    if (parsedData.sounds !== undefined && parsedData.sounds !== null) {\n        for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {\n            const parsedSound = parsedData.sounds[index];\n            if (AbstractEngine.audioEngine?.canUseWebAudio) {\n                if (!parsedSound.url) {\n                    parsedSound.url = parsedSound.name;\n                }\n                if (!loadedSounds[parsedSound.url]) {\n                    loadedSound = Sound.Parse(parsedSound, scene, rootUrl);\n                    loadedSounds[parsedSound.url] = loadedSound;\n                    container.sounds.push(loadedSound);\n                }\n                else {\n                    container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));\n                }\n            }\n            else {\n                container.sounds.push(new Sound(parsedSound.name, null, scene));\n            }\n        }\n    }\n    loadedSounds = [];\n});\nObject.defineProperty(Scene.prototype, \"mainSoundTrack\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (!this._mainSoundTrack) {\n            this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });\n        }\n        return this._mainSoundTrack;\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.getSoundByName = function (name) {\n    let index;\n    for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\n        if (this.mainSoundTrack.soundCollection[index].name === name) {\n            return this.mainSoundTrack.soundCollection[index];\n        }\n    }\n    if (this.soundTracks) {\n        for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\n            for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\n                if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\n                    return this.soundTracks[sdIndex].soundCollection[index];\n                }\n            }\n        }\n    }\n    return null;\n};\nObject.defineProperty(Scene.prototype, \"audioEnabled\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioEnabled;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value) {\n            compo.enableAudio();\n        }\n        else {\n            compo.disableAudio();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"headphone\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.headphone;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value) {\n            compo.switchAudioModeForHeadphones();\n        }\n        else {\n            compo.switchAudioModeForNormalSpeakers();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"audioListenerPositionProvider\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioListenerPositionProvider;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value && typeof value !== \"function\") {\n            throw new Error(\"The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3\");\n        }\n        else {\n            compo.audioListenerPositionProvider = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"audioListenerRotationProvider\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioListenerRotationProvider;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value && typeof value !== \"function\") {\n            throw new Error(\"The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3\");\n        }\n        else {\n            compo.audioListenerRotationProvider = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"audioPositioningRefreshRate\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioPositioningRefreshRate;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        compo.audioPositioningRefreshRate = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Defines the sound scene component responsible to manage any sounds\n * in a given scene.\n */\nexport class AudioSceneComponent {\n    /**\n     * Gets whether audio is enabled or not.\n     * Please use related enable/disable method to switch state.\n     */\n    get audioEnabled() {\n        return this._audioEnabled;\n    }\n    /**\n     * Gets whether audio is outputting to headphone or not.\n     * Please use the according Switch methods to change output.\n     */\n    get headphone() {\n        return this._headphone;\n    }\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_AUDIO;\n        this._audioEnabled = true;\n        this._headphone = false;\n        /**\n         * Gets or sets a refresh rate when using 3D audio positioning\n         */\n        this.audioPositioningRefreshRate = 500;\n        /**\n         * Gets or Sets a custom listener position for all sounds in the scene\n         * By default, this is the position of the first active camera\n         */\n        this.audioListenerPositionProvider = null;\n        /**\n         * Gets or Sets a custom listener rotation for all sounds in the scene\n         * By default, this is the rotation of the first active camera\n         */\n        this.audioListenerRotationProvider = null;\n        this._cachedCameraDirection = new Vector3();\n        this._cachedCameraPosition = new Vector3();\n        this._lastCheck = 0;\n        this._invertMatrixTemp = new Matrix();\n        this._cameraDirectionTemp = new Vector3();\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this.scene = scene;\n        scene.soundTracks = [];\n        scene.sounds = [];\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do here. (Not rendering related)\n    }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        serializationObject.sounds = [];\n        if (this.scene.soundTracks) {\n            for (let index = 0; index < this.scene.soundTracks.length; index++) {\n                const soundtrack = this.scene.soundTracks[index];\n                for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\n                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     * @param container the container holding the elements\n     */\n    addFromContainer(container) {\n        if (!container.sounds) {\n            return;\n        }\n        for (const sound of container.sounds) {\n            sound.play();\n            sound.autoplay = true;\n            this.scene.mainSoundTrack.addSound(sound);\n        }\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     * @param container contains the elements to remove\n     * @param dispose if the removed element should be disposed (default: false)\n     */\n    removeFromContainer(container, dispose = false) {\n        if (!container.sounds) {\n            return;\n        }\n        for (const sound of container.sounds) {\n            sound.stop();\n            sound.autoplay = false;\n            this.scene.mainSoundTrack.removeSound(sound);\n            if (dispose) {\n                sound.dispose();\n            }\n        }\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        const scene = this.scene;\n        if (scene._mainSoundTrack) {\n            scene.mainSoundTrack.dispose();\n        }\n        if (scene.soundTracks) {\n            for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {\n                scene.soundTracks[scIndex].dispose();\n            }\n        }\n    }\n    /**\n     * Disables audio in the associated scene.\n     */\n    disableAudio() {\n        const scene = this.scene;\n        this._audioEnabled = false;\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            AbstractEngine.audioEngine.audioContext.suspend();\n        }\n        let i;\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n            scene.mainSoundTrack.soundCollection[i].pause();\n        }\n        if (scene.soundTracks) {\n            for (i = 0; i < scene.soundTracks.length; i++) {\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n                    scene.soundTracks[i].soundCollection[j].pause();\n                }\n            }\n        }\n    }\n    /**\n     * Enables audio in the associated scene.\n     */\n    enableAudio() {\n        const scene = this.scene;\n        this._audioEnabled = true;\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            AbstractEngine.audioEngine.audioContext.resume();\n        }\n        let i;\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n            if (scene.mainSoundTrack.soundCollection[i].isPaused) {\n                scene.mainSoundTrack.soundCollection[i].play();\n            }\n        }\n        if (scene.soundTracks) {\n            for (i = 0; i < scene.soundTracks.length; i++) {\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n                    if (scene.soundTracks[i].soundCollection[j].isPaused) {\n                        scene.soundTracks[i].soundCollection[j].play();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Switch audio to headphone output.\n     */\n    switchAudioModeForHeadphones() {\n        const scene = this.scene;\n        this._headphone = true;\n        scene.mainSoundTrack.switchPanningModelToHRTF();\n        if (scene.soundTracks) {\n            for (let i = 0; i < scene.soundTracks.length; i++) {\n                scene.soundTracks[i].switchPanningModelToHRTF();\n            }\n        }\n    }\n    /**\n     * Switch audio to normal speakers.\n     */\n    switchAudioModeForNormalSpeakers() {\n        const scene = this.scene;\n        this._headphone = false;\n        scene.mainSoundTrack.switchPanningModelToEqualPower();\n        if (scene.soundTracks) {\n            for (let i = 0; i < scene.soundTracks.length; i++) {\n                scene.soundTracks[i].switchPanningModelToEqualPower();\n            }\n        }\n    }\n    _afterRender() {\n        const now = PrecisionDate.Now;\n        if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {\n            return;\n        }\n        this._lastCheck = now;\n        const scene = this.scene;\n        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || (scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1)) {\n            return;\n        }\n        const audioEngine = AbstractEngine.audioEngine;\n        if (!audioEngine) {\n            return;\n        }\n        if (audioEngine.audioContext) {\n            let listeningCamera = scene.activeCamera;\n            if (scene.activeCameras && scene.activeCameras.length > 0) {\n                listeningCamera = scene.activeCameras[0];\n            }\n            // A custom listener position provider was set\n            // Use the users provided position instead of camera's\n            if (this.audioListenerPositionProvider) {\n                const position = this.audioListenerPositionProvider();\n                // Set the listener position\n                audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);\n                // Check if there is a listening camera\n            }\n            else if (listeningCamera) {\n                // Set the listener position to the listening camera global position\n                if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {\n                    this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);\n                    audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);\n                }\n            }\n            // Otherwise set the listener position to 0, 0 ,0\n            else {\n                // Set the listener position\n                audioEngine.audioContext.listener.setPosition(0, 0, 0);\n            }\n            // A custom listener rotation provider was set\n            // Use the users provided rotation instead of camera's\n            if (this.audioListenerRotationProvider) {\n                const rotation = this.audioListenerRotationProvider();\n                audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);\n                // Check if there is a listening camera\n            }\n            else if (listeningCamera) {\n                // for VR cameras\n                if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\n                    listeningCamera = listeningCamera.rigCameras[0];\n                }\n                listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);\n                Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);\n                this._cameraDirectionTemp.normalize();\n                // To avoid some errors on GearVR\n                if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {\n                    if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {\n                        this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);\n                        audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);\n                    }\n                }\n            }\n            // Otherwise set the listener rotation to 0, 0 ,0\n            else {\n                // Set the listener position\n                audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);\n            }\n            let i;\n            for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n                const sound = scene.mainSoundTrack.soundCollection[i];\n                if (sound.useCustomAttenuation) {\n                    sound.updateDistanceFromListener();\n                }\n            }\n            if (scene.soundTracks) {\n                for (i = 0; i < scene.soundTracks.length; i++) {\n                    for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n                        const sound = scene.soundTracks[i].soundCollection[j];\n                        if (sound.useCustomAttenuation) {\n                            sound.updateDistanceFromListener();\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nAudioSceneComponent._CameraDirection = new Vector3(0, 0, -1);\nSound._SceneComponentInitialization = (scene) => {\n    let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n        compo = new AudioSceneComponent(scene);\n        scene._addComponent(compo);\n    }\n};\n//# sourceMappingURL=audioSceneComponent.js.map","import { Vector3 } from \"core/Maths/math.vector\";\nimport { Tools } from \"core/Misc/tools\";\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\nimport { Sound } from \"core/Audio/sound\";\nimport { WeightedSound } from \"core/Audio/weightedsound\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport \"core/Audio/audioSceneComponent\";\nconst NAME = \"MSFT_audio_emitter\";\n/**\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_audio_emitter {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        this._clips = null;\n        this._emitters = null;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._clips = extension.clips;\n            this._emitters = extension.emitters;\n            ArrayItem.Assign(this._clips);\n            ArrayItem.Assign(this._emitters);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadSceneAsync(context, scene) {\n        return GLTFLoader.LoadExtensionAsync(context, scene, this.name, async (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadSceneAsync(context, scene));\n            for (const emitterIndex of extension.emitters) {\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                if (emitter.refDistance != undefined ||\n                    emitter.maxDistance != undefined ||\n                    emitter.rolloffFactor != undefined ||\n                    emitter.distanceModel != undefined ||\n                    emitter.innerAngle != undefined ||\n                    emitter.outerAngle != undefined) {\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n                }\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n            }\n            await Promise.all(promises);\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            const promises = new Array();\n            const babylonMesh = await this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\n                for (const emitterIndex of extension.emitters) {\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                    promises.push(\n                    // eslint-disable-next-line github/no-then\n                    this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n                        for (const sound of emitter._babylonSounds) {\n                            sound.attachToMesh(babylonMesh);\n                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                sound.setLocalDirectionToMesh(Vector3.Forward());\n                                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n                            }\n                        }\n                    }));\n                }\n                assign(babylonMesh);\n            });\n            await Promise.all(promises);\n            return babylonMesh;\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAnimationAsync(context, animation) {\n        return GLTFLoader.LoadExtensionAsync(context, animation, this.name, async (extensionContext, extension) => {\n            const babylonAnimationGroup = await this._loader.loadAnimationAsync(context, animation);\n            const promises = new Array();\n            ArrayItem.Assign(extension.events);\n            for (const event of extension.events) {\n                promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n            }\n            await Promise.all(promises);\n            return babylonAnimationGroup;\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadClipAsync(context, clip) {\n        if (clip._objectURL) {\n            return clip._objectURL;\n        }\n        let promise;\n        if (clip.uri) {\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n        }\n        // eslint-disable-next-line github/no-then\n        clip._objectURL = promise.then((data) => {\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\n        });\n        return clip._objectURL;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadEmitterAsync(context, emitter) {\n        emitter._babylonSounds = emitter._babylonSounds || [];\n        if (!emitter._babylonData) {\n            const clipPromises = new Array();\n            const name = emitter.name || `emitter${emitter.index}`;\n            const options = {\n                loop: false,\n                autoplay: false,\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\n            };\n            for (let i = 0; i < emitter.clips.length; i++) {\n                const clipContext = `/extensions/${this.name}/clips`;\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n                clipPromises.push(\n                // eslint-disable-next-line github/no-then\n                this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL) => {\n                    const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\n                    sound.refDistance = emitter.refDistance || 1;\n                    sound.maxDistance = emitter.maxDistance || 256;\n                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                    sound.distanceModel = emitter.distanceModel || \"exponential\";\n                }));\n            }\n            // eslint-disable-next-line github/no-then\n            const promise = Promise.all(clipPromises).then(() => {\n                const weights = emitter.clips.map((clip) => {\n                    return clip.weight || 1;\n                });\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                if (emitter.innerAngle) {\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\n                }\n                if (emitter.outerAngle) {\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\n                }\n                if (emitter.volume) {\n                    weightedSound.volume = emitter.volume;\n                }\n                emitter._babylonData.sound = weightedSound;\n            });\n            emitter._babylonData = {\n                loaded: promise,\n            };\n        }\n        return emitter._babylonData.loaded;\n    }\n    _getEventAction(context, sound, action, time, startOffset) {\n        switch (action) {\n            case \"play\" /* IMSFTAudioEmitter_AnimationEventAction.play */: {\n                return (currentFrame) => {\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\n                    sound.play(frameOffset);\n                };\n            }\n            case \"stop\" /* IMSFTAudioEmitter_AnimationEventAction.stop */: {\n                return () => {\n                    sound.stop();\n                };\n            }\n            case \"pause\" /* IMSFTAudioEmitter_AnimationEventAction.pause */: {\n                return () => {\n                    sound.pause();\n                };\n            }\n            default: {\n                throw new Error(`${context}: Unsupported action ${action}`);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadAnimationEventAsync(context, animationContext, animation, event, babylonAnimationGroup) {\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n            return Promise.resolve();\n        }\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n        const emitterIndex = event.emitter;\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n        // eslint-disable-next-line github/no-then\n        return this._loadEmitterAsync(context, emitter).then(() => {\n            const sound = emitter._babylonData.sound;\n            if (sound) {\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                // Make sure all started audio stops when this animation is terminated.\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n                    sound.stop();\n                });\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n                    sound.pause();\n                });\n            }\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_audio_emitter(loader));\n//# sourceMappingURL=MSFT_audio_emitter.js.map"],"names":["AnimationEvent","constructor","frame","action","onlyOnce","this","isDone","_clone","Sound","loop","_loop","value","updateOptions","currentTime","_htmlAudioElement","AbstractEngine","audioEngine","audioContext","isPlaying","isPaused","timeSinceLastStart","_startTime","_currentTime","spatialSound","_spatialSound","newValue","wasPlaying","pause","_updateSpatialParameters","_disableSpatialSound","play","name","urlOrArrayBuffer","scene","readyToPlayCallback","options","autoplay","useCustomAttenuation","refDistance","rolloffFactor","maxDistance","distanceModel","metadata","onEndedObservable","Observable","_panningModel","_playbackRate","_streaming","_position","Vector3","Zero","_localDirection","_volume","_isReadyToPlay","_isDirectional","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_isOutputConnected","_urlType","EngineStore","LastCreatedScene","_scene","_SceneComponentInitialization","_readyToPlayCallback","_customAttenuationFunction","currentVolume","currentDistance","undefined","volume","playbackRate","streaming","_length","length","_offset","offset","canUseWebAudio","_soundGain","createGain","gain","_inputAudioNode","_outputAudioNode","_createSpatialParameters","mainSoundTrack","addSound","validParameter","_url","ArrayBuffer","HTMLMediaElement","MediaStream","AudioBuffer","Array","isArray","urls","codecSupportedFound","_streamingSource","createMediaElementSource","createMediaStreamSource","byteLength","_soundLoaded","_audioBufferLoaded","push","i","url","skipCodecCheck","indexOf","isMP3supported","isOGGsupported","Audio","controls","Tools","SetCorsBehavior","preload","addEventListener","once","document","body","appendChild","load","_loadFile","data","exception","Logger","Error","status","removeSound","setTimeout","ex","WarnedWebAudioUnsupported","dispose","stop","soundTrackId","soundTracks","disconnect","_soundPanner","_soundSource","_audioBuffer","src","removeChild","_connectedTransformNode","_registerFunc","unregisterAfterWorldMatrixUpdate","_clearTimeoutsAndObservers","isReady","getClassName","buffer","audioData","decodeAudioData","err","setAudioBuffer","audioBuffer","_setOffset","setVolume","loopStart","loopEnd","headphone","createPanner","connect","Number","MAX_VALUE","panningModel","switchPanningModelToHRTF","_switchPanningModel","switchPanningModelToEqualPower","connectToSoundTrackAudioNode","soundTrackAudioNode","setDirectionalCone","coneInnerAngle","coneOuterAngle","coneOuterGain","directionalConeInnerAngle","directionalConeOuterAngle","setPosition","newPosition","equals","copyFrom","isNaN","x","y","z","positionX","positionY","positionZ","setLocalDirectionToMesh","newLocalDirection","_updateDirection","mat","getWorldMatrix","direction","TransformNormal","normalize","orientationX","orientationY","orientationZ","updateDistanceFromListener","activeCamera","distance","audioListenerPositionProvider","position","subtract","getDistanceToCamera","setAttenuationFunction","callback","time","audioEnabled","startTime","setOrientation","onended","_onended","tryToPlay","unlocked","playPromise","catch","lock","_audioUnlockedObserver","onAudioUnlockedObservable","addOnce","oldSource","createBufferSource","actualOffset","duration","start","state","_tryToPlayTimeout","message","notifyObservers","stopTime","newVolume","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","setPlaybackRate","newPlaybackRate","getPlaybackRate","getVolume","attachToMesh","transformNode","_onRegisterAfterWorldMatrixUpdate","registerAfterWorldMatrixUpdate","detachFromMesh","node","getBoundingInfo","boundingInfo","boundingSphere","centerWorld","absolutePosition","clone","setBufferAndRun","_RetryWithInterval","clonedSound","getAudioBuffer","currentOptions","getSoundSource","getSoundGain","serialize","serializationObject","connectedMeshId","id","asArray","isDirectional","localDirectionToMesh","Parse","parsedSound","rootUrl","sourceSound","soundName","soundUrl","newSound","removePendingData","addPendingData","soundPosition","FromArray","connectedMesh","getMeshById","clearTimeout","remove","_","_WarnImport","RegisterClass","WeightedSound","sounds","weights","_sounds","_weights","weightSum","weight","invWeightSum","sound","add","_currentIndex","startOffset","randomValue","Math","random","total","SoundTrack","_isInitialized","soundCollection","_options","mainTrack","_initializeSoundTrackAudioGraph","masterGain","_connectedAnalyser","stopDebugCanvas","index","splice","connectToAnalyser","analyser","connectAudioNodes","Object","defineProperty","Scene","prototype","get","compo","_getComponent","SceneComponentConstants","NAME_AUDIO","AudioSceneComponent","_addComponent","_mainSoundTrack","enumerable","configurable","getSoundByName","sdIndex","set","enableAudio","disableAudio","switchAudioModeForHeadphones","switchAudioModeForNormalSpeakers","audioListenerRotationProvider","audioPositioningRefreshRate","_audioEnabled","_headphone","_cachedCameraDirection","_cachedCameraPosition","_lastCheck","_invertMatrixTemp","Matrix","_cameraDirectionTemp","register","_afterRenderStage","registerStep","STEP_AFTERRENDER_AUDIO","_afterRender","rebuild","soundtrack","soundId","addFromContainer","container","removeFromContainer","scIndex","suspend","j","resume","now","PrecisionDate","Now","listeningCamera","activeCameras","listener","globalPosition","rotation","rigCameras","getViewMatrix","invertToRef","TransformNormalToRef","_CameraDirection","NAME","MSFT_audio_emitter","loader","_loader","enabled","isExtensionUsed","_clips","_emitters","onLoading","extensions","gltf","extension","clips","emitters","ArrayItem","Assign","loadSceneAsync","context","GLTFLoader","LoadExtensionAsync","async","extensionContext","promises","emitterIndex","emitter","Get","innerAngle","outerAngle","_loadEmitterAsync","Promise","all","loadNodeAsync","assign","babylonMesh","then","_babylonSounds","Forward","ToDegrees","PI","loadAnimationAsync","animation","babylonAnimationGroup","events","event","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","promise","uri","loadUriAsync","bufferView","bufferViews","loadBufferViewAsync","URL","createObjectURL","Blob","type","mimeType","_babylonData","clipPromises","clipContext","objectURL","babylonScene","map","weightedSound","loaded","_getEventAction","currentFrame","frameOffset","animationContext","targetedAnimations","resolve","babylonAnimation","babylonAnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}