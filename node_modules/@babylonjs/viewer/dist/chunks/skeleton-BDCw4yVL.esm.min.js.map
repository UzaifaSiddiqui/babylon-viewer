{"version":3,"file":"skeleton-BDCw4yVL.esm.min.js","sources":["../../../../../dev/core/dist/Bones/skeleton.js"],"sourcesContent":["import { Bone } from \"./bone\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { Animation } from \"../Animations/animation\";\nimport { AnimationRange } from \"../Animations/animationRange\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Constants } from \"../Engines/constants\";\nimport { Logger } from \"../Misc/logger\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreBoneMatrices() {\n        return this._useTextureToStoreBoneMatrices;\n    }\n    set useTextureToStoreBoneMatrices(value) {\n        this._useTextureToStoreBoneMatrices = value;\n        this._markAsDirty();\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get isUsingTextureForMatrices() {\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    }\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Creates a new skeleton\n     * @param name defines the skeleton name\n     * @param id defines the skeleton Id\n     * @param scene defines the hosting scene\n     */\n    constructor(\n    /** defines the skeleton name */\n    name, \n    /** defines the skeleton Id */\n    id, scene) {\n        this.name = name;\n        this.id = id;\n        /**\n         * Defines the list of child bones\n         */\n        this.bones = [];\n        /**\n         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n         */\n        this.needInitialSkinMatrix = false;\n        this._isDirty = true;\n        this._meshesWithPoseMatrix = new Array();\n        this._identity = Matrix.Identity();\n        this._currentRenderId = -1;\n        this._ranges = {};\n        this._absoluteTransformIsDirty = true;\n        this._canUseTextureForBones = false;\n        this._uniqueId = 0;\n        /** @internal */\n        this._numBonesWithLinkedTransformNode = 0;\n        /** @internal */\n        this._hasWaitingData = null;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Specifies if the skeleton should be serialized\n         */\n        this.doNotSerialize = false;\n        this._useTextureToStoreBoneMatrices = true;\n        this._animationPropertiesOverride = null;\n        // Events\n        /**\n         * An observable triggered before computing the skeleton's matrices\n         */\n        this.onBeforeComputeObservable = new Observable();\n        this.bones = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._uniqueId = this._scene.getUniqueId();\n        this._scene.addSkeleton(this);\n        //make sure it will recalculate the matrix next time prepare is called.\n        this._isDirty = true;\n        const engineCaps = this._scene.getEngine().getCaps();\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Skeleton\";\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.bones.filter((b) => !b.getParent());\n    }\n    // Members\n    /**\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a Float32Array containing matrices data\n     */\n    getTransformMatrices(mesh) {\n        if (this.needInitialSkinMatrix) {\n            if (!mesh) {\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\n            }\n            if (!mesh._bonesTransformMatrices) {\n                this.prepare(true);\n            }\n            return mesh._bonesTransformMatrices;\n        }\n        if (!this._transformMatrices || this._isDirty) {\n            this.prepare(!this._transformMatrices);\n        }\n        return this._transformMatrices;\n    }\n    /**\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a raw texture containing the data\n     */\n    getTransformMatrixTexture(mesh) {\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n            return mesh._transformMatrixTexture;\n        }\n        return this._transformMatrixTexture;\n    }\n    /**\n     * Gets the current hosting scene\n     * @returns a scene object\n     */\n    getScene() {\n        return this._scene;\n    }\n    // Methods\n    /**\n     * Gets a string representing the current skeleton data\n     * @param fullDetails defines a boolean indicating if we want a verbose version\n     * @returns a string representing the current skeleton data\n     */\n    toString(fullDetails) {\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n        if (fullDetails) {\n            ret += \", Ranges: {\";\n            let first = true;\n            for (const name in this._ranges) {\n                if (first) {\n                    ret += \", \";\n                    first = false;\n                }\n                ret += name;\n            }\n            ret += \"}\";\n        }\n        return ret;\n    }\n    /**\n     * Get bone's index searching by name\n     * @param name defines bone's name to search for\n     * @returns the indice of the bone. Returns -1 if not found\n     */\n    getBoneIndexByName(name) {\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n            if (this.bones[boneIndex].name === name) {\n                return boneIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Create a new animation range\n     * @param name defines the name of the range\n     * @param from defines the start key\n     * @param to defines the end key\n     */\n    createAnimationRange(name, from, to) {\n        // check name not already in use\n        if (!this._ranges[name]) {\n            this._ranges[name] = new AnimationRange(name, from, to);\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].createRange(name, from, to);\n                }\n            }\n        }\n    }\n    /**\n     * Delete a specific animation range\n     * @param name defines the name of the range\n     * @param deleteFrames defines if frames must be removed as well\n     */\n    deleteAnimationRange(name, deleteFrames = true) {\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\n            }\n        }\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n    }\n    /**\n     * Gets a specific animation range\n     * @param name defines the name of the range to look for\n     * @returns the requested animation range or null if not found\n     */\n    getAnimationRange(name) {\n        return this._ranges[name] || null;\n    }\n    /**\n     * Gets the list of all animation ranges defined on this skeleton\n     * @returns an array\n     */\n    getAnimationRanges() {\n        const animationRanges = [];\n        let name;\n        for (name in this._ranges) {\n            animationRanges.push(this._ranges[name]);\n        }\n        return animationRanges;\n    }\n    /**\n     * Copy animation range from a source skeleton.\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n     * @param source defines the source skeleton\n     * @param name defines the name of the range to copy\n     * @param rescaleAsRequired defines if rescaling must be applied if required\n     * @returns true if operation was successful\n     */\n    copyAnimationRange(source, name, rescaleAsRequired = false) {\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\n            return false;\n        }\n        let ret = true;\n        const frameOffset = this._getHighestAnimationFrame() + 1;\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n        const boneDict = {};\n        const sourceBones = source.bones;\n        let nBones;\n        let i;\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n            boneDict[sourceBones[i].name] = sourceBones[i];\n        }\n        if (this.bones.length !== sourceBones.length) {\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n            ret = false;\n        }\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n            const boneName = this.bones[i].name;\n            const sourceBone = boneDict[boneName];\n            if (sourceBone) {\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n            }\n            else {\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                ret = false;\n            }\n        }\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\n        const range = source.getAnimationRange(name);\n        if (range) {\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n        }\n        return ret;\n    }\n    /**\n     * Forces the skeleton to go to rest pose\n     */\n    returnToRest() {\n        for (const bone of this.bones) {\n            if (bone._index !== -1) {\n                bone.returnToRest();\n            }\n        }\n    }\n    _getHighestAnimationFrame() {\n        let ret = 0;\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                const highest = this.bones[i].animations[0].getHighestFrame();\n                if (ret < highest) {\n                    ret = highest;\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Begin a specific animation range\n     * @param name defines the name of the range to start\n     * @param loop defines if looping must be turned on (false by default)\n     * @param speedRatio defines the speed ratio to apply (1 by default)\n     * @param onAnimationEnd defines a callback which will be called when animation will end\n     * @returns a new animatable\n     */\n    beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n        const range = this.getAnimationRange(name);\n        if (!range) {\n            return null;\n        }\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n    }\n    /**\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n     * @param skeleton defines the Skeleton containing the animation range to convert\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n     * @returns the original skeleton\n     */\n    static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n        const rangeValue = skeleton.getAnimationRange(range);\n        // We can't make a range additive if it doesn't exist\n        if (!rangeValue) {\n            return null;\n        }\n        // Find any current scene-level animatable belonging to the target that matches the range\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n        let rangeAnimatable = null;\n        for (let index = 0; index < sceneAnimatables.length; index++) {\n            const sceneAnimatable = sceneAnimatables[index];\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\n                rangeAnimatable = sceneAnimatable;\n                break;\n            }\n        }\n        // Convert the animations belonging to the skeleton to additive keyframes\n        const animatables = skeleton.getAnimatables();\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            const animations = animatable.animations;\n            if (!animations) {\n                continue;\n            }\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n            }\n        }\n        // Mark the scene-level animatable as additive\n        if (rangeAnimatable) {\n            rangeAnimatable.isAdditive = true;\n        }\n        return skeleton;\n    }\n    /** @internal */\n    _markAsDirty() {\n        this._isDirty = true;\n        this._absoluteTransformIsDirty = true;\n    }\n    /**\n     * @internal\n     */\n    _registerMeshWithPoseMatrix(mesh) {\n        this._meshesWithPoseMatrix.push(mesh);\n    }\n    /**\n     * @internal\n     */\n    _unregisterMeshWithPoseMatrix(mesh) {\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\n        if (index > -1) {\n            this._meshesWithPoseMatrix.splice(index, 1);\n        }\n    }\n    _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n        this.onBeforeComputeObservable.notifyObservers(this);\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            bone._childUpdateId++;\n            const parentBone = bone.getParent();\n            if (parentBone) {\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n            }\n            else {\n                if (initialSkinMatrix) {\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n                }\n                else {\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n                }\n            }\n            if (bone._index !== -1) {\n                const mappedIndex = bone._index === null ? index : bone._index;\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n            }\n        }\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n    }\n    /**\n     * Build all resources required to render a skeleton\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n     */\n    prepare(dontCheckFrameId = false) {\n        if (!dontCheckFrameId) {\n            const currentRenderId = this.getScene().getRenderId();\n            if (this._currentRenderId === currentRenderId) {\n                return;\n            }\n            this._currentRenderId = currentRenderId;\n        }\n        // Update the local matrix of bones with linked transform nodes.\n        if (this._numBonesWithLinkedTransformNode > 0) {\n            for (const bone of this.bones) {\n                if (bone._linkedTransformNode) {\n                    const node = bone._linkedTransformNode;\n                    bone.position = node.position;\n                    if (node.rotationQuaternion) {\n                        bone.rotationQuaternion = node.rotationQuaternion;\n                    }\n                    else {\n                        bone.rotation = node.rotation;\n                    }\n                    bone.scaling = node.scaling;\n                }\n            }\n        }\n        if (this.needInitialSkinMatrix) {\n            for (const mesh of this._meshesWithPoseMatrix) {\n                const poseMatrix = mesh.getPoseMatrix();\n                let needsUpdate = this._isDirty;\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    needsUpdate = true;\n                }\n                if (!needsUpdate) {\n                    continue;\n                }\n                if (this._synchronizedWithMesh !== mesh) {\n                    this._synchronizedWithMesh = mesh;\n                    // Prepare bones\n                    for (const bone of this.bones) {\n                        if (!bone.getParent()) {\n                            const matrix = bone.getBindMatrix();\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n                        }\n                    }\n                    if (this.isUsingTextureForMatrices) {\n                        const textureWidth = (this.bones.length + 1) * 4;\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n                            if (mesh._transformMatrixTexture) {\n                                mesh._transformMatrixTexture.dispose();\n                            }\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                        }\n                    }\n                }\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n                }\n            }\n        }\n        else {\n            if (!this._isDirty) {\n                return;\n            }\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                if (this.isUsingTextureForMatrices) {\n                    if (this._transformMatrixTexture) {\n                        this._transformMatrixTexture.dispose();\n                    }\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                }\n            }\n            this._computeTransformMatrices(this._transformMatrices, null);\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n                this._transformMatrixTexture.update(this._transformMatrices);\n            }\n        }\n        this._isDirty = false;\n    }\n    /**\n     * Gets the list of animatables currently running for this skeleton\n     * @returns an array of animatables\n     */\n    getAnimatables() {\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\n            this._animatables = [];\n            for (let index = 0; index < this.bones.length; index++) {\n                this._animatables.push(this.bones[index]);\n            }\n        }\n        return this._animatables;\n    }\n    /**\n     * Clone the current skeleton\n     * @param name defines the name of the new skeleton\n     * @param id defines the id of the new skeleton\n     * @returns the new skeleton\n     */\n    clone(name, id) {\n        const result = new Skeleton(name, id || name, this._scene);\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        for (let index = 0; index < this.bones.length; index++) {\n            const source = this.bones[index];\n            let parentBone = null;\n            const parent = source.getParent();\n            if (parent) {\n                const parentIndex = this.bones.indexOf(parent);\n                parentBone = result.bones[parentIndex];\n            }\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n            bone._index = source._index;\n            if (source._linkedTransformNode) {\n                bone.linkTransformNode(source._linkedTransformNode);\n            }\n            DeepCopier.DeepCopy(source.animations, bone.animations);\n        }\n        if (this._ranges) {\n            result._ranges = {};\n            for (const rangeName in this._ranges) {\n                const range = this._ranges[rangeName];\n                if (range) {\n                    result._ranges[rangeName] = range.clone();\n                }\n            }\n        }\n        this._isDirty = true;\n        result.prepare(true);\n        return result;\n    }\n    /**\n     * Enable animation blending for this skeleton\n     * @param blendingSpeed defines the blending speed to apply\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    enableBlending(blendingSpeed = 0.01) {\n        for (const bone of this.bones) {\n            for (const animation of bone.animations) {\n                animation.enableBlending = true;\n                animation.blendingSpeed = blendingSpeed;\n            }\n        }\n    }\n    /**\n     * Releases all resources associated with the current skeleton\n     */\n    dispose() {\n        this._meshesWithPoseMatrix.length = 0;\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeSkeleton(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.skeletons.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.skeletons.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n    }\n    /**\n     * Serialize the skeleton in a JSON object\n     * @returns a JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        if (this.dimensionsAtRest) {\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n        }\n        serializationObject.bones = [];\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            const parent = bone.getParent();\n            const serializedBone = {\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n                index: bone.getIndex(),\n                name: bone.name,\n                id: bone.id,\n                matrix: bone.getBindMatrix().asArray(),\n                rest: bone.getRestMatrix().asArray(),\n                linkedTransformNodeId: bone.getTransformNode()?.id,\n            };\n            serializationObject.bones.push(serializedBone);\n            if (bone.length) {\n                serializedBone.length = bone.length;\n            }\n            if (bone.metadata) {\n                serializedBone.metadata = bone.metadata;\n            }\n            if (bone.animations && bone.animations.length > 0) {\n                serializedBone.animation = bone.animations[0].serialize();\n            }\n            serializationObject.ranges = [];\n            for (const name in this._ranges) {\n                const source = this._ranges[name];\n                if (!source) {\n                    continue;\n                }\n                const range = {};\n                range.name = name;\n                range.from = source.from;\n                range.to = source.to;\n                serializationObject.ranges.push(range);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new skeleton from serialized data\n     * @param parsedSkeleton defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns a new skeleton\n     */\n    static Parse(parsedSkeleton, scene) {\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n        if (parsedSkeleton.dimensionsAtRest) {\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n        }\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n        let index;\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\n            const parsedBone = parsedSkeleton.bones[index];\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\n            let parentBone = null;\n            if (parsedBone.parentBoneIndex > -1) {\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n            }\n            const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\n                bone.id = parsedBone.id;\n            }\n            if (parsedBone.length) {\n                bone.length = parsedBone.length;\n            }\n            if (parsedBone.metadata) {\n                bone.metadata = parsedBone.metadata;\n            }\n            if (parsedBone.animation) {\n                bone.animations.push(Animation.Parse(parsedBone.animation));\n            }\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n            }\n        }\n        // placed after bones, so createAnimationRange can cascade down\n        if (parsedSkeleton.ranges) {\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                const data = parsedSkeleton.ranges[index];\n                skeleton.createAnimationRange(data.name, data.from, data.to);\n            }\n        }\n        return skeleton;\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     */\n    computeAbsoluteMatrices(forceUpdate = false) {\n        if (this._absoluteTransformIsDirty || forceUpdate) {\n            this.bones[0].computeAbsoluteMatrices();\n            this._absoluteTransformIsDirty = false;\n        }\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     * @deprecated Please use computeAbsoluteMatrices instead\n     */\n    computeAbsoluteTransforms(forceUpdate = false) {\n        this.computeAbsoluteMatrices(forceUpdate);\n    }\n    /**\n     * Gets the root pose matrix\n     * @returns a matrix\n     */\n    getPoseMatrix() {\n        let poseMatrix = null;\n        if (this._meshesWithPoseMatrix.length > 0) {\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n        }\n        return poseMatrix;\n    }\n    /**\n     * Sorts bones per internal index\n     */\n    sortBones() {\n        const bones = [];\n        const visited = new Array(this.bones.length);\n        for (let index = 0; index < this.bones.length; index++) {\n            this._sortBones(index, bones, visited);\n        }\n        this.bones = bones;\n    }\n    _sortBones(index, bones, visited) {\n        if (visited[index]) {\n            return;\n        }\n        visited[index] = true;\n        const bone = this.bones[index];\n        if (!bone) {\n            return;\n        }\n        if (bone._index === undefined) {\n            bone._index = index;\n        }\n        const parentBone = bone.getParent();\n        if (parentBone) {\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n        }\n        bones.push(bone);\n    }\n    /**\n     * Set the current local matrix as the restPose for all bones in the skeleton.\n     */\n    setCurrentPoseAsRest() {\n        for (const b of this.bones) {\n            b.setCurrentPoseAsRest();\n        }\n    }\n}\n//# sourceMappingURL=skeleton.js.map"],"names":["Skeleton","useTextureToStoreBoneMatrices","this","_useTextureToStoreBoneMatrices","value","_markAsDirty","animationPropertiesOverride","_animationPropertiesOverride","_scene","isUsingTextureForMatrices","_canUseTextureForBones","uniqueId","_uniqueId","constructor","name","id","scene","bones","needInitialSkinMatrix","_isDirty","_meshesWithPoseMatrix","Array","_identity","Matrix","Identity","_currentRenderId","_ranges","_absoluteTransformIsDirty","_numBonesWithLinkedTransformNode","_hasWaitingData","_parentContainer","doNotSerialize","onBeforeComputeObservable","Observable","EngineStore","LastCreatedScene","getUniqueId","addSkeleton","engineCaps","getEngine","getCaps","textureFloat","maxVertexTextureImageUnits","getClassName","getChildren","filter","b","getParent","getTransformMatrices","mesh","Error","_bonesTransformMatrices","prepare","_transformMatrices","getTransformMatrixTexture","_transformMatrixTexture","getScene","toString","fullDetails","ret","length","Object","keys","first","getBoneIndexByName","boneIndex","cache","createAnimationRange","from","to","AnimationRange","i","nBones","animations","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","push","copyAnimationRange","source","rescaleAsRequired","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","Logger","Warn","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","range","returnToRest","bone","_index","highest","getHighestFrame","beginAnimation","loop","speedRatio","onAnimationEnd","MakeAnimationAdditive","skeleton","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","index","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animIndex","Animation","isAdditive","_registerMeshWithPoseMatrix","_unregisterMeshWithPoseMatrix","indexOf","splice","_computeTransformMatrices","targetMatrix","initialSkinMatrix","notifyObservers","_childUpdateId","parentBone","getLocalMatrix","multiplyToRef","getFinalMatrix","copyFrom","mappedIndex","getAbsoluteInverseBindMatrix","multiplyToArray","copyToArray","dontCheckFrameId","currentRenderId","getRenderId","_linkedTransformNode","node","position","rotationQuaternion","rotation","scaling","poseMatrix","getPoseMatrix","needsUpdate","Float32Array","_synchronizedWithMesh","getBindMatrix","TmpVectors","_updateAbsoluteBindMatrices","textureWidth","getSize","width","dispose","RawTexture","CreateRGBATexture","Constants","TEXTURE_NEAREST_SAMPLINGMODE","TEXTURETYPE_FLOAT","update","_animatables","clone","result","parent","parentIndex","Bone","getRestMatrix","linkTransformNode","DeepCopier","DeepCopy","rangeName","enableBlending","blendingSpeed","animation","stopAnimation","removeSkeleton","skeletons","serialize","serializationObject","asArray","serializedBone","parentBoneIndex","getIndex","matrix","rest","linkedTransformNodeId","getTransformNode","metadata","ranges","Parse","parsedSkeleton","Vector3","FromArray","parsedBone","parsedBoneIndex","undefined","_waitingTransformNodeId","data","computeAbsoluteMatrices","forceUpdate","computeAbsoluteTransforms","sortBones","visited","_sortBones","setCurrentPoseAsRest"],"mappings":"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"}