import{aG as s,T as t,j as e,a6 as i,V as a,m as r,L as n,aH as o,g as l,f as h,aI as _,b as p,aF as m}from"./index-VvGulz6u.esm.min.js";import{A as d}from"./assetContainer-Da0Xx6Do.esm.min.js";import{S as u}from"./standardMaterial-Dbz5M_oS.esm.min.js";class c{constructor(){this.materials=[]}parseMTL(t,e,i,a){if(e instanceof ArrayBuffer)return;const r=e.split("\n"),n=/\s+/;let o,l=null;for(let e=0;e<r.length;e++){const h=r[e].trim();if(0===h.length||"#"===h.charAt(0))continue;const _=h.indexOf(" ");let p=_>=0?h.substring(0,_):h;p=p.toLowerCase();const m=_>=0?h.substring(_+1).trim():"";if("newmtl"===p)l&&this.materials.push(l),t._blockEntityCollection=!!a,l=new u(m,t),l._parentContainer=a,t._blockEntityCollection=!1;else if("kd"===p&&l)o=m.split(n,3).map(parseFloat),l.diffuseColor=s.FromArray(o);else if("ka"===p&&l)o=m.split(n,3).map(parseFloat),l.ambientColor=s.FromArray(o);else if("ks"===p&&l)o=m.split(n,3).map(parseFloat),l.specularColor=s.FromArray(o);else if("ke"===p&&l)o=m.split(n,3).map(parseFloat),l.emissiveColor=s.FromArray(o);else if("ns"===p&&l)l.specularPower=parseFloat(m);else if("d"===p&&l)l.alpha=parseFloat(m);else if("map_ka"===p&&l)l.ambientTexture=c._GetTexture(i,m,t);else if("map_kd"===p&&l)l.diffuseTexture=c._GetTexture(i,m,t);else if("map_ks"===p&&l)l.specularTexture=c._GetTexture(i,m,t);else if("map_ns"===p);else if("map_bump"===p&&l){const s=m.split(n),e=s.indexOf("-bm");let a=null;e>=0&&(a=s[e+1],s.splice(e,2)),l.bumpTexture=c._GetTexture(i,s.join(" "),t),l.bumpTexture&&null!==a&&(l.bumpTexture.level=parseFloat(a))}else"map_d"===p&&l&&(l.opacityTexture=c._GetTexture(i,m,t))}l&&this.materials.push(l)}static _GetTexture(s,e,i){if(!e)return null;let a=s;if("file:"===s){let s=e.lastIndexOf("\\");-1===s&&(s=e.lastIndexOf("/")),a+=s>-1?e.substring(s+1):e}else a+=e;return new t(a,i,!1,c.INVERT_TEXTURE_Y)}}c.INVERT_TEXTURE_Y=!0;class g{constructor(s,t,i){this._positions=[],this._normals=[],this._uvs=[],this._colors=[],this._extColors=[],this._meshesFromObj=[],this._indicesForBabylon=[],this._wrappedPositionForBabylon=[],this._wrappedUvsForBabylon=[],this._wrappedColorsForBabylon=[],this._wrappedNormalsForBabylon=[],this._tuplePosNorm=[],this._curPositionInIndices=0,this._hasMeshes=!1,this._unwrappedPositionsForBabylon=[],this._unwrappedColorsForBabylon=[],this._unwrappedNormalsForBabylon=[],this._unwrappedUVForBabylon=[],this._triangles=[],this._materialNameFromObj="",this._objMeshName="",this._increment=1,this._isFirstMaterial=!0,this._grayColor=new e(.5,.5,.5,1),this._hasLineData=!1,this._materialToUse=s,this._babylonMeshesArray=t,this._loadingOptions=i}_isInArray(s,t){s[t[0]]||(s[t[0]]={normals:[],idx:[]});const e=s[t[0]].normals.indexOf(t[1]);return-1===e?-1:s[t[0]].idx[e]}_isInArrayUV(s,t){s[t[0]]||(s[t[0]]={normals:[],idx:[],uv:[]});const e=s[t[0]].normals.indexOf(t[1]);return 1!=e&&t[2]===s[t[0]].uv[e]?s[t[0]].idx[e]:-1}_setData(s,t,e,a,r,n,o){let l;l=this._loadingOptions.optimizeWithUV?this._isInArrayUV(this._tuplePosNorm,[s,e,t]):this._isInArray(this._tuplePosNorm,[s,e]),-1===l?(this._indicesForBabylon.push(this._wrappedPositionForBabylon.length),this._wrappedPositionForBabylon.push(a),r=r??new i(0,0),this._wrappedUvsForBabylon.push(r),this._wrappedNormalsForBabylon.push(n),void 0!==o&&this._wrappedColorsForBabylon.push(o),this._tuplePosNorm[s].normals.push(e),this._tuplePosNorm[s].idx.push(this._curPositionInIndices++),this._loadingOptions.optimizeWithUV&&this._tuplePosNorm[s].uv.push(t)):this._indicesForBabylon.push(l)}_unwrapData(){try{for(let s=0;s<this._wrappedPositionForBabylon.length;s++)this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[s].x*this._handednessSign,this._wrappedPositionForBabylon[s].y,this._wrappedPositionForBabylon[s].z),this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[s].x*this._handednessSign,this._wrappedNormalsForBabylon[s].y,this._wrappedNormalsForBabylon[s].z),this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[s].x,this._wrappedUvsForBabylon[s].y),this._loadingOptions.importVertexColors&&this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[s].r,this._wrappedColorsForBabylon[s].g,this._wrappedColorsForBabylon[s].b,this._wrappedColorsForBabylon[s].a);this._wrappedPositionForBabylon.length=0,this._wrappedNormalsForBabylon.length=0,this._wrappedUvsForBabylon.length=0,this._wrappedColorsForBabylon.length=0,this._tuplePosNorm.length=0,this._curPositionInIndices=0}catch(s){throw new Error("Unable to unwrap data while parsing OBJ data.")}}_getTriangles(s,t){for(let e=t;e<s.length-1;e++)this._pushTriangle(s,e)}_getColor(s){return this._loadingOptions.importVertexColors?this._extColors[s]??this._colors[s]:void 0}_setDataForCurrentFaceWithPattern1(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=parseInt(this._triangles[s])-1;this._setData(t,0,0,this._positions[t],i.Zero(),a.Up(),this._getColor(t))}this._triangles.length=0}_setDataForCurrentFaceWithPattern2(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("/"),e=parseInt(t[0])-1,r=parseInt(t[1])-1;this._setData(e,r,0,this._positions[e],this._uvs[r]??i.Zero(),a.Up(),this._getColor(e))}this._triangles.length=0}_setDataForCurrentFaceWithPattern3(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("/"),e=parseInt(t[0])-1,r=parseInt(t[1])-1,n=parseInt(t[2])-1;this._setData(e,r,n,this._positions[e],this._uvs[r]??i.Zero(),this._normals[n]??a.Up())}this._triangles.length=0}_setDataForCurrentFaceWithPattern4(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("//"),e=parseInt(t[0])-1,a=parseInt(t[1])-1;this._setData(e,1,a,this._positions[e],i.Zero(),this._normals[a],this._getColor(e))}this._triangles.length=0}_setDataForCurrentFaceWithPattern5(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("/"),e=this._positions.length+parseInt(t[0]),i=this._uvs.length+parseInt(t[1]),a=this._normals.length+parseInt(t[2]);this._setData(e,i,a,this._positions[e],this._uvs[i],this._normals[a],this._getColor(e))}this._triangles.length=0}_addPreviousObjMesh(){this._meshesFromObj.length>0&&(this._handledMesh=this._meshesFromObj[this._meshesFromObj.length-1],this._unwrapData(),this._loadingOptions.useLegacyBehavior&&this._indicesForBabylon.reverse(),this._handledMesh.indices=this._indicesForBabylon.slice(),this._handledMesh.positions=this._unwrappedPositionsForBabylon.slice(),this._handledMesh.normals=this._unwrappedNormalsForBabylon.slice(),this._handledMesh.uvs=this._unwrappedUVForBabylon.slice(),this._handledMesh.hasLines=this._hasLineData,this._loadingOptions.importVertexColors&&(this._handledMesh.colors=this._unwrappedColorsForBabylon.slice()),this._indicesForBabylon.length=0,this._unwrappedPositionsForBabylon.length=0,this._unwrappedColorsForBabylon.length=0,this._unwrappedNormalsForBabylon.length=0,this._unwrappedUVForBabylon.length=0,this._hasLineData=!1)}_optimizeNormals(s){const t=s.getVerticesData(r.PositionKind),e=s.getVerticesData(r.NormalKind),i={};if(!t||!e)return;for(let s=0;s<t.length/3;s++){const e=t[3*s+0]+"_"+t[3*s+1]+"_"+t[3*s+2];let a=i[e];a||(a=[],i[e]=a),a.push(s)}const n=new a;for(const s in i){const t=i[s];if(t.length<2)continue;const a=t[0];for(let s=1;s<t.length;++s){const i=t[s];e[3*a+0]+=e[3*i+0],e[3*a+1]+=e[3*i+1],e[3*a+2]+=e[3*i+2]}n.copyFromFloats(e[3*a+0],e[3*a+1],e[3*a+2]),n.normalize();for(let s=0;s<t.length;++s){const i=t[s];e[3*i+0]=n.x,e[3*i+1]=n.y,e[3*i+2]=n.z}}s.setVerticesData(r.NormalKind,e)}static _IsLineElement(s){return s.startsWith("l")}static _IsObjectElement(s){return s.startsWith("o")}static _IsGroupElement(s){return s.startsWith("g")}static _GetZbrushMRGB(s,t){if(!s.startsWith("mrgb"))return null;if(s=s.replace("mrgb","").trim(),t)return[];const i=s.match(/[a-z0-9]/g);if(!i||i.length%8!=0)return[];const a=[];for(let s=0;s<i.length/8;s++){const t=i[8*s+2]+i[8*s+3],r=i[8*s+4]+i[8*s+5],n=i[8*s+6]+i[8*s+7];a.push(new e(parseInt(t,16)/255,parseInt(r,16)/255,parseInt(n,16)/255,1))}return a}parse(t,r,_,p,m){r=(r=r.replace(/#MRGB/g,"mrgb")).replace(/#.*$/gm,"").trim(),this._loadingOptions.useLegacyBehavior?(this._pushTriangle=(s,t)=>this._triangles.push(s[0],s[t],s[t+1]),this._handednessSign=1):_.useRightHandedSystem?(this._pushTriangle=(s,t)=>this._triangles.push(s[0],s[t+1],s[t]),this._handednessSign=1):(this._pushTriangle=(s,t)=>this._triangles.push(s[0],s[t],s[t+1]),this._handednessSign=-1);const d=r.split("\n"),c=[];let F=[];c.push(F);for(let s=0;s<d.length;s++){const t=d[s].trim().replace(/\s\s/g," ");if(0!==t.length&&"#"!==t.charAt(0))if((g._IsGroupElement(t)||g._IsObjectElement(t))&&(F=[],c.push(F)),g._IsLineElement(t)){const s=t.split(" ");for(let t=1;t<s.length-1;t++)F.push(`l ${s[t]} ${s[t+1]}`)}else F.push(t)}const b=c.flat();for(let s=0;s<b.length;s++){const t=b[s].trim().replace(/\s\s/g," ");let r;if(0!==t.length&&"#"!==t.charAt(0))if(g.VertexPattern.test(t)){if(r=t.match(/[^ ]+/g),this._positions.push(new a(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3]))),this._loadingOptions.importVertexColors)if(r.length>=7){const s=parseFloat(r[4]),t=parseFloat(r[5]),i=parseFloat(r[6]);this._colors.push(new e(s>1?s/255:s,t>1?t/255:t,i>1?i/255:i,7===r.length||void 0===r[7]?1:parseFloat(r[7])))}else this._colors.push(this._grayColor)}else if(null!==(r=g.NormalPattern.exec(t)))this._normals.push(new a(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3])));else if(null!==(r=g.UVPattern.exec(t)))this._uvs.push(new i(parseFloat(r[1])*this._loadingOptions.UVScaling.x,parseFloat(r[2])*this._loadingOptions.UVScaling.y));else if(null!==(r=g.FacePattern3.exec(t)))this._setDataForCurrentFaceWithPattern3(r[1].trim().split(" "),1);else if(null!==(r=g.FacePattern4.exec(t)))this._setDataForCurrentFaceWithPattern4(r[1].trim().split(" "),1);else if(null!==(r=g.FacePattern5.exec(t)))this._setDataForCurrentFaceWithPattern5(r[1].trim().split(" "),1);else if(null!==(r=g.FacePattern2.exec(t)))this._setDataForCurrentFaceWithPattern2(r[1].trim().split(" "),1);else if(null!==(r=g.FacePattern1.exec(t)))this._setDataForCurrentFaceWithPattern1(r[1].trim().split(" "),1);else if(null!==(r=g.LinePattern1.exec(t)))this._setDataForCurrentFaceWithPattern1(r[1].trim().split(" "),0),this._hasLineData=!0;else if(null!==(r=g.LinePattern2.exec(t)))this._setDataForCurrentFaceWithPattern2(r[1].trim().split(" "),0),this._hasLineData=!0;else if(r=g._GetZbrushMRGB(t,!this._loadingOptions.importVertexColors))for(const s of r)this._extColors.push(s);else if(null!==(r=g.LinePattern3.exec(t)))this._setDataForCurrentFaceWithPattern3(r[1].trim().split(" "),0),this._hasLineData=!0;else if(g.GroupDescriptor.test(t)||g.ObjectDescriptor.test(t)){const s={name:t.substring(2).trim(),indices:null,positions:null,normals:null,uvs:null,colors:null,materialName:this._materialNameFromObj,isObject:g.ObjectDescriptor.test(t)};this._addPreviousObjMesh(),this._meshesFromObj.push(s),this._hasMeshes=!0,this._isFirstMaterial=!0,this._increment=1}else if(g.UseMtlDescriptor.test(t)){if(this._materialNameFromObj=t.substring(7).trim(),!this._isFirstMaterial||!this._hasMeshes){this._addPreviousObjMesh();const s={name:(this._objMeshName||"mesh")+"_mm"+this._increment.toString(),indices:null,positions:null,normals:null,uvs:null,colors:null,materialName:this._materialNameFromObj,isObject:!1};this._increment++,this._meshesFromObj.push(s),this._hasMeshes=!0}this._hasMeshes&&this._isFirstMaterial&&(this._meshesFromObj[this._meshesFromObj.length-1].materialName=this._materialNameFromObj,this._isFirstMaterial=!1)}else g.MtlLibGroupDescriptor.test(t)?m(t.substring(7).trim()):g.SmoothDescriptor.test(t)||n.Log("Unhandled expression at line : "+t)}if(this._hasMeshes&&(this._handledMesh=this._meshesFromObj[this._meshesFromObj.length-1],this._loadingOptions.useLegacyBehavior&&this._indicesForBabylon.reverse(),this._unwrapData(),this._handledMesh.indices=this._indicesForBabylon,this._handledMesh.positions=this._unwrappedPositionsForBabylon,this._handledMesh.normals=this._unwrappedNormalsForBabylon,this._handledMesh.uvs=this._unwrappedUVForBabylon,this._handledMesh.hasLines=this._hasLineData,this._loadingOptions.importVertexColors&&(this._handledMesh.colors=this._unwrappedColorsForBabylon)),!this._hasMeshes){let t=null;if(this._indicesForBabylon.length)this._loadingOptions.useLegacyBehavior&&this._indicesForBabylon.reverse(),this._unwrapData();else{for(const s of this._positions)this._unwrappedPositionsForBabylon.push(s.x,s.y,s.z);if(this._normals.length)for(const s of this._normals)this._unwrappedNormalsForBabylon.push(s.x,s.y,s.z);if(this._uvs.length)for(const s of this._uvs)this._unwrappedUVForBabylon.push(s.x,s.y);if(this._extColors.length)for(const s of this._extColors)this._unwrappedColorsForBabylon.push(s.r,s.g,s.b,s.a);else if(this._colors.length)for(const s of this._colors)this._unwrappedColorsForBabylon.push(s.r,s.g,s.b,s.a);this._materialNameFromObj||(t=new u(o.RandomId(),_),t.pointsCloud=!0,this._materialNameFromObj=t.name,this._normals.length||(t.disableLighting=!0,t.emissiveColor=s.White()))}this._meshesFromObj.push({name:o.RandomId(),indices:this._indicesForBabylon,positions:this._unwrappedPositionsForBabylon,colors:this._unwrappedColorsForBabylon,normals:this._unwrappedNormalsForBabylon,uvs:this._unwrappedUVForBabylon,materialName:this._materialNameFromObj,directMaterial:t,isObject:!0,hasLines:this._hasLineData})}for(let s=0;s<this._meshesFromObj.length;s++){if(t&&this._meshesFromObj[s].name)if(t instanceof Array){if(-1===t.indexOf(this._meshesFromObj[s].name))continue}else if(this._meshesFromObj[s].name!==t)continue;this._handledMesh=this._meshesFromObj[s],_._blockEntityCollection=!!p;const e=new l(this._meshesFromObj[s].name,_);if(e._parentContainer=p,_._blockEntityCollection=!1,this._handledMesh._babylonMesh=e,!this._handledMesh.isObject)for(let t=s-1;t>=0;--t)if(this._meshesFromObj[t].isObject&&this._meshesFromObj[t]._babylonMesh){e.parent=this._meshesFromObj[t]._babylonMesh;break}if(this._materialToUse.push(this._meshesFromObj[s].materialName),this._handledMesh.hasLines&&(e._internalMetadata??={},e._internalMetadata._isLine=!0),0===this._handledMesh.positions?.length){this._babylonMeshesArray.push(e);continue}const i=new h;if(i.uvs=this._handledMesh.uvs,i.indices=this._handledMesh.indices,i.positions=this._handledMesh.positions,this._loadingOptions.computeNormals){const s=new Array;h.ComputeNormals(this._handledMesh.positions,this._handledMesh.indices,s),i.normals=s}else i.normals=this._handledMesh.normals;this._loadingOptions.importVertexColors&&(i.colors=this._handledMesh.colors),i.applyToMesh(e),this._loadingOptions.invertY&&(e.scaling.y*=-1),this._loadingOptions.optimizeNormals&&this._optimizeNormals(e),this._babylonMeshesArray.push(e),this._handledMesh.directMaterial&&(e.material=this._handledMesh.directMaterial)}}}g.ObjectDescriptor=/^o/,g.GroupDescriptor=/^g/,g.MtlLibGroupDescriptor=/^mtllib /,g.UseMtlDescriptor=/^usemtl /,g.SmoothDescriptor=/^s /,g.VertexPattern=/^v(\s+[\d|.|+|\-|e|E]+){3,7}/,g.NormalPattern=/^vn(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/,g.UVPattern=/^vt(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/,g.FacePattern1=/^f\s+(([\d]{1,}[\s]?){3,})+/,g.FacePattern2=/^f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,g.FacePattern3=/^f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,g.FacePattern4=/^f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/,g.FacePattern5=/^f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/,g.LinePattern1=/^l\s+(([\d]{1,}[\s]?){2,})+/,g.LinePattern2=/^l\s+((([\d]{1,}\/[\d]{1,}[\s]?){2,})+)/,g.LinePattern3=/^l\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;class F{static get INVERT_TEXTURE_Y(){return c.INVERT_TEXTURE_Y}static set INVERT_TEXTURE_Y(s){c.INVERT_TEXTURE_Y=s}constructor(s){this.name=_.name,this.extensions=_.extensions,this._assetContainer=null,this._loadingOptions={...F._DefaultLoadingOptions,...s??{}}}static get _DefaultLoadingOptions(){return{computeNormals:F.COMPUTE_NORMALS,optimizeNormals:F.OPTIMIZE_NORMALS,importVertexColors:F.IMPORT_VERTEX_COLORS,invertY:F.INVERT_Y,invertTextureY:F.INVERT_TEXTURE_Y,UVScaling:F.UV_SCALING,materialLoadingFailsSilently:F.MATERIAL_LOADING_FAILS_SILENTLY,optimizeWithUV:F.OPTIMIZE_WITH_UV,skipMaterials:F.SKIP_MATERIALS,useLegacyBehavior:F.USE_LEGACY_BEHAVIOR}}_loadMTL(s,t,e,i){const a=t+s;p.LoadFile(a,e,void 0,void 0,!1,((s,t)=>{i(a,t)}))}createPlugin(s){return new F(s[_.name])}canDirectLoad(){return!1}importMeshAsync(s,t,e,i){return this._parseSolidAsync(s,t,e,i).then((s=>({meshes:s,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})))}loadAsync(s,t,e){return this.importMeshAsync(null,s,t,e).then((()=>{}))}loadAssetContainerAsync(s,t,e){const i=new d(s);return this._assetContainer=i,this.importMeshAsync(null,s,t,e).then((s=>(s.meshes.forEach((s=>i.meshes.push(s))),s.meshes.forEach((s=>{const t=s.material;if(t&&-1==i.materials.indexOf(t)){i.materials.push(t);t.getActiveTextures().forEach((s=>{-1==i.textures.indexOf(s)&&i.textures.push(s)}))}})),this._assetContainer=null,i))).catch((s=>{throw this._assetContainer=null,s}))}_parseSolidAsync(s,t,e,i){let a="";const r=new c,n=[],o=[];e=e.replace(/#.*$/gm,"").trim();new g(n,o,this._loadingOptions).parse(s,e,t,this._assetContainer,(s=>{a=s}));const l=[];return""===a||this._loadingOptions.skipMaterials||l.push(new Promise(((s,e)=>{this._loadMTL(a,i,(l=>{try{r.parseMTL(t,l,i,this._assetContainer);for(let s=0;s<r.materials.length;s++){let t=0;const e=[];let i;for(;(i=n.indexOf(r.materials[s].name,t))>-1;)e.push(i),t=i+1;if(-1===i&&0===e.length)r.materials[s].dispose();else for(let t=0;t<e.length;t++){const i=o[e[t]],a=r.materials[s];i.material=a,i.getTotalIndices()||(a.pointsCloud=!0)}}s()}catch(t){p.Warn(`Error processing MTL file: '${a}'`),this._loadingOptions.materialLoadingFailsSilently?s():e(t)}}),((t,i)=>{p.Warn(`Error downloading MTL file: '${a}'`),this._loadingOptions.materialLoadingFailsSilently?s():e(i)}))}))),Promise.all(l).then((()=>{const s=s=>Boolean(s._internalMetadata?._isLine??!1);return o.forEach((e=>{if(s(e)){let i=e.material??new u(e.name+"_line",t);i.getBindedMeshes().filter((t=>!s(t))).length>0&&(i=i.clone(i.name+"_line")??i),i.wireframe=!0,e.material=i,e._internalMetadata&&(e._internalMetadata._isLine=void 0)}})),o}))}}F.OPTIMIZE_WITH_UV=!0,F.INVERT_Y=!1,F.IMPORT_VERTEX_COLORS=!1,F.COMPUTE_NORMALS=!1,F.OPTIMIZE_NORMALS=!1,F.UV_SCALING=new i(1,1),F.SKIP_MATERIALS=!1,F.MATERIAL_LOADING_FAILS_SILENTLY=!0,F.USE_LEGACY_BEHAVIOR=!1,m(new F);export{F as OBJFileLoader};
//# sourceMappingURL=objFileLoader-DtLciUID.esm.min.js.map
