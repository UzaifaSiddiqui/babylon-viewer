{"version":3,"file":"iblShadowGBufferDebug.fragment-BGdgiiz1.esm.min.js","sources":["../../../../../dev/core/dist/Shaders/iblShadowGBufferDebug.fragment.js"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nconst name = \"iblShadowGBufferDebugPixelShader\";\nconst shader = `#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D depthSampler;uniform sampler2D normalSampler;uniform sampler2D positionSampler;uniform sampler2D velocitySampler;uniform vec4 sizeParams;uniform float maxDepth;\n#define offsetX sizeParams.x\n#define offsetY sizeParams.y\n#define widthScale sizeParams.z\n#define heightScale sizeParams.w\nvoid main(void) {vec2 uv =\nvec2((offsetX+vUV.x)*widthScale,(offsetY+vUV.y)*heightScale);vec4 backgroundColour=texture2D(textureSampler,vUV).rgba;vec4 depth=texture2D(depthSampler,vUV);vec4 worldNormal=texture2D(normalSampler,vUV);vec4 worldPosition=texture2D(positionSampler,vUV);vec4 velocityLinear=texture2D(velocitySampler,vUV);if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {gl_FragColor.rgba=backgroundColour;} else {gl_FragColor.a=1.0;if (uv.x<=0.25) {gl_FragColor.rgb=depth.rgb;gl_FragColor.a=1.0;} else if (uv.x<=0.5) {velocityLinear.rg=velocityLinear.rg*0.5+0.5;gl_FragColor.rgb=velocityLinear.rgb;} else if (uv.x<=0.75) {gl_FragColor.rgb=worldPosition.rgb;} else {gl_FragColor.rgb=worldNormal.rgb;}}}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const iblShadowGBufferDebugPixelShader = { name, shader };\n//# sourceMappingURL=iblShadowGBufferDebug.fragment.js.map"],"names":["name","shader","ShaderStore","ShadersStore","iblShadowGBufferDebugPixelShader"],"mappings":"gDAEA,MAAMA,EAAO,mCACPC,EAAS,kmCAWVC,EAAYC,aAAaH,KAC1BE,EAAYC,aAAaH,GAAQC,GAGzB,MAACG,EAAmC,CAAEJ,OAAMC"}