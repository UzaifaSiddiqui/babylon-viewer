{"version":3,"file":"flowGraphGetPropertyBlock-v4pci8V_.esm.js","sources":["../../../../../dev/core/dist/FlowGraph/Blocks/Data/flowGraphGetPropertyBlock.js"],"sourcesContent":["import { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphCachedOperationBlock } from \"./flowGraphCachedOperationBlock\";\n/**\n * This block will deliver a property of an asset, based on the property name and an input asset.\n * The property name can include dots (\".\"), which will be interpreted as a path to the property.\n *\n * For example, with an input of a mesh asset, the property name \"position.x\" will deliver the x component of the position of the mesh.\n *\n * Note that it is recommended to input the object on which you are working on (i.e. a material) rather than providing a mesh as object and then getting the material from it.\n */\nexport class FlowGraphGetPropertyBlock extends FlowGraphCachedOperationBlock {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(RichTypeAny, config);\n        this.config = config;\n        this.object = this.registerDataInput(\"object\", RichTypeAny, config.object);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config.propertyName);\n        this.customGetFunction = this.registerDataInput(\"customGetFunction\", RichTypeAny);\n    }\n    _doOperation(context) {\n        const getter = this.customGetFunction.getValue(context);\n        let value;\n        if (getter) {\n            value = getter(this.object.getValue(context), this.propertyName.getValue(context), context);\n        }\n        else {\n            const target = this.object.getValue(context);\n            const propertyName = this.propertyName.getValue(context);\n            value = target && propertyName ? this._getPropertyValue(target, propertyName) : undefined;\n        }\n        return value;\n    }\n    _getPropertyValue(target, propertyName) {\n        const path = propertyName.split(\".\");\n        let value = target;\n        for (const prop of path) {\n            value = value[prop];\n            if (value === undefined) {\n                return;\n            }\n        }\n        return value;\n    }\n    getClassName() {\n        return \"FlowGraphGetPropertyBlock\" /* FlowGraphBlockNames.GetProperty */;\n    }\n}\nRegisterClass(\"FlowGraphGetPropertyBlock\" /* FlowGraphBlockNames.GetProperty */, FlowGraphGetPropertyBlock);\n//# sourceMappingURL=flowGraphGetPropertyBlock.js.map"],"names":[],"mappings":";;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,yBAAyB,SAAS,6BAA6B,CAAC;AAC7E,IAAI,WAAW;AACf;AACA;AACA;AACA,IAAI,MAAM,EAAE;AACZ,QAAQ,KAAK,CAAC,WAAW,EAAE,MAAM,CAAC;AAClC,QAAQ,IAAI,CAAC,MAAM,GAAG,MAAM;AAC5B,QAAQ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,WAAW,EAAE,MAAM,CAAC,MAAM,CAAC;AAClF,QAAQ,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,cAAc,EAAE,WAAW,EAAE,MAAM,CAAC,YAAY,CAAC;AACpG,QAAQ,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,EAAE,WAAW,CAAC;AACzF;AACA,IAAI,YAAY,CAAC,OAAO,EAAE;AAC1B,QAAQ,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,OAAO,CAAC;AAC/D,QAAQ,IAAI,KAAK;AACjB,QAAQ,IAAI,MAAM,EAAE;AACpB,YAAY,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;AACvG;AACA,aAAa;AACb,YAAY,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC;AACxD,YAAY,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC;AACpE,YAAY,KAAK,GAAG,MAAM,IAAI,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,YAAY,CAAC,GAAG,SAAS;AACrG;AACA,QAAQ,OAAO,KAAK;AACpB;AACA,IAAI,iBAAiB,CAAC,MAAM,EAAE,YAAY,EAAE;AAC5C,QAAQ,MAAM,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC;AAC5C,QAAQ,IAAI,KAAK,GAAG,MAAM;AAC1B,QAAQ,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE;AACjC,YAAY,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;AAC/B,YAAY,IAAI,KAAK,KAAK,SAAS,EAAE;AACrC,gBAAgB;AAChB;AACA;AACA,QAAQ,OAAO,KAAK;AACpB;AACA,IAAI,YAAY,GAAG;AACnB,QAAQ,OAAO,2BAA2B;AAC1C;AACA;AACA,aAAa,CAAC,2BAA2B,wCAAwC,yBAAyB,CAAC;;;;"}