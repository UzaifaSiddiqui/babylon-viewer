{"version":3,"file":"splatFileLoader-Ca9Qo8sC.esm.min.js","sources":["../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingFragmentDeclaration.js","../../../../../dev/core/dist/Shaders/gaussianSplatting.fragment.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingVertexDeclaration.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingUboDeclaration.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplatting.js","../../../../../dev/core/dist/Shaders/gaussianSplatting.vertex.js","../../../../../dev/core/dist/ShadersWGSL/ShadersInclude/gaussianSplattingFragmentDeclaration.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplatting.fragment.js","../../../../../dev/core/dist/ShadersWGSL/ShadersInclude/gaussianSplatting.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplatting.vertex.js","../../../../../dev/core/dist/Materials/GaussianSplatting/gaussianSplattingMaterial.js","../../../../../dev/core/dist/Maths/math.scalar.js","../../../../../dev/core/dist/Meshes/GaussianSplatting/gaussianSplattingMesh.js","../../../../../dev/core/dist/Particles/pointsCloudSystem.js","../../../../../dev/loaders/dist/SPLAT/splatFileLoader.js","../../../../../dev/core/dist/Particles/cloudPoint.js"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./logDepthFragment\";\nimport \"./fogFragment\";\nconst name = \"gaussianSplattingFragmentDeclaration\";\nconst shader = `vec4 gaussianColor(vec4 inColor)\n{float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*inColor.a;\n#include<logDepthFragment>\nvec3 color=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4(color,B);}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingFragmentDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplattingFragmentDeclaration>\nvoid main () { \n#include<clipPlaneFragment>\ngl_FragColor=gaussianColor(vColor);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingPixelShader = { name, shader };\n//# sourceMappingURL=gaussianSplatting.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplattingVertexDeclaration\";\nconst shader = `attribute vec2 position;uniform mat4 view;uniform mat4 projection;uniform mat4 world;uniform vec4 vEyePosition;`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\nconst name = \"gaussianSplattingUboDeclaration\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute vec2 position;`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingUboDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplatting\";\nconst shader = `#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\n#if SH_DEGREE>0\nivec2 getDataUVint(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return ivec2(uint(x+0.5),uint(y+0.5));}\n#endif\nstruct Splat {vec4 center;vec4 color;vec4 covA;vec4 covB;\n#if SH_DEGREE>0\nuvec4 sh0; \n#endif\n#if SH_DEGREE>1\nuvec4 sh1;\n#endif\n#if SH_DEGREE>2\nuvec4 sh2;\n#endif\n};Splat readSplat(float splatIndex)\n{Splat splat;vec2 splatUV=getDataUV(splatIndex,dataTextureSize);splat.center=texture2D(centersTexture,splatUV);splat.color=texture2D(colorsTexture,splatUV);splat.covA=texture2D(covariancesATexture,splatUV)*splat.center.w;splat.covB=texture2D(covariancesBTexture,splatUV)*splat.center.w;\n#if SH_DEGREE>0\nivec2 splatUVint=getDataUVint(splatIndex,dataTextureSize);splat.sh0=texelFetch(shTexture0,splatUVint,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=texelFetch(shTexture1,splatUVint,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=texelFetch(shTexture2,splatUVint,0);\n#endif\nreturn splat;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nvec3 computeColorFromSHDegree(vec3 dir,const vec3 sh[16])\n{const float SH_C0=0.28209479;const float SH_C1=0.48860251;float SH_C2[5];SH_C2[0]=1.092548430;SH_C2[1]=-1.09254843;SH_C2[2]=0.315391565;SH_C2[3]=-1.09254843;SH_C2[4]=0.546274215;float SH_C3[7];SH_C3[0]=-0.59004358;SH_C3[1]=2.890611442;SH_C3[2]=-0.45704579;SH_C3[3]=0.373176332;SH_C3[4]=-0.45704579;SH_C3[5]=1.445305721;SH_C3[6]=-0.59004358;vec3 result=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nfloat x=dir.x;float y=dir.y;float z=dir.z;result+=- SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nfloat xx=x*x,yy=y*y,zz=z*z;float xy=x*y,yz=y*z,xz=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0*zz-3.0*xx-3.0*yy)*sh[12] +\nSH_C3[4]*x*(4.0*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nvec4 decompose(uint value)\n{vec4 components=vec4(\nfloat((value ) & 255u),\nfloat((value>>uint( 8)) & 255u),\nfloat((value>>uint(16)) & 255u),\nfloat((value>>uint(24)) & 255u));return components*vec4(2./255.)-vec4(1.);}\nvec3 computeSH(Splat splat,vec3 dir)\n{vec3 sh[16];sh[0]=vec3(0.,0.,0.);\n#if SH_DEGREE>0\nvec4 sh00=decompose(splat.sh0.x);vec4 sh01=decompose(splat.sh0.y);vec4 sh02=decompose(splat.sh0.z);sh[1]=vec3(sh00.x,sh00.y,sh00.z);sh[2]=vec3(sh00.w,sh01.x,sh01.y);sh[3]=vec3(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nvec4 sh03=decompose(splat.sh0.w);vec4 sh04=decompose(splat.sh1.x);vec4 sh05=decompose(splat.sh1.y);sh[4]=vec3(sh02.y,sh02.z,sh02.w);sh[5]=vec3(sh03.x,sh03.y,sh03.z);sh[6]=vec3(sh03.w,sh04.x,sh04.y);sh[7]=vec3(sh04.z,sh04.w,sh05.x);sh[8]=vec3(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nvec4 sh06=decompose(splat.sh1.z);vec4 sh07=decompose(splat.sh1.w);vec4 sh08=decompose(splat.sh2.x);vec4 sh09=decompose(splat.sh2.y);vec4 sh10=decompose(splat.sh2.z);vec4 sh11=decompose(splat.sh2.w);sh[9]=vec3(sh06.x,sh06.y,sh06.z);sh[10]=vec3(sh06.w,sh07.x,sh07.y);sh[11]=vec3(sh07.z,sh07.w,sh08.x);sh[12]=vec3(sh08.y,sh08.z,sh08.w);sh[13]=vec3(sh09.x,sh09.y,sh09.z);sh[14]=vec3(sh09.w,sh10.x,sh10.y);sh[15]=vec3(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\n#else\nvec3 computeSH(Splat splat,vec3 dir)\n{return vec3(0.,0.,0.);}\n#endif\nvec4 gaussianSplatting(vec2 meshPos,vec3 worldPos,vec2 scale,vec3 covA,vec3 covB,mat4 worldMatrix,mat4 viewMatrix,mat4 projectionMatrix)\n{mat4 modelView=viewMatrix*worldMatrix;vec4 camspace=viewMatrix*vec4(worldPos,1.);vec4 pos2d=projectionMatrix*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {return vec4(0.0,0.0,2.0,1.0);}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);mat3 J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nfloat c00=cov2d[0][0];float c11=cov2d[1][1];float c01=cov2d[0][1];float detOrig=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nvec3 c2d=vec3(cov2d[0][0],c01,cov2d[1][1]);float detBlur=c2d.x*c2d.z-c2d.y*c2d.y;float compensation=sqrt(max(0.,detOrig/detBlur));vColor.w*=compensation;\n#endif\nfloat mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float epsilon=0.0001;float lambda1=mid+radius+epsilon,lambda2=mid-radius+epsilon;if (lambda2<0.0)\n{return vec4(0.0,0.0,2.0,1.0);}\nvec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vec2 vCenter=vec2(pos2d);return vec4(\nvCenter \n+ ((meshPos.x*majorAxis\n+ meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,pos2d.zw);}`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplatting = { name, shader };\n//# sourceMappingURL=gaussianSplatting.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingVertexDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingUboDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/gaussianSplatting\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\nattribute float splatIndex;uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform vec3 eyePosition;uniform vec3 viewDirectionFactor;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if SH_DEGREE>0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE>1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE>2\nuniform highp usampler2D shTexture2;\n#endif\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplatting>\nvoid main () {Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPos=world*vec4(splat.center.xyz,1.0);vColor=splat.color;vPosition=position;\n#if SH_DEGREE>0\nmat3 worldRot=mat3(world);mat3 normWorldRot=inverseMat3(worldRot);vec3 dir=normalize(normWorldRot*(worldPos.xyz-eyePosition));dir*=viewDirectionFactor;vColor.xyz=splat.color.xyz+computeSH(splat,dir);\n#endif\ngl_Position=gaussianSplatting(position,worldPos.xyz,vec2(1.,1.),covA,covB,world,view,projection);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexShader = { name, shader };\n//# sourceMappingURL=gaussianSplatting.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./logDepthFragment\";\nimport \"./fogFragment\";\nconst name = \"gaussianSplattingFragmentDeclaration\";\nconst shader = `fn gaussianColor(inColor: vec4f,inPosition: vec2f)->vec4f\n{var A : f32=-dot(inPosition,inPosition);if (A>-4.0)\n{var B: f32=exp(A)*inColor.a;\n#include<logDepthFragment>\nvar color: vec3f=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4f(color,B);} else {return vec4f(0.0);}}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingFragmentDeclarationWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplattingFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\nfragmentOutputs.color=gaussianColor(input.vColor,input.vPosition);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingPixelShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplatting\";\nconst shader = `fn getDataUV(index: f32,dataTextureSize: vec2f)->vec2<f32> {let y: f32=floor(index/dataTextureSize.x);let x: f32=index-y*dataTextureSize.x;return vec2f((x+0.5),(y+0.5));}\nstruct Splat {center: vec4f,\ncolor: vec4f,\ncovA: vec4f,\ncovB: vec4f,\n#if SH_DEGREE>0\nsh0: vec4<u32>,\n#endif\n#if SH_DEGREE>1\nsh1: vec4<u32>,\n#endif\n#if SH_DEGREE>2\nsh2: vec4<u32>,\n#endif\n};fn readSplat(splatIndex: f32,dataTextureSize: vec2f)->Splat {var splat: Splat;let splatUV=getDataUV(splatIndex,dataTextureSize);let splatUVi32=vec2<i32>(i32(splatUV.x),i32(splatUV.y));splat.center=textureLoad(centersTexture,splatUVi32,0);splat.color=textureLoad(colorsTexture,splatUVi32,0);splat.covA=textureLoad(covariancesATexture,splatUVi32,0)*splat.center.w;splat.covB=textureLoad(covariancesBTexture,splatUVi32,0)*splat.center.w;\n#if SH_DEGREE>0\nsplat.sh0=textureLoad(shTexture0,splatUVi32,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=textureLoad(shTexture1,splatUVi32,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=textureLoad(shTexture2,splatUVi32,0);\n#endif\nreturn splat;}\nfn computeColorFromSHDegree(dir: vec3f,sh: array<vec3<f32>,16>)->vec3f\n{let SH_C0: f32=0.28209479;let SH_C1: f32=0.48860251;var SH_C2: array<f32,5>=array<f32,5>(\n1.092548430,\n-1.09254843,\n0.315391565,\n-1.09254843,\n0.546274215\n);var SH_C3: array<f32,7>=array<f32,7>(\n-0.59004358,\n2.890611442,\n-0.45704579,\n0.373176332,\n-0.45704579,\n1.445305721,\n-0.59004358\n);var result: vec3f=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nlet x: f32=dir.x;let y: f32=dir.y;let z: f32=dir.z;result+=-SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nlet xx: f32=x*x;let yy: f32=y*y;let zz: f32=z*z;let xy: f32=x*y;let yz: f32=y*z;let xz: f32=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0f*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0f*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0f*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0f*zz-3.0f*xx-3.0f*yy)*sh[12] +\nSH_C3[4]*x*(4.0f*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0f*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nfn decompose(value: u32)->vec4f\n{let components : vec4f=vec4f(\nf32((value ) & 255u),\nf32((value>>u32( 8)) & 255u),\nf32((value>>u32(16)) & 255u),\nf32((value>>u32(24)) & 255u));return components*vec4f(2./255.)-vec4f(1.);}\nfn computeSH(splat: Splat,dir: vec3f)->vec3f\n{var sh: array<vec3<f32>,16>;sh[0]=vec3f(0.,0.,0.);\n#if SH_DEGREE>0\nlet sh00: vec4f=decompose(splat.sh0.x);let sh01: vec4f=decompose(splat.sh0.y);let sh02: vec4f=decompose(splat.sh0.z);sh[1]=vec3f(sh00.x,sh00.y,sh00.z);sh[2]=vec3f(sh00.w,sh01.x,sh01.y);sh[3]=vec3f(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nlet sh03: vec4f=decompose(splat.sh0.w);let sh04: vec4f=decompose(splat.sh1.x);let sh05: vec4f=decompose(splat.sh1.y);sh[4]=vec3f(sh02.y,sh02.z,sh02.w);sh[5]=vec3f(sh03.x,sh03.y,sh03.z);sh[6]=vec3f(sh03.w,sh04.x,sh04.y);sh[7]=vec3f(sh04.z,sh04.w,sh05.x);sh[8]=vec3f(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nlet sh06: vec4f=decompose(splat.sh1.z);let sh07: vec4f=decompose(splat.sh1.w);let sh08: vec4f=decompose(splat.sh2.x);let sh09: vec4f=decompose(splat.sh2.y);let sh10: vec4f=decompose(splat.sh2.z);let sh11: vec4f=decompose(splat.sh2.w);sh[9]=vec3f(sh06.x,sh06.y,sh06.z);sh[10]=vec3f(sh06.w,sh07.x,sh07.y);sh[11]=vec3f(sh07.z,sh07.w,sh08.x);sh[12]=vec3f(sh08.y,sh08.z,sh08.w);sh[13]=vec3f(sh09.x,sh09.y,sh09.z);sh[14]=vec3f(sh09.w,sh10.x,sh10.y);sh[15]=vec3f(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\nfn gaussianSplatting(\nmeshPos: vec2<f32>,\nworldPos: vec3<f32>,\nscale: vec2<f32>,\ncovA: vec3<f32>,\ncovB: vec3<f32>,\nworldMatrix: mat4x4<f32>,\nviewMatrix: mat4x4<f32>,\nprojectionMatrix: mat4x4<f32>,\nfocal: vec2f,\ninvViewport: vec2f,\nkernelSize: f32\n)->vec4f {let modelView=viewMatrix*worldMatrix;let camspace=viewMatrix*vec4f(worldPos,1.0);let pos2d=projectionMatrix*camspace;let bounds=1.2*pos2d.w;if (pos2d.z<0. || pos2d.x<-bounds || pos2d.x>bounds || pos2d.y<-bounds || pos2d.y>bounds) {return vec4f(0.0,0.0,2.0,1.0);}\nlet Vrk=mat3x3<f32>(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);let J=mat3x3<f32>(\nfocal.x/camspace.z,0.0,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.0,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.0,0.0,0.0\n);let invy=mat3x3<f32>(\n1.0,0.0,0.0,\n0.0,-1.0,0.0,\n0.0,0.0,1.0\n);let T=invy*transpose(mat3x3<f32>(\nmodelView[0].xyz,\nmodelView[1].xyz,\nmodelView[2].xyz))*J;var cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nlet c00: f32=cov2d[0][0];let c11: f32=cov2d[1][1];let c01: f32=cov2d[0][1];let detOrig: f32=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nlet c2d: vec3f=vec3f(cov2d[0][0],c01,cov2d[1][1]);let detBlur: f32=c2d.x*c2d.z-c2d.y*c2d.y;let compensation: f32=sqrt(max(0.,detOrig/detBlur));vertexOutputs.vColor.w*=compensation;\n#endif\nlet mid=(cov2d[0][0]+cov2d[1][1])/2.0;let radius=length(vec2<f32>((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));let lambda1=mid+radius;let lambda2=mid-radius;if (lambda2<0.0) {return vec4f(0.0,0.0,2.0,1.0);}\nlet diagonalVector=normalize(vec2<f32>(cov2d[0][1],lambda1-cov2d[0][0]));let majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;let minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2<f32>(diagonalVector.y,-diagonalVector.x);let vCenter=vec2<f32>(pos2d.x,pos2d.y);return vec4f(\nvCenter+((meshPos.x*majorAxis+meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,\npos2d.z,\npos2d.w\n);}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<helperFunctions>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex: f32;attribute position: vec2f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform eyePosition: vec3f;uniform viewDirectionFactor: vec3f;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var splat: Splat=readSplat(input.splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position;\n#if SH_DEGREE>0\nlet worldRot: mat3x3f= mat3x3f(mesh.world[0].xyz,mesh.world[1].xyz,mesh.world[2].xyz);let normWorldRot: mat3x3f=inverseMat3(worldRot);var dir: vec3f=normalize(normWorldRot*(worldPos.xyz-uniforms.eyePosition.xyz));dir*=viewDirectionFactor;vertexOutputs.vColor=vec4f(splat.color.xyz+computeSH(splat,dir),splat.color.w);\n#else\nvertexOutputs.vColor=splat.color;\n#endif\nvertexOutputs.position=gaussianSplatting(input.position,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.vertex.js.map","import { SerializationHelper } from \"../../Misc/decorators.serialization\";\nimport { VertexBuffer } from \"../../Buffers/buffer\";\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\nimport { RegisterClass } from \"../../Misc/typeStore\";\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\nimport { Camera } from \"core/Cameras/camera\";\nimport \"../../Shaders/gaussianSplatting.fragment\";\nimport \"../../Shaders/gaussianSplatting.vertex\";\nimport \"../../ShadersWGSL/gaussianSplatting.fragment\";\nimport \"../../ShadersWGSL/gaussianSplatting.vertex\";\nimport { BindFogParameters, BindLogDepth, PrepareAttributesForInstances, PrepareDefinesForAttributes, PrepareDefinesForFrameBoundValues, PrepareDefinesForMisc, PrepareUniformsAndSamplersList, } from \"../materialHelper.functions\";\n/**\n * @internal\n */\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\n    /**\n     * Constructor of the defines.\n     */\n    constructor() {\n        super();\n        this.FOG = false;\n        this.THIN_INSTANCES = true;\n        this.LOGARITHMICDEPTH = false;\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.SH_DEGREE = 0;\n        this.COMPENSATION = false;\n        this.rebuild();\n    }\n}\n/**\n * GaussianSplattingMaterial material used to render Gaussian Splatting\n * @experimental\n */\nexport class GaussianSplattingMaterial extends PushMaterial {\n    /**\n     * Instantiates a Gaussian Splatting Material in the given scene\n     * @param name The friendly name of the material\n     * @param scene The scene to add the material to\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Point spread function (default 0.3). Can be overriden per GS material, otherwise, using default static `KernelSize` value\n         */\n        this.kernelSize = GaussianSplattingMaterial.KernelSize;\n        this._compensation = GaussianSplattingMaterial.Compensation;\n        // set to true when material defines are dirty\n        this._isDirty = false;\n        this.backFaceCulling = false;\n    }\n    /**\n     * Set compensation default value is `GaussianSplattingMaterial.Compensation`\n     */\n    set compensation(value) {\n        this._isDirty = this._isDirty != value;\n        this._compensation = value;\n    }\n    /**\n     * Get compensation\n     */\n    get compensation() {\n        return this._compensation;\n    }\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get hasRenderTargetTextures() {\n        return false;\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha test mode.\n     * @returns false\n     */\n    needAlphaTesting() {\n        return false;\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha blend mode.\n     * @returns true\n     */\n    needAlphaBlending() {\n        return true;\n    }\n    /**\n     * Checks whether the material is ready to be rendered for a given mesh.\n     * @param mesh The mesh to render\n     * @param subMesh The submesh to check against\n     * @returns true if all the dependencies are ready (Textures, Effects...)\n     */\n    isReadyForSubMesh(mesh, subMesh) {\n        const useInstances = true;\n        const drawWrapper = subMesh._drawWrapper;\n        let defines = subMesh.materialDefines;\n        if (defines && this._isDirty) {\n            defines.markAsUnprocessed();\n        }\n        if (drawWrapper.effect && this.isFrozen) {\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            defines = subMesh.materialDefines = new GaussianSplattingMaterialDefines();\n        }\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const engine = scene.getEngine();\n        const gsMesh = mesh;\n        // Misc.\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);\n        // Values that need to be evaluated on every frame\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\n        // Attribs\n        PrepareDefinesForAttributes(mesh, defines, false, false);\n        // SH is disabled for webGL1\n        if (engine.version > 1 || engine.isWebGPU) {\n            defines[\"SH_DEGREE\"] = gsMesh.shDegree;\n        }\n        // Compensation\n        const splatMaterial = gsMesh.material;\n        defines[\"COMPENSATION\"] = splatMaterial && splatMaterial.compensation ? splatMaterial.compensation : GaussianSplattingMaterial.Compensation;\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind, \"splatIndex\"];\n            PrepareAttributesForInstances(attribs, defines);\n            const uniforms = [\n                \"world\",\n                \"view\",\n                \"projection\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"logarithmicDepthConstant\",\n                \"invViewport\",\n                \"dataTextureSize\",\n                \"focal\",\n                \"eyePosition\",\n                \"kernelSize\",\n                \"viewDirectionFactor\",\n            ];\n            const samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\", \"shTexture0\", \"shTexture1\", \"shTexture2\"];\n            const uniformBuffers = [\"Scene\", \"Mesh\"];\n            PrepareUniformsAndSamplersList({\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n            });\n            AddClipPlaneUniforms(uniforms);\n            const join = defines.toString();\n            const effect = scene.getEngine().createEffect(\"gaussianSplatting\", {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: {},\n                shaderLanguage: this._shaderLanguage,\n                extraInitializationsAsync: async () => {\n                    if (this._shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n                        await Promise.all([import(\"../../ShadersWGSL/gaussianSplatting.fragment\"), import(\"../../ShadersWGSL/gaussianSplatting.vertex\")]);\n                    }\n                    else {\n                        await Promise.all([import(\"../../Shaders/gaussianSplatting.fragment\"), import(\"../../Shaders/gaussianSplatting.vertex\")]);\n                    }\n                },\n            }, engine);\n            subMesh.setEffect(effect, defines, this._materialContext);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        drawWrapper._wasPreviouslyReady = true;\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\n        this._isDirty = false;\n        return true;\n    }\n    /**\n     * Bind material effect for a specific Gaussian Splatting mesh\n     * @param mesh Gaussian splatting mesh\n     * @param effect Splatting material or node material\n     * @param scene scene that contains mesh and camera used for rendering\n     */\n    static BindEffect(mesh, effect, scene) {\n        const engine = scene.getEngine();\n        const camera = scene.activeCamera;\n        const renderWidth = engine.getRenderWidth();\n        const renderHeight = engine.getRenderHeight();\n        const gsMesh = mesh;\n        const gsMaterial = gsMesh.material;\n        // check if rigcamera, get number of rigs\n        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;\n        effect.setFloat2(\"invViewport\", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);\n        let focal = 1000;\n        if (camera) {\n            /*\n            more explicit version:\n            const t = camera.getProjectionMatrix().m[5];\n            const FovY = Math.atan(1.0 / t) * 2.0;\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\n            Using a shorter version here to not have tan(atan) and 2.0 factor\n            */\n            const t = camera.getProjectionMatrix().m[5];\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\n                focal = (renderHeight * t) / 2.0;\n            }\n            else {\n                focal = (renderWidth * t) / 2.0;\n            }\n        }\n        effect.setFloat2(\"focal\", focal, focal);\n        effect.setVector3(\"viewDirectionFactor\", gsMesh.viewDirectionFactor);\n        effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\n        scene.bindEyePosition(effect, \"eyePosition\", true);\n        if (gsMesh.covariancesATexture) {\n            const textureSize = gsMesh.covariancesATexture.getSize();\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\n            if (gsMesh.shTextures) {\n                for (let i = 0; i < gsMesh.shTextures?.length; i++) {\n                    effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);\n                }\n            }\n        }\n    }\n    /**\n     * Binds the submesh to this material by preparing the effect and shader to draw\n     * @param world defines the world transformation matrix\n     * @param mesh defines the mesh containing the submesh\n     * @param subMesh defines the submesh to bind the material to\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices Mesh.\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n        mesh.transferToEffect(world);\n        // Bind data\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\n        if (mustRebind) {\n            this.bindView(effect);\n            this.bindViewProjection(effect);\n            GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);\n            // Clip plane\n            BindClipPlane(effect, this, scene);\n        }\n        else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n            this._needToBindSceneUbo = true;\n        }\n        // Fog\n        BindFogParameters(scene, mesh, effect);\n        // Log. depth\n        if (this.useLogarithmicDepth) {\n            BindLogDepth(defines, effect, scene);\n        }\n        this._afterBind(mesh, this._activeEffect, subMesh);\n    }\n    /**\n     * Clones the material.\n     * @param name The cloned name.\n     * @returns The cloned material.\n     */\n    clone(name) {\n        return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\n    }\n    /**\n     * Serializes the current material to its JSON representation.\n     * @returns The JSON representation.\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\n        return serializationObject;\n    }\n    /**\n     * Gets the class name of the material\n     * @returns \"GaussianSplattingMaterial\"\n     */\n    getClassName() {\n        return \"GaussianSplattingMaterial\";\n    }\n    /**\n     * Parse a JSON input to create back a Gaussian Splatting material.\n     * @param source The JSON data to parse\n     * @param scene The scene to create the parsed material in\n     * @param rootUrl The root url of the assets the material depends upon\n     * @returns the instantiated GaussianSplattingMaterial.\n     */\n    static Parse(source, scene, rootUrl) {\n        return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\n/**\n * Point spread function (default 0.3). Can be overriden per GS material\n */\nGaussianSplattingMaterial.KernelSize = 0.3;\n/**\n * Compensation\n */\nGaussianSplattingMaterial.Compensation = false;\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\n//# sourceMappingURL=gaussianSplattingMaterial.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport * as functions from \"./math.scalar.functions\";\nconst HCF = functions.HighestCommonFactor;\n/**\n * Scalar computation library\n */\nexport const Scalar = {\n    ...functions,\n    /**\n     * Two pi constants convenient for computation.\n     */\n    TwoPi: Math.PI * 2,\n    /**\n     * Returns -1 if value is negative and +1 is value is positive.\n     * @param value the value\n     * @returns the value itself if it's equal to zero.\n     */\n    Sign: Math.sign,\n    /**\n     * the log2 of value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    Log2: Math.log2,\n    /**\n     * Returns the highest common factor of two integers.\n     * @param a first parameter\n     * @param b second parameter\n     * @returns HCF of a and b\n     */\n    HCF,\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n//# sourceMappingURL=math.scalar.js.map","import { SubMesh } from \"../subMesh\";\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { Matrix, TmpVectors, Vector2, Vector3 } from \"core/Maths/math.vector\";\nimport { Logger } from \"core/Misc/logger\";\nimport { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\nimport { Constants } from \"core/Engines/constants\";\nimport { Tools } from \"core/Misc/tools\";\nimport \"core/Meshes/thinInstanceMesh\";\nimport { ToHalfFloat } from \"core/Misc/textureTools\";\nimport { Scalar } from \"core/Maths/math.scalar\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"core/Misc/coroutine\";\nimport { EngineStore } from \"core/Engines/engineStore\";\n// @internal\nconst UnpackUnorm = (value, bits) => {\n    const t = (1 << bits) - 1;\n    return (value & t) / t;\n};\n// @internal\nconst Unpack111011 = (value, result) => {\n    result.x = UnpackUnorm(value >>> 21, 11);\n    result.y = UnpackUnorm(value >>> 11, 10);\n    result.z = UnpackUnorm(value, 11);\n};\n// @internal\nconst Unpack8888 = (value, result) => {\n    result[0] = UnpackUnorm(value >>> 24, 8) * 255;\n    result[1] = UnpackUnorm(value >>> 16, 8) * 255;\n    result[2] = UnpackUnorm(value >>> 8, 8) * 255;\n    result[3] = UnpackUnorm(value, 8) * 255;\n};\n// @internal\n// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)\nconst UnpackRot = (value, result) => {\n    const norm = 1.0 / (Math.sqrt(2) * 0.5);\n    const a = (UnpackUnorm(value >>> 20, 10) - 0.5) * norm;\n    const b = (UnpackUnorm(value >>> 10, 10) - 0.5) * norm;\n    const c = (UnpackUnorm(value, 10) - 0.5) * norm;\n    const m = Math.sqrt(1.0 - (a * a + b * b + c * c));\n    switch (value >>> 30) {\n        case 0:\n            result.set(m, a, b, c);\n            break;\n        case 1:\n            result.set(a, m, b, c);\n            break;\n        case 2:\n            result.set(a, b, m, c);\n            break;\n        case 3:\n            result.set(a, b, c, m);\n            break;\n    }\n};\n/**\n * Representation of the types\n */\nvar PLYType;\n(function (PLYType) {\n    PLYType[PLYType[\"FLOAT\"] = 0] = \"FLOAT\";\n    PLYType[PLYType[\"INT\"] = 1] = \"INT\";\n    PLYType[PLYType[\"UINT\"] = 2] = \"UINT\";\n    PLYType[PLYType[\"DOUBLE\"] = 3] = \"DOUBLE\";\n    PLYType[PLYType[\"UCHAR\"] = 4] = \"UCHAR\";\n    PLYType[PLYType[\"UNDEFINED\"] = 5] = \"UNDEFINED\";\n})(PLYType || (PLYType = {}));\n/**\n * Usage types of the PLY values\n */\nvar PLYValue;\n(function (PLYValue) {\n    PLYValue[PLYValue[\"MIN_X\"] = 0] = \"MIN_X\";\n    PLYValue[PLYValue[\"MIN_Y\"] = 1] = \"MIN_Y\";\n    PLYValue[PLYValue[\"MIN_Z\"] = 2] = \"MIN_Z\";\n    PLYValue[PLYValue[\"MAX_X\"] = 3] = \"MAX_X\";\n    PLYValue[PLYValue[\"MAX_Y\"] = 4] = \"MAX_Y\";\n    PLYValue[PLYValue[\"MAX_Z\"] = 5] = \"MAX_Z\";\n    PLYValue[PLYValue[\"MIN_SCALE_X\"] = 6] = \"MIN_SCALE_X\";\n    PLYValue[PLYValue[\"MIN_SCALE_Y\"] = 7] = \"MIN_SCALE_Y\";\n    PLYValue[PLYValue[\"MIN_SCALE_Z\"] = 8] = \"MIN_SCALE_Z\";\n    PLYValue[PLYValue[\"MAX_SCALE_X\"] = 9] = \"MAX_SCALE_X\";\n    PLYValue[PLYValue[\"MAX_SCALE_Y\"] = 10] = \"MAX_SCALE_Y\";\n    PLYValue[PLYValue[\"MAX_SCALE_Z\"] = 11] = \"MAX_SCALE_Z\";\n    PLYValue[PLYValue[\"PACKED_POSITION\"] = 12] = \"PACKED_POSITION\";\n    PLYValue[PLYValue[\"PACKED_ROTATION\"] = 13] = \"PACKED_ROTATION\";\n    PLYValue[PLYValue[\"PACKED_SCALE\"] = 14] = \"PACKED_SCALE\";\n    PLYValue[PLYValue[\"PACKED_COLOR\"] = 15] = \"PACKED_COLOR\";\n    PLYValue[PLYValue[\"X\"] = 16] = \"X\";\n    PLYValue[PLYValue[\"Y\"] = 17] = \"Y\";\n    PLYValue[PLYValue[\"Z\"] = 18] = \"Z\";\n    PLYValue[PLYValue[\"SCALE_0\"] = 19] = \"SCALE_0\";\n    PLYValue[PLYValue[\"SCALE_1\"] = 20] = \"SCALE_1\";\n    PLYValue[PLYValue[\"SCALE_2\"] = 21] = \"SCALE_2\";\n    PLYValue[PLYValue[\"DIFFUSE_RED\"] = 22] = \"DIFFUSE_RED\";\n    PLYValue[PLYValue[\"DIFFUSE_GREEN\"] = 23] = \"DIFFUSE_GREEN\";\n    PLYValue[PLYValue[\"DIFFUSE_BLUE\"] = 24] = \"DIFFUSE_BLUE\";\n    PLYValue[PLYValue[\"OPACITY\"] = 25] = \"OPACITY\";\n    PLYValue[PLYValue[\"F_DC_0\"] = 26] = \"F_DC_0\";\n    PLYValue[PLYValue[\"F_DC_1\"] = 27] = \"F_DC_1\";\n    PLYValue[PLYValue[\"F_DC_2\"] = 28] = \"F_DC_2\";\n    PLYValue[PLYValue[\"F_DC_3\"] = 29] = \"F_DC_3\";\n    PLYValue[PLYValue[\"ROT_0\"] = 30] = \"ROT_0\";\n    PLYValue[PLYValue[\"ROT_1\"] = 31] = \"ROT_1\";\n    PLYValue[PLYValue[\"ROT_2\"] = 32] = \"ROT_2\";\n    PLYValue[PLYValue[\"ROT_3\"] = 33] = \"ROT_3\";\n    PLYValue[PLYValue[\"MIN_COLOR_R\"] = 34] = \"MIN_COLOR_R\";\n    PLYValue[PLYValue[\"MIN_COLOR_G\"] = 35] = \"MIN_COLOR_G\";\n    PLYValue[PLYValue[\"MIN_COLOR_B\"] = 36] = \"MIN_COLOR_B\";\n    PLYValue[PLYValue[\"MAX_COLOR_R\"] = 37] = \"MAX_COLOR_R\";\n    PLYValue[PLYValue[\"MAX_COLOR_G\"] = 38] = \"MAX_COLOR_G\";\n    PLYValue[PLYValue[\"MAX_COLOR_B\"] = 39] = \"MAX_COLOR_B\";\n    PLYValue[PLYValue[\"SH_0\"] = 40] = \"SH_0\";\n    PLYValue[PLYValue[\"SH_1\"] = 41] = \"SH_1\";\n    PLYValue[PLYValue[\"SH_2\"] = 42] = \"SH_2\";\n    PLYValue[PLYValue[\"SH_3\"] = 43] = \"SH_3\";\n    PLYValue[PLYValue[\"SH_4\"] = 44] = \"SH_4\";\n    PLYValue[PLYValue[\"SH_5\"] = 45] = \"SH_5\";\n    PLYValue[PLYValue[\"SH_6\"] = 46] = \"SH_6\";\n    PLYValue[PLYValue[\"SH_7\"] = 47] = \"SH_7\";\n    PLYValue[PLYValue[\"SH_8\"] = 48] = \"SH_8\";\n    PLYValue[PLYValue[\"SH_9\"] = 49] = \"SH_9\";\n    PLYValue[PLYValue[\"SH_10\"] = 50] = \"SH_10\";\n    PLYValue[PLYValue[\"SH_11\"] = 51] = \"SH_11\";\n    PLYValue[PLYValue[\"SH_12\"] = 52] = \"SH_12\";\n    PLYValue[PLYValue[\"SH_13\"] = 53] = \"SH_13\";\n    PLYValue[PLYValue[\"SH_14\"] = 54] = \"SH_14\";\n    PLYValue[PLYValue[\"SH_15\"] = 55] = \"SH_15\";\n    PLYValue[PLYValue[\"SH_16\"] = 56] = \"SH_16\";\n    PLYValue[PLYValue[\"SH_17\"] = 57] = \"SH_17\";\n    PLYValue[PLYValue[\"SH_18\"] = 58] = \"SH_18\";\n    PLYValue[PLYValue[\"SH_19\"] = 59] = \"SH_19\";\n    PLYValue[PLYValue[\"SH_20\"] = 60] = \"SH_20\";\n    PLYValue[PLYValue[\"SH_21\"] = 61] = \"SH_21\";\n    PLYValue[PLYValue[\"SH_22\"] = 62] = \"SH_22\";\n    PLYValue[PLYValue[\"SH_23\"] = 63] = \"SH_23\";\n    PLYValue[PLYValue[\"SH_24\"] = 64] = \"SH_24\";\n    PLYValue[PLYValue[\"SH_25\"] = 65] = \"SH_25\";\n    PLYValue[PLYValue[\"SH_26\"] = 66] = \"SH_26\";\n    PLYValue[PLYValue[\"SH_27\"] = 67] = \"SH_27\";\n    PLYValue[PLYValue[\"SH_28\"] = 68] = \"SH_28\";\n    PLYValue[PLYValue[\"SH_29\"] = 69] = \"SH_29\";\n    PLYValue[PLYValue[\"SH_30\"] = 70] = \"SH_30\";\n    PLYValue[PLYValue[\"SH_31\"] = 71] = \"SH_31\";\n    PLYValue[PLYValue[\"SH_32\"] = 72] = \"SH_32\";\n    PLYValue[PLYValue[\"SH_33\"] = 73] = \"SH_33\";\n    PLYValue[PLYValue[\"SH_34\"] = 74] = \"SH_34\";\n    PLYValue[PLYValue[\"SH_35\"] = 75] = \"SH_35\";\n    PLYValue[PLYValue[\"SH_36\"] = 76] = \"SH_36\";\n    PLYValue[PLYValue[\"SH_37\"] = 77] = \"SH_37\";\n    PLYValue[PLYValue[\"SH_38\"] = 78] = \"SH_38\";\n    PLYValue[PLYValue[\"SH_39\"] = 79] = \"SH_39\";\n    PLYValue[PLYValue[\"SH_40\"] = 80] = \"SH_40\";\n    PLYValue[PLYValue[\"SH_41\"] = 81] = \"SH_41\";\n    PLYValue[PLYValue[\"SH_42\"] = 82] = \"SH_42\";\n    PLYValue[PLYValue[\"SH_43\"] = 83] = \"SH_43\";\n    PLYValue[PLYValue[\"SH_44\"] = 84] = \"SH_44\";\n    PLYValue[PLYValue[\"UNDEFINED\"] = 85] = \"UNDEFINED\";\n})(PLYValue || (PLYValue = {}));\n/**\n * Class used to render a gaussian splatting mesh\n */\nexport class GaussianSplattingMesh extends Mesh {\n    /**\n     * View direction factor used to compute the SH view direction in the shader.\n     */\n    get viewDirectionFactor() {\n        return this._viewDirectionFactor;\n    }\n    /**\n     * SH degree. 0 = no sh (default). 1 = 3 parameters. 2 = 8 parameters. 3 = 15 parameters.\n     */\n    get shDegree() {\n        return this._shDegree;\n    }\n    /**\n     * returns the splats data array buffer that contains in order : postions (3 floats), size (3 floats), color (4 bytes), orientation quaternion (4 bytes)\n     */\n    get splatsData() {\n        return this._splatsData;\n    }\n    /**\n     * Gets the covariancesA texture\n     */\n    get covariancesATexture() {\n        return this._covariancesATexture;\n    }\n    /**\n     * Gets the covariancesB texture\n     */\n    get covariancesBTexture() {\n        return this._covariancesBTexture;\n    }\n    /**\n     * Gets the centers texture\n     */\n    get centersTexture() {\n        return this._centersTexture;\n    }\n    /**\n     * Gets the colors texture\n     */\n    get colorsTexture() {\n        return this._colorsTexture;\n    }\n    /**\n     * Gets the SH textures\n     */\n    get shTextures() {\n        return this._shTextures;\n    }\n    /**\n     * set rendering material\n     */\n    set material(value) {\n        this._material = value;\n        this._material.backFaceCulling = true;\n        this._material.cullBackFaces = false;\n        value.resetDrawCache();\n    }\n    /**\n     * get rendering material\n     */\n    get material() {\n        return this._material;\n    }\n    /**\n     * Creates a new gaussian splatting mesh\n     * @param name defines the name of the mesh\n     * @param url defines the url to load from (optional)\n     * @param scene defines the hosting scene (optional)\n     * @param keepInRam keep datas in ram for editing purpose\n     */\n    constructor(name, url = null, scene = null, keepInRam = false) {\n        super(name, scene);\n        this._vertexCount = 0;\n        this._worker = null;\n        this._frameIdLastUpdate = -1;\n        this._modelViewMatrix = Matrix.Identity();\n        this._canPostToWorker = true;\n        this._readyToDisplay = false;\n        this._covariancesATexture = null;\n        this._covariancesBTexture = null;\n        this._centersTexture = null;\n        this._colorsTexture = null;\n        this._splatPositions = null;\n        this._splatIndex = null;\n        this._shTextures = null;\n        this._splatsData = null;\n        this._sh = null;\n        this._keepInRam = false;\n        this._delayedTextureUpdate = null;\n        this._oldDirection = new Vector3();\n        this._useRGBACovariants = false;\n        this._material = null;\n        this._tmpCovariances = [0, 0, 0, 0, 0, 0];\n        this._sortIsDirty = false;\n        this._shDegree = 0;\n        this._viewDirectionFactor = new Vector3(1, 1, -1);\n        const vertexData = new VertexData();\n        // Use an intanced quad or triangle. Triangle might be a bit faster because of less shader invocation but I didn't see any difference.\n        // Keeping both and use triangle for now.\n        // for quad, use following lines\n        //vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];\n        //vertexData.indices = [0, 1, 2, 0, 2, 3];\n        vertexData.positions = [-3, -2, 0, 3, -2, 0, 0, 4, 0];\n        vertexData.indices = [0, 1, 2];\n        vertexData.applyToMesh(this);\n        this.subMeshes = [];\n        // for quad, use following line\n        //new SubMesh(0, 0, 4, 0, 6, this);\n        new SubMesh(0, 0, 3, 0, 3, this);\n        this.setEnabled(false);\n        // webGL2 and webGPU support for RG texture with float16 is fine. not webGL1\n        this._useRGBACovariants = !this.getEngine().isWebGPU && this.getEngine().version === 1.0;\n        this._keepInRam = keepInRam;\n        if (url) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.loadFileAsync(url);\n        }\n        this._material = new GaussianSplattingMaterial(this.name + \"_material\", this._scene);\n    }\n    /**\n     * Returns the class name\n     * @returns \"GaussianSplattingMesh\"\n     */\n    getClassName() {\n        return \"GaussianSplattingMesh\";\n    }\n    /**\n     * Returns the total number of vertices (splats) within the mesh\n     * @returns the total number of vertices\n     */\n    getTotalVertices() {\n        return this._vertexCount;\n    }\n    /**\n     * Is this node ready to be used/rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @returns true when ready\n     */\n    isReady(completeCheck = false) {\n        if (!super.isReady(completeCheck, true)) {\n            return false;\n        }\n        if (!this._readyToDisplay) {\n            // mesh is ready when worker has done at least 1 sorting\n            this._postToWorker(true);\n            return false;\n        }\n        return true;\n    }\n    /** @internal */\n    _postToWorker(forced = false) {\n        const frameId = this.getScene().getFrameId();\n        if ((forced || frameId !== this._frameIdLastUpdate) && this._worker && this._scene.activeCamera && this._canPostToWorker) {\n            const cameraMatrix = this._scene.activeCamera.getViewMatrix();\n            this.getWorldMatrix().multiplyToRef(cameraMatrix, this._modelViewMatrix);\n            cameraMatrix.invertToRef(TmpVectors.Matrix[0]);\n            this.getWorldMatrix().multiplyToRef(TmpVectors.Matrix[0], TmpVectors.Matrix[1]);\n            Vector3.TransformNormalToRef(Vector3.Forward(this._scene.useRightHandedSystem), TmpVectors.Matrix[1], TmpVectors.Vector3[2]);\n            TmpVectors.Vector3[2].normalize();\n            const dot = Vector3.Dot(TmpVectors.Vector3[2], this._oldDirection);\n            if (forced || Math.abs(dot - 1) >= 0.01) {\n                this._oldDirection.copyFrom(TmpVectors.Vector3[2]);\n                this._frameIdLastUpdate = frameId;\n                this._canPostToWorker = false;\n                this._worker.postMessage({ view: this._modelViewMatrix.m, depthMix: this._depthMix, useRightHandedSystem: this._scene.useRightHandedSystem }, [\n                    this._depthMix.buffer,\n                ]);\n            }\n        }\n    }\n    /**\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n     * @param subMesh defines the subMesh to render\n     * @param enableAlphaMode defines if alpha mode can be changed\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n     * @returns the current mesh\n     */\n    render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n        this._postToWorker();\n        return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);\n    }\n    static _TypeNameToEnum(name) {\n        switch (name) {\n            case \"float\":\n                return 0 /* PLYType.FLOAT */;\n            case \"int\":\n                return 1 /* PLYType.INT */;\n                break;\n            case \"uint\":\n                return 2 /* PLYType.UINT */;\n            case \"double\":\n                return 3 /* PLYType.DOUBLE */;\n            case \"uchar\":\n                return 4 /* PLYType.UCHAR */;\n        }\n        return 5 /* PLYType.UNDEFINED */;\n    }\n    static _ValueNameToEnum(name) {\n        switch (name) {\n            case \"min_x\":\n                return 0 /* PLYValue.MIN_X */;\n            case \"min_y\":\n                return 1 /* PLYValue.MIN_Y */;\n            case \"min_z\":\n                return 2 /* PLYValue.MIN_Z */;\n            case \"max_x\":\n                return 3 /* PLYValue.MAX_X */;\n            case \"max_y\":\n                return 4 /* PLYValue.MAX_Y */;\n            case \"max_z\":\n                return 5 /* PLYValue.MAX_Z */;\n            case \"min_scale_x\":\n                return 6 /* PLYValue.MIN_SCALE_X */;\n            case \"min_scale_y\":\n                return 7 /* PLYValue.MIN_SCALE_Y */;\n            case \"min_scale_z\":\n                return 8 /* PLYValue.MIN_SCALE_Z */;\n            case \"max_scale_x\":\n                return 9 /* PLYValue.MAX_SCALE_X */;\n            case \"max_scale_y\":\n                return 10 /* PLYValue.MAX_SCALE_Y */;\n            case \"max_scale_z\":\n                return 11 /* PLYValue.MAX_SCALE_Z */;\n            case \"packed_position\":\n                return 12 /* PLYValue.PACKED_POSITION */;\n            case \"packed_rotation\":\n                return 13 /* PLYValue.PACKED_ROTATION */;\n            case \"packed_scale\":\n                return 14 /* PLYValue.PACKED_SCALE */;\n            case \"packed_color\":\n                return 15 /* PLYValue.PACKED_COLOR */;\n            case \"x\":\n                return 16 /* PLYValue.X */;\n            case \"y\":\n                return 17 /* PLYValue.Y */;\n            case \"z\":\n                return 18 /* PLYValue.Z */;\n            case \"scale_0\":\n                return 19 /* PLYValue.SCALE_0 */;\n            case \"scale_1\":\n                return 20 /* PLYValue.SCALE_1 */;\n            case \"scale_2\":\n                return 21 /* PLYValue.SCALE_2 */;\n            case \"diffuse_red\":\n            case \"red\":\n                return 22 /* PLYValue.DIFFUSE_RED */;\n            case \"diffuse_green\":\n            case \"green\":\n                return 23 /* PLYValue.DIFFUSE_GREEN */;\n            case \"diffuse_blue\":\n            case \"blue\":\n                return 24 /* PLYValue.DIFFUSE_BLUE */;\n            case \"f_dc_0\":\n                return 26 /* PLYValue.F_DC_0 */;\n            case \"f_dc_1\":\n                return 27 /* PLYValue.F_DC_1 */;\n            case \"f_dc_2\":\n                return 28 /* PLYValue.F_DC_2 */;\n            case \"f_dc_3\":\n                return 29 /* PLYValue.F_DC_3 */;\n            case \"opacity\":\n                return 25 /* PLYValue.OPACITY */;\n            case \"rot_0\":\n                return 30 /* PLYValue.ROT_0 */;\n            case \"rot_1\":\n                return 31 /* PLYValue.ROT_1 */;\n            case \"rot_2\":\n                return 32 /* PLYValue.ROT_2 */;\n            case \"rot_3\":\n                return 33 /* PLYValue.ROT_3 */;\n            case \"min_r\":\n                return 34 /* PLYValue.MIN_COLOR_R */;\n            case \"min_g\":\n                return 35 /* PLYValue.MIN_COLOR_G */;\n            case \"min_b\":\n                return 36 /* PLYValue.MIN_COLOR_B */;\n            case \"max_r\":\n                return 37 /* PLYValue.MAX_COLOR_R */;\n            case \"max_g\":\n                return 38 /* PLYValue.MAX_COLOR_G */;\n            case \"max_b\":\n                return 39 /* PLYValue.MAX_COLOR_B */;\n            case \"f_rest_0\":\n                return 40 /* PLYValue.SH_0 */;\n            case \"f_rest_1\":\n                return 41 /* PLYValue.SH_1 */;\n            case \"f_rest_2\":\n                return 42 /* PLYValue.SH_2 */;\n            case \"f_rest_3\":\n                return 43 /* PLYValue.SH_3 */;\n            case \"f_rest_4\":\n                return 44 /* PLYValue.SH_4 */;\n            case \"f_rest_5\":\n                return 45 /* PLYValue.SH_5 */;\n            case \"f_rest_6\":\n                return 46 /* PLYValue.SH_6 */;\n            case \"f_rest_7\":\n                return 47 /* PLYValue.SH_7 */;\n            case \"f_rest_8\":\n                return 48 /* PLYValue.SH_8 */;\n            case \"f_rest_9\":\n                return 49 /* PLYValue.SH_9 */;\n            case \"f_rest_10\":\n                return 50 /* PLYValue.SH_10 */;\n            case \"f_rest_11\":\n                return 51 /* PLYValue.SH_11 */;\n            case \"f_rest_12\":\n                return 52 /* PLYValue.SH_12 */;\n            case \"f_rest_13\":\n                return 53 /* PLYValue.SH_13 */;\n            case \"f_rest_14\":\n                return 54 /* PLYValue.SH_14 */;\n            case \"f_rest_15\":\n                return 55 /* PLYValue.SH_15 */;\n            case \"f_rest_16\":\n                return 56 /* PLYValue.SH_16 */;\n            case \"f_rest_17\":\n                return 57 /* PLYValue.SH_17 */;\n            case \"f_rest_18\":\n                return 58 /* PLYValue.SH_18 */;\n            case \"f_rest_19\":\n                return 59 /* PLYValue.SH_19 */;\n            case \"f_rest_20\":\n                return 60 /* PLYValue.SH_20 */;\n            case \"f_rest_21\":\n                return 61 /* PLYValue.SH_21 */;\n            case \"f_rest_22\":\n                return 62 /* PLYValue.SH_22 */;\n            case \"f_rest_23\":\n                return 63 /* PLYValue.SH_23 */;\n            case \"f_rest_24\":\n                return 64 /* PLYValue.SH_24 */;\n            case \"f_rest_25\":\n                return 65 /* PLYValue.SH_25 */;\n            case \"f_rest_26\":\n                return 66 /* PLYValue.SH_26 */;\n            case \"f_rest_27\":\n                return 67 /* PLYValue.SH_27 */;\n            case \"f_rest_28\":\n                return 68 /* PLYValue.SH_28 */;\n            case \"f_rest_29\":\n                return 69 /* PLYValue.SH_29 */;\n            case \"f_rest_30\":\n                return 70 /* PLYValue.SH_30 */;\n            case \"f_rest_31\":\n                return 71 /* PLYValue.SH_31 */;\n            case \"f_rest_32\":\n                return 72 /* PLYValue.SH_32 */;\n            case \"f_rest_33\":\n                return 73 /* PLYValue.SH_33 */;\n            case \"f_rest_34\":\n                return 74 /* PLYValue.SH_34 */;\n            case \"f_rest_35\":\n                return 75 /* PLYValue.SH_35 */;\n            case \"f_rest_36\":\n                return 76 /* PLYValue.SH_36 */;\n            case \"f_rest_37\":\n                return 77 /* PLYValue.SH_37 */;\n            case \"f_rest_38\":\n                return 78 /* PLYValue.SH_38 */;\n            case \"f_rest_39\":\n                return 79 /* PLYValue.SH_39 */;\n            case \"f_rest_40\":\n                return 80 /* PLYValue.SH_40 */;\n            case \"f_rest_41\":\n                return 81 /* PLYValue.SH_41 */;\n            case \"f_rest_42\":\n                return 82 /* PLYValue.SH_42 */;\n            case \"f_rest_43\":\n                return 83 /* PLYValue.SH_43 */;\n            case \"f_rest_44\":\n                return 84 /* PLYValue.SH_44 */;\n        }\n        return 85 /* PLYValue.UNDEFINED */;\n    }\n    /**\n     * Parse a PLY file header and returns metas infos on splats and chunks\n     * @param data the loaded buffer\n     * @returns a PLYHeader\n     */\n    static ParseHeader(data) {\n        const ubuf = new Uint8Array(data);\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n        const headerEnd = \"end_header\\n\";\n        const headerEndIndex = header.indexOf(headerEnd);\n        if (headerEndIndex < 0 || !header) {\n            // standard splat\n            return null;\n        }\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\n        let chunkCount = 0;\n        if (chunkElement) {\n            chunkCount = parseInt(chunkElement[1]);\n        }\n        let rowVertexOffset = 0;\n        let rowChunkOffset = 0;\n        const offsets = {\n            double: 8,\n            int: 4,\n            uint: 4,\n            float: 4,\n            short: 2,\n            ushort: 2,\n            uchar: 1,\n            list: 0,\n        };\n        let ElementMode;\n        (function (ElementMode) {\n            ElementMode[ElementMode[\"Vertex\"] = 0] = \"Vertex\";\n            ElementMode[ElementMode[\"Chunk\"] = 1] = \"Chunk\";\n            ElementMode[ElementMode[\"SH\"] = 2] = \"SH\";\n        })(ElementMode || (ElementMode = {}));\n        let chunkMode = 1 /* ElementMode.Chunk */;\n        const vertexProperties = [];\n        const chunkProperties = [];\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\n        let shDegree = 0;\n        for (const prop of filtered) {\n            if (prop.startsWith(\"property \")) {\n                const [, typeName, name] = prop.split(\" \");\n                const value = GaussianSplattingMesh._ValueNameToEnum(name);\n                // SH degree 1,2 or 3 for 9, 24 or 45 values\n                if (value >= 84 /* PLYValue.SH_44 */) {\n                    shDegree = 3;\n                }\n                else if (value >= 64 /* PLYValue.SH_24 */) {\n                    shDegree = 2;\n                }\n                else if (value >= 48 /* PLYValue.SH_8 */) {\n                    shDegree = 1;\n                }\n                const type = GaussianSplattingMesh._TypeNameToEnum(typeName);\n                if (chunkMode == 1 /* ElementMode.Chunk */) {\n                    chunkProperties.push({ value, type, offset: rowChunkOffset });\n                    rowChunkOffset += offsets[typeName];\n                }\n                else if (chunkMode == 0 /* ElementMode.Vertex */) {\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\n                    rowVertexOffset += offsets[typeName];\n                }\n                else if (chunkMode == 2 /* ElementMode.SH */) {\n                    // SH doesn't count for vertex row size but its properties are used to retrieve SH\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\n                }\n                if (!offsets[typeName]) {\n                    Logger.Warn(`Unsupported property type: ${typeName}.`);\n                }\n            }\n            else if (prop.startsWith(\"element \")) {\n                const [, type] = prop.split(\" \");\n                if (type == \"chunk\") {\n                    chunkMode = 1 /* ElementMode.Chunk */;\n                }\n                else if (type == \"vertex\") {\n                    chunkMode = 0 /* ElementMode.Vertex */;\n                }\n                else if (type == \"sh\") {\n                    chunkMode = 2 /* ElementMode.SH */;\n                }\n            }\n        }\n        const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n        const buffer = new ArrayBuffer(GaussianSplattingMesh._RowOutputLength * vertexCount);\n        let shBuffer = null;\n        let shCoefficientCount = 0;\n        if (shDegree) {\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;\n            shCoefficientCount = shVectorCount * 3;\n            shBuffer = new ArrayBuffer(shCoefficientCount * vertexCount);\n        }\n        return {\n            vertexCount: vertexCount,\n            chunkCount: chunkCount,\n            rowVertexLength: rowVertexOffset,\n            rowChunkLength: rowChunkOffset,\n            vertexProperties: vertexProperties,\n            chunkProperties: chunkProperties,\n            dataView: dataView,\n            buffer: buffer,\n            shDegree: shDegree,\n            shCoefficientCount: shCoefficientCount,\n            shBuffer: shBuffer,\n        };\n    }\n    static _GetCompressedChunks(header, offset) {\n        if (!header.chunkCount) {\n            return null;\n        }\n        const dataView = header.dataView;\n        const compressedChunks = new Array(header.chunkCount);\n        for (let i = 0; i < header.chunkCount; i++) {\n            const currentChunk = {\n                min: new Vector3(),\n                max: new Vector3(),\n                minScale: new Vector3(),\n                maxScale: new Vector3(),\n                minColor: new Vector3(0, 0, 0),\n                maxColor: new Vector3(1, 1, 1),\n            };\n            compressedChunks[i] = currentChunk;\n            for (let propertyIndex = 0; propertyIndex < header.chunkProperties.length; propertyIndex++) {\n                const property = header.chunkProperties[propertyIndex];\n                let value;\n                switch (property.type) {\n                    case 0 /* PLYType.FLOAT */:\n                        value = dataView.getFloat32(property.offset + offset.value, true);\n                        break;\n                    default:\n                        continue;\n                }\n                switch (property.value) {\n                    case 0 /* PLYValue.MIN_X */:\n                        currentChunk.min.x = value;\n                        break;\n                    case 1 /* PLYValue.MIN_Y */:\n                        currentChunk.min.y = value;\n                        break;\n                    case 2 /* PLYValue.MIN_Z */:\n                        currentChunk.min.z = value;\n                        break;\n                    case 3 /* PLYValue.MAX_X */:\n                        currentChunk.max.x = value;\n                        break;\n                    case 4 /* PLYValue.MAX_Y */:\n                        currentChunk.max.y = value;\n                        break;\n                    case 5 /* PLYValue.MAX_Z */:\n                        currentChunk.max.z = value;\n                        break;\n                    case 6 /* PLYValue.MIN_SCALE_X */:\n                        currentChunk.minScale.x = value;\n                        break;\n                    case 7 /* PLYValue.MIN_SCALE_Y */:\n                        currentChunk.minScale.y = value;\n                        break;\n                    case 8 /* PLYValue.MIN_SCALE_Z */:\n                        currentChunk.minScale.z = value;\n                        break;\n                    case 9 /* PLYValue.MAX_SCALE_X */:\n                        currentChunk.maxScale.x = value;\n                        break;\n                    case 10 /* PLYValue.MAX_SCALE_Y */:\n                        currentChunk.maxScale.y = value;\n                        break;\n                    case 11 /* PLYValue.MAX_SCALE_Z */:\n                        currentChunk.maxScale.z = value;\n                        break;\n                    case 34 /* PLYValue.MIN_COLOR_R */:\n                        currentChunk.minColor.x = value;\n                        break;\n                    case 35 /* PLYValue.MIN_COLOR_G */:\n                        currentChunk.minColor.y = value;\n                        break;\n                    case 36 /* PLYValue.MIN_COLOR_B */:\n                        currentChunk.minColor.z = value;\n                        break;\n                    case 37 /* PLYValue.MAX_COLOR_R */:\n                        currentChunk.maxColor.x = value;\n                        break;\n                    case 38 /* PLYValue.MAX_COLOR_G */:\n                        currentChunk.maxColor.y = value;\n                        break;\n                    case 39 /* PLYValue.MAX_COLOR_B */:\n                        currentChunk.maxColor.z = value;\n                        break;\n                }\n            }\n            offset.value += header.rowChunkLength;\n        }\n        return compressedChunks;\n    }\n    static _GetSplat(header, index, compressedChunks, offset) {\n        const q = TmpVectors.Quaternion[0];\n        const temp3 = TmpVectors.Vector3[0];\n        const rowOutputLength = GaussianSplattingMesh._RowOutputLength;\n        const buffer = header.buffer;\n        const dataView = header.dataView;\n        const position = new Float32Array(buffer, index * rowOutputLength, 3);\n        const scale = new Float32Array(buffer, index * rowOutputLength + 12, 3);\n        const rgba = new Uint8ClampedArray(buffer, index * rowOutputLength + 24, 4);\n        const rot = new Uint8ClampedArray(buffer, index * rowOutputLength + 28, 4);\n        let sh = null;\n        if (header.shBuffer) {\n            sh = new Uint8ClampedArray(header.shBuffer, index * header.shCoefficientCount, header.shCoefficientCount);\n        }\n        const chunkIndex = index >> 8;\n        let r0 = 255;\n        let r1 = 0;\n        let r2 = 0;\n        let r3 = 0;\n        const plySH = [];\n        for (let propertyIndex = 0; propertyIndex < header.vertexProperties.length; propertyIndex++) {\n            const property = header.vertexProperties[propertyIndex];\n            let value;\n            switch (property.type) {\n                case 0 /* PLYType.FLOAT */:\n                    value = dataView.getFloat32(offset.value + property.offset, true);\n                    break;\n                case 1 /* PLYType.INT */:\n                    value = dataView.getInt32(offset.value + property.offset, true);\n                    break;\n                case 2 /* PLYType.UINT */:\n                    value = dataView.getUint32(offset.value + property.offset, true);\n                    break;\n                case 3 /* PLYType.DOUBLE */:\n                    value = dataView.getFloat64(offset.value + property.offset, true);\n                    break;\n                case 4 /* PLYType.UCHAR */:\n                    value = dataView.getUint8(offset.value + property.offset);\n                    break;\n                default:\n                    continue;\n            }\n            switch (property.value) {\n                case 12 /* PLYValue.PACKED_POSITION */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack111011(value, temp3);\n                        position[0] = Scalar.Lerp(compressedChunk.min.x, compressedChunk.max.x, temp3.x);\n                        position[1] = Scalar.Lerp(compressedChunk.min.y, compressedChunk.max.y, temp3.y);\n                        position[2] = Scalar.Lerp(compressedChunk.min.z, compressedChunk.max.z, temp3.z);\n                    }\n                    break;\n                case 13 /* PLYValue.PACKED_ROTATION */:\n                    {\n                        UnpackRot(value, q);\n                        r0 = q.x;\n                        r1 = q.y;\n                        r2 = q.z;\n                        r3 = q.w;\n                    }\n                    break;\n                case 14 /* PLYValue.PACKED_SCALE */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack111011(value, temp3);\n                        scale[0] = Math.exp(Scalar.Lerp(compressedChunk.minScale.x, compressedChunk.maxScale.x, temp3.x));\n                        scale[1] = Math.exp(Scalar.Lerp(compressedChunk.minScale.y, compressedChunk.maxScale.y, temp3.y));\n                        scale[2] = Math.exp(Scalar.Lerp(compressedChunk.minScale.z, compressedChunk.maxScale.z, temp3.z));\n                    }\n                    break;\n                case 15 /* PLYValue.PACKED_COLOR */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack8888(value, rgba);\n                        rgba[0] = Scalar.Lerp(compressedChunk.minColor.x, compressedChunk.maxColor.x, rgba[0] / 255) * 255;\n                        rgba[1] = Scalar.Lerp(compressedChunk.minColor.y, compressedChunk.maxColor.y, rgba[1] / 255) * 255;\n                        rgba[2] = Scalar.Lerp(compressedChunk.minColor.z, compressedChunk.maxColor.z, rgba[2] / 255) * 255;\n                    }\n                    break;\n                case 16 /* PLYValue.X */:\n                    position[0] = value;\n                    break;\n                case 17 /* PLYValue.Y */:\n                    position[1] = -value;\n                    break;\n                case 18 /* PLYValue.Z */:\n                    position[2] = -value;\n                    break;\n                case 19 /* PLYValue.SCALE_0 */:\n                    scale[0] = Math.exp(value);\n                    break;\n                case 20 /* PLYValue.SCALE_1 */:\n                    scale[1] = Math.exp(value);\n                    break;\n                case 21 /* PLYValue.SCALE_2 */:\n                    scale[2] = Math.exp(value);\n                    break;\n                case 22 /* PLYValue.DIFFUSE_RED */:\n                    rgba[0] = value;\n                    break;\n                case 23 /* PLYValue.DIFFUSE_GREEN */:\n                    rgba[1] = value;\n                    break;\n                case 24 /* PLYValue.DIFFUSE_BLUE */:\n                    rgba[2] = value;\n                    break;\n                case 26 /* PLYValue.F_DC_0 */:\n                    rgba[0] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 27 /* PLYValue.F_DC_1 */:\n                    rgba[1] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 28 /* PLYValue.F_DC_2 */:\n                    rgba[2] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 29 /* PLYValue.F_DC_3 */:\n                    rgba[3] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 25 /* PLYValue.OPACITY */:\n                    rgba[3] = (1 / (1 + Math.exp(-value))) * 255;\n                    break;\n                case 30 /* PLYValue.ROT_0 */:\n                    r0 = value;\n                    break;\n                case 31 /* PLYValue.ROT_1 */:\n                    r1 = value;\n                    break;\n                case 32 /* PLYValue.ROT_2 */:\n                    r2 = -value;\n                    break;\n                case 33 /* PLYValue.ROT_3 */:\n                    r3 = -value;\n                    break;\n            }\n            if (sh && property.value >= 40 /* PLYValue.SH_0 */ && property.value <= 84 /* PLYValue.SH_44 */) {\n                const shIndex = property.value - 40 /* PLYValue.SH_0 */;\n                if (property.type == 4 /* PLYType.UCHAR */ && header.chunkCount) {\n                    // compressed ply. dataView points to beginning of vertex\n                    // could be improved with a direct copy instead of a per SH index computation + copy\n                    const compressedValue = dataView.getUint8(header.rowChunkLength * header.chunkCount + header.vertexCount * header.rowVertexLength + index * header.shCoefficientCount + shIndex);\n                    // compressed .ply SH import : https://github.com/playcanvas/engine/blob/fda3f0368b45d7381f0b5a1722bd2056128eaebe/src/scene/gsplat/gsplat-compressed-data.js#L88C81-L88C98\n                    plySH[shIndex] = (compressedValue * (8 / 255) - 4) * 127.5 + 127.5;\n                }\n                else {\n                    const clampedValue = Scalar.Clamp(value * 127.5 + 127.5, 0, 255);\n                    plySH[shIndex] = clampedValue;\n                }\n            }\n        }\n        if (sh) {\n            const shDim = header.shDegree == 1 ? 3 : header.shDegree == 2 ? 8 : 15;\n            for (let j = 0; j < shDim; j++) {\n                sh[j * 3 + 0] = plySH[j];\n                sh[j * 3 + 1] = plySH[j + shDim];\n                sh[j * 3 + 2] = plySH[j + shDim * 2];\n            }\n        }\n        q.set(r1, r2, r3, r0);\n        q.normalize();\n        rot[0] = q.w * 127.5 + 127.5;\n        rot[1] = q.x * 127.5 + 127.5;\n        rot[2] = q.y * 127.5 + 127.5;\n        rot[3] = q.z * 127.5 + 127.5;\n        offset.value += header.rowVertexLength;\n    }\n    /**\n     * Converts a .ply data with SH coefficients splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @param useCoroutine use coroutine and yield\n     * @returns the loaded splat buffer and optional array of sh coefficients\n     */\n    static *ConvertPLYWithSHToSplat(data, useCoroutine = false) {\n        const header = GaussianSplattingMesh.ParseHeader(data);\n        if (!header) {\n            return { buffer: data };\n        }\n        const offset = { value: 0 };\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\n        for (let i = 0; i < header.vertexCount; i++) {\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\n                yield;\n            }\n        }\n        let sh = null;\n        // make SH texture buffers\n        if (header.shDegree && header.shBuffer) {\n            const textureCount = Math.ceil(header.shCoefficientCount / 16); // 4 components can be stored per texture, 4 sh per component\n            let shIndexRead = 0;\n            const ubuf = new Uint8Array(header.shBuffer);\n            // sh is an array of uint8array that will be used to create sh textures\n            sh = [];\n            const splatCount = header.vertexCount;\n            const engine = EngineStore.LastCreatedEngine;\n            if (engine) {\n                const width = engine.getCaps().maxTextureSize;\n                const height = Math.ceil(splatCount / width);\n                // create array for the number of textures needed.\n                for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n                    const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n                    sh.push(texture);\n                }\n                for (let i = 0; i < splatCount; i++) {\n                    for (let shIndexWrite = 0; shIndexWrite < header.shCoefficientCount; shIndexWrite++) {\n                        const shValue = ubuf[shIndexRead++];\n                        const textureIndex = Math.floor(shIndexWrite / 16);\n                        const shArray = sh[textureIndex];\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                        shArray[byteIndexInTexture + offsetPerSplat] = shValue;\n                    }\n                }\n            }\n        }\n        return { buffer: header.buffer, sh: sh };\n    }\n    /**\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @param useCoroutine use coroutine and yield\n     * @returns the loaded splat buffer without SH coefficient, whether ply contains or not SH.\n     */\n    static *ConvertPLYToSplat(data, useCoroutine = false) {\n        const header = GaussianSplattingMesh.ParseHeader(data);\n        if (!header) {\n            return data;\n        }\n        const offset = { value: 0 };\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\n        for (let i = 0; i < header.vertexCount; i++) {\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\n                yield;\n            }\n        }\n        return header.buffer;\n    }\n    /**\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer\n     */\n    static async ConvertPLYToSplatAsync(data) {\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYToSplat(data, true), createYieldingScheduler());\n    }\n    /**\n     * Converts a .ply with SH data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer with SH\n     */\n    static async ConvertPLYWithSHToSplatAsync(data) {\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYWithSHToSplat(data, true), createYieldingScheduler());\n    }\n    /**\n     * Loads a .splat Gaussian Splatting array buffer asynchronously\n     * @param data arraybuffer containing splat file\n     * @returns a promise that resolves when the operation is complete\n     */\n    async loadDataAsync(data) {\n        return await this.updateDataAsync(data);\n    }\n    /**\n     * Loads a .splat Gaussian or .ply Splatting file asynchronously\n     * @param url path to the splat file to load\n     * @returns a promise that resolves when the operation is complete\n     * @deprecated Please use SceneLoader.ImportMeshAsync instead\n     */\n    async loadFileAsync(url) {\n        const plyBuffer = await Tools.LoadFileAsync(url, true);\n        const splatsData = await GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(plyBuffer);\n        await this.updateDataAsync(splatsData.buffer, splatsData.sh);\n    }\n    /**\n     * Releases resources associated with this mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     */\n    dispose(doNotRecurse) {\n        this._covariancesATexture?.dispose();\n        this._covariancesBTexture?.dispose();\n        this._centersTexture?.dispose();\n        this._colorsTexture?.dispose();\n        if (this._shTextures) {\n            for (const shTexture of this._shTextures) {\n                shTexture.dispose();\n            }\n        }\n        this._covariancesATexture = null;\n        this._covariancesBTexture = null;\n        this._centersTexture = null;\n        this._colorsTexture = null;\n        this._shTextures = null;\n        this._worker?.terminate();\n        this._worker = null;\n        super.dispose(doNotRecurse, true);\n    }\n    _copyTextures(source) {\n        this._covariancesATexture = source.covariancesATexture?.clone();\n        this._covariancesBTexture = source.covariancesBTexture?.clone();\n        this._centersTexture = source.centersTexture?.clone();\n        this._colorsTexture = source.colorsTexture?.clone();\n        if (source._shTextures) {\n            this._shTextures = [];\n            for (const shTexture of this._shTextures) {\n                this._shTextures?.push(shTexture.clone());\n            }\n        }\n    }\n    /**\n     * Returns a new Mesh object generated from the current mesh properties.\n     * @param name is a string, the name given to the new mesh\n     * @returns a new Gaussian Splatting Mesh\n     */\n    clone(name = \"\") {\n        const newGS = new GaussianSplattingMesh(name, undefined, this.getScene());\n        newGS._copySource(this);\n        newGS.makeGeometryUnique();\n        newGS._vertexCount = this._vertexCount;\n        newGS._copyTextures(this);\n        newGS._modelViewMatrix = Matrix.Identity();\n        newGS._splatPositions = this._splatPositions;\n        newGS._readyToDisplay = false;\n        newGS._instanciateWorker();\n        const binfo = this.getBoundingInfo();\n        newGS.getBoundingInfo().reConstruct(binfo.minimum, binfo.maximum, this.getWorldMatrix());\n        newGS.forcedInstanceCount = newGS._vertexCount;\n        newGS.setEnabled(true);\n        return newGS;\n    }\n    _makeSplat(index, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum) {\n        const matrixRotation = TmpVectors.Matrix[0];\n        const matrixScale = TmpVectors.Matrix[1];\n        const quaternion = TmpVectors.Quaternion[0];\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\n        const x = fBuffer[8 * index + 0];\n        const y = -fBuffer[8 * index + 1];\n        const z = fBuffer[8 * index + 2];\n        this._splatPositions[4 * index + 0] = x;\n        this._splatPositions[4 * index + 1] = y;\n        this._splatPositions[4 * index + 2] = z;\n        minimum.minimizeInPlaceFromFloats(x, y, z);\n        maximum.maximizeInPlaceFromFloats(x, y, z);\n        quaternion.set((uBuffer[32 * index + 28 + 1] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5, -(uBuffer[32 * index + 28 + 0] - 127.5) / 127.5);\n        quaternion.toRotationMatrix(matrixRotation);\n        Matrix.ScalingToRef(fBuffer[8 * index + 3 + 0] * 2, fBuffer[8 * index + 3 + 1] * 2, fBuffer[8 * index + 3 + 2] * 2, matrixScale);\n        const m = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;\n        const covariances = this._tmpCovariances;\n        covariances[0] = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];\n        covariances[1] = m[0] * m[4] + m[1] * m[5] + m[2] * m[6];\n        covariances[2] = m[0] * m[8] + m[1] * m[9] + m[2] * m[10];\n        covariances[3] = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];\n        covariances[4] = m[4] * m[8] + m[5] * m[9] + m[6] * m[10];\n        covariances[5] = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];\n        // normalize covA, covB\n        let factor = -10000;\n        for (let covIndex = 0; covIndex < 6; covIndex++) {\n            factor = Math.max(factor, Math.abs(covariances[covIndex]));\n        }\n        this._splatPositions[4 * index + 3] = factor;\n        const transform = factor;\n        covA[index * 4 + 0] = ToHalfFloat(covariances[0] / transform);\n        covA[index * 4 + 1] = ToHalfFloat(covariances[1] / transform);\n        covA[index * 4 + 2] = ToHalfFloat(covariances[2] / transform);\n        covA[index * 4 + 3] = ToHalfFloat(covariances[3] / transform);\n        covB[index * covBSItemSize + 0] = ToHalfFloat(covariances[4] / transform);\n        covB[index * covBSItemSize + 1] = ToHalfFloat(covariances[5] / transform);\n        // colors\n        colorArray[index * 4 + 0] = uBuffer[32 * index + 24 + 0];\n        colorArray[index * 4 + 1] = uBuffer[32 * index + 24 + 1];\n        colorArray[index * 4 + 2] = uBuffer[32 * index + 24 + 2];\n        colorArray[index * 4 + 3] = uBuffer[32 * index + 24 + 3];\n    }\n    _updateTextures(covA, covB, colorArray, sh) {\n        const textureSize = this._getTextureSize(this._vertexCount);\n        // Update the textures\n        const createTextureFromData = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n        };\n        const createTextureFromDataU8 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_BYTE);\n        };\n        const createTextureFromDataU32 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_INTEGER);\n        };\n        const createTextureFromDataF16 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_HALF_FLOAT);\n        };\n        if (this._covariancesATexture) {\n            this._delayedTextureUpdate = { covA: covA, covB: covB, colors: colorArray, centers: this._splatPositions, sh: sh };\n            const positions = Float32Array.from(this._splatPositions);\n            const vertexCount = this._vertexCount;\n            this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n            this._postToWorker(true);\n        }\n        else {\n            this._covariancesATexture = createTextureFromDataF16(covA, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            this._covariancesBTexture = createTextureFromDataF16(covB, textureSize.x, textureSize.y, this._useRGBACovariants ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_RG);\n            this._centersTexture = createTextureFromData(this._splatPositions, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            this._colorsTexture = createTextureFromDataU8(colorArray, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            if (sh) {\n                this._shTextures = [];\n                for (const shData of sh) {\n                    const buffer = new Uint32Array(shData.buffer);\n                    const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA_INTEGER);\n                    shTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    shTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    this._shTextures.push(shTexture);\n                }\n            }\n            this._instanciateWorker();\n        }\n    }\n    *_updateData(data, isAsync, sh) {\n        // if a covariance texture is present, then it's not a creation but an update\n        if (!this._covariancesATexture) {\n            this._readyToDisplay = false;\n        }\n        // Parse the data\n        const uBuffer = new Uint8Array(data);\n        const fBuffer = new Float32Array(uBuffer.buffer);\n        if (this._keepInRam) {\n            this._splatsData = data;\n            if (sh) {\n                this._sh = sh;\n            }\n        }\n        const vertexCount = uBuffer.length / GaussianSplattingMesh._RowOutputLength;\n        if (vertexCount != this._vertexCount) {\n            this._updateSplatIndexBuffer(vertexCount);\n        }\n        this._vertexCount = vertexCount;\n        // degree == 1 for 1 texture (3 terms), 2 for 2 textures(8 terms) and 3 for 3 textures (15 terms)\n        this._shDegree = sh ? sh.length : 0;\n        const textureSize = this._getTextureSize(vertexCount);\n        const textureLength = textureSize.x * textureSize.y;\n        const lineCountUpdate = GaussianSplattingMesh.ProgressiveUpdateAmount ?? textureSize.y;\n        const textureLengthPerUpdate = textureSize.x * lineCountUpdate;\n        this._splatPositions = new Float32Array(4 * textureLength);\n        const covA = new Uint16Array(textureLength * 4);\n        const covB = new Uint16Array((this._useRGBACovariants ? 4 : 2) * textureLength);\n        const colorArray = new Uint8Array(textureLength * 4);\n        const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        if (GaussianSplattingMesh.ProgressiveUpdateAmount) {\n            // create textures with not filled-yet array, then update directly portions of it\n            this._updateTextures(covA, covB, colorArray, sh);\n            this.setEnabled(true);\n            const partCount = Math.ceil(textureSize.y / lineCountUpdate);\n            for (let partIndex = 0; partIndex < partCount; partIndex++) {\n                const updateLine = partIndex * lineCountUpdate;\n                const splatIndexBase = updateLine * textureSize.x;\n                for (let i = 0; i < textureLengthPerUpdate; i++) {\n                    this._makeSplat(splatIndexBase + i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\n                }\n                this._updateSubTextures(this._splatPositions, covA, covB, colorArray, updateLine, Math.min(lineCountUpdate, textureSize.y - updateLine));\n                // Update the binfo\n                this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\n                if (isAsync) {\n                    yield;\n                }\n            }\n            // sort will be dirty here as just finished filled positions will not be sorted\n            const positions = Float32Array.from(this._splatPositions);\n            const vertexCount = this._vertexCount;\n            this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n            this._sortIsDirty = true;\n        }\n        else {\n            for (let i = 0; i < vertexCount; i++) {\n                this._makeSplat(i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\n                if (isAsync && i % GaussianSplattingMesh._SplatBatchSize === 0) {\n                    yield;\n                }\n            }\n            // textures\n            this._updateTextures(covA, covB, colorArray, sh);\n            // Update the binfo\n            this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\n            this.setEnabled(true);\n        }\n        this._postToWorker(true);\n    }\n    /**\n     * Update asynchronously the buffer\n     * @param data array buffer containing center, color, orientation and scale of splats\n     * @param sh optional array of uint8 array for SH data\n     * @returns a promise\n     */\n    async updateDataAsync(data, sh) {\n        return await runCoroutineAsync(this._updateData(data, true, sh), createYieldingScheduler());\n    }\n    /**\n     * @experimental\n     * Update data from GS (position, orientation, color, scaling)\n     * @param data array that contain all the datas\n     * @param sh optional array of uint8 array for SH data\n     */\n    updateData(data, sh) {\n        runCoroutineSync(this._updateData(data, false, sh));\n    }\n    /**\n     * Refreshes the bounding info, taking into account all the thin instances defined\n     * @returns the current Gaussian Splatting\n     */\n    refreshBoundingInfo() {\n        this.thinInstanceRefreshBoundingInfo(false);\n        return this;\n    }\n    // in case size is different\n    _updateSplatIndexBuffer(vertexCount) {\n        if (!this._splatIndex || vertexCount > this._splatIndex.length) {\n            this._splatIndex = new Float32Array(vertexCount);\n            this.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 1, false);\n        }\n        this.forcedInstanceCount = vertexCount;\n    }\n    _updateSubTextures(centers, covA, covB, colors, lineStart, lineCount, sh) {\n        const updateTextureFromData = (texture, data, width, lineStart, lineCount) => {\n            this.getEngine().updateTextureData(texture.getInternalTexture(), data, 0, lineStart, width, lineCount, 0, 0, false);\n        };\n        const textureSize = this._getTextureSize(this._vertexCount);\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\n        const texelStart = lineStart * textureSize.x;\n        const texelCount = lineCount * textureSize.x;\n        const covAView = new Uint16Array(covA.buffer, texelStart * 4 * Uint16Array.BYTES_PER_ELEMENT, texelCount * 4);\n        const covBView = new Uint16Array(covB.buffer, texelStart * covBSItemSize * Uint16Array.BYTES_PER_ELEMENT, texelCount * covBSItemSize);\n        const colorsView = new Uint8Array(colors.buffer, texelStart * 4, texelCount * 4);\n        const centersView = new Float32Array(centers.buffer, texelStart * 4 * Float32Array.BYTES_PER_ELEMENT, texelCount * 4);\n        updateTextureFromData(this._covariancesATexture, covAView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._covariancesBTexture, covBView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._centersTexture, centersView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._colorsTexture, colorsView, textureSize.x, lineStart, lineCount);\n        if (sh) {\n            for (let i = 0; i < sh.length; i++) {\n                const componentCount = 4;\n                const shView = new Uint8Array(this._sh[i].buffer, texelStart * componentCount, texelCount * componentCount);\n                updateTextureFromData(this._shTextures[i], shView, textureSize.x, lineStart, lineCount);\n            }\n        }\n    }\n    _instanciateWorker() {\n        if (!this._vertexCount) {\n            return;\n        }\n        this._updateSplatIndexBuffer(this._vertexCount);\n        // Start the worker thread\n        this._worker?.terminate();\n        this._worker = new Worker(URL.createObjectURL(new Blob([\"(\", GaussianSplattingMesh._CreateWorker.toString(), \")(self)\"], {\n            type: \"application/javascript\",\n        })));\n        this._depthMix = new BigInt64Array(this._vertexCount);\n        const positions = Float32Array.from(this._splatPositions);\n        const vertexCount = this._vertexCount;\n        this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n        this._worker.onmessage = (e) => {\n            this._depthMix = e.data.depthMix;\n            const indexMix = new Uint32Array(e.data.depthMix.buffer);\n            if (this._splatIndex) {\n                for (let j = 0; j < this._vertexCount; j++) {\n                    this._splatIndex[j] = indexMix[2 * j];\n                }\n            }\n            if (this._delayedTextureUpdate) {\n                const textureSize = this._getTextureSize(vertexCount);\n                this._updateSubTextures(this._delayedTextureUpdate.centers, this._delayedTextureUpdate.covA, this._delayedTextureUpdate.covB, this._delayedTextureUpdate.colors, 0, textureSize.y, this._delayedTextureUpdate.sh);\n                this._delayedTextureUpdate = null;\n            }\n            this.thinInstanceBufferUpdated(\"splatIndex\");\n            this._canPostToWorker = true;\n            this._readyToDisplay = true;\n            // sort is dirty when GS is visible for progressive update with a this message arriving but positions were partially filled\n            // another update needs to be kicked. The kick can't happen just when the position buffer is ready because _canPostToWorker might be false.\n            if (this._sortIsDirty) {\n                this._postToWorker(true);\n                this._sortIsDirty = false;\n            }\n        };\n    }\n    _getTextureSize(length) {\n        const engine = this._scene.getEngine();\n        const width = engine.getCaps().maxTextureSize;\n        let height = 1;\n        if (engine.version === 1 && !engine.isWebGPU) {\n            while (width * height < length) {\n                height *= 2;\n            }\n        }\n        else {\n            height = Math.ceil(length / width);\n        }\n        if (height > width) {\n            Logger.Error(\"GaussianSplatting texture size: (\" + width + \", \" + height + \"), maxTextureSize: \" + width);\n            height = width;\n        }\n        return new Vector2(width, height);\n    }\n}\nGaussianSplattingMesh._RowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // Vector3 position, Vector3 scale, 1 u8 quaternion, 1 color with alpha\nGaussianSplattingMesh._SH_C0 = 0.28209479177387814;\n// batch size between 2 yield calls. This value is a tradeoff between updates overhead and framerate hiccups\n// This step is faster the PLY conversion. So batch size can be bigger\nGaussianSplattingMesh._SplatBatchSize = 327680;\n// batch size between 2 yield calls during the PLY to splat conversion.\nGaussianSplattingMesh._PlyConversionBatchSize = 32768;\n/**\n * Set the number of batch (a batch is 16384 splats) after which a display update is performed\n * A value of 0 (default) means display update will not happens before splat is ready.\n */\nGaussianSplattingMesh.ProgressiveUpdateAmount = 0;\nGaussianSplattingMesh._CreateWorker = function (self) {\n    let vertexCount = 0;\n    let positions;\n    let depthMix;\n    let indices;\n    let floatMix;\n    self.onmessage = (e) => {\n        // updated on init\n        if (e.data.positions) {\n            positions = e.data.positions;\n            vertexCount = e.data.vertexCount;\n        }\n        // udpate on view changed\n        else {\n            const viewProj = e.data.view;\n            if (!positions || !viewProj) {\n                // Sanity check, it shouldn't happen!\n                throw new Error(\"positions or view is not defined!\");\n            }\n            depthMix = e.data.depthMix;\n            indices = new Uint32Array(depthMix.buffer);\n            floatMix = new Float32Array(depthMix.buffer);\n            // Sort\n            for (let j = 0; j < vertexCount; j++) {\n                indices[2 * j] = j;\n            }\n            let depthFactor = -1;\n            if (e.data.useRightHandedSystem) {\n                depthFactor = 1;\n            }\n            for (let j = 0; j < vertexCount; j++) {\n                floatMix[2 * j + 1] = 10000 + (viewProj[2] * positions[4 * j + 0] + viewProj[6] * positions[4 * j + 1] + viewProj[10] * positions[4 * j + 2]) * depthFactor;\n            }\n            depthMix.sort();\n            self.postMessage({ depthMix }, [depthMix.buffer]);\n        }\n    };\n};\n//# sourceMappingURL=gaussianSplattingMesh.js.map","import { Color4, Color3 } from \"../Maths/math\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { VertexBuffer } from \"../Buffers/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\nimport { Ray } from \"../Culling/ray\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\nimport { RandomRange } from \"../Maths/math.scalar.functions\";\n/** Defines the 4 color options */\nexport var PointColor;\n(function (PointColor) {\n    /** color value */\n    PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n    /** uv value */\n    PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n    /** random value */\n    PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n    /** stated value */\n    PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : TO BE ENTERED\n */\nexport class PointsCloudSystem {\n    /**\n     * Gets the particle positions computed by the Point Cloud System\n     */\n    get positions() {\n        return this._positions32;\n    }\n    /**\n     * Gets the particle colors computed by the Point Cloud System\n     */\n    get colors() {\n        return this._colors32;\n    }\n    /**\n     * Gets the particle uvs computed by the Point Cloud System\n     */\n    get uvs() {\n        return this._uvs32;\n    }\n    /**\n     * Creates a PCS (Points Cloud System) object\n     * @param name (String) is the PCS name, this will be the underlying mesh name\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\n     * @param scene (Scene) is the scene in which the PCS is added\n     * @param options defines the options of the PCS e.g.\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\n     */\n    constructor(name, pointSize, scene, options) {\n        /**\n         *  The PCS array of cloud point objects. Just access each particle as with any classic array.\n         *  Example : var p = SPS.particles[i];\n         */\n        this.particles = new Array();\n        /**\n         * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\n         */\n        this.nbParticles = 0;\n        /**\n         * This a counter for your own usage. It's not set by any SPS functions.\n         */\n        this.counter = 0;\n        /**\n         * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\n         * Please read :\n         */\n        this.vars = {};\n        this._promises = [];\n        this._positions = new Array();\n        this._indices = new Array();\n        this._normals = new Array();\n        this._colors = new Array();\n        this._uvs = new Array();\n        this._updatable = true;\n        this._isVisibilityBoxLocked = false;\n        this._alwaysVisible = false;\n        this._groups = new Array(); //start indices for each group of particles\n        this._groupCounter = 0;\n        this._computeParticleColor = true;\n        this._computeParticleTexture = true;\n        this._computeParticleRotation = true;\n        this._computeBoundingBox = false;\n        this._isReady = false;\n        this.name = name;\n        this._size = pointSize;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        if (options && options.updatable !== undefined) {\n            this._updatable = options.updatable;\n        }\n        else {\n            this._updatable = true;\n        }\n    }\n    /**\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\n     * If no points were added to the PCS, the returned mesh is just a single point.\n     * @param material The material to use to render the mesh. If not provided, will create a default one\n     * @returns a promise for the created mesh\n     */\n    async buildMeshAsync(material) {\n        await Promise.all(this._promises);\n        this._isReady = true;\n        return await this._buildMeshAsync(material);\n    }\n    async _buildMeshAsync(material) {\n        if (this.nbParticles === 0) {\n            this.addPoints(1);\n        }\n        this._positions32 = new Float32Array(this._positions);\n        this._uvs32 = new Float32Array(this._uvs);\n        this._colors32 = new Float32Array(this._colors);\n        const vertexData = new VertexData();\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\n        if (this._uvs32.length > 0) {\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\n        }\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\n        if (this._colors32.length > 0) {\n            ec = 1;\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\n        }\n        const mesh = new Mesh(this.name, this._scene);\n        vertexData.applyToMesh(mesh, this._updatable);\n        this.mesh = mesh;\n        // free memory\n        this._positions = null;\n        this._uvs = null;\n        this._colors = null;\n        if (!this._updatable) {\n            this.particles.length = 0;\n        }\n        let mat = material;\n        if (!mat) {\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\n            mat.emissiveColor = new Color3(ec, ec, ec);\n            mat.disableLighting = true;\n            mat.pointsCloud = true;\n            mat.pointSize = this._size;\n        }\n        mesh.material = mat;\n        return mesh;\n    }\n    // adds a new particle object in the particles array\n    _addParticle(idx, group, groupId, idxInGroup) {\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n        this.particles.push(cp);\n        return cp;\n    }\n    _randomUnitVector(particle) {\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n        particle.color = new Color4(1, 1, 1, 1);\n    }\n    _getColorIndicesForCoord(pointsGroup, x, y, width) {\n        const imageData = pointsGroup._groupImageData;\n        const color = y * (width * 4) + x * 4;\n        const colorIndices = [color, color + 1, color + 2, color + 3];\n        const redIndex = colorIndices[0];\n        const greenIndex = colorIndices[1];\n        const blueIndex = colorIndices[2];\n        const alphaIndex = colorIndices[3];\n        const redForCoord = imageData[redIndex];\n        const greenForCoord = imageData[greenIndex];\n        const blueForCoord = imageData[blueIndex];\n        const alphaForCoord = imageData[alphaIndex];\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n    }\n    _setPointsColorOrUV(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range, uvSetIndex) {\n        uvSetIndex = uvSetIndex ?? 0;\n        if (isVolume) {\n            mesh.updateFacetData();\n        }\n        const boundInfo = mesh.getBoundingInfo();\n        const diameter = 2 * boundInfo.boundingSphere.radius;\n        let meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        const meshUV = mesh.getVerticesData(VertexBuffer.UVKind + (uvSetIndex ? uvSetIndex + 1 : \"\"));\n        const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n        const place = Vector3.Zero();\n        mesh.computeWorldMatrix();\n        const meshMatrix = mesh.getWorldMatrix();\n        if (!meshMatrix.isIdentity()) {\n            meshPos = meshPos.slice(0);\n            for (let p = 0; p < meshPos.length / 3; p++) {\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n                meshPos[3 * p] = place.x;\n                meshPos[3 * p + 1] = place.y;\n                meshPos[3 * p + 2] = place.z;\n            }\n        }\n        let idxPoints = 0;\n        let id0 = 0;\n        let id1 = 0;\n        let id2 = 0;\n        let v0X = 0;\n        let v0Y = 0;\n        let v0Z = 0;\n        let v1X = 0;\n        let v1Y = 0;\n        let v1Z = 0;\n        let v2X = 0;\n        let v2Y = 0;\n        let v2Z = 0;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        let uv0X = 0;\n        let uv0Y = 0;\n        let uv1X = 0;\n        let uv1Y = 0;\n        let uv2X = 0;\n        let uv2Y = 0;\n        const uv0 = Vector2.Zero();\n        const uv1 = Vector2.Zero();\n        const uv2 = Vector2.Zero();\n        const uvec0 = Vector2.Zero();\n        const uvec1 = Vector2.Zero();\n        let col0X = 0;\n        let col0Y = 0;\n        let col0Z = 0;\n        let col0A = 0;\n        let col1X = 0;\n        let col1Y = 0;\n        let col1Z = 0;\n        let col1A = 0;\n        let col2X = 0;\n        let col2Y = 0;\n        let col2Z = 0;\n        let col2A = 0;\n        const col0 = Vector4.Zero();\n        const col1 = Vector4.Zero();\n        const col2 = Vector4.Zero();\n        const colvec0 = Vector4.Zero();\n        const colvec1 = Vector4.Zero();\n        let lamda = 0;\n        let mu = 0;\n        range = range ? range : 0;\n        let facetPoint;\n        let uvPoint;\n        let colPoint = new Vector4(0, 0, 0, 0);\n        let norm = Vector3.Zero();\n        let tang = Vector3.Zero();\n        let biNorm = Vector3.Zero();\n        let angle = 0;\n        let facetPlaneVec = Vector3.Zero();\n        let gap = 0;\n        let distance = 0;\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n        let pickInfo;\n        let direction = Vector3.Zero();\n        for (let index = 0; index < meshInd.length / 3; index++) {\n            id0 = meshInd[3 * index];\n            id1 = meshInd[3 * index + 1];\n            id2 = meshInd[3 * index + 2];\n            v0X = meshPos[3 * id0];\n            v0Y = meshPos[3 * id0 + 1];\n            v0Z = meshPos[3 * id0 + 2];\n            v1X = meshPos[3 * id1];\n            v1Y = meshPos[3 * id1 + 1];\n            v1Z = meshPos[3 * id1 + 2];\n            v2X = meshPos[3 * id2];\n            v2Y = meshPos[3 * id2 + 1];\n            v2Z = meshPos[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            if (meshUV) {\n                uv0X = meshUV[2 * id0];\n                uv0Y = meshUV[2 * id0 + 1];\n                uv1X = meshUV[2 * id1];\n                uv1Y = meshUV[2 * id1 + 1];\n                uv2X = meshUV[2 * id2];\n                uv2Y = meshUV[2 * id2 + 1];\n                uv0.set(uv0X, uv0Y);\n                uv1.set(uv1X, uv1Y);\n                uv2.set(uv2X, uv2Y);\n                uv1.subtractToRef(uv0, uvec0);\n                uv2.subtractToRef(uv1, uvec1);\n            }\n            if (meshCol && colorFromTexture) {\n                col0X = meshCol[4 * id0];\n                col0Y = meshCol[4 * id0 + 1];\n                col0Z = meshCol[4 * id0 + 2];\n                col0A = meshCol[4 * id0 + 3];\n                col1X = meshCol[4 * id1];\n                col1Y = meshCol[4 * id1 + 1];\n                col1Z = meshCol[4 * id1 + 2];\n                col1A = meshCol[4 * id1 + 3];\n                col2X = meshCol[4 * id2];\n                col2Y = meshCol[4 * id2 + 1];\n                col2Z = meshCol[4 * id2 + 2];\n                col2A = meshCol[4 * id2 + 3];\n                col0.set(col0X, col0Y, col0Z, col0A);\n                col1.set(col1X, col1Y, col1Z, col1A);\n                col2.set(col2X, col2Y, col2Z, col2A);\n                col1.subtractToRef(col0, colvec0);\n                col2.subtractToRef(col1, colvec1);\n            }\n            let width;\n            let height;\n            let deltaS;\n            let deltaV;\n            let h;\n            let s;\n            let v;\n            let hsvCol;\n            const statedColor = new Color3(0, 0, 0);\n            const colPoint3 = new Color3(0, 0, 0);\n            let pointColors;\n            let particle;\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\n                idxPoints = this.particles.length;\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n                particle = this.particles[idxPoints];\n                //form a point inside the facet v0, v1, v2;\n                lamda = Math.sqrt(RandomRange(0, 1));\n                mu = RandomRange(0, 1);\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n                if (isVolume) {\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\n                    tang = vec0.clone().normalize();\n                    biNorm = Vector3.Cross(norm, tang);\n                    angle = RandomRange(0, 2 * Math.PI);\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n                    angle = RandomRange(0.1, Math.PI / 2);\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\n                    ray.direction = direction;\n                    ray.length = diameter;\n                    pickInfo = ray.intersectsMesh(mesh);\n                    if (pickInfo.hit) {\n                        distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n                        gap = RandomRange(0, 1) * distance;\n                        facetPoint.addInPlace(direction.scale(gap));\n                    }\n                }\n                particle.position = facetPoint.clone();\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n                if (colorFromTexture !== undefined) {\n                    if (meshUV) {\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n                        if (colorFromTexture) {\n                            //Set particle color to texture color\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\n                                width = pointsGroup._groupImgWidth;\n                                height = pointsGroup._groupImgHeight;\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                                particle.color = pointColors;\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n                            }\n                            else {\n                                if (meshCol) {\n                                    //failure in texture and colors available\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                                else {\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                            }\n                        }\n                        else {\n                            //Set particle uv based on a mesh uv\n                            particle.uv = uvPoint.clone();\n                            this._uvs.push(particle.uv.x, particle.uv.y);\n                        }\n                    }\n                }\n                else {\n                    if (color) {\n                        statedColor.set(color.r, color.g, color.b);\n                        deltaS = RandomRange(-range, range);\n                        deltaV = RandomRange(-range, range);\n                        hsvCol = statedColor.toHSV();\n                        h = hsvCol.r;\n                        s = hsvCol.g + deltaS;\n                        v = hsvCol.b + deltaV;\n                        if (s < 0) {\n                            s = 0;\n                        }\n                        if (s > 1) {\n                            s = 1;\n                        }\n                        if (v < 0) {\n                            v = 0;\n                        }\n                        if (v > 1) {\n                            v = 1;\n                        }\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n                    }\n                    else {\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                    }\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n            }\n        }\n    }\n    // stores mesh texture in dynamic texture for color pixel retrieval\n    // when pointColor type is color for surface points\n    _colorFromTexture(mesh, pointsGroup, isVolume) {\n        if (mesh.material === null) {\n            Logger.Warn(mesh.name + \"has no material.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const mat = mesh.material;\n        const textureList = mat.getActiveTextures();\n        if (textureList.length === 0) {\n            Logger.Warn(mesh.name + \"has no usable texture.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const clone = mesh.clone();\n        clone.setEnabled(false);\n        this._promises.push(new Promise((resolve) => {\n            BaseTexture.WhenAllReady(textureList, () => {\n                let n = pointsGroup._textureNb;\n                if (n < 0) {\n                    n = 0;\n                }\n                if (n > textureList.length - 1) {\n                    n = textureList.length - 1;\n                }\n                const finalize = () => {\n                    pointsGroup._groupImgWidth = textureList[n].getSize().width;\n                    pointsGroup._groupImgHeight = textureList[n].getSize().height;\n                    this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true, undefined, undefined, textureList[n].coordinatesIndex);\n                    clone.dispose();\n                    resolve();\n                };\n                pointsGroup._groupImageData = null;\n                const dataPromise = textureList[n].readPixels();\n                if (!dataPromise) {\n                    finalize();\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                    dataPromise.then((data) => {\n                        pointsGroup._groupImageData = data;\n                        finalize();\n                    });\n                }\n            });\n        }));\n    }\n    // calculates the point density per facet of a mesh for surface points\n    _calculateDensity(nbPoints, positions, indices) {\n        let id0;\n        let id1;\n        let id2;\n        let v0X;\n        let v0Y;\n        let v0Z;\n        let v1X;\n        let v1Y;\n        let v1Z;\n        let v2X;\n        let v2Y;\n        let v2Z;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        const normal = Vector3.Zero();\n        let area;\n        const cumulativeAreas = [];\n        let surfaceArea = 0;\n        const nbFacets = indices.length / 3;\n        //surface area\n        for (let index = 0; index < nbFacets; index++) {\n            id0 = indices[3 * index];\n            id1 = indices[3 * index + 1];\n            id2 = indices[3 * index + 2];\n            v0X = positions[3 * id0];\n            v0Y = positions[3 * id0 + 1];\n            v0Z = positions[3 * id0 + 2];\n            v1X = positions[3 * id1];\n            v1Y = positions[3 * id1 + 1];\n            v1Z = positions[3 * id1 + 2];\n            v2X = positions[3 * id2];\n            v2Y = positions[3 * id2 + 1];\n            v2Z = positions[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            Vector3.CrossToRef(vec0, vec1, normal);\n            area = 0.5 * normal.length();\n            surfaceArea += area;\n            cumulativeAreas[index] = surfaceArea;\n        }\n        const density = new Array(nbFacets);\n        let remainingPoints = nbPoints;\n        for (let index = nbFacets - 1; index > 0; index--) {\n            const cumulativeArea = cumulativeAreas[index];\n            if (cumulativeArea === 0) {\n                // avoiding division by 0 upon degenerate triangles\n                density[index] = 0;\n            }\n            else {\n                const area = cumulativeArea - cumulativeAreas[index - 1];\n                const facetPointsWithFraction = (area / cumulativeArea) * remainingPoints;\n                const floored = Math.floor(facetPointsWithFraction);\n                const fraction = facetPointsWithFraction - floored;\n                const extraPoint = Number(Math.random() < fraction);\n                const facetPoints = floored + extraPoint;\n                density[index] = facetPoints;\n                remainingPoints -= facetPoints;\n            }\n        }\n        density[0] = remainingPoints;\n        return density;\n    }\n    /**\n     * Adds points to the PCS in random positions within a unit sphere\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\n     * @returns the number of groups in the system\n     */\n    addPoints(nb, pointFunction = this._randomUnitVector) {\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n        let cp;\n        // particles\n        let idx = this.nbParticles;\n        for (let i = 0; i < nb; i++) {\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n            if (pointsGroup && pointsGroup._positionFunction) {\n                pointsGroup._positionFunction(cp, idx, i);\n            }\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n            if (cp.color) {\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n            }\n            if (cp.uv) {\n                this._uvs.push(cp.uv.x, cp.uv.y);\n            }\n            idx++;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter;\n    }\n    /**\n     * Adds points to the PCS from the surface of the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addSurfacePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : 0 /* PointColor.Random */;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = 0 /* PointColor.Random */;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === 2 /* PointColor.Color */) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case 2 /* PointColor.Color */:\n                this._colorFromTexture(mesh, pointsGroup, false);\n                break;\n            case 1 /* PointColor.UV */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n                break;\n            case 0 /* PointColor.Random */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\n                break;\n            case 3 /* PointColor.Stated */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     * Adds points to the PCS inside the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addVolumePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : 0 /* PointColor.Random */;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = 0 /* PointColor.Random */;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === 2 /* PointColor.Color */) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case 2 /* PointColor.Color */:\n                this._colorFromTexture(mesh, pointsGroup, true);\n                break;\n            case 1 /* PointColor.UV */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n                break;\n            case 0 /* PointColor.Random */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\n                break;\n            case 3 /* PointColor.Stated */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n     *  This method calls `updateParticle()` for each particle of the SPS.\n     *  For an animated SPS, it is usually called within the render loop.\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n     * @returns the PCS.\n     */\n    setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n        if (!this._updatable || !this._isReady) {\n            return this;\n        }\n        // custom beforeUpdate\n        this.beforeUpdateParticles(start, end, update);\n        const rotMatrix = TmpVectors.Matrix[0];\n        const mesh = this.mesh;\n        const colors32 = this._colors32;\n        const positions32 = this._positions32;\n        const uvs32 = this._uvs32;\n        const tempVectors = TmpVectors.Vector3;\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n        Matrix.IdentityToRef(rotMatrix);\n        let idx = 0; // current index of the particle\n        if (this.mesh?.isFacetDataEnabled) {\n            this._computeBoundingBox = true;\n        }\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n        if (this._computeBoundingBox) {\n            if (start != 0 || end != this.nbParticles - 1) {\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n                const boundingInfo = this.mesh?.getBoundingInfo();\n                if (boundingInfo) {\n                    minimum.copyFrom(boundingInfo.minimum);\n                    maximum.copyFrom(boundingInfo.maximum);\n                }\n            }\n        }\n        idx = 0; // particle index\n        let pindex = 0; //index in positions array\n        let cindex = 0; //index in color array\n        let uindex = 0; //index in uv array\n        // particle loop\n        for (let p = start; p <= end; p++) {\n            const particle = this.particles[p];\n            idx = particle.idx;\n            pindex = 3 * idx;\n            cindex = 4 * idx;\n            uindex = 2 * idx;\n            // call to custom user function to update the particle properties\n            this.updateParticle(particle);\n            const particleRotationMatrix = particle._rotationMatrix;\n            const particlePosition = particle.position;\n            const particleGlobalPosition = particle._globalPosition;\n            if (this._computeParticleRotation) {\n                particle.getRotationMatrix(rotMatrix);\n            }\n            const particleHasParent = particle.parentId !== null;\n            if (particleHasParent) {\n                const parent = this.particles[particle.parentId];\n                const parentRotationMatrix = parent._rotationMatrix;\n                const parentGlobalPosition = parent._globalPosition;\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] =\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n                    particleRotationMatrix[1] =\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n                    particleRotationMatrix[2] =\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n                    particleRotationMatrix[3] =\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n                    particleRotationMatrix[4] =\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n                    particleRotationMatrix[5] =\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n                    particleRotationMatrix[6] =\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n                    particleRotationMatrix[7] =\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n                    particleRotationMatrix[8] =\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n                }\n            }\n            else {\n                particleGlobalPosition.x = 0;\n                particleGlobalPosition.y = 0;\n                particleGlobalPosition.z = 0;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] = rotMatrixValues[0];\n                    particleRotationMatrix[1] = rotMatrixValues[1];\n                    particleRotationMatrix[2] = rotMatrixValues[2];\n                    particleRotationMatrix[3] = rotMatrixValues[4];\n                    particleRotationMatrix[4] = rotMatrixValues[5];\n                    particleRotationMatrix[5] = rotMatrixValues[6];\n                    particleRotationMatrix[6] = rotMatrixValues[8];\n                    particleRotationMatrix[7] = rotMatrixValues[9];\n                    particleRotationMatrix[8] = rotMatrixValues[10];\n                }\n            }\n            const pivotBackTranslation = tempVectors[11];\n            if (particle.translateFromPivot) {\n                pivotBackTranslation.setAll(0.0);\n            }\n            else {\n                pivotBackTranslation.copyFrom(particle.pivot);\n            }\n            // positions\n            const tmpVertex = tempVectors[0];\n            tmpVertex.copyFrom(particle.position);\n            const vertexX = tmpVertex.x - particle.pivot.x;\n            const vertexY = tmpVertex.y - particle.pivot.y;\n            const vertexZ = tmpVertex.z - particle.pivot.z;\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n            rotatedX += pivotBackTranslation.x;\n            rotatedY += pivotBackTranslation.y;\n            rotatedZ += pivotBackTranslation.z;\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\n            if (this._computeBoundingBox) {\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\n            }\n            if (this._computeParticleColor && particle.color) {\n                const color = particle.color;\n                const colors32 = this._colors32;\n                colors32[cindex] = color.r;\n                colors32[cindex + 1] = color.g;\n                colors32[cindex + 2] = color.b;\n                colors32[cindex + 3] = color.a;\n            }\n            if (this._computeParticleTexture && particle.uv) {\n                const uv = particle.uv;\n                const uvs32 = this._uvs32;\n                uvs32[uindex] = uv.x;\n                uvs32[uindex + 1] = uv.y;\n            }\n        }\n        // if the VBO must be updated\n        if (mesh) {\n            if (update) {\n                if (this._computeParticleColor) {\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n                }\n                if (this._computeParticleTexture) {\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n                }\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n            }\n            if (this._computeBoundingBox) {\n                if (mesh.hasBoundingInfo) {\n                    mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n                }\n                else {\n                    mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n                }\n            }\n        }\n        this.afterUpdateParticles(start, end, update);\n        return this;\n    }\n    /**\n     * Disposes the PCS.\n     */\n    dispose() {\n        this.mesh?.dispose();\n        this.vars = null;\n        // drop references to internal big arrays for the GC\n        this._positions = null;\n        this._indices = null;\n        this._normals = null;\n        this._uvs = null;\n        this._colors = null;\n        this._indices32 = null;\n        this._positions32 = null;\n        this._uvs32 = null;\n        this._colors32 = null;\n    }\n    /**\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\n     * doc :\n     * @returns the PCS.\n     */\n    refreshVisibleSize() {\n        if (!this._isVisibilityBoxLocked) {\n            this.mesh?.refreshBoundingInfo();\n        }\n        return this;\n    }\n    /**\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n     * @param size the size (float) of the visibility box\n     * note : this doesn't lock the PCS mesh bounding box.\n     * doc :\n     */\n    setVisibilityBox(size) {\n        if (!this.mesh) {\n            return;\n        }\n        const vis = size / 2;\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n    }\n    /**\n     * Gets whether the PCS is always visible or not\n     * doc :\n     */\n    get isAlwaysVisible() {\n        return this._alwaysVisible;\n    }\n    /**\n     * Sets the PCS as always visible or not\n     * doc :\n     */\n    set isAlwaysVisible(val) {\n        if (!this.mesh) {\n            return;\n        }\n        this._alwaysVisible = val;\n        this.mesh.alwaysSelectAsActiveMesh = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle rotations or not\n     * Default value : false. The PCS is faster when it's set to false\n     * Note : particle rotations are only applied to parent particles\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\n     */\n    set computeParticleRotation(val) {\n        this._computeParticleRotation = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle colors or not.\n     * Default value : true. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    set computeParticleColor(val) {\n        this._computeParticleColor = val;\n    }\n    set computeParticleTexture(val) {\n        this._computeParticleTexture = val;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle colors or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    get computeParticleColor() {\n        return this._computeParticleColor;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle textures or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n     */\n    get computeParticleTexture() {\n        return this._computeParticleTexture;\n    }\n    /**\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n     */\n    set computeBoundingBox(val) {\n        this._computeBoundingBox = val;\n    }\n    /**\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n     */\n    get computeBoundingBox() {\n        return this._computeBoundingBox;\n    }\n    // =======================================================================\n    // Particle behavior logic\n    // these following methods may be overwritten by users to fit their needs\n    /**\n     * This function does nothing. It may be overwritten to set all the particle first values.\n     * The PCS doesn't call this function, you may have to call it by your own.\n     * doc :\n     */\n    initParticles() { }\n    /**\n     * This function does nothing. It may be overwritten to recycle a particle\n     * The PCS doesn't call this function, you can to call it\n     * doc :\n     * @param particle The particle to recycle\n     * @returns the recycled particle\n     */\n    recycleParticle(particle) {\n        return particle;\n    }\n    /**\n     * Updates a particle : this function should  be overwritten by the user.\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n     * doc :\n     * @example : just set a particle position or velocity and recycle conditions\n     * @param particle The particle to update\n     * @returns the updated particle\n     */\n    updateParticle(particle) {\n        return particle;\n    }\n    /**\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    beforeUpdateParticles(start, stop, update) { }\n    /**\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n     * This will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    afterUpdateParticles(start, stop, update) { }\n}\n//# sourceMappingURL=pointsCloudSystem.js.map","import { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata\";\nimport { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { Logger } from \"core/Misc/logger\";\nimport { Vector3 } from \"core/Maths/math.vector\";\nimport { PointsCloudSystem } from \"core/Particles/pointsCloudSystem\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\nimport { Scalar } from \"core/Maths/math.scalar\";\n/**\n * Indicator of the parsed ply buffer. A standard ready to use splat or an array of positions for a point cloud\n */\nvar Mode;\n(function (Mode) {\n    Mode[Mode[\"Splat\"] = 0] = \"Splat\";\n    Mode[Mode[\"PointCloud\"] = 1] = \"PointCloud\";\n    Mode[Mode[\"Mesh\"] = 2] = \"Mesh\";\n    Mode[Mode[\"Reject\"] = 3] = \"Reject\";\n})(Mode || (Mode = {}));\n/**\n * @experimental\n * SPLAT file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class SPLATFileLoader {\n    /**\n     * Creates loader for gaussian splatting files\n     * @param loadingOptions options for loading and parsing splat and PLY files.\n     */\n    constructor(loadingOptions = SPLATFileLoader._DefaultLoadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = SPLATFileLoaderMetadata.name;\n        this._assetContainer = null;\n        /**\n         * Defines the extensions the splat loader is able to load.\n         * force data to come in as an ArrayBuffer\n         */\n        this.extensions = SPLATFileLoaderMetadata.extensions;\n        this._loadingOptions = loadingOptions;\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\n    }\n    /**\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the gaussian splatting data to load\n     * @param rootUrl root url to load from\n     * @param _onProgress callback called while file is loading\n     * @param _fileName Defines the name of the file to load\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    async importMeshAsync(meshesNames, scene, data, rootUrl, _onProgress, _fileName) {\n        // eslint-disable-next-line github/no-then\n        return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            };\n        });\n    }\n    static _BuildPointCloud(pointcloud, data) {\n        if (!data.byteLength) {\n            return false;\n        }\n        const uBuffer = new Uint8Array(data);\n        const fBuffer = new Float32Array(data);\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const pointcloudfunc = function (particle, i) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            particle.position = new Vector3(x, y, z);\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\n            particle.color = new Color4(r, g, b, 1);\n        };\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\n        return true;\n    }\n    static _BuildMesh(scene, parsedPLY) {\n        const mesh = new Mesh(\"PLYMesh\", scene);\n        const uBuffer = new Uint8Array(parsedPLY.data);\n        const fBuffer = new Float32Array(parsedPLY.data);\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const positions = [];\n        const vertexData = new VertexData();\n        for (let i = 0; i < vertexCount; i++) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            positions.push(x, y, z);\n        }\n        if (parsedPLY.hasVertexColors) {\n            const colors = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i++) {\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\n                colors[i * 4 + 0] = r;\n                colors[i * 4 + 1] = g;\n                colors[i * 4 + 2] = b;\n                colors[i * 4 + 3] = 1;\n            }\n            vertexData.colors = colors;\n        }\n        vertexData.positions = positions;\n        vertexData.indices = parsedPLY.faces;\n        vertexData.applyToMesh(mesh);\n        return mesh;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _parseSPZAsync(data, scene) {\n        const ubuf = new Uint8Array(data);\n        const ubufu32 = new Uint32Array(data.slice(0, 12)); // Only need ubufu32[0] to [2]\n        // debug infos\n        const splatCount = ubufu32[2];\n        const shDegree = ubuf[12];\n        const fractionalBits = ubuf[13];\n        const flags = ubuf[14];\n        const reserved = ubuf[15];\n        // check magic and version\n        if (reserved || ubufu32[0] != 0x5053474e || ubufu32[1] != 2) {\n            // reserved must be 0\n            return new Promise((resolve) => {\n                resolve({ mode: 3 /* Mode.Reject */, data: buffer, hasVertexColors: false });\n            });\n        }\n        const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\n        const buffer = new ArrayBuffer(rowOutputLength * splatCount);\n        const positionScale = 1.0 / (1 << fractionalBits);\n        const int32View = new Int32Array(1);\n        const uint8View = new Uint8Array(int32View.buffer);\n        const read24bComponent = function (u8, offset) {\n            uint8View[0] = u8[offset + 0];\n            uint8View[1] = u8[offset + 1];\n            uint8View[2] = u8[offset + 2];\n            uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\n            return int32View[0] * positionScale;\n        };\n        let byteOffset = 16;\n        const position = new Float32Array(buffer);\n        const scale = new Float32Array(buffer);\n        const rgba = new Uint8ClampedArray(buffer);\n        const rot = new Uint8ClampedArray(buffer);\n        let coordinateSign = 1;\n        let quaternionOffset = 0;\n        if (!this._loadingOptions.flipY) {\n            coordinateSign = -1;\n            quaternionOffset = 255;\n        }\n        // positions\n        for (let i = 0; i < splatCount; i++) {\n            position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\n            position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);\n            position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);\n            byteOffset += 9;\n        }\n        // colors\n        const shC0 = 0.282;\n        for (let i = 0; i < splatCount; i++) {\n            for (let component = 0; component < 3; component++) {\n                const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\n                // 0.15 is hard coded value from spz\n                // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\n                // be useful to represent base colors that are out of range if the higher spherical harmonics bands\n                // bring them back into range so we multiply by a smaller value.\n                const value = (byteValue - 127.5) / (0.15 * 255);\n                rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);\n            }\n            rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\n        }\n        byteOffset += splatCount * 4;\n        // scales\n        for (let i = 0; i < splatCount; i++) {\n            scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\n            scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\n            scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\n            byteOffset += 3;\n        }\n        // convert quaternion\n        for (let i = 0; i < splatCount; i++) {\n            const x = ubuf[byteOffset + 0];\n            const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;\n            const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;\n            const nx = x / 127.5 - 1;\n            const ny = y / 127.5 - 1;\n            const nz = z / 127.5 - 1;\n            rot[i * 32 + 28 + 1] = x;\n            rot[i * 32 + 28 + 2] = y;\n            rot[i * 32 + 28 + 3] = z;\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\n            byteOffset += 3;\n        }\n        //SH\n        if (shDegree) {\n            // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\n            // number of vec3 vector needed per splat\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\n            // number of component values : 3 per vector3 (45)\n            const shComponentCount = shVectorCount * 3;\n            const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\n            let shIndexRead = byteOffset;\n            // sh is an array of uint8array that will be used to create sh textures\n            const sh = [];\n            const engine = scene.getEngine();\n            const width = engine.getCaps().maxTextureSize;\n            const height = Math.ceil(splatCount / width);\n            // create array for the number of textures needed.\n            for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n                const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n                sh.push(texture);\n            }\n            for (let i = 0; i < splatCount; i++) {\n                for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\n                    const shValue = ubuf[shIndexRead++];\n                    const textureIndex = Math.floor(shIndexWrite / 16);\n                    const shArray = sh[textureIndex];\n                    const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                    const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                    shArray[byteIndexInTexture + offsetPerSplat] = shValue;\n                }\n            }\n            return new Promise((resolve) => {\n                resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, sh: sh, trainedWithAntialiasing: !!flags });\n            });\n        }\n        return new Promise((resolve) => {\n            resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _parseAsync(meshesNames, scene, data, _rootUrl) {\n        const babylonMeshesArray = []; //The mesh for babylon\n        const readableStream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\n                controller.close();\n            },\n        });\n        // Use GZip DecompressionStream\n        const decompressionStream = new DecompressionStream(\"gzip\");\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\n        return new Promise((resolve) => {\n            new Response(decompressedStream)\n                .arrayBuffer()\n                // eslint-disable-next-line github/no-then\n                .then((buffer) => {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                this._parseSPZAsync(buffer, scene).then((parsedSPZ) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                    if (parsedSPZ.trainedWithAntialiasing) {\n                        const gsMaterial = gaussianSplatting.material;\n                        gsMaterial.kernelSize = 0.1;\n                        gsMaterial.compensation = true;\n                    }\n                    gaussianSplatting._parentContainer = this._assetContainer;\n                    babylonMeshesArray.push(gaussianSplatting);\n                    gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);\n                    scene._blockEntityCollection = false;\n                    resolve(babylonMeshesArray);\n                });\n            })\n                // eslint-disable-next-line github/no-then\n                .catch(() => {\n                // Catch any decompression errors\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                SPLATFileLoader._ConvertPLYToSplat(data).then(async (parsedPLY) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    switch (parsedPLY.mode) {\n                        case 0 /* Mode.Splat */:\n                            {\n                                const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                                gaussianSplatting._parentContainer = this._assetContainer;\n                                babylonMeshesArray.push(gaussianSplatting);\n                                gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);\n                                if (parsedPLY.compressed) {\n                                    gaussianSplatting.viewDirectionFactor.set(-1, -1, 1);\n                                }\n                            }\n                            break;\n                        case 1 /* Mode.PointCloud */:\n                            {\n                                const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\n                                if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\n                                    // eslint-disable-next-line github/no-then\n                                    await pointcloud.buildMeshAsync().then((mesh) => {\n                                        babylonMeshesArray.push(mesh);\n                                    });\n                                }\n                                else {\n                                    pointcloud.dispose();\n                                }\n                            }\n                            break;\n                        case 2 /* Mode.Mesh */:\n                            {\n                                if (parsedPLY.faces) {\n                                    babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\n                                }\n                                else {\n                                    throw new Error(\"PLY mesh doesn't contain face informations.\");\n                                }\n                            }\n                            break;\n                        default:\n                            throw new Error(\"Unsupported Splat mode\");\n                    }\n                    scene._blockEntityCollection = false;\n                    resolve(babylonMeshesArray);\n                });\n            });\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return (this.importMeshAsync(null, scene, data, rootUrl)\n            // eslint-disable-next-line github/no-then\n            .then((result) => {\n            for (const mesh of result.meshes) {\n                container.meshes.push(mesh);\n            }\n            // mesh material will be null before 1st rendered frame.\n            this._assetContainer = null;\n            return container;\n        })\n            // eslint-disable-next-line github/no-then\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        }));\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer\n     */\n    static _ConvertPLYToSplat(data) {\n        const ubuf = new Uint8Array(data);\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n        const headerEnd = \"end_header\\n\";\n        const headerEndIndex = header.indexOf(headerEnd);\n        if (headerEndIndex < 0 || !header) {\n            // standard splat\n            return new Promise((resolve) => {\n                resolve({ mode: 0 /* Mode.Splat */, data: data });\n            });\n        }\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n        const faceElement = /element face (\\d+)\\n/.exec(header);\n        let faceCount = 0;\n        if (faceElement) {\n            faceCount = parseInt(faceElement[1]);\n        }\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\n        let chunkCount = 0;\n        if (chunkElement) {\n            chunkCount = parseInt(chunkElement[1]);\n        }\n        let rowVertexOffset = 0;\n        let rowChunkOffset = 0;\n        const offsets = {\n            double: 8,\n            int: 4,\n            uint: 4,\n            float: 4,\n            short: 2,\n            ushort: 2,\n            uchar: 1,\n            list: 0,\n        };\n        let ElementMode;\n        (function (ElementMode) {\n            ElementMode[ElementMode[\"Vertex\"] = 0] = \"Vertex\";\n            ElementMode[ElementMode[\"Chunk\"] = 1] = \"Chunk\";\n            ElementMode[ElementMode[\"SH\"] = 2] = \"SH\";\n        })(ElementMode || (ElementMode = {}));\n        let chunkMode = 1 /* ElementMode.Chunk */;\n        const vertexProperties = [];\n        const chunkProperties = [];\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\n        for (const prop of filtered) {\n            if (prop.startsWith(\"property \")) {\n                const [, type, name] = prop.split(\" \");\n                if (chunkMode == 1 /* ElementMode.Chunk */) {\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\n                    rowChunkOffset += offsets[type];\n                }\n                else if (chunkMode == 0 /* ElementMode.Vertex */) {\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\n                    rowVertexOffset += offsets[type];\n                }\n                else if (chunkMode == 2 /* ElementMode.SH */) {\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\n                }\n                if (!offsets[type]) {\n                    Logger.Warn(`Unsupported property type: ${type}.`);\n                }\n            }\n            else if (prop.startsWith(\"element \")) {\n                const [, type] = prop.split(\" \");\n                if (type == \"chunk\") {\n                    chunkMode = 1 /* ElementMode.Chunk */;\n                }\n                else if (type == \"vertex\") {\n                    chunkMode = 0 /* ElementMode.Vertex */;\n                }\n                else if (type == \"sh\") {\n                    chunkMode = 2 /* ElementMode.SH */;\n                }\n            }\n        }\n        const rowVertexLength = rowVertexOffset;\n        const rowChunkLength = rowChunkOffset;\n        // eslint-disable-next-line github/no-then\n        return GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then(async (splatsData) => {\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\n            // faces\n            const faces = [];\n            if (faceCount) {\n                for (let i = 0; i < faceCount; i++) {\n                    const faceVertexCount = dataView.getUint8(offset);\n                    if (faceVertexCount != 3) {\n                        continue; // only support triangles\n                    }\n                    offset += 1;\n                    for (let j = 0; j < faceVertexCount; j++) {\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\n                        faces.push(vertexIndex);\n                    }\n                    offset += 12;\n                }\n            }\n            // early exit for chunked/quantized ply\n            if (chunkCount) {\n                return await new Promise((resolve) => {\n                    resolve({ mode: 0 /* Mode.Splat */, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false, compressed: true });\n                });\n            }\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\n            // if faces are found, then it's a standard mesh\n            let propertyCount = 0;\n            let propertyColorCount = 0;\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\n                const property = vertexProperties[propertyIndex];\n                if (splatProperties.includes(property.name)) {\n                    propertyCount++;\n                }\n                if (splatColorProperties.includes(property.name)) {\n                    propertyColorCount++;\n                }\n            }\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\n            const currentMode = faceCount ? 2 /* Mode.Mesh */ : hasMandatoryProperties ? 0 /* Mode.Splat */ : 1 /* Mode.PointCloud */;\n            // parsed ready ready to be used as a splat\n            return await new Promise((resolve) => {\n                resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: !!propertyColorCount, compressed: false });\n            });\n        });\n    }\n}\nSPLATFileLoader._DefaultLoadingOptions = {\n    keepInRam: false,\n    flipY: false,\n};\n// Add this loader into the register plugin\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\n//# sourceMappingURL=splatFileLoader.js.map","import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\n/**\n * Represents one particle of a points cloud system.\n */\nexport class CloudPoint {\n    /**\n     * Creates a Point Cloud object.\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\n     * @param group (PointsGroup) is the group the particle belongs to\n     * @param groupId (integer) is the group identifier in the PCS.\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\n     * @param pcs defines the PCS it is associated to\n     */\n    constructor(particleIndex, group, groupId, idxInGroup, pcs) {\n        /**\n         * particle global index\n         */\n        this.idx = 0;\n        /**\n         * The color of the particle\n         */\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        /**\n         * The world space position of the particle.\n         */\n        this.position = Vector3.Zero();\n        /**\n         * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n         */\n        this.rotation = Vector3.Zero();\n        /**\n         * The uv of the particle.\n         */\n        this.uv = new Vector2(0.0, 0.0);\n        /**\n         * The current speed of the particle.\n         */\n        this.velocity = Vector3.Zero();\n        /**\n         * The pivot point in the particle local space.\n         */\n        this.pivot = Vector3.Zero();\n        /**\n         * Must the particle be translated from its pivot point in its local space ?\n         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n         * Default : false\n         */\n        this.translateFromPivot = false;\n        /**\n         * Index of this particle in the global \"positions\" array (Internal use)\n         * @internal\n         */\n        this._pos = 0;\n        /**\n         * @internal Index of this particle in the global \"indices\" array (Internal use)\n         */\n        this._ind = 0;\n        /**\n         * Group id of this particle\n         */\n        this.groupId = 0;\n        /**\n         * Index of the particle in its group id (Internal use)\n         */\n        this.idxInGroup = 0;\n        /**\n         * @internal Still set as invisible in order to skip useless computations (Internal use)\n         */\n        this._stillInvisible = false;\n        /**\n         * @internal Last computed particle rotation matrix\n         */\n        this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n        /**\n         * Parent particle Id, if any.\n         * Default null.\n         */\n        this.parentId = null;\n        /**\n         * @internal Internal global position in the PCS.\n         */\n        this._globalPosition = Vector3.Zero();\n        this.idx = particleIndex;\n        this._group = group;\n        this.groupId = groupId;\n        this.idxInGroup = idxInGroup;\n        this._pcs = pcs;\n    }\n    /**\n     * get point size\n     */\n    get size() {\n        return this.size;\n    }\n    /**\n     * Set point size\n     */\n    set size(scale) {\n        this.size = scale;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    get quaternion() {\n        return this.rotationQuaternion;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    set quaternion(q) {\n        this.rotationQuaternion = q;\n    }\n    /**\n     * Returns a boolean. True if the particle intersects a mesh, else false\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\n     * @param target is the object (point or mesh) what the intersection is computed against\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\n     * @returns true if it intersects\n     */\n    intersectsMesh(target, isSphere) {\n        if (!target.hasBoundingInfo) {\n            return false;\n        }\n        if (!this._pcs.mesh) {\n            throw new Error(\"Point Cloud System doesnt contain the Mesh\");\n        }\n        if (isSphere) {\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n        }\n        const bbox = target.getBoundingInfo().boundingBox;\n        const maxX = bbox.maximumWorld.x;\n        const minX = bbox.minimumWorld.x;\n        const maxY = bbox.maximumWorld.y;\n        const minY = bbox.minimumWorld.y;\n        const maxZ = bbox.maximumWorld.z;\n        const minZ = bbox.minimumWorld.z;\n        const x = this.position.x + this._pcs.mesh.position.x;\n        const y = this.position.y + this._pcs.mesh.position.y;\n        const z = this.position.z + this._pcs.mesh.position.z;\n        return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n    }\n    /**\n     * get the rotation matrix of the particle\n     * @internal\n     */\n    getRotationMatrix(m) {\n        let quaternion;\n        if (this.rotationQuaternion) {\n            quaternion = this.rotationQuaternion;\n        }\n        else {\n            quaternion = TmpVectors.Quaternion[0];\n            const rotation = this.rotation;\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        }\n        quaternion.toRotationMatrix(m);\n    }\n}\n/**\n * Represents a group of points in a points cloud system\n *  * PCS internal tool, don't use it manually.\n */\nexport class PointsGroup {\n    /**\n     * Get or set the groupId\n     * @deprecated Please use groupId instead\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get groupID() {\n        return this.groupId;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    set groupID(groupID) {\n        this.groupId = groupID;\n    }\n    /**\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\n     * PCS internal tool, don't use it manually.\n     * @internal\n     */\n    constructor(id, posFunction) {\n        this.groupId = id;\n        this._positionFunction = posFunction;\n    }\n}\n//# sourceMappingURL=cloudPoint.js.map"],"names":["name","ShaderStore","IncludesShadersStore","shader","ShadersStore","gaussianSplattingPixelShader","gaussianSplattingVertexShader","IncludesShadersStoreWGSL","ShadersStoreWGSL","gaussianSplattingPixelShaderWGSL","gaussianSplattingVertexShaderWGSL","GaussianSplattingMaterialDefines","MaterialDefines","constructor","super","this","FOG","THIN_INSTANCES","LOGARITHMICDEPTH","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","SH_DEGREE","COMPENSATION","rebuild","GaussianSplattingMaterial","PushMaterial","scene","kernelSize","KernelSize","_compensation","Compensation","_isDirty","backFaceCulling","compensation","value","hasRenderTargetTextures","needAlphaTesting","needAlphaBlending","isReadyForSubMesh","mesh","subMesh","useInstances","drawWrapper","_drawWrapper","defines","materialDefines","markAsUnprocessed","effect","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","getScene","_isReadyForSubMesh","engine","getEngine","gsMesh","PrepareDefinesForMisc","_useLogarithmicDepth","pointsCloud","fogEnabled","PrepareDefinesForFrameBoundValues","PrepareDefinesForAttributes","version","isWebGPU","shDegree","splatMaterial","material","isDirty","markAsProcessed","resetCachedMaterial","attribs","VertexBuffer","PositionKind","PrepareAttributesForInstances","uniforms","samplers","uniformBuffers","PrepareUniformsAndSamplersList","uniformsNames","uniformBuffersNames","AddClipPlaneUniforms","join","toString","createEffect","attributes","onCompiled","onError","indexParameters","shaderLanguage","_shaderLanguage","extraInitializationsAsync","async","Promise","all","resolve","then","gaussianSplatting_fragment","gaussianSplatting_vertex","gaussianSplatting_fragment$1","gaussianSplatting_vertex$1","setEffect","_materialContext","isReady","_renderId","getRenderId","BindEffect","camera","activeCamera","renderWidth","getRenderWidth","renderHeight","getRenderHeight","gsMaterial","numberOfRigs","rigParent","rigCameras","length","setFloat2","focal","t","getProjectionMatrix","m","fovMode","Camera","FOVMODE_VERTICAL_FIXED","setVector3","viewDirectionFactor","setFloat","bindEyePosition","covariancesATexture","textureSize","getSize","width","height","setTexture","covariancesBTexture","centersTexture","colorsTexture","shTextures","i","bindForSubMesh","world","_activeEffect","getMeshUniformBuffer","bindToEffect","transferToEffect","_mustRebind","visibility","bindView","bindViewProjection","BindClipPlane","_features","needToAlwaysBindUniformBuffers","_needToBindSceneUbo","BindFogParameters","useLogarithmicDepth","BindLogDepth","_afterBind","clone","SerializationHelper","Clone","serialize","serializationObject","customType","getClassName","Parse","source","rootUrl","RegisterClass","HCF","functions.HighestCommonFactor","Scalar","functions","TwoPi","Math","PI","Sign","sign","Log2","log2","UnpackUnorm","bits","Unpack111011","result","x","y","z","Unpack8888","UnpackRot","norm","sqrt","a","b","c","set","PLYType","PLYValue","PointColor","Mode","GaussianSplattingMesh","Mesh","_viewDirectionFactor","_shDegree","splatsData","_splatsData","_covariancesATexture","_covariancesBTexture","_centersTexture","_colorsTexture","_shTextures","_material","cullBackFaces","resetDrawCache","url","keepInRam","_vertexCount","_worker","_frameIdLastUpdate","_modelViewMatrix","Matrix","Identity","_canPostToWorker","_readyToDisplay","_splatPositions","_splatIndex","_sh","_keepInRam","_delayedTextureUpdate","_oldDirection","Vector3","_useRGBACovariants","_tmpCovariances","_sortIsDirty","vertexData","VertexData","positions","indices","applyToMesh","subMeshes","SubMesh","setEnabled","loadFileAsync","_scene","getTotalVertices","completeCheck","_postToWorker","forced","frameId","getFrameId","cameraMatrix","getViewMatrix","getWorldMatrix","multiplyToRef","invertToRef","TmpVectors","TransformNormalToRef","Forward","useRightHandedSystem","normalize","dot","Dot","abs","copyFrom","postMessage","view","depthMix","_depthMix","buffer","render","enableAlphaMode","effectiveMeshReplacement","_TypeNameToEnum","_ValueNameToEnum","ParseHeader","data","ubuf","Uint8Array","header","TextDecoder","decode","slice","headerEnd","headerEndIndex","indexOf","vertexCount","parseInt","exec","chunkElement","chunkCount","rowVertexOffset","rowChunkOffset","offsets","double","int","uint","float","short","ushort","uchar","list","ElementMode","chunkMode","vertexProperties","chunkProperties","filtered","split","prop","startsWith","typeName","type","push","offset","Logger","Warn","dataView","DataView","ArrayBuffer","_RowOutputLength","shBuffer","shCoefficientCount","rowVertexLength","rowChunkLength","_GetCompressedChunks","compressedChunks","Array","currentChunk","min","max","minScale","maxScale","minColor","maxColor","propertyIndex","property","getFloat32","_GetSplat","index","q","Quaternion","temp3","rowOutputLength","position","Float32Array","scale","rgba","Uint8ClampedArray","rot","sh","chunkIndex","r0","r1","r2","r3","plySH","getInt32","getUint32","getFloat64","getUint8","compressedChunk","Lerp","w","exp","_SH_C0","shIndex","compressedValue","clampedValue","Clamp","shDim","j","ConvertPLYWithSHToSplat","useCoroutine","_PlyConversionBatchSize","textureCount","ceil","shIndexRead","splatCount","EngineStore","LastCreatedEngine","getCaps","maxTextureSize","textureIndex","texture","shIndexWrite","shValue","floor","ConvertPLYToSplat","ConvertPLYToSplatAsync","runCoroutineAsync","createYieldingScheduler","ConvertPLYWithSHToSplatAsync","loadDataAsync","updateDataAsync","plyBuffer","Tools","LoadFileAsync","dispose","doNotRecurse","shTexture","terminate","_copyTextures","newGS","undefined","_copySource","makeGeometryUnique","_instanciateWorker","binfo","getBoundingInfo","reConstruct","minimum","maximum","forcedInstanceCount","_makeSplat","fBuffer","uBuffer","covA","covB","colorArray","matrixRotation","matrixScale","quaternion","covBSItemSize","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","toRotationMatrix","ScalingToRef","covariances","factor","covIndex","transform","ToHalfFloat","_updateTextures","_getTextureSize","createTextureFromData","format","RawTexture","Constants","TEXTURE_BILINEAR_SAMPLINGMODE","TEXTURETYPE_FLOAT","createTextureFromDataU8","TEXTURETYPE_UNSIGNED_BYTE","createTextureFromDataU32","TEXTURE_NEAREST_SAMPLINGMODE","TEXTURETYPE_UNSIGNED_INTEGER","createTextureFromDataF16","TEXTURETYPE_HALF_FLOAT","colors","centers","from","TEXTUREFORMAT_RGBA","TEXTUREFORMAT_RG","shData","Uint32Array","TEXTUREFORMAT_RGBA_INTEGER","wrapU","TEXTURE_CLAMP_ADDRESSMODE","wrapV","_updateData","isAsync","_updateSplatIndexBuffer","textureLength","lineCountUpdate","ProgressiveUpdateAmount","textureLengthPerUpdate","Uint16Array","Number","MAX_VALUE","partCount","partIndex","updateLine","splatIndexBase","_updateSubTextures","_SplatBatchSize","updateData","runCoroutineSync","refreshBoundingInfo","thinInstanceRefreshBoundingInfo","thinInstanceSetBuffer","lineStart","lineCount","updateTextureFromData","updateTextureData","getInternalTexture","texelStart","texelCount","covAView","BYTES_PER_ELEMENT","covBView","colorsView","centersView","componentCount","shView","Worker","URL","createObjectURL","Blob","_CreateWorker","BigInt64Array","onmessage","e","indexMix","thinInstanceBufferUpdated","Error","Vector2","self","floatMix","viewProj","depthFactor","sort","CloudPoint","particleIndex","group","groupId","idxInGroup","pcs","idx","color","Color4","Zero","rotation","uv","velocity","pivot","translateFromPivot","_pos","_ind","_stillInvisible","_rotationMatrix","parentId","_globalPosition","_group","_pcs","size","rotationQuaternion","intersectsMesh","target","isSphere","hasBoundingInfo","boundingSphere","intersectsPoint","add","bbox","boundingBox","maxX","maximumWorld","minX","minimumWorld","maxY","minY","maxZ","minZ","getRotationMatrix","RotationYawPitchRollToRef","PointsGroup","groupID","id","posFunction","_positionFunction","PointsCloudSystem","_positions32","_colors32","uvs","_uvs32","pointSize","options","particles","nbParticles","counter","vars","_promises","_positions","_indices","_normals","_colors","_uvs","_updatable","_isVisibilityBoxLocked","_alwaysVisible","_groups","_groupCounter","_computeParticleColor","_computeParticleTexture","_computeParticleRotation","_computeBoundingBox","_isReady","_size","LastCreatedScene","updatable","buildMeshAsync","_buildMeshAsync","addPoints","UVKind","ec","ColorKind","mat","StandardMaterial","emissiveColor","Color3","disableLighting","_addParticle","cp","_randomUnitVector","particle","random","_getColorIndicesForCoord","pointsGroup","imageData","_groupImageData","colorIndices","greenIndex","blueIndex","alphaIndex","redForCoord","greenForCoord","blueForCoord","alphaForCoord","_setPointsColorOrUV","isVolume","colorFromTexture","hasTexture","range","uvSetIndex","updateFacetData","diameter","radius","meshPos","getVerticesData","meshInd","getIndices","meshUV","meshCol","place","computeWorldMatrix","meshMatrix","isIdentity","p","TransformCoordinatesFromFloatsToRef","idxPoints","id0","id1","id2","v0X","v0Y","v0Z","v1X","v1Y","v1Z","v2X","v2Y","v2Z","vertex0","vertex1","vertex2","vec0","vec1","uv0X","uv0Y","uv1X","uv1Y","uv2X","uv2Y","uv0","uv1","uv2","uvec0","uvec1","col0X","col0Y","col0Z","col0A","col1X","col1Y","col1Z","col1A","col2X","col2Y","col2Z","col2A","col0","Vector4","col1","col2","colvec0","colvec1","facetPoint","uvPoint","lamda","mu","colPoint","tang","biNorm","angle","facetPlaneVec","gap","distance","ray","Ray","pickInfo","direction","deltaS","deltaV","h","s","v","hsvCol","subtractToRef","statedColor","colPoint3","pointColors","_groupDensity","RandomRange","getFacetNormal","Cross","cos","sin","origin","hit","pickedPoint","subtract","addInPlace","_groupImgWidth","_groupImgHeight","round","r","g","toHSV","HSVtoRGBToRef","_colorFromTexture","textureList","getActiveTextures","BaseTexture","WhenAllReady","n","_textureNb","finalize","coordinatesIndex","dataPromise","readPixels","_calculateDensity","nbPoints","normal","area","cumulativeAreas","surfaceArea","nbFacets","CrossToRef","density","remainingPoints","cumulativeArea","facetPointsWithFraction","floored","fraction","facetPoints","nb","pointFunction","addSurfacePoints","colorWith","colored","isNaN","addVolumePoints","setParticles","start","end","update","beforeUpdateParticles","rotMatrix","colors32","positions32","uvs32","tempVectors","camAxisX","copyFromFloats","camAxisY","camAxisZ","setAll","IdentityToRef","isFacetDataEnabled","boundingInfo","pindex","cindex","uindex","updateParticle","particleRotationMatrix","particlePosition","particleGlobalPosition","parent","parentRotationMatrix","parentGlobalPosition","rotatedY","rotatedX","rotatedZ","rotMatrixValues","pivotBackTranslation","tmpVertex","vertexX","vertexY","vertexZ","px","py","pz","updateVerticesData","_worldMatrix","buildBoundingInfo","afterUpdateParticles","_indices32","refreshVisibleSize","setVisibilityBox","vis","isAlwaysVisible","val","alwaysSelectAsActiveMesh","computeParticleRotation","computeParticleColor","computeParticleTexture","computeBoundingBox","initParticles","recycleParticle","stop","SPLATFileLoader","loadingOptions","_DefaultLoadingOptions","SPLATFileLoaderMetadata","_assetContainer","extensions","_loadingOptions","createPlugin","importMeshAsync","meshesNames","_onProgress","_fileName","_parseAsync","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","_BuildPointCloud","pointcloud","byteLength","_BuildMesh","parsedPLY","hasVertexColors","faces","_parseSPZAsync","ubufu32","fractionalBits","flags","mode","positionScale","int32View","Int32Array","uint8View","read24bComponent","u8","byteOffset","coordinateSign","quaternionOffset","flipY","component","nx","ny","nz","shComponentCount","trainedWithAntialiasing","_rootUrl","babylonMeshesArray","readableStream","ReadableStream","controller","enqueue","close","decompressionStream","DecompressionStream","decompressedStream","pipeThrough","Response","arrayBuffer","parsedSPZ","_blockEntityCollection","gaussianSplatting","_parentContainer","catch","_ConvertPLYToSplat","compressed","loadAssetContainerAsync","container","AssetContainer","ex","loadAsync","faceElement","faceCount","faceVertexCount","vertexIndex","propertyCount","propertyColorCount","splatProperties","splatColorProperties","includes","hasMandatoryProperties","currentMode","RegisterSceneLoaderPlugin"],"mappings":"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,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GAEf,OAAO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"}