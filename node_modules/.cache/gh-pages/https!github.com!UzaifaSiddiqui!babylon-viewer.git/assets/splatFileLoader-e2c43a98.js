import{ax as R,a7 as q,av as F,ay as H,az as D,aA as J,J as $,f as K,N as Q,V as X,as as Z}from"./index-52cd4afa.js";var W;(function(S){S[S.Splat=0]="Splat",S[S.PointCloud=1]="PointCloud",S[S.Mesh=2]="Mesh",S[S.Reject=3]="Reject"})(W||(W={}));class M{constructor(a=M._DefaultLoadingOptions){this.name=R.name,this._assetContainer=null,this.extensions=R.extensions,this._loadingOptions=a}createPlugin(a){return new M(a[R.name])}async importMeshAsync(a,r,t,c,s,p){return await this._parseAsync(a,r,t,c).then(C=>({meshes:C,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]}))}static _BuildPointCloud(a,r){if(!r.byteLength)return!1;const t=new Uint8Array(r),c=new Float32Array(r),s=3*4+3*4+4+4,p=t.length/s,C=function(w,l){const o=c[8*l+0],e=c[8*l+1],d=c[8*l+2];w.position=new X(o,e,d);const y=t[s*l+24+0]/255,_=t[s*l+24+1]/255,x=t[s*l+24+2]/255;w.color=new Z(y,_,x,1)};return a.addPoints(p,C),!0}static _BuildMesh(a,r){const t=new q("PLYMesh",a),c=new Uint8Array(r.data),s=new Float32Array(r.data),p=3*4+3*4+4+4,C=c.length/p,w=[],l=new F;for(let o=0;o<C;o++){const e=s[8*o+0],d=s[8*o+1],y=s[8*o+2];w.push(e,d,y)}if(r.hasVertexColors){const o=new Float32Array(C*4);for(let e=0;e<C;e++){const d=c[p*e+24+0]/255,y=c[p*e+24+1]/255,_=c[p*e+24+2]/255;o[e*4+0]=d,o[e*4+1]=y,o[e*4+2]=_,o[e*4+3]=1}l.colors=o}return l.positions=w,l.indices=r.faces,l.applyToMesh(t),t}_parseSPZAsync(a,r){const t=new Uint8Array(a),c=new Uint32Array(a.slice(0,12)),s=c[2],p=t[12],C=t[13],w=t[14];if(t[15]||c[0]!=1347635022||c[1]!=2)return new Promise(n=>{n({mode:3,data:e,hasVertexColors:!1})});const o=3*4+3*4+4+4,e=new ArrayBuffer(o*s),d=1/(1<<C),y=new Int32Array(1),_=new Uint8Array(y.buffer),x=function(n,f){return _[0]=n[f+0],_[1]=n[f+1],_[2]=n[f+2],_[3]=n[f+2]&128?255:0,y[0]*d};let u=16;const U=new Float32Array(e),P=new Float32Array(e),z=new Uint8ClampedArray(e),i=new Uint8ClampedArray(e);let h=1,A=0;this._loadingOptions.flipY||(h=-1,A=255);for(let n=0;n<s;n++)U[n*8+0]=x(t,u+0),U[n*8+1]=h*x(t,u+3),U[n*8+2]=h*x(t,u+6),u+=9;const O=.282;for(let n=0;n<s;n++){for(let f=0;f<3;f++){const k=(t[u+s+n*3+f]-127.5)/(.15*255);z[n*32+24+f]=H.Clamp((.5+O*k)*255,0,255)}z[n*32+24+3]=t[u+n]}u+=s*4;for(let n=0;n<s;n++)P[n*8+3+0]=Math.exp(t[u+0]/16-10),P[n*8+3+1]=Math.exp(t[u+1]/16-10),P[n*8+3+2]=Math.exp(t[u+2]/16-10),u+=3;for(let n=0;n<s;n++){const f=t[u+0],V=t[u+1]*h+A,k=t[u+2]*h+A,v=f/127.5-1,B=V/127.5-1,m=k/127.5-1;i[n*32+28+1]=f,i[n*32+28+2]=V,i[n*32+28+3]=k;const b=1-(v*v+B*B+m*m);i[n*32+28+0]=127.5+Math.sqrt(b<0?0:b)*127.5,u+=3}if(p){const f=((p+1)*(p+1)-1)*3,V=Math.ceil(f/16);let k=u;const v=[],m=r.getEngine().getCaps().maxTextureSize,b=Math.ceil(s/m);for(let g=0;g<V;g++){const I=new Uint8Array(b*m*4*4);v.push(I)}for(let g=0;g<s;g++)for(let I=0;I<f;I++){const E=t[k++],T=Math.floor(I/16),G=v[T],N=I%16,j=g*16;G[N+j]=E}return new Promise(g=>{g({mode:0,data:e,hasVertexColors:!1,sh:v,trainedWithAntialiasing:!!w})})}return new Promise(n=>{n({mode:0,data:e,hasVertexColors:!1,trainedWithAntialiasing:!!w})})}_parseAsync(a,r,t,c){const s=[],p=new ReadableStream({start(l){l.enqueue(new Uint8Array(t)),l.close()}}),C=new DecompressionStream("gzip"),w=p.pipeThrough(C);return new Promise(l=>{new Response(w).arrayBuffer().then(o=>{this._parseSPZAsync(o,r).then(e=>{r._blockEntityCollection=!!this._assetContainer;const d=new D("GaussianSplatting",null,r,this._loadingOptions.keepInRam);if(e.trainedWithAntialiasing){const y=d.material;y.kernelSize=.1,y.compensation=!0}d._parentContainer=this._assetContainer,s.push(d),d.updateData(e.data,e.sh),r._blockEntityCollection=!1,l(s)})}).catch(()=>{M._ConvertPLYToSplat(t).then(async o=>{switch(r._blockEntityCollection=!!this._assetContainer,o.mode){case 0:{const e=new D("GaussianSplatting",null,r,this._loadingOptions.keepInRam);e._parentContainer=this._assetContainer,s.push(e),e.updateData(o.data,o.sh),(o.compressed||!o.rawSplat)&&e.viewDirectionFactor.set(-1,-1,1)}break;case 1:{const e=new J("PointCloud",1,r);M._BuildPointCloud(e,o.data)?await e.buildMeshAsync().then(d=>{s.push(d)}):e.dispose()}break;case 2:if(o.faces)s.push(M._BuildMesh(r,o));else throw new Error("PLY mesh doesn't contain face informations.");break;default:throw new Error("Unsupported Splat mode")}r._blockEntityCollection=!1,l(s)})})})}loadAssetContainerAsync(a,r,t){const c=new $(a);return this._assetContainer=c,this.importMeshAsync(null,a,r,t).then(s=>{for(const p of s.meshes)c.meshes.push(p);return this._assetContainer=null,c}).catch(s=>{throw this._assetContainer=null,s})}loadAsync(a,r,t){return this.importMeshAsync(null,a,r,t).then(()=>{})}static _ConvertPLYToSplat(a){const r=new Uint8Array(a),t=new TextDecoder().decode(r.slice(0,1024*10)),c=`end_header
`,s=t.indexOf(c);if(s<0||!t)return new Promise(i=>{i({mode:0,data:a,rawSplat:!0})});const p=parseInt(/element vertex (\d+)\n/.exec(t)[1]),C=/element face (\d+)\n/.exec(t);let w=0;C&&(w=parseInt(C[1]));const l=/element chunk (\d+)\n/.exec(t);let o=0;l&&(o=parseInt(l[1]));let e=0,d=0;const y={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let _;(function(i){i[i.Vertex=0]="Vertex",i[i.Chunk=1]="Chunk",i[i.SH=2]="SH"})(_||(_={}));let x=1;const u=[],U=t.slice(0,s).split(`
`);for(const i of U)if(i.startsWith("property ")){const[,h,A]=i.split(" ");x==1?d+=y[h]:x==0?(u.push({name:A,type:h,offset:e}),e+=y[h]):x==2&&u.push({name:A,type:h,offset:e}),y[h]||K.Warn(`Unsupported property type: ${h}.`)}else if(i.startsWith("element ")){const[,h]=i.split(" ");h=="chunk"?x=1:h=="vertex"?x=0:h=="sh"&&(x=2)}const P=e,z=d;return D.ConvertPLYWithSHToSplatAsync(a).then(async i=>{const h=new DataView(a,s+c.length);let A=z*o+P*p;const O=[];if(w)for(let m=0;m<w;m++){const b=h.getUint8(A);if(b==3){A+=1;for(let g=0;g<b;g++){const I=h.getUint32(A+(2-g)*4,!0);O.push(I)}A+=12}}if(o)return await new Promise(m=>{m({mode:0,data:i.buffer,sh:i.sh,faces:O,hasVertexColors:!1,compressed:!0,rawSplat:!1})});let n=0,f=0;const V=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],k=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let m=0;m<u.length;m++){const b=u[m];V.includes(b.name)&&n++,k.includes(b.name)&&f++}const v=n==V.length&&f==3,B=w?2:v?0:1;return await new Promise(m=>{m({mode:B,data:i.buffer,sh:i.sh,faces:O,hasVertexColors:!!f,compressed:!1,rawSplat:!1})})})}}M._DefaultLoadingOptions={keepInRam:!1,flipY:!1};Q(new M);export{M as SPLATFileLoader};
