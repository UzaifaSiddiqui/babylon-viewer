import{a1 as e,V as A,Q as T,M as F,a4 as b,a3 as M}from"./index-e8942d72.js";import{G as V,A as w}from"./glTFLoader-b68613f3.js";import"./objectModelMapping-7f92a822.js";const n="EXT_mesh_gpu_instancing";class E{constructor(i){this.name=n,this._loader=i,this.enabled=this._loader.isExtensionUsed(n)}dispose(){this._loader=null}loadNodeAsync(i,t,_){return V.LoadExtensionAsync(i,t,this.name,async(f,m)=>{this._loader._disableInstancedMesh++;const h=this._loader.loadNodeAsync(`/nodes/${t.index}`,t,_);if(this._loader._disableInstancedMesh--,!t._primitiveBabylonMeshes)return await h;const c=new Array;let o=0;const l=a=>{if(m.attributes[a]==null){c.push(Promise.resolve(null));return}const s=w.Get(`${f}/attributes/${a}`,this._loader.gltf.accessors,m.attributes[a]);if(c.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),o===0)o=s.count;else if(o!==s.count)throw new Error(`${f}/attributes: Instance buffer accessors do not have the same count.`)};return l("TRANSLATION"),l("ROTATION"),l("SCALE"),await h.then(async a=>{const[s,d,y]=await Promise.all(c),p=new Float32Array(o*16);e.Vector3[0].copyFromFloats(0,0,0),e.Quaternion[0].copyFromFloats(0,0,0,1),e.Vector3[1].copyFromFloats(1,1,1);for(let r=0;r<o;++r)s&&A.FromArrayToRef(s,r*3,e.Vector3[0]),d&&T.FromArrayToRef(d,r*4,e.Quaternion[0]),y&&A.FromArrayToRef(y,r*3,e.Vector3[1]),F.ComposeToRef(e.Vector3[1],e.Quaternion[0],e.Vector3[0],e.Matrix[0]),e.Matrix[0].copyToArray(p,r*16);for(const r of t._primitiveBabylonMeshes)r.thinInstanceSetBuffer("matrix",p,16,!0);return a})})}}b(n);M(n,!0,u=>new E(u));export{E as EXT_mesh_gpu_instancing};
