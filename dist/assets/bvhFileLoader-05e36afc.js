import{w as b,x as h,V as w,y as Y,M as u,b as D,Q as y,z as g,J as V,N as B}from"./index-07961b59.js";const k="Xposition",F="Yposition",M="Zposition",x="Xrotation",_="Yrotation",L="Zrotation",K="HIERARCHY",j="MOTION";class z{constructor(o){this.loopMode=h.ANIMATIONLOOPMODE_CYCLE,this.list=[],this.root=P(),this.numFrames=0,this.frameRate=0,this.skeleton=o}}function P(){return{name:"",type:"",offset:new w,channels:[],children:[],frames:[],parent:null}}function X(){return{frame:0,position:new w,rotation:new y}}function Z(t){const o=t.offset.x,n=t.offset.y,a=t.offset.z;return u.Translation(o,n,a)}function Q(t,o){if(t.frames.length===0)return[];const n=[],a=t.channels.some(i=>i===k||i===F||i===M),e=t.channels.some(i=>i===x||i===_||i===L),s=new h(`${t.name}_pos`,"position",o.frameRate,h.ANIMATIONTYPE_VECTOR3,o.loopMode),f=new h(`${t.name}_rot`,"rotationQuaternion",o.frameRate,h.ANIMATIONTYPE_QUATERNION,o.loopMode),r=[],l=[];for(let i=0;i<t.frames.length;i++){const c=t.frames[i];a&&c.position&&r.push({frame:c.frame,value:c.position.clone()}),e&&l.push({frame:c.frame,value:c.rotation.clone()})}return r.length>0&&(s.setKeys(r),n.push(s)),l.length>0&&(f.setKeys(l),n.push(f)),n}function S(t,o,n){const a=Z(t),e=new Y(t.name,n.skeleton,o,a),s=Q(t,n);for(const f of s)f.getKeys()&&f.getKeys().length>0&&e.animations.push(f);for(const f of t.children)S(f,e,n)}function H(t,o,n,a){if(n.type==="ENDSITE")return;const e=X();e.frame=o,e.position=new w,e.rotation=new y,n.frames.push(e);let s=u.Identity();for(let f=0;f<n.channels.length;++f){const r=n.channels[f],l=t[a.i++];if(!l)continue;const i=parseFloat(l.trim());if(r.endsWith("position"))switch(r){case k:e.position.x=i;break;case F:e.position.y=i;break;case M:e.position.z=i;break}else if(r.endsWith("rotation")){const c=D.ToRadians(i);let m;switch(r){case x:m=u.RotationX(c);break;case _:m=u.RotationY(c);break;case L:m=u.RotationZ(c);break}s=m.multiply(s)}}y.FromRotationMatrixToRef(s,e.rotation);for(const f of n.children)H(t,o,f,a)}function U(t,o,n,a){var l,i,c,m;const e=P();e.parent=n,a.list.push(e);let s=o.trim().split(/\s+/);if(s[0].toUpperCase()==="END"&&s[1].toUpperCase()==="SITE"?(e.type="ENDSITE",e.name="ENDSITE"):(e.name=s[1],e.type=s[0].toUpperCase()),((l=t.shift())==null?void 0:l.trim())!="{")throw new Error("Expected opening { after type & name");const f=(i=t.shift())==null?void 0:i.trim().split(/\s+/);if(!f)throw new Error("Unexpected end of file: missing OFFSET");if(s=f,s[0].toUpperCase()!="OFFSET")throw new Error("Expected OFFSET, but got: "+s[0]);if(s.length!=4)throw new Error("OFFSET: Invalid number of values");const r=new w(parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3]));if(isNaN(r.x)||isNaN(r.y)||isNaN(r.z))throw new Error("OFFSET: Invalid values");if(e.offset=r,e.type!="ENDSITE"){if(s=(c=t.shift())==null?void 0:c.trim().split(/\s+/),!s)throw new Error("Unexpected end of file: missing CHANNELS");if(s[0].toUpperCase()!="CHANNELS")throw new Error("Expected CHANNELS definition");const p=parseInt(s[1]);e.channels=s.splice(2,p),e.children=[]}for(;t.length>0;){const p=(m=t.shift())==null?void 0:m.trim();if(p==="}")return e;p&&e.children.push(U(t,p,e,a))}throw new Error("Unexpected end of file: missing closing brace")}function I(t,o,n,a){const e=t.split(`
`),{loopMode:s}=a;o._blockEntityCollection=!!n;const f=new b("","",o);f._parentContainer=n,o._blockEntityCollection=!1;const r=new z(f);r.loopMode=s;const l=e.shift();if(!l||l.trim().toUpperCase()!==K)throw new Error("HIERARCHY expected");const i=e.shift();if(!i)throw new Error("Unexpected end of file after HIERARCHY");const c=U(e,i.trim(),null,r),m=e.shift();if(!m||m.trim().toUpperCase()!==j)throw new Error("MOTION expected");const p=e.shift();if(!p)throw new Error("Unexpected end of file before frame count");const T=p.trim().split(/[\s]+/);if(T.length<2)throw new Error("Invalid frame count line");const E=parseInt(T[1]);if(isNaN(E))throw new Error("Failed to read number of frames.");r.numFrames=E;const C=e.shift();if(!C)throw new Error("Unexpected end of file before frame time");const R=C.trim().split(/[\s]+/);if(R.length<3)throw new Error("Invalid frame time line");const O=parseFloat(R[2]);if(isNaN(O))throw new Error("Failed to read frame time.");r.frameRate=O;for(let N=0;N<E;++N){const A=e.shift();if(!A)continue;const v=A.trim().split(/[\s]+/)||[];H(v,N,c,{i:0})}return r.root=c,S(r.root,null,r),r.skeleton.returnToRest(),r.skeleton}class d{constructor(o){this.name=g.name,this.extensions=g.extensions,this._loadingOptions={...d._DefaultLoadingOptions,...o??{}}}static get _DefaultLoadingOptions(){return{loopMode:h.ANIMATIONLOOPMODE_CYCLE}}createPlugin(o){return new d(o[g.name])}canDirectLoad(){return!0}importMeshAsync(o,n,a){if(typeof a!="string")return Promise.reject("BVH loader expects string data.");try{const e=I(a,n,null,this._loadingOptions);return Promise.resolve({meshes:[],particleSystems:[],skeletons:[e],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})}catch(e){return Promise.reject(e)}}loadAsync(o,n){return typeof n!="string"?Promise.reject("BVH loader expects string data."):this.importMeshAsync(null,o,n).then(()=>{})}loadAssetContainerAsync(o,n){if(typeof n!="string")return Promise.reject("BVH loader expects string data.");const a=new V(o);try{const e=I(n,o,a,this._loadingOptions);return a.skeletons.push(e),Promise.resolve(a)}catch(e){return Promise.reject(e)}}}B(new d);export{d as BVHFileLoader};
